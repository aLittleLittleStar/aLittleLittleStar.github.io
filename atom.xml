<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>昨夜小楼又东风</title>
  
  <subtitle>纵豆蔻词工，青楼好梦，难赋深情</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-17T12:46:35.362Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LittleStar</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同源策略和跨域</title>
    <link href="http://yoursite.com/2019/03/17/Ajax/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/03/17/Ajax/同源策略和跨域/</id>
    <published>2019-03-17T08:56:03.000Z</published>
    <updated>2019-03-17T12:46:35.362Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载:<br>　　<a href="https://segmentfault.com/a/1190000012469713" target="_blank" rel="noopener">ajax跨域，这应该是最全的解决方案了</a><br>参考:<br>　　<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法</a><br>　　<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>同源即指：协议相同、域名相同、端口号相同。<br><a id="more"></a><br>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/dir2/other.html：同源</span><br><span class="line">http://example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://v2.www.example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://www.example.com:81/dir/other.html：不同源（端口不同）</span><br></pre></td></tr></table></figure></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>　　同源政策的目的，是为了<strong>为了保证使用者信息的安全，防止恶意网站篡改用户数据</strong>。<br>　　设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的<code>Cookie</code>，会发生什么？<br>　　很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，<code>Cookie</code> 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。<br>　　由此可见，”同源政策”是必需的，否则 <code>Cookie</code> 可以共享，互联网就毫无安全可言了。</p><h3 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h3><p>　　随着互联网的发展，”同源政策”越来越严格。目前，非同源的网站之间，共有四种行为受到限制。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1） Cookie、LocalStorage 和 IndexDB 无法读取。</span><br><span class="line">（2） DOM 无法获得。</span><br><span class="line">（3） AJAX 请求不能发送。</span><br><span class="line">（4）无法通过 flash 发送 http 请求</span><br></pre></td></tr></table></figure></p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>　　同源策略做了很严格的限制，但是在实际的场景中，又确实有很多地方需要突破同源策略的限制，也就是我们常说的跨域。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>　　同源策略最早被提出的时候，为的就是防止不同域名的网页之间共享 <code>cookie</code>。<code>Cookie</code>是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享<code>Cookie</code>。<br>举个例子，<br><code>https://market.douban.com</code>和<code>https://book.douban.com</code>，这两个网页的一级域名都是 <code>douban.com</code>，如果我在 <code>market.douban.com</code>中执行了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#A、B页面设置相同的document.domain</span></span><br><span class="line">document.domain = <span class="string">'douban.com'</span></span><br><span class="line"><span class="comment"># A页面通过脚本设置一个Cookie</span></span><br><span class="line">document.cookie = <span class="string">'cross=yes'</span></span><br><span class="line">或</span><br><span class="line">document.cookie = <span class="string">'cross=yes;path=/;domain=douban.com'</span></span><br><span class="line"><span class="comment"># B页面就可以读取到Cookie</span></span><br><span class="line">var allCookie = document.cookie</span><br></pre></td></tr></table></figure></p><p>这样设置了 <code>cookie</code>之后，在<code>book.douban.com</code>中是可以取到这个<code>cookie</code>的。<br>除了在前端设置之外，也可以直接在<code>response</code>里将<code>cookie</code>的<code>domain</code>设置成 <code>.douban.com</code>。</p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="什么是Ajax跨域"><a href="#什么是Ajax跨域" class="headerlink" title="什么是Ajax跨域"></a>什么是Ajax跨域</h4><h5 id="ajax跨域的原理"><a href="#ajax跨域的原理" class="headerlink" title="ajax跨域的原理"></a>ajax跨域的原理</h5><p>　　<code>ajax</code>出现请求跨域错误问题,主要原因就是因为浏览器的“同源策略”,可以参考</p><h5 id="ajax跨域的表现"><a href="#ajax跨域的表现" class="headerlink" title="ajax跨域的表现"></a>ajax跨域的表现</h5><p>　　<code>ajax</code>请求时,如果存在跨域现象,并且没有进行解决,会有如下表现:(注意，是<code>ajax</code>请求，请不要说为什么<code>http</code>请求可以，而<code>ajax</code>不行，因为<code>ajax</code>是伴随着跨域的，所以仅仅是<code>http</code>请求<code>ok</code>是不行的)<br><strong>第一种现象</strong>:<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>,并且<code>The response had HTTP status code 404</code><br><img src="/assets/images/ajax001.png" alt="ajax001"><br>出现这种情况的原因如下：<br>　　本次ajax请求是“非简单请求”,所以请求前会发送一次预检请求(<code>OPTIONS</code>)<br>　　服务器端后台接口没有允许<code>OPTIONS</code>请求,导致无法找到对应接口地址<br>解决方案: 后端允许options请求<br><strong>第二种现象</strong>:<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>,并且<code>The response had HTTP status code 405</code><br><img src="/assets/images/ajax002.png" alt="ajax001"><br>这种现象和第一种有区别,这种情况下，后台方法允许<code>OPTIONS</code>请求,但是一些配置文件中(如安全配置),阻止了<code>OPTIONS</code>请求,才会导致这个现象<br>解决方案: 后端关闭对应的安全配置<br><strong>第三种现象</strong>:<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>,并且<code>status 200</code><br><img src="/assets/images/ajax003.png" alt="ajax001"><br>这种现象和第一种和第二种有区别,这种情况下，服务器端后台允许<code>OPTIONS</code>请求,并且接口也允许<code>OPTIONS</code>请求,但是头部匹配时出现不匹配现象<br>比如<code>origin</code>头部检查不匹配,比如少了一些头部的支持(如常见的<code>X-Requested-With</code>头部),然后服务端就会将<code>response</code>返回给前端,前端检测到这个后就触发<code>XHR.onerror</code>,导致前端控制台报错<br>解决方案: 后端增加对应的头部支持<br><strong>第四种现象</strong>:<code>heade contains multiple values &#39;*,*&#39;</code><br><img src="/assets/images/ajax004.jpg" alt="ajax001"><br>表现现象是，后台响应的http头部信息有两个<code>Access-Control-Allow-Origin:*</code><br>说实话，这种问题出现的主要原因就是进行跨域配置的人不了解原理，导致了重复配置，如:<br>常见于<code>.net</code>后台(一般在<code>web.config</code>中配置了一次<code>origin</code>,然后代码中又手动添加了一次<code>origin</code>(比如代码手动设置了返回<code>*</code>))<br>常见于<code>.net</code>后台(在<code>IIS</code>和项目的<code>webconfig</code>中同时设置<code>Origin:*</code>)<br>解决方案(一一对应):<br>　　建议删除代码中手动添加的<code>*</code>，只用项目配置中的即可<br>　　建议删除IIS下的配置<code>*</code>，只用项目配置中的即可</p><h4 id="如何解决ajax跨域"><a href="#如何解决ajax跨域" class="headerlink" title="如何解决ajax跨域"></a>如何解决ajax跨域</h4><p>　　一般ajax跨域解决就是通过<code>JSONP</code>解决或者<code>CORS</code>解决,如以下:(注意，现在已经几乎不会再使用<code>JSONP</code>了，所以<code>JSONP</code>了解下即可)</p><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p>jsonp 其实算是一种 hack 形式的请求。<br>jsonp 的本质其实是请求一段 js 代码，是对静态文件资源的请求，所以并不遵循同源策略。但是因为是对静态文件资源的请求，所以只能支持 GET 请求，对于其他方法没有办法支持。</p><h5 id="设置CORS"><a href="#设置CORS" class="headerlink" title="设置CORS"></a>设置CORS</h5><p>　　<code>CORS</code>是一个<code>W3C</code>标准，全称是”跨域资源共享”（<code>Cross-origin resource sharing</code>）。<br>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了<code>AJAX</code>只能同源使用的限制。<br>本文详细介绍CORS的内部机制。</p><h6 id="CORS简介"><a href="#CORS简介" class="headerlink" title="CORS简介"></a>CORS简介</h6><p>　　<code>CORS</code>需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于<code>IE10</code>。<br>　　整个<code>CORS</code>通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现<code>AJAX</code>请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><h6 id="CORS两种请求"><a href="#CORS两种请求" class="headerlink" title="CORS两种请求"></a>CORS两种请求</h6><p>浏览器将CORS请求分成两类：简单请求（<code>simple request</code>）和非简单请求（<code>not-so-simple request</code>）。<br>只要同时满足以下两大条件，就属于简单请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">（1) 请求方法是以下三种方法之一：</span><br><span class="line">  HEAD</span><br><span class="line">  GET</span><br><span class="line">  POST</span><br><span class="line">（2）HTTP的头信息不超出以下几种字段：</span><br><span class="line">  Accept</span><br><span class="line">  Accept-Language</span><br><span class="line">  Content-Language</span><br><span class="line">  Last-Event-ID</span><br><span class="line">  Content-Type：只限于三个值</span><br><span class="line">                application/x-www-form-urlencoded、</span><br><span class="line">                multipart/form-data、</span><br><span class="line">                text/plain</span><br></pre></td></tr></table></figure></p><p>凡是不同时满足上面两个条件，就属于<code>非简单请求</code>。<br>浏览器对这两种请求的处理，是不一样的。</p><h6 id="CORS简单请求"><a href="#CORS简单请求" class="headerlink" title="CORS简单请求"></a>CORS简单请求</h6><p>对于简单请求，浏览器直接发出<code>CORS</code>请求。具体来说，就是在头信息之中，增加一个<code>Origin(protocal + host + path + port)</code>字段,来标明这个请求是来自哪里。<br>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>　　如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest的onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。<br>　　如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。<br>（1）Access-Control-Allow-Origin<br>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。<br>（2）Access-Control-Allow-Credentials<br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。<br>（3）Access-Control-Expose-Headers<br>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。<br>withCredentials 属性<br>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。<br><code>Access-Control-Allow-Credentials: true</code><br>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>否则，即使服务器同意发送<code>Cookie</code>，浏览器也不会发送。或者，服务器要求设置<code>Cookie</code>，浏览器也不会处理。<br>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送<code>Cookie</code>。这时，可以显式关闭<code>withCredentials</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，如果要发送<code>Cookie</code>，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，<code>Cookie</code>依然遵循同源政策，只有用服务器域名设置的<code>Cookie</code>才会上传，其他域名的<code>Cookie</code>并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的<code>Cookie</code>。</p><h6 id="CORS非简单请求"><a href="#CORS非简单请求" class="headerlink" title="CORS非简单请求"></a>CORS非简单请求</h6><p>与<code>简单请求</code>最大的不同在于，<code>非简单请求</code>实际上是发送了两个请求。<br><strong>预请求</strong><br>首先，在正式请求之前，会先发送一个预请求(preflight-request)，这个请求的作用是尽可能少的携带信息，供服务端判断是否响应该请求。<br><strong>浏览器</strong><br>浏览器发送预请求，请求的 Request Method 会设置为 options。<br>另外，还会带上这几个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin: 同简单请求的origin</span><br><span class="line">Access-Control-Request-Method: 请求将要使用的方法</span><br><span class="line">Access-Control-Request-Headers: 浏览器会额外发送哪些头信息</span><br></pre></td></tr></table></figure></p><p><strong>服务端</strong><br>服务端收到预请求之后会根据request中的origin,Access-Control-Request-Method和Access-Control-Request-Headers判断是否响应该请求。<br>如果判断响应这个请求，返回的response中将会携带：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: origin</span><br><span class="line">Access-Control-Allow-Methods: like request</span><br><span class="line">Access-Control-Allow-Headers: like request</span><br></pre></td></tr></table></figure></p><p>如果否定这个请求，直接返回不带这三个字段的response就可以，浏览器将会把这种返回判断为失败的返回，触发onerror方法<br><strong>正式响应</strong><br>如果预请求被正确响应，接下来就会发送正式请求，正式请求的request和正常的 ajax 请求基本没有区别，只是会携带 origin 字段；response和简单请求一样，会携带上Access-Control-*这些字段</p><h5 id="WebScoket"><a href="#WebScoket" class="headerlink" title="WebScoket"></a>WebScoket</h5><p>websocket 不遵循同源策略。</p><p>但是在 websocket 请求头中会带上 origin 这个字段，服务端可以通过这个字段来判断是否需要响应，在浏览器端并没有做任何限制。</p><h5 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h5><h5 id="代理请求方式"><a href="#代理请求方式" class="headerlink" title="代理请求方式"></a>代理请求方式</h5>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;转载:&lt;br&gt;　　&lt;a href=&quot;https://segmentfault.com/a/1190000012469713&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ajax跨域，这应该是最全的解决方案了&lt;/a&gt;&lt;br&gt;参考:&lt;br&gt;　　&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浏览器同源政策及其规避方法&lt;/a&gt;&lt;br&gt;　　&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/cors.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;跨域资源共享 CORS 详解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;同源即指：协议相同、域名相同、端口号相同。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ajax" scheme="http://yoursite.com/categories/Ajax/"/>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>Axios</title>
    <link href="http://yoursite.com/2019/03/17/Ajax/Axios/"/>
    <id>http://yoursite.com/2019/03/17/Ajax/Axios/</id>
    <published>2019-03-17T07:55:58.000Z</published>
    <updated>2019-03-17T12:55:16.713Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># helpers.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"># 定义常量ERR_OK</span><br><span class="line"><span class="keyword">const</span> ERR_OK = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 导出一个getDate方法</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getDate(url) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(url, &#123;</span><br><span class="line">      params</span><br><span class="line">      # 成功之后的.then方法</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      # 通过结构赋值的方法难道error和data的数值</span><br><span class="line">      <span class="keyword">const</span> &#123; error, data&#125; = res.data</span><br><span class="line">      # 如果成功的话，返回data数据</span><br><span class="line">      <span class="keyword">if</span>(error === ERR_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">      &#125;</span><br><span class="line">      # 如果失败的话打印失败的原因</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) =&gt; </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"error:"</span>, error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 出口文件</span><br><span class="line"># index.js</span><br><span class="line"><span class="keyword">import</span> &#123; getDate &#125; <span class="keyword">from</span> <span class="string">'./helpers'</span></span><br><span class="line"></span><br><span class="line"># 定义getSeller方法</span><br><span class="line"><span class="keyword">const</span> getSeller = getDate(<span class="string">'./api/seller'</span>)</span><br><span class="line"></span><br><span class="line"># 导出getSeller方法</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  getSeller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="Axios" scheme="http://yoursite.com/categories/Axios/"/>
    
    
      <category term="Axios" scheme="http://yoursite.com/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="http://yoursite.com/2019/03/16/Ajax/Ajax/"/>
    <id>http://yoursite.com/2019/03/16/Ajax/Ajax/</id>
    <published>2019-03-16T09:09:14.000Z</published>
    <updated>2019-03-16T09:10:31.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Ajax" scheme="http://yoursite.com/categories/Ajax/"/>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/15/JavaScript/index/"/>
    <id>http://yoursite.com/2019/03/15/JavaScript/index/</id>
    <published>2019-03-15T02:25:58.824Z</published>
    <updated>2019-03-17T13:05:01.475Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>test</title><script src="https://unpkg.com/axios/dist/axios.min.js"></script></head><body><div>body<input type="date"></div><script>function Person() {var name = 'hello'function say() {console.log("name:", name)}return say()}Person()</script></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/15/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/vue%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/15/面试题-思维/vue面试题/</id>
    <published>2019-03-15T01:03:34.091Z</published>
    <updated>2019-03-15T01:03:44.046Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单自我介绍, 做过哪些项目, 使用哪些技术栈 ?<br>如何看待前端框架选型 ?<br>vue的如何实现双向绑定的 ？<br>react 虚拟DOM 是什么? 如何实现? 说一下diff算法 ?<br>工作中最出色的点, 和你最头疼的问题 如何解决的 ?<br>平时如何学习, 最近接触了解了哪些新的知识 ?<br>技术一面<br>简单自我介绍, 介绍一下你的项目, 技术栈 ?<br>react和vue的比较 ?<br>React Diff 算法 ?<br>观察者模式实现 ?<br>http报文头部有哪些字段? 有什么意义 ?<br>移动端高清方案如何解决 ?<br>webpack的原理, loader 和 plugin 是干什么的? 有自己手写过么 ?<br>简述从网页输入url到网页展示的过程发生了哪些事情 ?<br>SSR 和 客户端渲染有什么区别 , vue是如何实现绑定事件的 ?<br>简述公司node架构中容灾的实现 ?<br>浏览器事件有哪些过程? 为什么一般在冒泡阶段, 而不是在捕获阶段注册监听? addEventListener 参数分别是什么 ?<br>面向对象如何实现? 需要复用的变量 怎么处理 ?<br>移动端300ms延时的原因? 如何处理?<br>主流框架的数据单向/双向绑定实现原理 ?<br>简述转行经历, 如何学习 ?<br>你觉得自己在前端工作的最大的优点是什么 拿实际工作的内容举例?<br>技术二面<br>和一面前3问基本一致,简述项目,React vue区别 virsualDOM实现<br>DIFF算法为什么是O(n)复杂度而不是O(n^3)<br>http code码?<br>移动端rem布局如何实现? 简述原理?<br>JSbridge原理, js和native是如何通信的?<br>Rollup和webpack区别, treeshaking是什么?<br>TCP三次握手的过程, get post请求的区别 ?<br>静态文件的浏览器缓存如何实现?<br>前端跨域方案<br>http 请求包含哪些字段 分别是什么意思<br>js 有哪些数据类型 如何判断? null 和 undefined区别 应用场景?<br>new String(‘a’) 和 ‘a’ 是一样的么?<br>移动端如何实现下拉到底部 跟随移动 结束后回弹的动画?<br>移动端如何优化首页白屏时间过长 ?<br>ES6 generator函数简述<br>数组去重实现?<br>js浮点数运算不精确 如何解决?<br>工作中最得意和出色的点, 头疼的点, 问题如何解决的<br>为何换工作?<br>聊了下阿里的压力,文化<br>技术三面<br>公司的前端工程化实践<br>转行之后是如何自学前端的, 学习途径 有没有一些自己的代码<br>DOM基础知识,添加元素,删除元素等等…<br>DOM节点类型<br>正则表达式如何匹配一段url ?在正则表达式中有哪几种作用?<br>移动端优化方式? 离线包是如何实现的?</p><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">https://ustbhuangyi.github.io/vue-analysis/</a></p><p>我的手机 2019/3/14 10:04:34<br><a href="https://www.jianshu.com/p/a804606ad8e9" target="_blank" rel="noopener">https://www.jianshu.com/p/a804606ad8e9</a></p><p>我的手机 2019/3/14 10:04:50<br><a href="https://www.cnblogs.com/chinabin1993/p/9115396.html" target="_blank" rel="noopener">https://www.cnblogs.com/chinabin1993/p/9115396.html</a></p><p>我的手机 2019/3/14 10:05:03<br><a href="https://segmentfault.com/a/1190000012996217" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012996217</a></p><p>我的手机 2019/3/14 10:05:20<br><a href="https://blog.csdn.net/qq_35430000/article/details/79291287" target="_blank" rel="noopener">https://blog.csdn.net/qq_35430000/article/details/79291287</a></p><p>我的手机 2019/3/14 10:05:37<br><a href="https://m.jb51.net/article/140581.htm" target="_blank" rel="noopener">https://m.jb51.net/article/140581.htm</a></p><p><a href="https://yukwan.cn/fronttech/front-end/" target="_blank" rel="noopener">https://yukwan.cn/fronttech/front-end/</a><br>2019/3/8 16:31:10<br>我的手机 2019/3/8 16:31:10<br><a href="https://mp.weixin.qq.com/s/L8P0RIXym4myfknzM5Nsog" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/L8P0RIXym4myfknzM5Nsog</a><br>2019/3/9 16:28:42<br>我的手机 2019/3/9 16:28:42<br><a href="https://campushr.hikvision.com/JobDetails.html?id=057c01652bb444b597345337c7b8c14f&amp;type=0" target="_blank" rel="noopener">https://campushr.hikvision.com/JobDetails.html?id=057c01652bb444b597345337c7b8c14f&amp;type=0</a></p><p><a href="https://wx2.sinaimg.cn/mw690/005NaMhPly1g0nayy8lbij30hs59p7wh.jpg?from=singlemessage" target="_blank" rel="noopener">https://wx2.sinaimg.cn/mw690/005NaMhPly1g0nayy8lbij30hs59p7wh.jpg?from=singlemessage</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/15/JavaScript/%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2019/03/15/JavaScript/学习知识点/</id>
    <published>2019-03-15T01:02:08.431Z</published>
    <updated>2019-03-16T08:52:17.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h3><h3 id="在HTML中使用JavaScript"><a href="#在HTML中使用JavaScript" class="headerlink" title="在HTML中使用JavaScript"></a>在HTML中使用JavaScript</h3><h4 id="混杂模式与标准模式"><a href="#混杂模式与标准模式" class="headerlink" title="混杂模式与标准模式"></a>混杂模式与标准模式</h4><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>变量、函数名和操作符都区分大小写</p><p>标识符，就是指变量、函数、属性的名字，或者函数的参数。ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的<br>首字母大写</p><p>严格模式： “use strict”; </p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><blockquote><p>简单数据类型(基本数据类型)：Undefined、Null、Boolean、Number、String  <br><br>复杂数据类型：Object      <br><br>typeof 操作符来区分函数和其他对象是有必要的  <br></p></blockquote><h5 id="Undefind"><a href="#Undefind" class="headerlink" title="Undefind"></a>Undefind</h5><p>　　即便未初始化的变量会自动被赋予 undefined 值，但显式地初始化变量依然是<br>明智的选择。如果能够做到这一点，那么当 typeof 操作符返回”undefined”值时，<br>我们就知道被检测的变量还没有被声明，而不是尚未初始化。</p><h5 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h5><h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h5><h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><h6 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h6><h6 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h6><h6 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h6><p>即非数值（Not a Number）<br>ECMAScript 定义了 isNaN()函数。这个函数接受一个参数，该参数可以<br>是任何类型，而函数会帮我们确定这个参数是否“不是数值”。</p><h6 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h6><p>把非数值转换为数值：Number()、parseInt()和 parseFloat()。</p><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><h4 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h4><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h3 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h3><h4 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h4><p>基本类型值指的是<br>简单的数据段，而引用类型值指那些可能由多个值构成的对象</p><h5 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h5><p>如果从一个变量向另一个变量复制<strong>基本类型</strong>的值，会在变量对象上创建一个新值，然后把该值复制<br>到为新变量分配的位置上.<br><br>当从一个变量向另一个变量复制<strong>引用类型</strong>的值时，同样也会将存储在变量对象中的值复制一份放到<br>为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一<br>个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另<br>一个变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = new Object(); </span><br><span class="line">var obj2 = obj1; </span><br><span class="line">obj1.name = <span class="string">"Nicholas"</span>; </span><br><span class="line">alert(obj2.name); //<span class="string">"Nicholas"</span></span><br></pre></td></tr></table></figure></p><h5 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h5><p>typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具 <br></p><p>虽然在检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的<br>用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript<br>提供了 instanceof 操作符，其语法如下所示：<br><code>result = variable instanceof constructor</code></p><h4 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h4><h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><h5 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h5><h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；</li><li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；</li><li>引用类型的值是对象，保存在堆内存中；</li><li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；</li><li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同<br>一个对象；</li><li>确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用<br>instanceof 操作符。</li><li>所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执<br>行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。</li></ol><h5 id="以下是关于执行环境的几点总结："><a href="#以下是关于执行环境的几点总结：" class="headerlink" title="以下是关于执行环境的几点总结："></a>以下是关于执行环境的几点总结：</h5><ul><li>执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；</li><li>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；<br>函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全<br>局环境；</li><li>全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；</li><li>变量的执行环境有助于确定应该何时释放内存。</li><li>JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。</li></ul><h5 id="可以对-JavaScript-的垃圾收集例程作如下总结："><a href="#可以对-JavaScript-的垃圾收集例程作如下总结：" class="headerlink" title="可以对 JavaScript 的垃圾收集例程作如下总结："></a>可以对 JavaScript 的垃圾收集例程作如下总结：</h5><ul><li>离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。<br>“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然<br>后再回收其内存。</li><li>另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript<br>引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种<br>算法仍然可能会导致问题。</li><li>当代码中存在循环引用现象时，“引用计数”算法就会导致问题。</li><li>解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回<br>收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h4><h5 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h5><ul><li>Array类型<ul><li>检测数组  value instanceof Array、 Array.isArray()方</li><li>转换方法 toLocaleString()、toString()和 valueOf()</li><li>栈方法 后进先出 push()、pop()</li><li>队列方法 后进先出 shift()、unshift()</li><li>重排序方法 reverse()、sort()</li><li>操作方法 concat() 连接数组、splice()</li><li>位置方法 indexOf()、lastIndexOf()</li><li>迭代方法<ul><li>every()  全部</li><li>filter() 筛选</li><li>forEach()</li><li>map() </li><li>some() 存在</li></ul></li><li>归并方法<ul><li>reduce()</li><li>reduceRight()</li></ul></li></ul></li><li>Date类型<ul><li>new Date()、Date.parse() 、Date.UTC()</li><li>继承的方法</li><li>日期格式化方法<ul><li>toDateString()——以特定于实现的格式显示星期几、月、日和年</li><li>toTimeString()——以特定于实现的格式显示时、分、秒和时区；</li><li>toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年</li><li>toLocaleTimeString()——以特定于实现的格式显示时、分、秒</li><li>toUTCString()——以特定于实现的格式完整的 UTC 日期</li></ul></li><li>日期/时间组件<ul><li>getTime() 返回表示日期的毫秒数；与valueOf()方法返回的值相同</li><li>setTime(毫秒) 以毫秒数设置日期，会改变整个日期</li><li>getFullYear() 取得4位数的年份（如2007而非仅07）</li><li>getUTCFullYear() 返回UTC日期的4位数年份</li></ul></li></ul></li><li>RegExp()类型</li><li>Function类型<ul><li>没有重载</li><li>函数声明与函数表达式<ul><li>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）</li><li>至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真<br>正被解释执行。</li></ul></li><li>作为值的函数</li><li>函数内部属性<ul><li>arguments</li><li>this</li><li>callee</li></ul></li><li>函数属性和方法<ul><li>length</li><li>prototype</li><li>apply()</li><li>call()</li></ul></li><li>基本包装类型<ul><li>Boolean类型</li><li>Number<ul><li>toFixed()方法会按照指定的小数位返回数值的字符串表示</li><li>toExponential()</li></ul></li><li>String<ul><li>trim()方法： 这个方法会创建一个字符串的副本，删除前置及<br>后缀的所有空格，然后返回结果</li><li>字符串大小写转换方法<ul><li>toLowerCase()</li><li>toLocaleLowerCase()</li><li>toUpperCase()</li><li>toLocaleUpperCase()。</li></ul></li></ul></li><li>字符串的模式匹配方法</li><li>localeCompare()</li><li>localeCompare()</li><li>fromCharCode()</li></ul></li><li>单体内置对象<ul><li>Global对象</li><li>Math对象<ul><li>Math对象的属性</li><li>min()、max()</li><li>舍入方法<ul><li>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数</li><li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数</li><li>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</li></ul></li><li>random() Math.radom()</li></ul></li></ul></li></ul></li></ul><p>160</p><h4 id="创建并操作数组"><a href="#创建并操作数组" class="headerlink" title="创建并操作数组"></a>创建并操作数组</h4><h4 id="基本的JavaScript类型"><a href="#基本的JavaScript类型" class="headerlink" title="基本的JavaScript类型"></a>基本的JavaScript类型</h4><h4 id="基本类型和基本包装类型"><a href="#基本类型和基本包装类型" class="headerlink" title="基本类型和基本包装类型"></a>基本类型和基本包装类型</h4><h3 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h3><h4 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h4><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><h3 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a>客户端检测</h3><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><h3 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h3><h3 id="DOM2和DOM3"><a href="#DOM2和DOM3" class="headerlink" title="DOM2和DOM3"></a>DOM2和DOM3</h3><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h3 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h3><h3 id="使用Canvas绘图"><a href="#使用Canvas绘图" class="headerlink" title="使用Canvas绘图"></a>使用Canvas绘图</h3><h3 id="HTML5脚本编程"><a href="#HTML5脚本编程" class="headerlink" title="HTML5脚本编程"></a>HTML5脚本编程</h3><h3 id="错误处理与调试"><a href="#错误处理与调试" class="headerlink" title="错误处理与调试"></a>错误处理与调试</h3><h3 id="JavaScript与XML"><a href="#JavaScript与XML" class="headerlink" title="JavaScript与XML"></a>JavaScript与XML</h3><h3 id="E4X"><a href="#E4X" class="headerlink" title="E4X"></a>E4X</h3><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><h3 id="Ajax与Comet"><a href="#Ajax与Comet" class="headerlink" title="Ajax与Comet"></a>Ajax与Comet</h3><h3 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h3><h3 id="离线应用和客户端储存"><a href="#离线应用和客户端储存" class="headerlink" title="离线应用和客户端储存"></a>离线应用和客户端储存</h3><h3 id="最佳实战"><a href="#最佳实战" class="headerlink" title="最佳实战"></a>最佳实战</h3><h3 id="新兴的API"><a href="#新兴的API" class="headerlink" title="新兴的API"></a>新兴的API</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>客户端渲染和服务端渲染详细执行流程</title>
    <link href="http://yoursite.com/2019/03/14/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/SSR%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2019/03/14/前端性能优化/SSR和客户端渲染/</id>
    <published>2019-03-14T13:09:08.000Z</published>
    <updated>2019-03-14T13:30:12.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>客户端渲染：CSR (client side render)<br>在服务端放了一个html 页面，里面有<script>//发请求，拿数据，模版引擎渲染等，$.ajax  ,</script><br>客户端发起请求，服务端把页面（响应的是字符串）发送过去，客户端从上到下依次解析，如果在解析的过程中，发现ajax<br>请求，再次像服务器发送新的请求，客户端拿到ajax 响应结果，模板引擎渲染。<br>过程至少和服务端发起两次请求</p></li><li><p>服务端渲染：SSR (server side render)<br>sever 端页面+数据，服务端过程：<br>1.读取index.html<br>2.模版进行渲染，在发送给客户端之前，在服务端已经把index.html 渲染处理了。var 渲染结果 = tempeter.render(模板字符串，｛解析替换对象｝)   response.end(渲染结果)，服务端响应的就是最总的结果<br>服务端只请求一次<br>多数网站既有服务端渲染又有客户端渲染</p></li><li><p>服务端渲染和客户端渲染的区别</p><ul><li>客户端渲染不利于 SEO 搜索引擎优化</li><li>服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的</li><li>所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的</li><li>而是两者结合来做的</li><li>例如京东的商品列表就采用的是服务端渲染，目的了为了 SEO 搜索引擎优化</li><li>而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端性能优化" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件间通信&amp;传值</title>
    <link href="http://yoursite.com/2019/03/14/Vue/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1&amp;%E4%BC%A0%E5%80%BC/"/>
    <id>http://yoursite.com/2019/03/14/Vue/Vue组件间通信&amp;传值/</id>
    <published>2019-03-14T02:18:02.000Z</published>
    <updated>2019-03-14T12:41:39.999Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- 目录 --><!-- toc --><p>转载：<br>　　<a href="https://blog.csdn.net/qq_35430000/article/details/79291287" target="_blank" rel="noopener">vue通信、传值的多种方式（详细）</a><br>　　<a href="https://www.jianshu.com/p/a804606ad8e9" target="_blank" rel="noopener">Vue.js——十分钟入门Vuex</a></p><h4 id="通过路由带参数进行传值"><a href="#通过路由带参数进行传值" class="headerlink" title="通过路由带参数进行传值"></a>通过路由带参数进行传值</h4><ol><li>两个组件 A和B,A组件通过query把orderId传递给B组件（触发事件可以是点击事件、钩子函数等）<br><code>this.$router.push({ path: &#39;/conponentsB&#39;, query: { orderId: 123 } }) // 跳转到B</code></li><li>在B组件中获取A组件传递过来的参数<br><code>this.$route.query.orderId</code><a id="more"></a></li></ol><h4 id="通过设置-Session-Storage缓存的形式进行传递"><a href="#通过设置-Session-Storage缓存的形式进行传递" class="headerlink" title="通过设置 Session Storage缓存的形式进行传递"></a>通过设置 Session Storage缓存的形式进行传递</h4><ol><li><p>两个组件A和B，在A组件中设置缓存orderData</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const orderData = &#123; &apos;orderId&apos;: 123, &apos;price&apos;: 88 &#125;</span><br><span class="line"> </span><br><span class="line">sessionStorage.setItem(&apos;缓存名称&apos;, JSON.stringify(orderData))</span><br></pre></td></tr></table></figure></li><li><p>B组件就可以获取在A中设置的缓存了<br><code>const dataB = JSON.parse(sessionStorage.getItem(&#39;缓存名称&#39;))</code><br>此时 dataB 就是数据 orderData</p><h4 id="父子组件之间的传值"><a href="#父子组件之间的传值" class="headerlink" title="父子组件之间的传值"></a>父子组件之间的传值</h4><h5 id="父组件往子组件传值props"><a href="#父组件往子组件传值props" class="headerlink" title="父组件往子组件传值props"></a>父组件往子组件传值props</h5><p>①定义父组件，父组件传递 number这个数值给子组件，如果传递的参数很多，推荐使用json数组{}的形式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"parent"</span>&gt;  <span class="comment"># 例如：传递数组88给子组件</span></span><br><span class="line">    &lt;children number=888&gt;&lt;/children&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">import Children from <span class="string">'components/children'</span>  <span class="comment"># 引入子组件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>②定义子组件，子组件通过 props方法获取父组件传递过来的值。props中可以定义能接收的数据类型，如果不符合会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># children.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"children"</span>&gt;</span><br><span class="line">    &#123;&#123;number&#125;&#125;  <span class="comment"># 显示父组件传递过来的值，显示88</span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  props: &#123;  <span class="comment"># 限制父组件传递过来的数据类型，如果不符合就报错</span></span><br><span class="line">    <span class="string">'number'</span>: [Number, String, Object],</span><br><span class="line">    <span class="string">'string'</span>: [String] <span class="comment">#可以传递多个值，逗号隔开</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然也可以简单一点，如果不考虑数据类型，直接 props:[“number”,”string”]就可以了,中括号包裹，多个值使用，分隔。<br>③假如接收的参数 是动态的，比如 input输入的内容 v-model的形式<br><strong>注意</strong>：传递的参数名称 支持驼峰命名，下面示例描述不正确（1.0是不支持的）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"parent"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"inputText"</span>&gt;</span><br><span class="line">    &lt;children :input-val = <span class="string">'inputText'</span>&gt;&lt;/children&gt; </span><br><span class="line">    <span class="comment"># 注意 :input-val 不支持驼峰命名，建议 - 分割 </span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import Children from <span class="string">'components/children'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"children"</span>&gt;</span><br><span class="line">    &#123;&#123;inputVal&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="string">'input-val'</span>: [String]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④父子组件传值，数据是异步请求，有可能数据渲染时报错<br>原因：异步请求时，数据还没有获取到但是此时已经渲染节点了<br>解决方案：可以在 父组件需要传递数据的节点加上<code>v-if = false</code>,异步请求获取数据后,<code>v-if = true</code></p><h5 id="子组件往父组件传值，通过emit事件"><a href="#子组件往父组件传值，通过emit事件" class="headerlink" title="子组件往父组件传值，通过emit事件"></a>子组件往父组件传值，通过emit事件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># children.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=<span class="string">"children"</span>&gt;</span><br><span class="line">      &lt;button @click=<span class="string">"emitToParent"</span>&gt;按钮点击传值给父组件&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">emitToParent</span></span>() &#123;</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">'child-event'</span>, <span class="string">'我是子组件往父组件传递的内容'</span>)</span><br><span class="line">      <span class="comment"># child-event 不支持驼峰命名</span></span><br><span class="line">      <span class="comment"># 子组件通过emit事件给父组件传递内容</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"parent"</span>&gt; <span class="comment"># 触发父组件的一个方法，然后进行相应的操作</span></span><br><span class="line">    &lt;children @child-event=<span class="string">"parentEvent"</span>&gt;&lt;/children&gt;</span><br><span class="line">    <span class="comment"># @child-event 这是子组件自定义的方法</span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import Children from <span class="string">'components/children'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    parentEvent(data) &#123; </span><br><span class="line">      <span class="comment"># data 就是子组件传递过来的数据</span></span><br><span class="line">      console.log(data)</span><br><span class="line">      <span class="comment"># 我是子组件往父组件传递的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用-vuex）"><a href="#不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用-vuex）" class="headerlink" title="不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用 vuex）"></a>不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用 vuex）</h4><p>①定义一个新的vue实例专门用于传递数据，并导出<br><br>就是定义一个公共的传值用的组件进行数据的交互<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建文佳eventBus.js</span></span><br><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line"><span class="built_in">export</span> default new Vue()</span><br></pre></td></tr></table></figure></p><p>②定义传递的方法名和传输内容，点击事件或钩子函数触发eventBus.emit事件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># componentA.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"componentsA"</span>&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"emitToB"</span>&gt;按钮点击传递数据给兄弟组件B&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import eventBus from <span class="string">'common/js/eventBus.js'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">emitToB</span></span>() &#123;</span><br><span class="line">      eventBus.<span class="variable">$emit</span>(<span class="string">'eventFromA'</span>, <span class="string">'我是组件A传递给组件B的数据'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>③接收传递过来的数据<br>注意：enentBus是一个另一个新的Vue实例，区分两个this所代表得vue实例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">componentB.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"componentsB"</span>&gt;</span><br><span class="line">    &#123;&#123;title&#125;&#125; <span class="comment"># 显示传递过来的值</span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import eventBus from <span class="string">'common/js/eventBus.js'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      title: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">    this.getEventData()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">getEventData</span></span>() &#123;</span><br><span class="line">      const that = this </span><br><span class="line">      <span class="comment">#this是项目vue的实例，用that接收，与eventBus的vue区分</span></span><br><span class="line">      eventBus.<span class="variable">$on</span>(<span class="string">'eventFormA'</span>, <span class="keyword">function</span>(val) &#123;</span><br><span class="line">        that.title = val</span><br><span class="line">        <span class="comment"># this.title = val </span></span><br><span class="line">        <span class="comment"># 这个this指的是eventBus的vue实例</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h4 id="Vuex进行传值"><a href="#Vuex进行传值" class="headerlink" title="Vuex进行传值"></a>Vuex进行传值</h4><h5 id="什么是Vuex"><a href="#什么是Vuex" class="headerlink" title="什么是Vuex"></a>什么是Vuex</h5><p>　　Vuex是一个专门为Vue.js应用程序开发的状态管理模式, 它采用集中式存储管理所有组件的公共状态, 并以相应的规则保证状态以一种可预测的方式发生变化.<br><img src="/assets/images/vuex.png" alt="vuex"><br>　　上图中绿色虚线包裹起来的部分就是Vuex的核心, <code>state</code>中保存的就是公共状态, 改变<code>state</code>的唯一方式就是通过<code>mutations</code>进行更改. 可能你现在看这张图有点不明白, 等经过本文的解释和案例演示, 再回来看这张图, 相信你会有更好的理解.</p><h5 id="为什么要使用Vuex"><a href="#为什么要使用Vuex" class="headerlink" title="为什么要使用Vuex"></a>为什么要使用Vuex</h5><p>　　试想这样的场景, 比如一个Vue的根实例下面有一个根组件名为App.vue, 它下面有两个子组件A.vue和B.vue, App.vue想要与A.vue或者B.vue通讯可以通过props传值的方式, 但是如果A.vue和B.vue之间的通讯就很麻烦了, 他们需要共有的父组件通过自定义事件进行实现, A组件想要和B组件通讯往往是这样的:<br><img src="/assets/images/vuex1.png" alt="vuex"></p><ul><li>A组件说: “报告老大, 能否帮我托个信给小弟B” =&gt; dispatch一个事件给App</li><li>App老大说: “包在我身上, 它需要监听A组件的dispatch的时间, 同时需要broadcast一个事件给B组件”</li><li>B小弟说: “信息已收到”, 它需要on监听App组件分发的事件</li></ul><p>　　这只是一条通讯路径, 如果父组件下有多个子组件, 子组件之间通讯的路径就会变的很繁琐, 父组件需要监听大量的事件, 还需要负责分发给不同的子组件, 很显然这并不是我们想要的组件化的开发体验.<br><strong>Vuex就是为了解决这一问题出现的</strong></p><h5 id="如何引入Vuex"><a href="#如何引入Vuex" class="headerlink" title="如何引入Vuex"></a>如何引入Vuex</h5><p>下载vuex: <code>npm install vuex --save</code> <br><br>在<code>main.js</code>添加:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import Vuex from <span class="string">'vuex'</span></span><br><span class="line"><span class="comment"># 使用vuex</span></span><br><span class="line">Vue.use( Vuex );</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    //待添加</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    store,</span><br><span class="line">    render: h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="Vuex的核心概念"><a href="#Vuex的核心概念" class="headerlink" title="Vuex的核心概念"></a>Vuex的核心概念</h5><p>　　在介绍Vuex的核心概念之前, 我使用<code>vue-cli</code>初始化了一个demo, 准备以代码的形式来说明Vuex的核心概念,这个demo分别有两个组件<code>ProductListOne.vue</code>和<code>ProductListTwo.vue</code>, 在<code>App.vue</code>的d<code>atat</code>中保存着共有的商品列表, 代码和初始化的效果如下图所示:<br><img src="/assets/images/vuex2.png" alt="vuex"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//App.vue中的初始化代码</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;product-list-one v-bind:products=<span class="string">"products"</span>&gt;&lt;/product-list-one&gt;</span><br><span class="line">    &lt;product-list-two v-bind:products=<span class="string">"products"</span>&gt;&lt;/product-list-two&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ProductListOne from <span class="string">'./components/ProductListOne.vue'</span></span><br><span class="line">import ProductListTwo from <span class="string">'./components/ProductListTwo.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    name: <span class="string">'app'</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">'product-list-one'</span>: ProductListOne,</span><br><span class="line">        <span class="string">'product-list-two'</span>: ProductListTwo</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products: [</span><br><span class="line">                &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">                &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">                &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">                &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">body&#123;</span><br><span class="line">  font-family: Ubuntu;</span><br><span class="line">  color: <span class="comment">#555;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//ProductListOne.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"product-list-one"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Product List One&lt;/h2&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=<span class="string">"product in products"</span>&gt;</span><br><span class="line">                &lt;span class=<span class="string">"name"</span>&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span class=<span class="string">"price"</span>&gt;<span class="variable">$&#123;&#123; product.price &#125;</span>&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    props: [<span class="string">'products'</span>],</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="comment">#product-list-one&#123;</span></span><br><span class="line">    background: <span class="comment">#FFF8B1;</span></span><br><span class="line">    box-shadow: 1px 2px 3px rgba(0,0,0,0.2);</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">    padding: 10px 20px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#product-list-one ul&#123;</span></span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#product-list-one li&#123;</span></span><br><span class="line">    display: inline-block;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    background: rgba(255,255,255,0.7);</span><br><span class="line">&#125;</span><br><span class="line">.price&#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    color: <span class="comment">#E8800C;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//ProductListTwo.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"product-list-two"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Product List Two&lt;/h2&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=<span class="string">"product in products"</span>&gt;</span><br><span class="line">                &lt;span class=<span class="string">"name"</span>&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span class=<span class="string">"price"</span>&gt;<span class="variable">$&#123;&#123; product.price &#125;</span>&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    props: [<span class="string">'products'</span>],</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="comment">#product-list-two&#123;</span></span><br><span class="line">    background: <span class="comment">#D1E4FF;</span></span><br><span class="line">    box-shadow: 1px 2px 3px rgba(0,0,0,0.2);</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">    padding: 10px 20px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#product-list-two ul&#123;</span></span><br><span class="line">    padding: 0;</span><br><span class="line">    list-style-type: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#product-list-two li&#123;</span></span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    background: rgba(255,255,255,0.7);</span><br><span class="line">&#125;</span><br><span class="line">.price&#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    color: <span class="comment">#860CE8;</span></span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h6 id="State"><a href="#State" class="headerlink" title="State"></a>State</h6><p>　　<code>state</code>就是Vuex中的公共的状态, 我是将<code>state</code>看作是所有组件的data, 用于保存所有组件的公共数据.</p><ol><li>此时我们就可以把App.vue中的两个组件共同使用的data抽离出来, 放到<code>state</code>中,代码如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.js</span></span><br><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import App from <span class="string">'./App.vue'</span></span><br><span class="line">import Vuex from <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use( Vuex )</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state:&#123; </span><br><span class="line">    products: [</span><br><span class="line">      &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">      &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">      &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">      &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>此时,<code>ProductListOne.vue</code>和<code>ProductListTwo.vue</code>也需要做相应的更改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ProductListOne.vue</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products : this.<span class="variable">$store</span>.state.products //获取store中state的数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ProductListTwo.vue</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products: this.<span class="variable">$store</span>.state.products //获取store中state的数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的页面如下图所示, 可以看到, 将公共数据抽离出来后, 页面没有发生变化.<br><img src="/assets/images/vuex3.png" alt="vuex"></p><h6 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h6><p>　　我将getters属性理解为所有组件的<code>computed</code>属性, 也就是计算属性. <code>vuex</code>的官方文档也是说到可以将<code>getter</code>理解为<code>store</code>的计算属性, <code>getters</code>的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>　　此时,我们可以在main.js中添加一个<code>getters</code>属性, 其中的<code>saleProducts</code>对象将state中的价格减少一半(除以2)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.js</span></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    products: [</span><br><span class="line">      &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">      &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">      &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">      &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters:&#123; //添加getters</span><br><span class="line">    saleProducts: (state) =&gt; &#123;</span><br><span class="line">      <span class="built_in">let</span> saleProducts = state.products.map( product =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">          name: product.name,</span><br><span class="line">          price: product.price / 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">return</span> saleProducts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>将<code>productListOne.vue</code>中的<code>products</code>的值更换为<code>this.$store.getters.saleProducts</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products : this.<span class="variable">$store</span>.getters.saleProducts </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在的页面中,Product List One中的每项商品的价格都减少了一半<br><img src="/assets/images/vuex4.png" alt="vuex"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">###### Mutations</span></span><br><span class="line">　　我将mutaions理解为store中的methods, mutations对象中保存着更改数据的回调函数,该函数名官方规定叫<span class="built_in">type</span>, 第一个参数是state, 第二参数是payload, 也就是自定义的参数.</span><br><span class="line"></span><br><span class="line">下面,我们在main.js中添加mutations属性,其中minusPrice这个回调函数用于将商品的价格减少payload这么多, 代码如下:</span><br><span class="line">```bash</span><br><span class="line">//main.js</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    products: [</span><br><span class="line">      &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">      &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">      &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">      &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters:&#123;</span><br><span class="line">    saleProducts: (state) =&gt; &#123;</span><br><span class="line">      <span class="built_in">let</span> saleProducts = state.products.map( product =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">          name: product.name,</span><br><span class="line">          price: product.price / 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">return</span> saleProducts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123; //添加mutations</span><br><span class="line">    minusPrice (state, payload ) &#123;</span><br><span class="line">      <span class="built_in">let</span> newPrice = state.products.forEach( product =&gt; &#123;</span><br><span class="line">        product.price -= payload</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在<code>ProductListTwo.vue</code>中添加一个按钮,为其添加一个点击事件, 给点击事件触发<code>minusPrice</code>方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ProductListTwo.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"product-list-two"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Product List Two&lt;/h2&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=<span class="string">"product in products"</span>&gt;</span><br><span class="line">                &lt;span class=<span class="string">"name"</span>&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span class=<span class="string">"price"</span>&gt;<span class="variable">$&#123;&#123; product.price &#125;</span>&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;button @click=<span class="string">"minusPrice"</span>&gt;减少价格&lt;/button&gt; //添加按钮</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>在<code>ProductListTwo.vue</code>中注册<code>minusPrice</code>方法, 在该方法中<code>commitmutations</code>中的<code>minusPrice</code>这个回调函数<br><strong>注意:调用<code>mutaions</code>中回调函数, 只能使用<code>store.commit(type, payload)</code></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ProductListTwo.vue</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products: this.<span class="variable">$store</span>.state.products</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">minusPrice</span></span>() &#123;</span><br><span class="line">            this.<span class="variable">$store</span>.commit(<span class="string">'minusPrice'</span>, 2); //提交`minusPrice,payload为2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加按钮, 可以发现,<code>Product List Two</code>中的价格减少了2, 当然你可以自定义<code>payload</code>,以此自定义减少对应的价格.<br><img src="/assets/images/vuex5.png" alt="vuex"></p><h6 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h6><p><code>actions</code> 类似于 <code>mutations</code>，不同在于：<br><code>actions</code>提交的是<code>mutations</code>而不是直接变更状态<br><code>actions</code>中可以包含异步操作, <code>mutations</code>中绝对不允许出现异步<br><code>actions</code>中的回调函数的第一个参数是<code>context</code>, 是一个与<code>store</code>实例具有相同属性和方法的对象<br>　　此时,我们在<code>store</code>中添加<code>actions</code>属性, 其中<code>minusPriceAsync</code>采用<code>setTimeout</code>来模拟异步操作,延迟2s执行 该方法用于异步改变我们刚才在<code>mutaions</code>中定义的<code>minusPrice</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    products: [</span><br><span class="line">      &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">      &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">      &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">      &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters:&#123;</span><br><span class="line">    saleProducts: (state) =&gt; &#123;</span><br><span class="line">      <span class="built_in">let</span> saleProducts = state.products.map( product =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">          name: product.name,</span><br><span class="line">          price: product.price / 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">return</span> saleProducts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123;</span><br><span class="line">    minusPrice (state, payload ) &#123;</span><br><span class="line">      <span class="built_in">let</span> newPrice = state.products.forEach( product =&gt; &#123;</span><br><span class="line">        product.price -= payload</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions:&#123; //添加actions</span><br><span class="line">    minusPriceAsync( context, payload ) &#123;</span><br><span class="line">      setTimeout( () =&gt; &#123;</span><br><span class="line">        context.commit( <span class="string">'minusPrice'</span>, payload ); //context提交</span><br><span class="line">      &#125;, 2000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在<code>ProductListTwo.vue</code>中添加一个按钮,为其添加一个点击事件, 给点击事件触发<code>minusPriceAsync</code>方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"product-list-two"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Product List Two&lt;/h2&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=<span class="string">"product in products"</span>&gt;</span><br><span class="line">                &lt;span class=<span class="string">"name"</span>&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span class=<span class="string">"price"</span>&gt;<span class="variable">$&#123;&#123; product.price &#125;</span>&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;button @click=<span class="string">"minusPrice"</span>&gt;减少价格&lt;/button&gt;</span><br><span class="line">            &lt;button @click=<span class="string">"minusPriceAsync"</span>&gt;异步减少价格&lt;/button&gt; //添加按钮</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>在<code>ProductListTwo.vue</code>中注册<code>minusPriceAsync</code>方法, 在该方法中<code>dispatchactions</code>中的<code>minusPriceAsync</code>这个回调函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products: this.<span class="variable">$store</span>.state.products</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">minusPrice</span></span>() &#123;</span><br><span class="line">            this.<span class="variable">$store</span>.commit(<span class="string">'minusPrice'</span>, 2);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">minusPriceAsync</span></span>() &#123;</span><br><span class="line">            this.<span class="variable">$store</span>.dispatch(<span class="string">'minusPriceAsync'</span>, 5); //分发actions中的minusPriceAsync这个异步函数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加按钮, 可以发现, <code>Product List Two</code>中的价格延迟2s后减少了5<br><img src="/assets/images/vuex6.png" alt="vuex"></p><h6 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h6><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，<code>store</code> 对象就有可能变得相当臃肿。为了解决以上问题，<code>Vuex</code>允许我们将 <code>store</code> 分割成模块<code>（module）</code>。每个模块拥有自己的 <code>state</code>、<code>mutation</code>、<code>action</code>、<code>getter</code>、甚至是嵌套子模块——从上至下进行同样方式的分割</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure><h5 id="mapactions-amp-amp-…mapgetters"><a href="#mapactions-amp-amp-…mapgetters" class="headerlink" title="..mapactions&amp;&amp; …mapgetters"></a>..mapactions&amp;&amp; …mapgetters</h5>]]></content>
    
    <summary type="html">
    
      &lt;!-- 目录 --&gt;
&lt;!-- toc --&gt;
&lt;p&gt;转载：&lt;br&gt;　　&lt;a href=&quot;https://blog.csdn.net/qq_35430000/article/details/79291287&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue通信、传值的多种方式（详细）&lt;/a&gt;&lt;br&gt;　　&lt;a href=&quot;https://www.jianshu.com/p/a804606ad8e9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue.js——十分钟入门Vuex&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;通过路由带参数进行传值&quot;&gt;&lt;a href=&quot;#通过路由带参数进行传值&quot; class=&quot;headerlink&quot; title=&quot;通过路由带参数进行传值&quot;&gt;&lt;/a&gt;通过路由带参数进行传值&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;两个组件 A和B,A组件通过query把orderId传递给B组件（触发事件可以是点击事件、钩子函数等）&lt;br&gt;&lt;code&gt;this.$router.push({ path: &amp;#39;/conponentsB&amp;#39;, query: { orderId: 123 } }) // 跳转到B&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在B组件中获取A组件传递过来的参数&lt;br&gt;&lt;code&gt;this.$route.query.orderId&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue基础" scheme="http://yoursite.com/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="http://yoursite.com/2019/03/08/CSS3/flex%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2019/03/08/CSS3/flex布局/</id>
    <published>2019-03-08T11:03:14.000Z</published>
    <updated>2019-03-09T02:31:23.050Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载：<br>　　阮一峰：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a><br><img src="/assets/images/flex.jpg" alt="flex布局"><br>　　2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。<br><a id="more"></a><br><img src="/assets/images/flexSupport.jpg" alt="flex"></p><h4 id="Flex布局是什么？"><a href="#Flex布局是什么？" class="headerlink" title="Flex布局是什么？"></a>Flex布局是什么？</h4><p>　　Flex 是 <code>Flexible Box</code> 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: felx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>行内元素也可以使用 <code>Flex</code> 布局。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: -webkit-flex; /* Safari */</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="注意，设为-Flex-布局以后，子元素的float、clear和vertical-align属性将失效。"><a href="#注意，设为-Flex-布局以后，子元素的float、clear和vertical-align属性将失效。" class="headerlink" title="注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。"></a>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</h5><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>　　采用 <code>Flex</code> 布局的元素，称为 <code>Flex</code> 容器（<code>flex container</code>），简称”容器”。它的所有子元素自动成为容器成员，称为 <code>Flex</code> 项目（<code>flex item</code>），简称”项目”。<br><img src="/assets/images/flex01.png" alt="flex01"><br>容器默认存在两根轴：水平的主轴（<code>main axis</code>）和垂直的交叉轴（<code>cross axis</code>）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h4 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h4><p>　　以下6个属性设置在容器上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-direction</span><br><span class="line">flex-wrap</span><br><span class="line">flex-flow</span><br><span class="line">justify-content</span><br><span class="line">align-items</span><br><span class="line">align-content</span><br></pre></td></tr></table></figure></p><h5 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h5><p>　　<code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex02.png" alt="flex02"><br>　　它可能有4个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row（默认值）：主轴为水平方向，起点在左端。</span><br><span class="line">row-reverse：主轴为水平方向，起点在右端。</span><br><span class="line">column：主轴为垂直方向，起点在上沿。</span><br><span class="line">column-reverse：主轴为垂直方向，起点在下沿。</span><br></pre></td></tr></table></figure></p><h5 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h5><p>　　默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。<br><img src="/assets/images/flex03.png" alt="flex03"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　它可能取三个值。<br>（1）<code>nowrap</code>（默认）：不换行。<br><img src="/assets/images/flex04.png" alt="flex04"><br>（2）<code>wrap</code>：换行，第一行在上方。<br><img src="/assets/images/flex05.jpg" alt="flex05"><br>（3）<code>wrap-reverse</code>：换行，第一行在下方。<br><img src="/assets/images/flex06.jpg" alt="flex06"></p><h5 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h5><p>　　<code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h5><p>　　<code>justify-content</code>属性定义了项目在主轴上的对齐方式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex07.png" alt="flex07"><br>　　它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex-start（默认值）：左对齐</span><br><span class="line">flex-end：右对齐</span><br><span class="line">center： 居中</span><br><span class="line">space-between：两端对齐，项目之间的间隔都相等。</span><br><span class="line">space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br></pre></td></tr></table></figure></p><h5 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h5><p>　　<code>align-items</code>属性定义项目在交叉轴上如何对齐。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>建立在主轴为水平方向时测试，即 <code>flex-direction: row</code></strong><br>默认值为 <code>stretch</code> 即如果项目未设置高度或者设为 <code>auto</code>，将占满整个容器的高度。<br><img src="/assets/images/flex08.jpg" alt="flex08"><br>假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。<br><img src="/assets/images/flex08.png" alt="flex08"><br>　　它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex-start：交叉轴的起点对齐。</span><br><span class="line">flex-end：交叉轴的终点对齐。</span><br><span class="line">center：交叉轴的中点对齐。</span><br><span class="line">baseline: 项目的第一行文字的基线对齐。</span><br><span class="line">stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span><br></pre></td></tr></table></figure></p><h5 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h5><p>　　<code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex09.png" alt="flex09"><br>　　该属性可能取6个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-start：与交叉轴的起点对齐。</span><br><span class="line">flex-end：与交叉轴的终点对齐。</span><br><span class="line">center：与交叉轴的中点对齐。</span><br><span class="line">space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</span><br><span class="line">space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</span><br><span class="line">stretch（默认值）：轴线占满整个交叉轴。</span><br></pre></td></tr></table></figure></p><h4 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h4><p>以下6个属性设置在项目上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">order</span><br><span class="line">flex-grow</span><br><span class="line">flex-shrink</span><br><span class="line">flex-basis</span><br><span class="line">flex</span><br><span class="line">align-self</span><br></pre></td></tr></table></figure></p><h5 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h5><p>　　<code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  order: &lt;<span class="built_in">integer</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex10.png" alt="flex10"></p><h5 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h5><p>　　<code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-grow: &lt;number&gt;; /* default 0 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex11.png" alt="flex11"><br>　　如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h5 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h5><p>　　<code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-shrink: &lt;number&gt;; /* default 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex12.jpg" alt="flex12"></p><p>　　如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h5 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h5><p>　　flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><p>.item {<br>  flex-basis: <length> | auto; /<em> default auto </em>/<br>}<br>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</length></p><h5 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h5><p>　　<code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该属性有两个快捷值：<code>auto (1 1 auto)`</code> 和 <code>none (0 0 auto)</code>。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h5 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h5><p>　　<code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex13.png" alt="flex13"><br>　　该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;转载：&lt;br&gt;　　阮一峰：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flex 布局教程：语法篇&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/assets/images/flex.jpg&quot; alt=&quot;flex布局&quot;&gt;&lt;br&gt;　　2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="页面布局" scheme="http://yoursite.com/tags/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>网页从输入网址到渲染完成经历了哪些过程</title>
    <link href="http://yoursite.com/2019/02/23/HTTP/%E7%BD%91%E9%A1%B5%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/23/HTTP/网页从输入网址到渲染完成经历了哪些过程/</id>
    <published>2019-02-23T14:45:31.000Z</published>
    <updated>2019-03-08T13:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="过程概述"><a href="#过程概述" class="headerlink" title="过程概述"></a>过程概述</h4><p>　　从输入域名到网页打开的简单过程如下：<br><strong>1. DNS域名解析</strong><br>　　客户端输入域名后，由DNS服务器来将域名解析成对应服务器的IP地址<br><strong>2. 建立TCP连接</strong><br>　　客户端得到IP地址以后,会根据所获得的IP地址以及要访问的端口号发起网络连接， 即<font color="blue"><strong>tcp三次握手</strong></font>连接， 建立起TCP/IP网络连接， 具体过程如下：<a id="more"></a><br>　　第一次握手：<br>　　　　<font color="orange">主机向服务器发送一个建立连接的请求（您好，我想认识您）</font><br>　　　　<font color="red">建立连接时，客户端发送syn包(syn=j)到服务器，并进入<strong><em>SYN_SEND</em></strong>状态，等待服务器确认</font><br>　　第二次握手：<br>　　　　<font color="orange">服务器接到请求后发送同意连接的信号（好的，很高兴认识您）</font><br>　　　　<font color="red">服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器 进入SYN_RECV状态；</font><br>　　第三次握手：<br>　　　　<font color="orange">主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接</font><br>　　　　<font color="red">客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。<br>通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。</font><br><strong>补充说明:</strong><br>　　　　TCP 协议：三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号。<br><strong>3. 发送HTTP请求</strong><br>　　与服务器建立连接之后，就可以向服务器发送请求了，请求需要遵循http协议<br><strong>4.服务器处理请求；</strong><br>　　被请求的服务器解析用户请求的有哪些资源，通过服务器返回数据给客户端<br><strong>5.返回响应结果；</strong><br>　　给客户端返回请求的状态码，通过状态码可以知道服务器端的处理是否正常<br><strong>6.浏览器渲染：</strong><br>　　返回成功之后，浏览器拿到请求页面的代码，将其解析渲染出来。解析和渲染的过程主要由浏览器的渲染引擎实现。</p><h5 id="根据域名查找-IP-地址"><a href="#根据域名查找-IP-地址" class="headerlink" title="根据域名查找 IP 地址"></a>根据域名查找 IP 地址</h5><h6 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h6><p>　　<strong>IP 地址</strong>：IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址；<br>　　<strong>域名(DN)</strong>：IP 地址由四个数字组成，中间用点号连接，在使用过程中难记忆且易输入错误，所以用我们熟悉的字母和数字组合来代替纯数字的 IP 地址，比如我们只会记住 <code>www.baidu.com</code>（百度域名） 而不是 <code>220.181.112.244</code>（百度的其中一个 IP 地址）；<br>　　<strong>DNS</strong>： 每个域名都对应一个或多个提供相同服务服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。</p><p>　　知道了上面的概念，大概就知道了想要获得服务器的门牌号码，需要先将域名转换成 IP 地址。转换过程如下（以查询 <code>www.baidu.com</code> 的 IP 地址为例，其中2、3、4步均在上一步未查询成功的情况下进行）：</p><h6 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h6><ol><li>浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；</li><li>搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；</li><li>搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；</li><li>操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；<ol><li>LDNS 向 <code>Root Name Server</code>（根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，<code>Root Name Server</code>返回 com 域的顶级域名服务器的地址；</li><li>LDNS 向 com 域的顶级域名服务器发起请求，返回 <code>baidu.com</code>域名服务器地址；</li><li>LDNS 向 baidu.com 域名服务器发起请求，得到 <code>www.baidu.com</code>的 IP 地址；</li></ol></li><li>LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；</li><li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；</li><li>至此，浏览器已经得到了域名对应的 IP 地址。</li></ol><p><strong>补充说明</strong><br>　　域名与 URL 是两个概念：域名是一台或一组服务器的名称，用来确定服务器在 Internet 上的位置；URL 是统一资源定位符，用来确定某一个文件的具体位置，例如，<code>zhihu.com</code> 是 知乎的域名，根据这个域名可以找到知乎的服务器，<code>zhihu.com/people/CompileYouth</code> 是 URL ，可以根据这个 URL 定位我的知乎主页；<br>　　IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限；</p><h5 id="网页请求与显示"><a href="#网页请求与显示" class="headerlink" title="网页请求与显示"></a>网页请求与显示</h5><p>　　当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。</p><ol><li>服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；</li><li>服务器将得到的 HTML 文件发送给浏览器；</li><li>在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；</li><li>在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML </li></ol><h4 id="断开连接–四次挥手"><a href="#断开连接–四次挥手" class="headerlink" title="断开连接–四次挥手"></a>断开连接–四次挥手</h4><ol><li>主机向服务器发送一个断开连接的请求（不早了，我该走了）；</li><li>服务器接到请求后发送确认收到请求的信号（知道了）；</li><li>服务器向主机发送断开通知（我也该走了）；</li><li>主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；</li></ol><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>　　一个完整的URL地址由：<strong>协议</strong>、<strong>服务器地址(主机)</strong>、<strong>端口</strong>、<strong>资源路径(文件)</strong>。其中网络地址指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；协议是从 该计算机获取资源的方式，常见的是HTTP、FTP，不同协议有不同的通讯内容格式；资源路径指示从服务器上获取哪一项资源。<br>例如：<code>http://www.guokr.com/question/554991/</code><br>超文本传输协议：<code>http</code><br>服务器地址：<code>www.guokr.com</code><br>端口： http协议的默认<strong>端口</strong>为80<br>资源路径：是指要活的的文件的路径 -&gt;<code>/question/554991/</code></p><p>转载：<br>　　<a href="https://www.cnblogs.com/ishuanghe/p/5200775.html" target="_blank" rel="noopener">一个页面从输入url,到页面显示加载完成,这个过程中都发生了什么?</a><br>　　<a href="https://zhuanlan.zhihu.com/p/23155051" target="_blank" rel="noopener">从输入 URL 到页面加载完成的过程中都发生了什么</a><br>参考文章：<br>　　<a href="http://www.cnblogs.com/beyond-Acm/p/4309983.html" target="_blank" rel="noopener">从键入网址到页面显示经历了那些过程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h4 id=&quot;过程概述&quot;&gt;&lt;a href=&quot;#过程概述&quot; class=&quot;headerlink&quot; title=&quot;过程概述&quot;&gt;&lt;/a&gt;过程概述&lt;/h4&gt;&lt;p&gt;　　从输入域名到网页打开的简单过程如下：&lt;br&gt;&lt;strong&gt;1. DNS域名解析&lt;/strong&gt;&lt;br&gt;　　客户端输入域名后，由DNS服务器来将域名解析成对应服务器的IP地址&lt;br&gt;&lt;strong&gt;2. 建立TCP连接&lt;/strong&gt;&lt;br&gt;　　客户端得到IP地址以后,会根据所获得的IP地址以及要访问的端口号发起网络连接， 即&lt;font color=&quot;blue&quot;&gt;&lt;strong&gt;tcp三次握手&lt;/strong&gt;&lt;/font&gt;连接， 建立起TCP/IP网络连接， 具体过程如下：&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="网页从输入网址到渲染完成经历了哪些过程" scheme="http://yoursite.com/tags/%E7%BD%91%E9%A1%B5%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MVVM开发模式的理解</title>
    <link href="http://yoursite.com/2019/02/23/Vue/MVVM%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/23/Vue/MVVM开发模式的理解/</id>
    <published>2019-02-23T06:28:24.000Z</published>
    <updated>2019-03-14T13:08:29.768Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- 目录 --><!-- toc --><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>　　MVVM（模型视图ViewModel 是一种基于MVC和MVP的架构模式，<font color="FF0000">它试图更清楚地将用户界面（UI）的开发与应用程序中的业务逻辑和行为的开发分开</font>。为此，此模式的许多实现都使用声明性数据绑定，以允许将视图上的工作与其他层分离。<a id="more"></a></p><h4 id="Model、View、ViewModel"><a href="#Model、View、ViewModel" class="headerlink" title="Model、View、ViewModel"></a>Model、View、ViewModel</h4><p>　　MVVM分为Model、View、ViewModel三者。</p><ul><li>Model 代表数据模型，数据和业务逻辑都在Model层中定义；</li><li>View 代表UI视图，负责数据的展示，是用户在屏幕上看到的结构；</li><li>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；<br>　　Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。<br>这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom。<br><img src="/assets/images/mvvm2.png" alt="mvvm"><br><img src="/assets/images/mvvm.png" alt="mvvm"></li></ul><h3 id="设计模式编辑"><a href="#设计模式编辑" class="headerlink" title="设计模式编辑"></a>设计模式编辑</h3><p>　　因为WPF技术出现，从而使MVC架构模式有所改进，MVVM 模式便是使用的是数据绑定基础架构。它们可以轻松构建UI的必要元素。<br>可以参考The Composite Application Guidance for WPF(prism)<br>View绑定到ViewModel，然后执行一些命令在向它请求一个动作。而反过来，ViewModel跟Model通讯，告诉它更新来响应UI。这样便使得为应用构建UI非常的容易。往一个应用程序上贴一个界面越容易，外观设计师就越容易使用Blend来创建一个漂亮的界面。同时，当UI和功能越来越松耦合的时候，功能的可测试性就越来越强。<br>在MVP模式中，为了让UI层能够从逻辑层上分离下来，设计师们在UI层与逻辑层之间加了一层interface。无论是UI开发人员还是数据开发人员，都要尊重这个契约、按照它进行设计和开发。这样，理想状态下无论是Web UI还是Window UI就都可以使用同一套数据逻辑了。借鉴MVP的IView层，养成习惯。View Model听起来比Presenter要贴切得多；会把一些跟事件、命令相关的东西放在MVC的’C’,或者是MVVM的’Vm’。</p><h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>　　MVVM模式和MVC模式一样，主要目的是<font color="#FF0000">分离视图（View）</font>和<font color="#FF0000">模型（Model）</font>，有几大优点:</p><ol><li><strong>低耦合</strong>: <strong>视图（View）</strong>可以独立于 <strong>Model</strong> 变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li><li><strong>可重用性</strong>: 你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li><li><strong>独立开发</strong>:开发人员可以专注于业务逻辑和数据的开发(ViewModel), 设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。</li><li><strong>可测试</strong>:界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</li><li>MVVM有助于更轻松地并行开发UI以及为其提供支持的构建块</li><li>抽象视图，从而减少其背后的代码所需的业务逻辑（或粘合剂）的数量</li><li>ViewModel比事件驱动的代码更容易进行单元测试</li><li>可以在不关心UI自动化和交互的情况下测试ViewModel（比View更多的模型）</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>对于更简单的UI，MVVM可能过度</li><li>虽然数据绑定可以是声明性的并且很好用，但它们比我们简单设置断点的命令式代码更难调试</li><li>非平凡应用程序中的数据绑定可以创建大量的簿记。您也不希望在绑定比绑定的对象更重的情况下结束</li><li>在较大的应用程序中，预先设计ViewModel以获得必要的泛化量可能更加困难</li></ol><p>参考文章：<br>　　<a href="https://www.cnblogs.com/iovec/p/7840228.html" target="_blank" rel="noopener">前后端分手大师——MVVM 模式</a><br>　　<a href="https://zhuanlan.zhihu.com/p/38296857" target="_blank" rel="noopener">简单理解MVVM–实现Vue的MVVM模式</a><br>　　<a href="https://addyosmani.com/blog/understanding-mvvm-a-guide-for-javascript-developers/" target="_blank" rel="noopener">了解MVVM - JavaScript开发人员指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- 目录 --&gt;
&lt;!-- toc --&gt;
&lt;h3 id=&quot;MVVM&quot;&gt;&lt;a href=&quot;#MVVM&quot; class=&quot;headerlink&quot; title=&quot;MVVM&quot;&gt;&lt;/a&gt;MVVM&lt;/h3&gt;&lt;p&gt;　　MVVM（模型视图ViewModel 是一种基于MVC和MVP的架构模式，&lt;font color=&quot;FF0000&quot;&gt;它试图更清楚地将用户界面（UI）的开发与应用程序中的业务逻辑和行为的开发分开&lt;/font&gt;。为此，此模式的许多实现都使用声明性数据绑定，以允许将视图上的工作与其他层分离。&lt;/p&gt;
    
    </summary>
    
      <category term="开发模式" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>stylus基础</title>
    <link href="http://yoursite.com/2019/02/22/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/stylus%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/22/CSS预处理器/stylus基础语法/</id>
    <published>2019-02-22T13:47:36.000Z</published>
    <updated>2019-03-08T13:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="stylus" scheme="http://yoursite.com/categories/stylus/"/>
    
    
      <category term="stylus基础" scheme="http://yoursite.com/tags/stylus%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>redis基础</title>
    <link href="http://yoursite.com/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    <id>http://yoursite.com/2019/02/22/数据库/redis/</id>
    <published>2019-02-22T13:47:36.000Z</published>
    <updated>2019-03-08T13:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis基础" scheme="http://yoursite.com/tags/redis%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>mongoose</title>
    <link href="http://yoursite.com/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/mongoose/"/>
    <id>http://yoursite.com/2019/02/22/数据库/mongoose/</id>
    <published>2019-02-22T13:27:12.000Z</published>
    <updated>2019-03-08T13:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h4><h5 id="mongodb-的概念-amp-安装"><a href="#mongodb-的概念-amp-安装" class="headerlink" title="mongodb 的概念 &amp; 安装"></a>mongodb 的概念 &amp; 安装</h5><p>mongod</p><h5 id="mongodb-可视化工具-RoRo-3T-安装及应用"><a href="#mongodb-可视化工具-RoRo-3T-安装及应用" class="headerlink" title="mongodb 可视化工具 RoRo 3T 安装及应用"></a>mongodb 可视化工具 RoRo 3T 安装及应用</h5><h5 id="mongoose-的作用"><a href="#mongoose-的作用" class="headerlink" title="mongoose 的作用"></a>mongoose 的作用</h5><h5 id="mongoose-的应用"><a href="#mongoose-的应用" class="headerlink" title="mongoose 的应用"></a>mongoose 的应用</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="mongoose" scheme="http://yoursite.com/categories/mongoose/"/>
    
    
      <category term="mongoose" scheme="http://yoursite.com/tags/mongoose/"/>
    
  </entry>
  
  <entry>
    <title>Koa2基础</title>
    <link href="http://yoursite.com/2019/02/21/Koa2/Koa2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/02/21/Koa2/Koa2基础知识/</id>
    <published>2019-02-21T15:54:01.000Z</published>
    <updated>2019-03-08T13:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p><a href="https://koa.bootcss.com" target="_blank" rel="noopener">Koa官网</a><br><a href="https://chenshenhai.github.io/koa2-note/" target="_blank" rel="noopener">《Koa2进阶学习笔记》已完结</a></p><h3 id="使用koa-generator生成koa2项目"><a href="#使用koa-generator生成koa2项目" class="headerlink" title="使用koa-generator生成koa2项目"></a>使用koa-generator生成koa2项目</h3><p>全局安装koa-generator: <code>npm install -g koa-generator</code><br>使用koa-generator生成koa2项目: <code>koa2 -e koa2-learn</code><br>　　　　　　　　　　　　　　　　　<strong>-e 添加ejs模板引擎支持(默认是jade)</strong><br>　　　　　　　　　　　　　　　　　koa2-learn 项目名<a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ koa2 -e koa2-learning</span><br><span class="line"></span><br><span class="line">   create : koa2-learning</span><br><span class="line">   create : koa2-learning/package.json</span><br><span class="line">   create : koa2-learning/app.js</span><br><span class="line">   create : koa2-learning/public/javascripts</span><br><span class="line">   create : koa2-learning/routes</span><br><span class="line">   create : koa2-learning/routes/index.js</span><br><span class="line">   create : koa2-learning/routes/users.js</span><br><span class="line">   create : koa2-learning/public/images</span><br><span class="line">   create : koa2-learning/public/stylesheets</span><br><span class="line">   create : koa2-learning/public/stylesheets/style.css</span><br><span class="line">   create : koa2-learning/public</span><br><span class="line">   create : koa2-learning/views</span><br><span class="line">   create : koa2-learning/views/index.ejs</span><br><span class="line">   create : koa2-learning/views/error.ejs</span><br><span class="line">   create : koa2-learning/bin</span><br><span class="line">   create : koa2-learning/bin/www</span><br><span class="line"></span><br><span class="line">   install dependencies:</span><br><span class="line">     $ cd koa2-learning &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">   run the app:</span><br><span class="line">     $ DEBUG=koa2-learning:* npm start</span><br></pre></td></tr></table></figure></p><p>PS: 如果出现 <code>npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.7: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})</code>  不用担心。出现原因：<br><code>fsevents</code> 不在 <code>package.json</code>里，但是仍然安装了，是因为你的系统是Windows系统，fsevents是苹果系统的可选依赖,你的项目有可能是团队项目，别人在他的mac上安装了fsevents相关依赖库，所以到这边你也就安装到你的windows上边了。你可以检查你的package.json 文件中是不是有fsevents相关依赖，删除即好！<br>如果没有，其他的npm包也会有依赖fsevents的！！！<br><strong>这是warning错误，是因为mac下需要fsevents，这里是在windows环境，所以可以忽略这个警告，对你没什么影响的。</strong><br>运行: <code>DEBUG=koa2-learning:* npm start</code> || <code>npm run dev</code><br>效果： 出现 <strong>node bin/www</strong> 访问 <code>http://localhost:3000/</code><br>注意： npm start 、 npm test 、 npm run dev 、 npm run prd</p><h3 id="async-和-await-语法"><a href="#async-和-await-语法" class="headerlink" title="async 和 await 语法"></a>async 和 await 语法</h3><h4 id="异步概念"><a href="#异步概念" class="headerlink" title="异步概念"></a>异步概念</h4><blockquote><p>是指一个进程在执行某个请求的时候，如果这个请求没有执行完毕，进程不会等待，而是继续执行下面的请求。</p></blockquote><h4 id="理解async-和-await"><a href="#理解async-和-await" class="headerlink" title="理解async 和 await"></a>理解async 和 await</h4><h3 id="Koa2-中间件"><a href="#Koa2-中间件" class="headerlink" title="Koa2 中间件"></a>Koa2 中间件</h3><h4 id="koa2-中间件的原理"><a href="#koa2-中间件的原理" class="headerlink" title="koa2 中间件的原理"></a>koa2 中间件的原理</h4><p><img src="/assets/images/koa2.png" alt="koa2"><br><img src="/assets/images/koa2中间件.png" alt="koa2"></p><h4 id="自定义-koa2-中间件"><a href="#自定义-koa2-中间件" class="headerlink" title="自定义 koa2 中间件"></a>自定义 koa2 中间件</h4><h3 id="koa2-路由"><a href="#koa2-路由" class="headerlink" title="koa2 路由"></a>koa2 路由</h3><h4 id="路由写法"><a href="#路由写法" class="headerlink" title="路由写法"></a>路由写法</h4><h4 id="接口举例"><a href="#接口举例" class="headerlink" title="接口举例"></a>接口举例</h4><h3 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h3><h4 id="cookie-和-session-的定义"><a href="#cookie-和-session-的定义" class="headerlink" title="cookie 和 session 的定义"></a>cookie 和 session 的定义</h4><h4 id="cookie-和-session-的作用"><a href="#cookie-和-session-的作用" class="headerlink" title="cookie 和 session 的作用"></a>cookie 和 session 的作用</h4><p>推荐：<br>　　<a href="https://zhuanlan.zhihu.com/p/35040744" target="_blank" rel="noopener">从头实现一个koa框架</a><br>　　<a href="https://segmentfault.com/a/1190000013981513" target="_blank" rel="noopener">浅析koa的洋葱模型实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;&lt;a href=&quot;https://koa.bootcss.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Koa官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://chenshenhai.github.io/koa2-note/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Koa2进阶学习笔记》已完结&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用koa-generator生成koa2项目&quot;&gt;&lt;a href=&quot;#使用koa-generator生成koa2项目&quot; class=&quot;headerlink&quot; title=&quot;使用koa-generator生成koa2项目&quot;&gt;&lt;/a&gt;使用koa-generator生成koa2项目&lt;/h3&gt;&lt;p&gt;全局安装koa-generator: &lt;code&gt;npm install -g koa-generator&lt;/code&gt;&lt;br&gt;使用koa-generator生成koa2项目: &lt;code&gt;koa2 -e koa2-learn&lt;/code&gt;&lt;br&gt;　　　　　　　　　　　　　　　　　&lt;strong&gt;-e 添加ejs模板引擎支持(默认是jade)&lt;/strong&gt;&lt;br&gt;　　　　　　　　　　　　　　　　　koa2-learn 项目名&lt;/p&gt;
    
    </summary>
    
      <category term="Koa2" scheme="http://yoursite.com/categories/Koa2/"/>
    
    
      <category term="Koa2基础" scheme="http://yoursite.com/tags/Koa2%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js基础</title>
    <link href="http://yoursite.com/2019/02/15/Vue/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2019/02/15/Vue/基础知识点/</id>
    <published>2019-02-15T09:32:51.000Z</published>
    <updated>2019-03-08T13:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- 目录 --><!-- toc --><p>Vue.js基础，模块化，单文件组件，路由，与服务器通信，状态管理，单元测试与生产发布，服务端渲染SSR与Nuxt.js，基于Vue.js企业级项目开发(Mint UI, Element UI)等<br>132131</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue基础" scheme="http://yoursite.com/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局</title>
    <link href="http://yoursite.com/2019/02/15/CSS3/css%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2019/02/15/CSS3/css布局/</id>
    <published>2019-02-15T08:27:32.000Z</published>
    <updated>2019-03-09T06:53:26.134Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载：<br>　　知乎专栏：<a href="https://zhuanlan.zhihu.com/p/25565751" target="_blank" rel="noopener">CSS布局十八般武艺都在这里了</a><br>参考：掘金：<a href="https://juejin.im/post/599970f4518825243a78b9d5#heading-43" target="_blank" rel="noopener">CSS 常见布局方式</a><br><img src="https://user-gold-cdn.xitu.io/2017/8/21/395302ae7949d78570a6102e5ded1ff0?imageslim" alt="css布局"><br><!-- toc --></p><h4 id="常用居中方法"><a href="#常用居中方法" class="headerlink" title="常用居中方法"></a>常用居中方法</h4><p>　　居中在布局中很常见，我们假设DOM文档结构如下，子元素要在父元素中居中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"parent"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"child"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h5 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h5><p>　　子元素为行内元素还是块状元素，宽度一定还是宽度未定，采取的布局方案不同。<br>子元素为:</p><hr><p>行内元素：对父元素设置<code>text-align:center</code>;<br>定宽块状元素: 设置左右<code>margin</code>值为<code>auto</code>;<br>不定宽块状元素: 设置子元素为<code>display:inline</code>,然后在父元素上设置<code>text-align:center;</code><br>通用方案: flex布局，对父元素设置<code>display:flex;justify-content:center;`</code></p><hr><p>例子：<br><strong>固定宽度</strong><br>　　这种方式是绝对定位居中，除了使用 margin，我们还可以使用 transform（注意浏览器兼容性，只适用于 ie9+，移动开发请忽略）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.inner&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-top: -25px;</span><br><span class="line">    margin-left: -50px;</span><br><span class="line">    background: <span class="comment">#fff;</span></span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.inner&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    /* transform: translate(-50%, -50%); */</span><br><span class="line">    transform: translate(-50px, -25px);</span><br><span class="line">    background: <span class="comment">#fff;</span></span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>宽度未知</strong><br>　　将子元素设置为行内元素，然后父元素设置 <code>text-align: center</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line">    position: relative;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.inner&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>多个块状元素</strong><br>　　上面的方式即使子元素不止一个也想实现水平居中也是有效的，（宽度固定不固定都可，不固定的话就不需要设置宽度，会被自动撑开，但是要考虑到撑爆的情况）例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    width: 250px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line">    position: relative;</span><br><span class="line">    text-align: center;</span><br><span class="line">    padding: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.inner&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    background: <span class="comment">#fff;</span></span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　当然也可以使用我们刚刚介绍的 flex，我们只需要让子元素在主轴上的对齐方式设置为居中就可以<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    width: 250px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    padding: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.inner&#123;</span><br><span class="line">    background: <span class="comment">#fff;</span></span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h5><p>　　垂直居中对于子元素是单行内联文本、多行内联文本以及块状元素采用的方案是不同的。<br><strong>父元素一定，子元素为单行内联文本</strong>:设置父元素的<code>height</code>等于行高<code>line-height</code><br><strong>父元素一定，子元素为多行内联文本</strong>:设置父元素的<code>display:table-cell或inline-block</code>，再设置<code>vertical-align:middle</code>;<br><strong>块状元素</strong>:设置子元素<code>position:absolute</code>并设置<code>top、bottom为0</code>，父元素要设置定位为<code>static</code>以外的值，<code>margin:auto</code>;<br><strong>通用方案</strong>:<code>flex</code>布局，给父元素设置<code>{display:flex; align-items:center;}</code>。</p><h4 id="单列布局"><a href="#单列布局" class="headerlink" title="单列布局"></a>单列布局</h4><p>　　<img src="/assets/images/css布局.png" alt="css布局"><br>特征：<strong>定宽、水平居中</strong><br>常见的单列布局有两种：<br>　　一种是header、content、footer宽度都相同，其一般不会占满浏览器的最宽宽度，但当浏览器宽度缩小低于其最大宽度时，宽度会自适应。<br>　　一种是header、footer宽度为浏览器宽度，但content以及header和footer里的内容却不会占满浏览器宽度。<br>对于第一种，对header、content、footer统一设置width或max-width，并通过margin:auto实现居中。<br>DOM文档:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"layout"</span>&gt;</span><br><span class="line">  &lt;div id=<span class="string">"header"</span>&gt;头部&lt;/div&gt;</span><br><span class="line">  &lt;div id=<span class="string">"content"</span>&gt;内容&lt;/div&gt;</span><br><span class="line">  &lt;div id=<span class="string">"footer"</span>&gt;尾部&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>CSS清单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.layout&#123;</span><br><span class="line">/*   width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/</span><br><span class="line">  max-width: 960px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　对于第二种，header、footer的内容宽度为100%，但header、footer的内容区以及content统一设置width 或 max-width，并通过margin:auto实现居中。<br>DOM文档:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"header"</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">"layout"</span>&gt;头部&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"content"</span> class=<span class="string">"layout"</span>&gt;内容&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"footer"</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">"layout"</span>&gt;尾部&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>CSS清单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.layout&#123;</span><br><span class="line">/*   width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/</span><br><span class="line">  max-width: 960px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二列-amp-三列布局"><a href="#二列-amp-三列布局" class="headerlink" title="二列&amp;三列布局"></a>二列&amp;三列布局</h4><p>　　<img src="/assets/images/css布局02.png" alt="css布局"><br>二列布局的特征是侧栏固定宽度，主栏自适应宽度。<br>三列布局的特征是两侧两列固定宽度，中间列自适应宽度。</p><p>之所以将二列布局和三列布局写在一起，是因为二列布局可以看做去掉一个侧栏的三列布局，其布局的思想有异曲同工之妙。对于传统的实现方法，主要讨论上图中前三种布局，经典的带有侧栏的二栏布局以及带有左右侧栏的三栏布局，对于flex布局，实现了上图的五种布局。</p><h5 id="float-margin"><a href="#float-margin" class="headerlink" title="float + margin"></a>float + margin</h5><p>　　原理说明：设置两个侧栏分别向左向右浮动，中间列通过外边距给两个侧栏腾出空间，中间列的宽度根据浏览器窗口自适应。</p><p>DOM文档:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"content"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"sub"</span>&gt;sub&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"extra"</span>&gt;extra&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;main&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>布局步骤:</p><p>对两边侧栏分别设置宽度，并对左侧栏添加左浮动，对右侧栏添加有浮动。<br>对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。<br>CSS清单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.sub&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.extra&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    <span class="built_in">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line">    margin-left: 100px; </span><br><span class="line">    margin-right: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一些说明:</p><p>注意DOM文档的书写顺序，先写两侧栏，再写主面板，更换后则侧栏会被挤到下一列（圣杯布局和双飞翼布局都会用到）。 　<br>这种布局方式比较简单明了，但缺点是渲染时先渲染了侧边栏，而不是比较重要的主面板。</p><p>二列的实现方法</p><p>如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。</p><h5 id="position-margin"><a href="#position-margin" class="headerlink" title="position + margin"></a>position + margin</h5><p>　　原理说明：通过绝对定位将两个侧栏固定，同样通过外边距给两个侧栏腾出空间，中间列自适应。</p><p>DOM文档:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"sub"</span>&gt;left&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"main"</span>&gt;main&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"extra"</span>&gt;right&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>布局步骤:</p><p>对两边侧栏分别设置宽度，设置定位方式为绝对定位。<br>设置两侧栏的top值都为0，设置左侧栏的left值为0， 右侧栏的right值为0。<br>对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。<br>CSS清单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.sub, .extra &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0; </span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.sub &#123; </span><br><span class="line">    left: 0;</span><br><span class="line">&#125;</span><br><span class="line">.extra &#123; </span><br><span class="line">    right: 0; </span><br><span class="line">&#125;</span><br><span class="line">.main &#123; </span><br><span class="line">    margin: 0 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一些说明:</p><p>本方法不限制DOM书写顺序，先写主面板会使主面板部分优先渲染（一般主面板会比侧栏内容重要）。<br>与上一种方法相比，本种方法是通过定位来实现侧栏的位置固定。<br>如果中间栏含有最小宽度限制，或是含有宽度的内部元素，则浏览器窗口小到一定程度，主面板与侧栏会发生重叠。<br>二列的实现方法</p><p>如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。</p><h5 id="圣杯布局-float-负margin"><a href="#圣杯布局-float-负margin" class="headerlink" title="圣杯布局 (float + 负margin)"></a>圣杯布局 (float + 负margin)</h5><p>原理说明：<br>　　主面板设置宽度为100%，主面板与两个侧栏都设置浮动，常见为左浮动，这时两个侧栏会被主面板挤下去。通过负边距将浮动的侧栏拉上来，左侧栏的负边距为100%，刚好是窗口的宽度，因此会从主面板下面的左边跑到与主面板对齐的左边，右侧栏此时浮动在主面板下面的左边，设置负边距为负的自身宽度刚好浮动到主面板对齐的右边。为了避免侧栏遮挡主面板内容，在外层设置左右padding值为左右侧栏的宽度，给侧栏腾出空间，此时主面板的宽度减小。由于侧栏的负margin都是相对主面板的，两个侧栏并不会像我们理想中的停靠在左右两边，而是跟着缩小的主面板一起向中间靠拢。此时使用相对布局，调整两个侧栏到相应的位置。</p><p>DOM文档:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=<span class="string">"bd"</span>&gt;         </span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;center&lt;/div&gt;        </span><br><span class="line">    &lt;div class=<span class="string">"sub"</span>&gt;left&lt;/div&gt;        </span><br><span class="line">    &lt;div class=<span class="string">"extra"</span>&gt;right&lt;/div&gt;  </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>布局步骤:<br>三者都设置向左浮动。<br>设置main宽度为100%，设置两侧栏的宽度。<br>设置 负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。<br>设置main的padding值给左右两个子面板留出空间。<br>设置两个子面板为相对定位，sub的left值为负的sub宽度，extra的right值为负的extra宽度。<br>CSS清单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;        </span><br><span class="line">    <span class="built_in">float</span>: left;       </span><br><span class="line">    width: 100%;   </span><br><span class="line"> &#125;  </span><br><span class="line"> .sub &#123;       </span><br><span class="line">    <span class="built_in">float</span>: left;        </span><br><span class="line">    width: 190px;        </span><br><span class="line">    margin-left: -100%;               </span><br><span class="line">    position: relative;  </span><br><span class="line">    left: -190px;  </span><br><span class="line">&#125;   </span><br><span class="line">.extra &#123;        </span><br><span class="line">    <span class="built_in">float</span>: left;        </span><br><span class="line">    width: 230px;        </span><br><span class="line">    margin-left: -230px; </span><br><span class="line">    position: relative; </span><br><span class="line">    right: -230px;  </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">#bd &#123;        </span></span><br><span class="line">    padding: 0 230px 0 190px;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>一些说明</p><p>DOM元素的书写顺序不得更改。<br>主面板部分优先渲染（一般主面板会比侧栏内容重要）。<br>当面板的main内容部分比两边的子面板宽度小的时候，布局就会乱掉。可以通过设置main的<code>min-width</code>属性或使用双飞翼布局避免问题。<br>二列的实现方法<br>如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的<code>padding-right</code>值，其他操作相同。反之亦然。</p><h5 id="双飞翼布局-float-负margin"><a href="#双飞翼布局-float-负margin" class="headerlink" title="双飞翼布局 (float + 负margin)"></a>双飞翼布局 (float + 负margin)</h5><p>　　原理说明：<br>双飞翼布局和圣杯布局的思想有些相似，都利用了浮动和负边距，但双飞翼布局在圣杯布局上做了改进，在main元素上加了一层div, 并设置<code>margin</code>,由于两侧栏的负边距都是相对于<code>main-wrap</code>而言，main的<code>margin</code>值变化便不会影响两个侧栏，因此省掉了对两侧栏设置相对布局的步骤。</p><p>DOM文档:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"main-wrap"</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">"main"</span>&gt;<span class="comment">#main&lt;/div&gt;</span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"sub"</span>&gt;left&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"extra"</span>&gt;right&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>布局步骤:<br>三者都设置向左浮动。设置<code>main-wrap</code>宽度为100%，设置两个侧栏的宽度。设置负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。<br>设置main的margin值给左右两个子面板留出空间。<br>CSS清单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.main-wrap &#123;        </span><br><span class="line">    <span class="built_in">float</span>: left;       </span><br><span class="line">    width: 100%;   </span><br><span class="line"> &#125;  </span><br><span class="line"> .sub &#123;       </span><br><span class="line">    <span class="built_in">float</span>: left;        </span><br><span class="line">    width: 190px;        </span><br><span class="line">    margin-left: -100%;   </span><br><span class="line">&#125;   </span><br><span class="line">.extra &#123;        </span><br><span class="line">    <span class="built_in">float</span>: left;        </span><br><span class="line">    width: 230px;        </span><br><span class="line">    margin-left: -230px; </span><br><span class="line"> &#125;</span><br><span class="line">.main &#123;    </span><br><span class="line">    margin: 0 230px 0 190px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一些说明</p><p>主面板部分优先渲染（一般主面板会比侧栏内容重要）。<br>圣杯采用的是padding，而双飞翼采用的margin，解决了圣杯布局main的最小宽度不能小于左侧栏的缺点。<br>双飞翼布局不用设置相对布局，以及对应的left和right值。<br>通过引入相对布局，可以实现三栏布局的各种组合，例如对右侧栏设置<code>position: relative; left: 190px;</code>,可以实现<code>sub+extra+main</code>的布局。<br>二列的实现方法<br>如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置main-wrap的margin-right值，其他操作相同。反之亦然。</p><h5 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h5><p>　　以下是五种布局的flex布局代码：<br>DOM文档：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"layout"</span>&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"layout"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"layout"</span>&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;左侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;右侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"layout"</span>&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;第1个侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;第2个侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"layout"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;第1个侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;第2个侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>CSS清单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.layout &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">.aside &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与之前所讲的几种传统布局方案相比，flex布局的代码可谓异常简洁，而且非常通用，利用简单的三行CSS即实现了常见的五种布局。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>　　传统的布局方法基于盒状模型，依赖 display属性 + position属性 + float属性，逻辑相对复杂，对于实现一些特殊效果，例如垂直居中，尤其复杂繁琐。而flex布局中的flex容器可以根据实际可用空间动态调整子元素的宽高比和顺序，使元素能够尽可能地利用可用空间，同时也能通过缩小来避免超出。flex布局提供了一套简便、完整、响应式的布局方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="页面布局" scheme="http://yoursite.com/tags/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>像素：(px、pt、em、rem、rpx)</title>
    <link href="http://yoursite.com/2019/02/14/%E5%83%8F%E7%B4%A0/%E5%83%8F%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/02/14/像素/像素/</id>
    <published>2019-02-14T12:04:32.000Z</published>
    <updated>2019-03-08T13:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考资料：<br><a href="http://www.runoob.com/w3cnote/px-em-rem-different.html" target="_blank" rel="noopener">px、em、rem区别介绍</a><br><a href="https://www.cnblogs.com/zhaowy/p/8400271.html" target="_blank" rel="noopener">字体大小之px、em、rem、pt,字号详解</a></p><p><strong>px:</strong><br>　　px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。<br>　　PX特点:<br>　　　　1. IE无法调整那些使用px作为单位的字体大小；<br>　　　　2. 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位；<br>　　　　3. Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。<a id="more"></a><br><strong>pt:</strong><br>　　pt(point，磅)：是一个物理长度单位，指的是72分之一英寸。表示绝对长度。<br><strong>em:</strong><br>　　em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。<br>　　em特点：<br>　　　　1. em的值并不是固定的；<br>　　　　2. em会继承父级元素的字体大小。<br>　　注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px<em>62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。<br>所以我们在写CSS的时候，需要注意两点：<br>　　　　1. body选择器中声明Font-size=62.5%；<br>　　　　2. 将你的原来的px数值除以10，然后换上em作为单位；<br>　　　　3. 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。也就是避免1.2 </em> 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。<br>　　　　<br><strong>rem:</strong><br>　　rem（root em，根em）：是CSS3新增的一个相对单位，相对的只是HTML根元素，可以只修改根元素就可以成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。兼容性IE9+都可以兼容，对于不兼容的浏览器写一个绝对单位的声明就可以了。<br><strong>rpx:</strong><br>　　rpx单位是微信小程序中css的尺寸单位，rpx可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：&lt;br&gt;&lt;a href=&quot;http://www.runoob.com/w3cnote/px-em-rem-different.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;px、em、rem区别介绍&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/zhaowy/p/8400271.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;字体大小之px、em、rem、pt,字号详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;px:&lt;/strong&gt;&lt;br&gt;　　px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。&lt;br&gt;　　PX特点:&lt;br&gt;　　　　1. IE无法调整那些使用px作为单位的字体大小；&lt;br&gt;　　　　2. 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位；&lt;br&gt;　　　　3. Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="像素" scheme="http://yoursite.com/tags/%E5%83%8F%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>重绘(repaint)与回流(reflow)</title>
    <link href="http://yoursite.com/2019/02/14/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%87%8D%E7%BB%98(repaint)%E4%B8%8E%E5%9B%9E%E6%B5%81(reflow)/"/>
    <id>http://yoursite.com/2019/02/14/前端性能优化/重绘(repaint)与回流(reflow)/</id>
    <published>2019-02-14T07:07:34.000Z</published>
    <updated>2019-03-08T13:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>文章转载：<br>　<a href="http://www.cnblogs.com/blackmanba/p/browser-repaint-reflow.html" target="_blank" rel="noopener">浏览器重绘和重排</a><br>文章参考：<br>　<a href="https://www.cnblogs.com/jiayuexuan/p/7490140.html" target="_blank" rel="noopener">重构与回流</a><br>　<a href="https://kb.cnblogs.com/page/169820/" target="_blank" rel="noopener">浏览器的重绘与重排</a><br>　<a href="http://www.cnblogs.com/shenqi0920/p/3545820.html" target="_blank" rel="noopener">探讨css中repaint和reflow</a></p><h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言：</strong></h5><p>　　页面设计中，不可避免的需要浏览器进行repaint和reflow。那到底什么是repaint和reflow呢。下面谈谈自己对repaint和reflow的理解，以及结合其他技术牛的讲解，谈谈如何优化repaint和reflow。</p><h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述：</strong></h5><p>　　<strong>重排(回流)</strong>, 顾名思义就是重新排版的意思; <strong>重绘</strong>, 就是浏览器重新绘制。理解重排和重绘的含义十分重要, 因为在评审页面交互效果的时候, 重绘和重排是必须考虑的因素。并不是说交互效果实现了就可以了, 必须同时考虑到这样做会引发什么性能问题。也就是说, 浏览器在进行重绘和重排的时候是要付出高昂的性能代价的。<br>　　只有静态页面才会不存在repaint和reflow。repaint主要是针对某一个DOM元素进行的重绘，reflow则是回流，针对整个页面的重排。字面意思来说：repaint就是重绘，reflow就是回流。<strong>回流必将引起重绘，而重绘不一定会引起回流</strong>，repaint和reflow的目的是：展示一个新的页面样貌。<a id="more"></a></p><h5 id="浏览器执行流："><a href="#浏览器执行流：" class="headerlink" title="浏览器执行流："></a><strong>浏览器执行流：</strong></h5><p>　　浏览器每次从服务器下载完页面后就会对页面进行渲染(Render), 这里面就包含了重绘以及重排。每种浏览器虽然工作原理略有差别, 但也遵循以下流程:<br>　　览器引擎会解析HTML文档来构建DOM树。树的每个节点都是标签, 有大小边距等等的属性, 这是因为每个HTML元素都遵循<strong>盒子模型</strong>(隐藏元素不包括在文档树中, 浏览器不会将其渲染)。<br>　　渲染树构建完毕后, 浏览器就能够确定每个元素的位置并将元素放到正确的位置上, 再根据<strong><em>树节点的样式属性</em></strong>绘制出页面元素。<br>　　由于浏览器的流布局的方式, 对渲染树的计算通常只需要遍历一遍即可。但table及其内部元素除外, 可能需要执行多次计算才能确定好在渲染树中的属性,这个过程通常要耗费3倍以上的时间。<br>　　这也是我们要避免使用table标签的其中一个原因。<br>　　简言之浏览器执行顺序为：<br>  　　1. 首先获取html，然后构建dom树 ，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。<br>  　　2. 浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。<br>  　　3. DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，render tree不包含隐藏的节点 (比如display:none的节点，还有head节点)，因为这些节点不会用于呈现。<br>  　　4. 一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。　　</p><h5 id="严重性："><a href="#严重性：" class="headerlink" title="严重性："></a><strong>严重性：</strong></h5><p>　在性能优先的前提下，性能消耗 reflow大于repaint。</p><h5 id="体现："><a href="#体现：" class="headerlink" title="体现："></a><strong>体现：</strong></h5><p>　repaint是某个DOM元素进行重绘；reflow是整个页面进行重排，也就是页面所有DOM元素渲染。</p><h5 id="如何触发："><a href="#如何触发：" class="headerlink" title="如何触发："></a><strong>如何触发：</strong></h5><p>　style变动造成repaint和reflow。<br>　不涉及任何DOM元素的排版问题的变动为repaint，例如元素的color/text-align/text-decoration等等属性的变动。<br>　除上面所提到的DOM元素style的修改基本为reflow。例如元素的任何涉及长、宽、行高、边框、display等style的修改。</p><h5 id="常见触发场景："><a href="#常见触发场景：" class="headerlink" title="常见触发场景："></a><strong>常见触发场景：</strong></h5><p>　　重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。重排(回流)是更明显的一种改变，可以理解为渲染树需要重新计算。</p><ol><li>触发repaint：<ol><li>color的修改，如color=#ddd；</li><li>text-align的修改，如text-align=center；</li><li>a:hover也会造成重绘。</li><li>:hover引起的颜色等不导致页面回流的style变动。</li></ol></li><li>触发reflow：<ol><li>width/height/border/margin/padding的修改，如width=778px；</li><li>动画，:hover等伪类引起的元素表现改动，display=none等造成页面回流；</li><li>appendChild等DOM元素操作；</li><li>font类style的修改；</li><li>background的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分background的修改只触发repaint，当然IE不用考虑；</li><li>scroll页面，这个不可避免；</li><li>resize页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize程序窗口大小的多窗口操作系统。</li><li>读取元素的属性(这个无法理解，但是技术达人是这么说的，那就把它当做定理吧)：读取元素的某些属性(offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE))</li></ol></li></ol><p><strong>如何避免：</strong><br>　　说避免那是不可能的，不然就是以前古老的静态页面了，没有交互，那在现在看来，就是一个失败的作品。所以，在我们进行网页设计的时候，就必须尽量减少页面的repaint和reflow。repaint和reflow的目的是为了展示一个新的页面，那么我们在进行页面交互时，尽量通过各种方法减少repaint和reflow但又能展示一个新的页面的目的。所以下面将结合其他技术达人的建议，通过自己的理解，给大家讲解如何避免和优化repaint和reflow：</p><ol><li>尽可能在DOM末梢通过改变class来修改元素的style属性： 将多次改变样式属性的操作合并成一次操作，尽可能的减少受影响的DOM元素。</li><li>避免设置多项内联样式：使用常用的class的方式进行设置样式，以避免设置样式时访问DOM的低效率。</li><li>设置动画元素position属性为fixed或者absolute：由于当前元素从DOM流中独立出来，因此受影响的只有当前元素，元素repaint。</li><li>牺牲平滑度满足性能：动画精度太强，会造成更多次的repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。</li><li>避免使用table进行布局：table的每个元素的大小以及内容的改动，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以进行针对性的repaint和避免不必要的reflow。</li><li>避免在CSS中使用运算式：学习CSS的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;文章转载：&lt;br&gt;　&lt;a href=&quot;http://www.cnblogs.com/blackmanba/p/browser-repaint-reflow.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浏览器重绘和重排&lt;/a&gt;&lt;br&gt;文章参考：&lt;br&gt;　&lt;a href=&quot;https://www.cnblogs.com/jiayuexuan/p/7490140.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;重构与回流&lt;/a&gt;&lt;br&gt;　&lt;a href=&quot;https://kb.cnblogs.com/page/169820/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浏览器的重绘与重排&lt;/a&gt;&lt;br&gt;　&lt;a href=&quot;http://www.cnblogs.com/shenqi0920/p/3545820.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;探讨css中repaint和reflow&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;　　页面设计中，不可避免的需要浏览器进行repaint和reflow。那到底什么是repaint和reflow呢。下面谈谈自己对repaint和reflow的理解，以及结合其他技术牛的讲解，谈谈如何优化repaint和reflow。&lt;/p&gt;
&lt;h5 id=&quot;概述：&quot;&gt;&lt;a href=&quot;#概述：&quot; class=&quot;headerlink&quot; title=&quot;概述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;概述：&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;　　&lt;strong&gt;重排(回流)&lt;/strong&gt;, 顾名思义就是重新排版的意思; &lt;strong&gt;重绘&lt;/strong&gt;, 就是浏览器重新绘制。理解重排和重绘的含义十分重要, 因为在评审页面交互效果的时候, 重绘和重排是必须考虑的因素。并不是说交互效果实现了就可以了, 必须同时考虑到这样做会引发什么性能问题。也就是说, 浏览器在进行重绘和重排的时候是要付出高昂的性能代价的。&lt;br&gt;　　只有静态页面才会不存在repaint和reflow。repaint主要是针对某一个DOM元素进行的重绘，reflow则是回流，针对整个页面的重排。字面意思来说：repaint就是重绘，reflow就是回流。&lt;strong&gt;回流必将引起重绘，而重绘不一定会引起回流&lt;/strong&gt;，repaint和reflow的目的是：展示一个新的页面样貌。&lt;/p&gt;
    
    </summary>
    
      <category term="前端优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端性能优化" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化</title>
    <link href="http://yoursite.com/2019/02/13/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/02/13/前端性能优化/前端性能优化/</id>
    <published>2019-02-13T12:37:12.000Z</published>
    <updated>2019-03-08T13:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- 目录 --><!-- toc --><p>转载：<br><a href="http://www.cnblogs.com/lei2007/archive/2013/08/16/3262897.html" target="_blank" rel="noopener">前端性能优化–yahoo前端性能团队总结的35条黄金定律</a><br>参考文章：<br><a href="https://www.zhihu.com/question/21658448/answer/18903129" target="_blank" rel="noopener">Web前端应该从哪些方面来优化网站? - 斯迪的回答 - 知乎</a><br><a href="https://segmentfault.com/a/1190000008829958" target="_blank" rel="noopener">WEB前端性能优化常见方法</a><br>　　前端是庞大的，包括 HTML、 CSS、 Javascript、Image 、Flash等等各种各样的资源。前端优化是复杂的，针对方方面面的资源都有不同的方式。那么，为什么要进行前端性能优化？ 怎么进行优化？ 优化到达的效果是什么？<br><a id="more"></a></p><h3 id="为什么需要前端性能优化-优化的好处-目的"><a href="#为什么需要前端性能优化-优化的好处-目的" class="headerlink" title="为什么需要前端性能优化[优化的好处/目的]"></a>为什么需要前端性能优化[优化的好处/目的]</h3><p>好处： </p><ol><li>从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。</li><li>从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。</li></ol><p>前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。</p><h3 id="怎么进行优化"><a href="#怎么进行优化" class="headerlink" title="怎么进行优化"></a>怎么进行优化</h3><ul><li><p>内容优化</p><ol><li>减少Http请求次数<ul><li>原因: 这条策略是最重要最有效的，因为一个完整的请求要经过DNS寻址，与服务器建立连接，发送数据，等待服务器响应，接收数据这样一个消耗时间成本和资源成本的复杂的过程。</li><li>使用方法：<ol><li>从设计实现层面简化页面</li><li>合并多个CSS文件和js文件</li><li>利用CSS Sprites整合图像</li><li>Inline Images(使用 data：URL scheme在实际的页面嵌入图像数据 )</li><li>合理设置HTTP缓存等。</li><li>使用懒加载进行图片的加载</li></ol></li></ul></li><li>减少DNS查询<ul><li>原因: DNS查询也消耗响应时间，如果我们的网页内容来自各个不同的domain (比如嵌入了开放广告，引用了外部图片或脚本)，那么客户端首次解析这些domain也需要消耗一定的时间。DNS查询结果缓存在本地系统和浏览器中一段时间，所以DNS查询一般是对首次访问响应速度有所影响。</li><li>使用方法: <a href="https://www.cnblogs.com/chenxizhang/archive/2013/05/02/3053996.html" target="_blank" rel="noopener">优化网站设计（九）：减少DNS查找的次数</a><ol><li>减少DNS查找次数，最理想的方法就是将所有的内容资源都放在同一个域(Domain)下面，这样访问整个网站就只需要进行一次DNS查找，这样可以提高性能。</li><li>但理想总归是理想，上面的理想做法会带来另外一个问题，就是由于这些资源都在同一个域，而HTTP /1.1 中推荐客户端针对每个域只有一定数量的并行度（它的建议是2），那么就会出现下载资源时的排队现象，这样就会降低性能。</li><li>所以，折衷的做法是：建议在一个网站里面使用至少2个域，但不多于4个域来提供资源。我认为这条建议是很合理的，也值得我们在项目实践中去应用。</li></ol></li></ul></li><li><p>避免重定向</p><ul><li><p>当客户端收到服务器的跳转回复时，客户端再次根据服务器回复中的location指定的地址再次发送请求，例如以下跳转回复:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Location: http://example.com/newuri</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure></li><li><p>当客户端遇到这种回复的时候，用户只能等待客户端再次发送请求，有的网站甚至会一直跳n次，跳到他想带你去的地方…当然在这个时候用户看不到任何页面内容，只有浏览器的进度条一直在刷新。</p></li></ul></li><li>使用Ajax缓存<ul><li>Ajax可以帮助我们异步的下载网页内容，但是有些网页内容即使是异步的，用户还是在等待它的返回结果，例如ajax的返回是用户联系人的下拉列表。所以我们还是要注意尽量应用以下规则提高ajax的响应速度。</li><li>使用方法：<ul><li>添加Expires 或 Cache-Control报文头使回复可以被客户端缓存</li><li>压缩回复内容</li><li>减少dns查询</li><li>精简javascript</li><li>避免跳转</li><li>配置Etags</li></ul></li></ul></li><li>延迟加载组件,预加载组件<ul><li>延迟加载<ul><li>这里讨论延迟加载需要我们知道我们的网页最初加载需要的最小内容集是什么。剩下的内容就可以推到延迟加载的集合中。</li><li>Javascript是典型的可以延迟加载内容。一个比较激进的做法是开发网页时先确保网页在没有Javascript的时候也可以基本工作，然后通过延迟加载脚本来完成一些高级的功能。</li></ul></li><li>预加载<ul><li>与延迟加载目的相反，提前加载的是为了提前加载接下来网页中访问的资源，下面是提前加载的类型</li><li>无条件提前加载：当前网页加载完成后，马上去下载一些其他的内容。例如google会在页面加载成功之后马上去下载一个所有结果中会用到的image sprite。</li><li>有预期的的加载：这种情况一般发生在网页重新设计时，由于用户经常访问旧网页，本地对旧的网页内容缓存充分从而显得旧网页速度很快，而新的网页内容却没有缓存，设计者可以在旧网页的内容中预先加载一些新网页中可能用到的内容，这样新的网页就会生下来一些需要下载的资源。</li></ul></li></ul></li><li>减少DOM元素数量:<ul><li>页面中存在大量DOM元素,会导致javascript遍历DOM的效率变慢。</li><li>网页中元素过多对网页的加载和脚本的执行都是沉重的负担，500个元素和5000个元素在加载速度上会有很大差别。</li><li>想知道你的网页中有多少元素，通过在浏览器中的一条简单命令就可以算出<code>document.getElementsByTagName(&#39;*&#39;).length</code></li></ul></li><li>最小化iframe的数量：<ul><li>iframes 提供了一个简单的方式把一个网站的内容嵌入到另一个网站中。但其创建速度比其他包括JavaScript和CSS的DOM元素的创建慢了1-2个数量级。</li><li>优点<ol><li>可以用来加载速度较慢的内容，例如广告。</li><li>安全沙箱保护。浏览器会对iframe中的内容进行安全控制。</li><li>脚本可以并行下载</li></ol></li><li>缺点<ol><li>即使iframe内容为空也消耗加载时间</li><li>会阻止页面加载</li><li>没有语义</li></ol></li></ul></li><li>避免404：HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。<ul><li>404我们都不陌生，代表服务器没有找到资源，我们要特别要注意404的情况不要在我们提供的网页资源上，客户端发送一个请求但是服务器却返回一个无用的结果，时间浪费掉了。更糟糕的是我们网页中需要加载一个外部脚本，结果返回一个404，不仅阻塞了其他脚本下载，下载回来的内容(404)客户端还会将其当成Javascript去解析。</li></ul></li></ol></li><li>服务器优化<ul><li>(1)使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。<ul><li>再次强调第一条黄金定律，减少网页内容的下载时间。提高下载速度还可以通过CDN(内容分发网络)来提升。CDN通过部署在不同地区的服务器来提高客户的下载速度。如果你的网站上有大量的静态内容，世界各地的用户都在访问，我说的是youtube么？那CDN是必不可少的。事实上大多数互联网中的巨头们都有自己的CDN。我们自己的网站可以先通过免费的CDN供应商来分发网页资源。</li><li>添加Expires 或Cache-Control报文头(这条规则分为两个方面)<ol><li>对于静态内容添加Expires，将静态内容设为永不过期，或者很长时间以后。在IIS中设置Expires可以看Configure the HTTP Expires Response Header (IIS 7)。</li><li>对于动态内容应用合适的Cache-Control，让浏览器根据条件来发送请求。关于asp.net的caching，可以看asp.net cache feature和asp.net caching best practices。</li></ol></li></ul></li><li>(2)GZIP压缩<ul><li>Gzip通常可以减少70%网页内容的大小，包括脚本、样式表、图片等文件。Gzip比deflate更高效，主流服务器都有相应的压缩支持模块。</li></ul></li><li>(3)设置ETag：ETags（Entity tags，实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。<ul><li>虽然标题叫配制ETags，但是这里你要根据具体情况进行一些判断。首先Etag简单来说是通过一个文件版本标识使得服务器可以轻松判断该请求的内容是否有所更新，如果没有就回复304 (not modified)，从而避免下载整个文件。</li></ul></li><li>(4)提前刷新缓冲区<br>+ </li><li>(5)对Ajax请求使用GET方法<ul><li>浏览器在实现XMLHttpRequest POST的时候分成两步，先发header，然后发送数据。而GET却可以用一个TCP报文完成请求。另外GET从语义上来讲是去服务器取数据，而POST则是向服务器发送数据，所以我们使用Ajax请求数据的时候尽量通过GET来完成。</li></ul></li><li>(6)避免空的图像src<ul><li>空的图片src仍然会使浏览器发送请求到服务器，这样完全是浪费时间，而且浪费服务器的资源。尤其是你的网站每天被很多人访问的时候，这种空请求造成的伤害不容忽略。</li></ul></li></ul></li><li>Cookie优化<ul><li>(1)减小Cookie大小<ul><li>去除没有必要的cookie，如果网页不需要cookie就完全禁掉</li><li>将cookie的大小减到最小</li><li>注意cookie设置的domain级别，没有必要情况下不要影响到sub-domain</li><li>设置合适的过期时间，比较长的过期时间可以提高响应速度。</li></ul></li><li>(2)针对Web组件使用域名无关的Cookie<ul><li>大多数网站的静态资源都没必要cookie，我们可以采用不同的domain来单独存放这些静态文件，这样做不仅可以减少cookie大小从而提高响应速度，还有一个好处是有些proxy拒绝缓存带有cookie的内容，如果能将这些静态资源cookie去除，那就可以得到这些proxy的缓存支持。</li><li>常见的划分domain的方式是将静态文件放在static.example.com，动态内容放在<a href="http://www.example.com。" target="_blank" rel="noopener">www.example.com。</a></li><li>也有一些网站需要在二级域名上应用cookie，所有的子域都会继承，这种情况下一般会再购买一个专门的域名来存放cookie-free的静态资源。例如Yahoo!的yimg.com，YouTube的ytimg.com等。</li></ul></li></ul></li><li>CSS优化<ul><li>(1)将CSS代码放在HTML页面的顶部<ul><li>经样式表(css)放在网页的HEAD中会让网页显得加载速度更快，因为这样做可以使浏览器逐步加载已将下载的网页内容。这对内容比较多的网页尤其重要，用户不用一直等待在一个白屏上，而是可以先看已经下载的内容。</li><li>如果将样式表放在底部，浏览器会拒绝渲染已经下载的网页，因为大多数浏览器在实现时都努力避免重绘，样式表中的内容是绘制网页的关键信息，没有下载下来之前只好对不起观众了。</li></ul></li><li>(2)避免使用CSS表达式<ul><li>CSS表达式可以动态的设置CSS属性，在IE5-IE8中支持，其他浏览器中表达式会被忽略。例如下面表达式在不同时间设置不同的背景颜色。</li><li>CSS表达式的问题在于它被重新计算的次数远比我们想象的要多，不仅在网页绘制或大小改变时计算，即使我们滚动屏幕或者移动鼠标的时候也在计算，因此我们还是尽量避免使用它来防止使用不当而造成的性能损耗。</li></ul></li><li>(3)使用<link>来代替@import<ul><li>避免使用@import的原因很简单，因为它相当于将css放在网页内容底部。</li></ul></li><li>(4)避免使用Filters<ul><li>AlphaImageLoad也是IE5.5 - IE8中支持，这种滤镜的使用会导致图片在下载的时候阻塞网页绘制，另外使用这种滤镜会导致内存使用量的问题。IE9中已经不再支持。</li></ul></li></ul></li><li>JS优化<ul><li>(1)将JavaScript脚本放在页面的底部。<ul><li>HTTP/1.1 specification建议浏览器对同一个hostname不要超过两个并行下载连接， 所以当你从多个domain下载图片的时候可以提高并行下载连接数量。但是当脚本在下载的时候，即使是来自不同的hostname浏览器也不会下载其他资源，因为浏览器要在脚本下载之后依次解析和执行。</li><li>因此对于脚本提速，我们可以考虑以下方式，<ul><li>把脚本置底，这样可以让网页渲染所需要的内容尽快加载显示给用户。</li><li>现在主流浏览器都支持defer关键字，可以指定脚本在文档加载后执行。</li><li>HTML5中新加了async关键字，可以让脚本异步执行。</li></ul></li></ul></li><li>(2)将JavaScript和CSS作为外部文件来引用：<ul><li>使用外部Javascript和CSS文件可以使这些文件被浏览器缓存，从而在不同的请求内容之间重用。</li><li>同时将Javascript和CSS从inline变为external也减小了网页内容的大小。</li><li>使用外部Javascript和CSS文件的决定因素在于这些外部文件的重用率，如果用户在浏览我们的页面时会访问多次相同页面或者可以重用脚本的不同页面，那么外部文件形式可以为你带来很大的好处。但对于用户通常只会访问一次的页面，例如microsoft.com首页，那inline的javascript和css相对来说可以提供更高的效率。</li></ul></li><li>(3)缩小JavaScript和CSS<ul><li>精简就是将Javascript或CSS中的空格和注释全去掉，</li></ul></li><li>(4)删除重复的脚本<ul><li>重复的脚本不仅浪费浏览器的下载时间，而且浪费解析和执行时间。一般用来避免引入重复脚本的做法是使用统一的脚本管理模块，这样不仅可以避免重复脚本引入，还可以兼顾脚本依赖管理和版本管理。</li></ul></li><li>(5)最小化DOM的访问：使用JavaScript访问DOM元素比较慢。<ul><li>通过Javascript访问DOM元素没有我们想象中快，元素多的网页尤其慢，对于Javascript对DOM的访问我们要注意<ul><li>缓存已经访问过的元素</li><li>Offline更新节点然后再加回DOM Tree</li><li>避免通过Javascript修复layout</li></ul></li></ul></li><li>(6)开发智能的事件处理程序<ul><li>这里说智能的事件处理需要开发者对事件处理有更深入的了解，通过不同的方式尽量少去触发事件，如果必要就尽早的去处理事件。</li><li>比如一个div中10个按钮都需要事件句柄，那么我们可以将事件放在div上，在事件冒泡过程中捕获该事件然后判断事件来源。</li></ul></li><li>(7)javascript代码注意：<ul><li>谨慎使用with,避免使用eval Function函数,减少作用域链查找。<ul><li>with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的 执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。</li><li>因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。</li></ul></li></ul></li></ul></li><li>图像优化<ul><li>(1)优化图片大小<ul><li>检查GIF图片中图像颜色的数量是否和调色板规格一致。如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。可以使用imagemagick检查：identify -verbose image.gif</li><li>尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。下面这条简单的命令可以安全地把GIF格式转换为PNG格式： convert image.gif image.png</li><li>在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如： pngcrush image.png -rem alla -reduce -brute result.png</li><li>在所有的JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息 jpegtran -copy none -optimize -perfect src.jpg dest.jpg</li></ul></li><li>(2)通过CSS Sprites优化图片<ul><li>Spirite中水平排列图片，垂直排列会增加文件大小；</li><li>Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；</li><li>不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小,但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100×100的图片为1万像素，1000×1000就是100万像素。</li></ul></li><li>(3)不要在HTML中使用缩放图片<ul><li>不要通过图片缩放来适应页面，如果你需要小图片，就直接使用小图片吧。</li></ul></li><li>(4)favicon.ico要小而且可缓存<ul><li>网站图标文件favicon.ico，不管你服务器有还是没有，浏览器都会去尝试请求这个图标。所以我们要确保这个图标<ol><li>存在</li><li>文件尽量小，最好小于1k</li><li>设置一个长的过期时间</li></ol></li></ul></li></ul></li><li>移动客户端<ul><li>保持单个内容小于25KB<ul><li>这限制是因为iphone，他只能缓存小于25K，注意这是解压后的大小。所以单纯gzip不一定够用，精简文件工具要用上了。</li></ul></li><li>打包组建成符合文档<ul><li>把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组建。当你使用这条规则时，首先要确定用户代理是否支持（iPhone不支持）。</li></ul></li></ul></li></ul><h3 id="待解决的方面"><a href="#待解决的方面" class="headerlink" title="待解决的方面"></a>待解决的方面</h3><blockquote><p>转载别人，如有错误请指出。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- 目录 --&gt;
&lt;!-- toc --&gt;
&lt;p&gt;转载：&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/lei2007/archive/2013/08/16/3262897.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端性能优化–yahoo前端性能团队总结的35条黄金定律&lt;/a&gt;&lt;br&gt;参考文章：&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/21658448/answer/18903129&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Web前端应该从哪些方面来优化网站? - 斯迪的回答 - 知乎&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008829958&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WEB前端性能优化常见方法&lt;/a&gt;&lt;br&gt;　　前端是庞大的，包括 HTML、 CSS、 Javascript、Image 、Flash等等各种各样的资源。前端优化是复杂的，针对方方面面的资源都有不同的方式。那么，为什么要进行前端性能优化？ 怎么进行优化？ 优化到达的效果是什么？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端性能优化" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
