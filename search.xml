<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[同源策略和跨域]]></title>
    <url>%2F2019%2F03%2F17%2FAjax%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[转载: ajax跨域，这应该是最全的解决方案了参考: 浏览器同源政策及其规避方法 跨域资源共享 CORS 详解 同源策略概念同源即指：协议相同、域名相同、端口号相同。举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。1234http://www.example.com/dir2/other.html：同源http://example.com/dir/other.html：不同源（域名不同）http://v2.www.example.com/dir/other.html：不同源（域名不同）http://www.example.com:81/dir/other.html：不同源（端口不同） 目的 同源政策的目的，是为了为了保证使用者信息的安全，防止恶意网站篡改用户数据。 设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的Cookie，会发生什么？ 很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。 由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 限制范围 随着互联网的发展，”同源政策”越来越严格。目前，非同源的网站之间，共有四种行为受到限制。1234（1） Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。（4）无法通过 flash 发送 http 请求 跨域 同源策略做了很严格的限制，但是在实际的场景中，又确实有很多地方需要突破同源策略的限制，也就是我们常说的跨域。 Cookie 同源策略最早被提出的时候，为的就是防止不同域名的网页之间共享 cookie。Cookie是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享Cookie。举个例子，https://market.douban.com和https://book.douban.com，这两个网页的一级域名都是 douban.com，如果我在 market.douban.com中执行了12345678#A、B页面设置相同的document.domaindocument.domain = 'douban.com'# A页面通过脚本设置一个Cookiedocument.cookie = 'cross=yes'或document.cookie = 'cross=yes;path=/;domain=douban.com'# B页面就可以读取到Cookievar allCookie = document.cookie 这样设置了 cookie之后，在book.douban.com中是可以取到这个cookie的。除了在前端设置之外，也可以直接在response里将cookie的domain设置成 .douban.com。 Ajax什么是Ajax跨域ajax跨域的原理 ajax出现请求跨域错误问题,主要原因就是因为浏览器的“同源策略”,可以参考 ajax跨域的表现 ajax请求时,如果存在跨域现象,并且没有进行解决,会有如下表现:(注意，是ajax请求，请不要说为什么http请求可以，而ajax不行，因为ajax是伴随着跨域的，所以仅仅是http请求ok是不行的)第一种现象:No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且The response had HTTP status code 404出现这种情况的原因如下： 本次ajax请求是“非简单请求”,所以请求前会发送一次预检请求(OPTIONS) 服务器端后台接口没有允许OPTIONS请求,导致无法找到对应接口地址解决方案: 后端允许options请求第二种现象:No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且The response had HTTP status code 405这种现象和第一种有区别,这种情况下，后台方法允许OPTIONS请求,但是一些配置文件中(如安全配置),阻止了OPTIONS请求,才会导致这个现象解决方案: 后端关闭对应的安全配置第三种现象:No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且status 200这种现象和第一种和第二种有区别,这种情况下，服务器端后台允许OPTIONS请求,并且接口也允许OPTIONS请求,但是头部匹配时出现不匹配现象比如origin头部检查不匹配,比如少了一些头部的支持(如常见的X-Requested-With头部),然后服务端就会将response返回给前端,前端检测到这个后就触发XHR.onerror,导致前端控制台报错解决方案: 后端增加对应的头部支持第四种现象:heade contains multiple values &#39;*,*&#39;表现现象是，后台响应的http头部信息有两个Access-Control-Allow-Origin:*说实话，这种问题出现的主要原因就是进行跨域配置的人不了解原理，导致了重复配置，如:常见于.net后台(一般在web.config中配置了一次origin,然后代码中又手动添加了一次origin(比如代码手动设置了返回*))常见于.net后台(在IIS和项目的webconfig中同时设置Origin:*)解决方案(一一对应): 建议删除代码中手动添加的*，只用项目配置中的即可 建议删除IIS下的配置*，只用项目配置中的即可 如何解决ajax跨域 一般ajax跨域解决就是通过JSONP解决或者CORS解决,如以下:(注意，现在已经几乎不会再使用JSONP了，所以JSONP了解下即可) JSONPjsonp 其实算是一种 hack 形式的请求。jsonp 的本质其实是请求一段 js 代码，是对静态文件资源的请求，所以并不遵循同源策略。但是因为是对静态文件资源的请求，所以只能支持 GET 请求，对于其他方法没有办法支持。 设置CORS CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。本文详细介绍CORS的内部机制。 CORS简介 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 CORS两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。12345678910111213（1) 请求方法是以下三种方法之一： HEAD GET POST（2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、 multipart/form-data、 text/plain 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 CORS简单请求对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin(protocal + host + path + port)字段,来标明这个请求是来自哪里。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。1234567GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...` 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。（1）Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。（2）Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。（3）Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。Access-Control-Allow-Credentials: true另一方面，开发者必须在AJAX请求中打开withCredentials属性。12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 CORS非简单请求与简单请求最大的不同在于，非简单请求实际上是发送了两个请求。预请求首先，在正式请求之前，会先发送一个预请求(preflight-request)，这个请求的作用是尽可能少的携带信息，供服务端判断是否响应该请求。浏览器浏览器发送预请求，请求的 Request Method 会设置为 options。另外，还会带上这几个字段：123Origin: 同简单请求的originAccess-Control-Request-Method: 请求将要使用的方法Access-Control-Request-Headers: 浏览器会额外发送哪些头信息 服务端服务端收到预请求之后会根据request中的origin,Access-Control-Request-Method和Access-Control-Request-Headers判断是否响应该请求。如果判断响应这个请求，返回的response中将会携带：123Access-Control-Allow-Origin: originAccess-Control-Allow-Methods: like requestAccess-Control-Allow-Headers: like request 如果否定这个请求，直接返回不带这三个字段的response就可以，浏览器将会把这种返回判断为失败的返回，触发onerror方法正式响应如果预请求被正确响应，接下来就会发送正式请求，正式请求的request和正常的 ajax 请求基本没有区别，只是会携带 origin 字段；response和简单请求一样，会携带上Access-Control-*这些字段 WebScoketwebsocket 不遵循同源策略。 但是在 websocket 请求头中会带上 origin 这个字段，服务端可以通过这个字段来判断是否需要响应，在浏览器端并没有做任何限制。 iframe代理请求方式]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios]]></title>
    <url>%2F2019%2F03%2F17%2FAjax%2FAxios%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536# helpers.jsimport axios from 'axios'# 定义常量ERR_OKconst ERR_OK = 0# 导出一个getDate方法export default getDate(url) &#123; return function(params) &#123; return axios.get(url, &#123; params # 成功之后的.then方法 &#125;).then((res) =&gt; &#123; # 通过结构赋值的方法难道error和data的数值 const &#123; error, data&#125; = res.data # 如果成功的话，返回data数据 if(error === ERR_OK) &#123; return data &#125; # 如果失败的话打印失败的原因 &#125;).catch(function(error) =&gt; &#123; console.log("error:", error) &#125;) &#125;&#125;# 出口文件# index.jsimport &#123; getDate &#125; from './helpers'# 定义getSeller方法const getSeller = getDate('./api/seller')# 导出getSeller方法export &#123; getSeller&#125;]]></content>
      <categories>
        <category>Axios</category>
      </categories>
      <tags>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2019%2F03%2F16%2FAjax%2FAjax%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F15%2FJavaScript%2Findex%2F</url>
    <content type="text"><![CDATA[test body function Person() { var name = 'hello' function say() { console.log("name:", name) } return say() } Person()]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F15%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4%2Fvue%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[简单自我介绍, 做过哪些项目, 使用哪些技术栈 ?如何看待前端框架选型 ?vue的如何实现双向绑定的 ？react 虚拟DOM 是什么? 如何实现? 说一下diff算法 ?工作中最出色的点, 和你最头疼的问题 如何解决的 ?平时如何学习, 最近接触了解了哪些新的知识 ?技术一面简单自我介绍, 介绍一下你的项目, 技术栈 ?react和vue的比较 ?React Diff 算法 ?观察者模式实现 ?http报文头部有哪些字段? 有什么意义 ?移动端高清方案如何解决 ?webpack的原理, loader 和 plugin 是干什么的? 有自己手写过么 ?简述从网页输入url到网页展示的过程发生了哪些事情 ?SSR 和 客户端渲染有什么区别 , vue是如何实现绑定事件的 ?简述公司node架构中容灾的实现 ?浏览器事件有哪些过程? 为什么一般在冒泡阶段, 而不是在捕获阶段注册监听? addEventListener 参数分别是什么 ?面向对象如何实现? 需要复用的变量 怎么处理 ?移动端300ms延时的原因? 如何处理?主流框架的数据单向/双向绑定实现原理 ?简述转行经历, 如何学习 ?你觉得自己在前端工作的最大的优点是什么 拿实际工作的内容举例?技术二面和一面前3问基本一致,简述项目,React vue区别 virsualDOM实现DIFF算法为什么是O(n)复杂度而不是O(n^3)http code码?移动端rem布局如何实现? 简述原理?JSbridge原理, js和native是如何通信的?Rollup和webpack区别, treeshaking是什么?TCP三次握手的过程, get post请求的区别 ?静态文件的浏览器缓存如何实现?前端跨域方案http 请求包含哪些字段 分别是什么意思js 有哪些数据类型 如何判断? null 和 undefined区别 应用场景?new String(‘a’) 和 ‘a’ 是一样的么?移动端如何实现下拉到底部 跟随移动 结束后回弹的动画?移动端如何优化首页白屏时间过长 ?ES6 generator函数简述数组去重实现?js浮点数运算不精确 如何解决?工作中最得意和出色的点, 头疼的点, 问题如何解决的为何换工作?聊了下阿里的压力,文化技术三面公司的前端工程化实践转行之后是如何自学前端的, 学习途径 有没有一些自己的代码DOM基础知识,添加元素,删除元素等等…DOM节点类型正则表达式如何匹配一段url ?在正则表达式中有哪几种作用?移动端优化方式? 离线包是如何实现的? https://ustbhuangyi.github.io/vue-analysis/ 我的手机 2019/3/14 10:04:34https://www.jianshu.com/p/a804606ad8e9 我的手机 2019/3/14 10:04:50https://www.cnblogs.com/chinabin1993/p/9115396.html 我的手机 2019/3/14 10:05:03https://segmentfault.com/a/1190000012996217 我的手机 2019/3/14 10:05:20https://blog.csdn.net/qq_35430000/article/details/79291287 我的手机 2019/3/14 10:05:37https://m.jb51.net/article/140581.htm https://yukwan.cn/fronttech/front-end/2019/3/8 16:31:10我的手机 2019/3/8 16:31:10https://mp.weixin.qq.com/s/L8P0RIXym4myfknzM5Nsog2019/3/9 16:28:42我的手机 2019/3/9 16:28:42https://campushr.hikvision.com/JobDetails.html?id=057c01652bb444b597345337c7b8c14f&amp;type=0 https://wx2.sinaimg.cn/mw690/005NaMhPly1g0nayy8lbij30hs59p7wh.jpg?from=singlemessage]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F15%2FJavaScript%2F%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[JavaScript简介在HTML中使用JavaScript混杂模式与标准模式基本概念语法变量、函数名和操作符都区分大小写 标识符，就是指变量、函数、属性的名字，或者函数的参数。ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写 严格模式： “use strict”; 数据类型 简单数据类型(基本数据类型)：Undefined、Null、Boolean、Number、String 复杂数据类型：Object typeof 操作符来区分函数和其他对象是有必要的 Undefind 即便未初始化的变量会自动被赋予 undefined 值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当 typeof 操作符返回”undefined”值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。 NullBooleanNumber整数浮点数NaN即非数值（Not a Number）ECMAScript 定义了 isNaN()函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。 数值转换把非数值转换为数值：Number()、parseInt()和 parseFloat()。 String流控制语句函数变量、作用域和内存问题基本类型和引用类型基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象 复制变量值如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上.当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量1234var obj1 = new Object(); var obj2 = obj1; obj1.name = "Nicholas"; alert(obj2.name); //"Nicholas" 检测类型typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具 虽然在检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了 instanceof 操作符，其语法如下所示：result = variable instanceof constructor 执行环境垃圾收集标记清除引用计数小结 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中； 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本； 引用类型的值是对象，保存在堆内存中； 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针； 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象； 确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用instanceof 操作符。 所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。 以下是关于执行环境的几点总结： 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分； 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境； 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据； 变量的执行环境有助于确定应该何时释放内存。 JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。 可以对 JavaScript 的垃圾收集例程作如下总结： 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题。 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。 引用类型使用对象Object类型 Array类型 检测数组 value instanceof Array、 Array.isArray()方 转换方法 toLocaleString()、toString()和 valueOf() 栈方法 后进先出 push()、pop() 队列方法 后进先出 shift()、unshift() 重排序方法 reverse()、sort() 操作方法 concat() 连接数组、splice() 位置方法 indexOf()、lastIndexOf() 迭代方法 every() 全部 filter() 筛选 forEach() map() some() 存在 归并方法 reduce() reduceRight() Date类型 new Date()、Date.parse() 、Date.UTC() 继承的方法 日期格式化方法 toDateString()——以特定于实现的格式显示星期几、月、日和年 toTimeString()——以特定于实现的格式显示时、分、秒和时区； toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年 toLocaleTimeString()——以特定于实现的格式显示时、分、秒 toUTCString()——以特定于实现的格式完整的 UTC 日期 日期/时间组件 getTime() 返回表示日期的毫秒数；与valueOf()方法返回的值相同 setTime(毫秒) 以毫秒数设置日期，会改变整个日期 getFullYear() 取得4位数的年份（如2007而非仅07） getUTCFullYear() 返回UTC日期的4位数年份 RegExp()类型 Function类型 没有重载 函数声明与函数表达式 解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问） 至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。 作为值的函数 函数内部属性 arguments this callee 函数属性和方法 length prototype apply() call() 基本包装类型 Boolean类型 Number toFixed()方法会按照指定的小数位返回数值的字符串表示 toExponential() String trim()方法： 这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果 字符串大小写转换方法 toLowerCase() toLocaleLowerCase() toUpperCase() toLocaleUpperCase()。 字符串的模式匹配方法 localeCompare() localeCompare() fromCharCode() 单体内置对象 Global对象 Math对象 Math对象的属性 min()、max() 舍入方法 Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数 Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数 Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数 random() Math.radom() 160 创建并操作数组基本的JavaScript类型基本类型和基本包装类型面向对象的程序设计对象属性创建对象继承函数表达式BOM客户端检测DOMDOM扩展DOM2和DOM3事件表单脚本使用Canvas绘图HTML5脚本编程错误处理与调试JavaScript与XMLE4XJSONAjax与Comet高级技巧离线应用和客户端储存最佳实战新兴的API]]></content>
  </entry>
  <entry>
    <title><![CDATA[客户端渲染和服务端渲染详细执行流程]]></title>
    <url>%2F2019%2F03%2F14%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2FSSR%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[客户端渲染：CSR (client side render)在服务端放了一个html 页面，里面有//发请求，拿数据，模版引擎渲染等，$.ajax ,客户端发起请求，服务端把页面（响应的是字符串）发送过去，客户端从上到下依次解析，如果在解析的过程中，发现ajax请求，再次像服务器发送新的请求，客户端拿到ajax 响应结果，模板引擎渲染。过程至少和服务端发起两次请求 服务端渲染：SSR (server side render)sever 端页面+数据，服务端过程：1.读取index.html2.模版进行渲染，在发送给客户端之前，在服务端已经把index.html 渲染处理了。var 渲染结果 = tempeter.render(模板字符串，｛解析替换对象｝) response.end(渲染结果)，服务端响应的就是最总的结果服务端只请求一次多数网站既有服务端渲染又有客户端渲染 服务端渲染和客户端渲染的区别 客户端渲染不利于 SEO 搜索引擎优化 服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的 所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的 而是两者结合来做的 例如京东的商品列表就采用的是服务端渲染，目的了为了 SEO 搜索引擎优化 而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染]]></content>
      <categories>
        <category>前端优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件间通信&传值]]></title>
    <url>%2F2019%2F03%2F14%2FVue%2FVue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%26%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[转载： vue通信、传值的多种方式（详细） Vue.js——十分钟入门Vuex 通过路由带参数进行传值 两个组件 A和B,A组件通过query把orderId传递给B组件（触发事件可以是点击事件、钩子函数等）this.$router.push({ path: &#39;/conponentsB&#39;, query: { orderId: 123 } }) // 跳转到B 在B组件中获取A组件传递过来的参数this.$route.query.orderId 通过设置 Session Storage缓存的形式进行传递 两个组件A和B，在A组件中设置缓存orderData 123const orderData = &#123; &apos;orderId&apos;: 123, &apos;price&apos;: 88 &#125; sessionStorage.setItem(&apos;缓存名称&apos;, JSON.stringify(orderData)) B组件就可以获取在A中设置的缓存了const dataB = JSON.parse(sessionStorage.getItem(&#39;缓存名称&#39;))此时 dataB 就是数据 orderData 父子组件之间的传值父组件往子组件传值props①定义父组件，父组件传递 number这个数值给子组件，如果传递的参数很多，推荐使用json数组{}的形式 1234567891011121314# parent.vue&lt;template&gt; &lt;div class="parent"&gt; # 例如：传递数组88给子组件 &lt;children number=888&gt;&lt;/children&gt; &lt;/div&gt;&lt;/template&gt;import Children from 'components/children' # 引入子组件export default &#123; components: &#123; Children &#125;&#125; ②定义子组件，子组件通过 props方法获取父组件传递过来的值。props中可以定义能接收的数据类型，如果不符合会报错。12345678910111213# children.vue&lt;template&gt; &lt;div class="children"&gt; &#123;&#123;number&#125;&#125; # 显示父组件传递过来的值，显示88 &lt;/div&gt;&lt;/template&gt;export default &#123; props: &#123; # 限制父组件传递过来的数据类型，如果不符合就报错 'number': [Number, String, Object], 'string': [String] #可以传递多个值，逗号隔开 &#125;&#125; 当然也可以简单一点，如果不考虑数据类型，直接 props:[“number”,”string”]就可以了,中括号包裹，多个值使用，分隔。③假如接收的参数 是动态的，比如 input输入的内容 v-model的形式注意：传递的参数名称 支持驼峰命名，下面示例描述不正确（1.0是不支持的）1234567891011121314# parent.vue&lt;template&gt; &lt;div class="parent"&gt; &lt;input type="text" v-model="inputText"&gt; &lt;children :input-val = 'inputText'&gt;&lt;/children&gt; # 注意 :input-val 不支持驼峰命名，建议 - 分割 &lt;/div&gt;&lt;/template&gt;import Children from 'components/children'export default &#123; components: &#123; Children &#125;&#125; 1234567891011&lt;template&gt; &lt;div class="children"&gt; &#123;&#123;inputVal&#125;&#125; &lt;/div&gt;&lt;/template&gt;export default &#123; props: &#123; 'input-val': [String] &#125;&#125; ④父子组件传值，数据是异步请求，有可能数据渲染时报错原因：异步请求时，数据还没有获取到但是此时已经渲染节点了解决方案：可以在 父组件需要传递数据的节点加上v-if = false,异步请求获取数据后,v-if = true 子组件往父组件传值，通过emit事件123456789101112131415# children.vue&lt;template&gt; &lt;div class="children"&gt; &lt;button @click="emitToParent"&gt;按钮点击传值给父组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; methods: &#123; emitToParent() &#123; this.$emit('child-event', '我是子组件往父组件传递的内容') # child-event 不支持驼峰命名 # 子组件通过emit事件给父组件传递内容 &#125; &#125;&#125; 1234567891011121314151617181920# parent.vue&lt;template&gt; &lt;div class="parent"&gt; # 触发父组件的一个方法，然后进行相应的操作 &lt;children @child-event="parentEvent"&gt;&lt;/children&gt; # @child-event 这是子组件自定义的方法 &lt;/div&gt;&lt;/template&gt;import Children from 'components/children'export default &#123; methods: &#123; parentEvent(data) &#123; # data 就是子组件传递过来的数据 console.log(data) # 我是子组件往父组件传递的内容 &#125; &#125;, components: &#123; Children &#125;&#125; 不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用 vuex）①定义一个新的vue实例专门用于传递数据，并导出就是定义一个公共的传值用的组件进行数据的交互123# 新建文佳eventBus.jsimport Vue from 'vue'export default new Vue() ②定义传递的方法名和传输内容，点击事件或钩子函数触发eventBus.emit事件12345678910111213141516# componentA.vue&lt;template&gt; &lt;div class="componentsA"&gt; &lt;button @click="emitToB"&gt;按钮点击传递数据给兄弟组件B&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from 'common/js/eventBus.js'export default &#123; methods: &#123; emitToB() &#123; eventBus.$emit('eventFromA', '我是组件A传递给组件B的数据') &#125; &#125;&#125;&lt;/script&gt; ③接收传递过来的数据注意：enentBus是一个另一个新的Vue实例，区分两个this所代表得vue实例123456789101112131415161718192021222324252627282930componentB.vue&lt;template&gt; &lt;div class="componentsB"&gt; &#123;&#123;title&#125;&#125; # 显示传递过来的值 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from 'common/js/eventBus.js'export default &#123; data() &#123; return &#123; title: '' &#125; &#125;, mounted() &#123; this.getEventData() &#125;, methods: &#123; getEventData() &#123; const that = this #this是项目vue的实例，用that接收，与eventBus的vue区分 eventBus.$on('eventFormA', function(val) &#123; that.title = val # this.title = val # 这个this指的是eventBus的vue实例 &#125;) &#125; &#125;&#125; &lt;/script&gt; Vuex进行传值什么是Vuex Vuex是一个专门为Vue.js应用程序开发的状态管理模式, 它采用集中式存储管理所有组件的公共状态, 并以相应的规则保证状态以一种可预测的方式发生变化. 上图中绿色虚线包裹起来的部分就是Vuex的核心, state中保存的就是公共状态, 改变state的唯一方式就是通过mutations进行更改. 可能你现在看这张图有点不明白, 等经过本文的解释和案例演示, 再回来看这张图, 相信你会有更好的理解. 为什么要使用Vuex 试想这样的场景, 比如一个Vue的根实例下面有一个根组件名为App.vue, 它下面有两个子组件A.vue和B.vue, App.vue想要与A.vue或者B.vue通讯可以通过props传值的方式, 但是如果A.vue和B.vue之间的通讯就很麻烦了, 他们需要共有的父组件通过自定义事件进行实现, A组件想要和B组件通讯往往是这样的: A组件说: “报告老大, 能否帮我托个信给小弟B” =&gt; dispatch一个事件给App App老大说: “包在我身上, 它需要监听A组件的dispatch的时间, 同时需要broadcast一个事件给B组件” B小弟说: “信息已收到”, 它需要on监听App组件分发的事件 这只是一条通讯路径, 如果父组件下有多个子组件, 子组件之间通讯的路径就会变的很繁琐, 父组件需要监听大量的事件, 还需要负责分发给不同的子组件, 很显然这并不是我们想要的组件化的开发体验.Vuex就是为了解决这一问题出现的 如何引入Vuex下载vuex: npm install vuex --save 在main.js添加:12345678910111213import Vuex from 'vuex'# 使用vuexVue.use( Vuex );const store = new Vuex.Store(&#123; //待添加&#125;)new Vue(&#123; el: '#app', store, render: h =&gt; h(App)&#125;) Vuex的核心概念 在介绍Vuex的核心概念之前, 我使用vue-cli初始化了一个demo, 准备以代码的形式来说明Vuex的核心概念,这个demo分别有两个组件ProductListOne.vue和ProductListTwo.vue, 在App.vue的datat中保存着共有的商品列表, 代码和初始化的效果如下图所示:1234567891011121314151617181920212223242526272829303132333435363738//App.vue中的初始化代码&lt;template&gt;&lt;div id="app"&gt; &lt;product-list-one v-bind:products="products"&gt;&lt;/product-list-one&gt; &lt;product-list-two v-bind:products="products"&gt;&lt;/product-list-two&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ProductListOne from './components/ProductListOne.vue'import ProductListTwo from './components/ProductListTwo.vue'export default &#123; name: 'app', components: &#123; 'product-list-one': ProductListOne, 'product-list-two': ProductListTwo &#125;, data () &#123; return &#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;body&#123; font-family: Ubuntu; color: #555;&#125;&lt;/style&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//ProductListOne.vue&lt;template&gt; &lt;div id="product-list-one"&gt; &lt;h2&gt;Product List One&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="product in products"&gt; &lt;span class="name"&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class="price"&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['products'], data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;#product-list-one&#123; background: #FFF8B1; box-shadow: 1px 2px 3px rgba(0,0,0,0.2); margin-bottom: 30px; padding: 10px 20px;&#125;#product-list-one ul&#123; padding: 0;&#125;#product-list-one li&#123; display: inline-block; margin-right: 10px; margin-top: 10px; padding: 20px; background: rgba(255,255,255,0.7);&#125;.price&#123; font-weight: bold; color: #E8800C;&#125;&lt;/style&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//ProductListTwo.vue&lt;template&gt; &lt;div id="product-list-two"&gt; &lt;h2&gt;Product List Two&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="product in products"&gt; &lt;span class="name"&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class="price"&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['products'], data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;#product-list-two&#123; background: #D1E4FF; box-shadow: 1px 2px 3px rgba(0,0,0,0.2); margin-bottom: 30px; padding: 10px 20px;&#125;#product-list-two ul&#123; padding: 0; list-style-type: none;&#125;#product-list-two li&#123; margin-right: 10px; margin-top: 10px; padding: 20px; background: rgba(255,255,255,0.7);&#125;.price&#123; font-weight: bold; color: #860CE8; display: block;&#125;&lt;/style&gt; State state就是Vuex中的公共的状态, 我是将state看作是所有组件的data, 用于保存所有组件的公共数据. 此时我们就可以把App.vue中的两个组件共同使用的data抽离出来, 放到state中,代码如下:1234567891011121314151617181920212223# main.jsimport Vue from 'vue'import App from './App.vue'import Vuex from 'vuex'Vue.use( Vuex )const store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125;&#125;)new Vue(&#123; el: '#app', store, render: h =&gt; h(App)&#125;) 此时,ProductListOne.vue和ProductListTwo.vue也需要做相应的更改12345678# ProductListOne.vueexport default &#123; data () &#123; return &#123; products : this.$store.state.products //获取store中state的数据 &#125; &#125;&#125; 12345678# ProductListTwo.vueexport default &#123; data () &#123; return &#123; products: this.$store.state.products //获取store中state的数据 &#125; &#125;&#125; 此时的页面如下图所示, 可以看到, 将公共数据抽离出来后, 页面没有发生变化. Getters 我将getters属性理解为所有组件的computed属性, 也就是计算属性. vuex的官方文档也是说到可以将getter理解为store的计算属性, getters的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 此时,我们可以在main.js中添加一个getters属性, 其中的saleProducts对象将state中的价格减少一半(除以2)12345678910111213141516171819202122# main.jsconst store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125;, getters:&#123; //添加getters saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map( product =&gt; &#123; return &#123; name: product.name, price: product.price / 2 &#125; &#125;) return saleProducts; &#125; &#125; &#125;) 将productListOne.vue中的products的值更换为this.$store.getters.saleProducts1234567export default &#123; data () &#123; return &#123; products : this.$store.getters.saleProducts &#125; &#125;&#125; 现在的页面中,Product List One中的每项商品的价格都减少了一半 123456789101112131415161718192021222324252627282930313233343536```###### Mutations 我将mutaions理解为store中的methods, mutations对象中保存着更改数据的回调函数,该函数名官方规定叫type, 第一个参数是state, 第二参数是payload, 也就是自定义的参数.下面,我们在main.js中添加mutations属性,其中minusPrice这个回调函数用于将商品的价格减少payload这么多, 代码如下:```bash//main.jsconst store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125;, getters:&#123; saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map( product =&gt; &#123; return &#123; name: product.name, price: product.price / 2 &#125; &#125;) return saleProducts; &#125; &#125;, mutations:&#123; //添加mutations minusPrice (state, payload ) &#123; let newPrice = state.products.forEach( product =&gt; &#123; product.price -= payload &#125;) &#125; &#125;&#125;) 在ProductListTwo.vue中添加一个按钮,为其添加一个点击事件, 给点击事件触发minusPrice方法12345678910111213# ProductListTwo.vue&lt;template&gt; &lt;div id="product-list-two"&gt; &lt;h2&gt;Product List Two&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="product in products"&gt; &lt;span class="name"&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class="price"&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;button @click="minusPrice"&gt;减少价格&lt;/button&gt; //添加按钮 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 在ProductListTwo.vue中注册minusPrice方法, 在该方法中commitmutations中的minusPrice这个回调函数注意:调用mutaions中回调函数, 只能使用store.commit(type, payload)12345678910111213# ProductListTwo.vueexport default &#123; data () &#123; return &#123; products: this.$store.state.products &#125; &#125;, methods: &#123; minusPrice() &#123; this.$store.commit('minusPrice', 2); //提交`minusPrice,payload为2 &#125; &#125;&#125; 添加按钮, 可以发现,Product List Two中的价格减少了2, 当然你可以自定义payload,以此自定义减少对应的价格. Actionsactions 类似于 mutations，不同在于：actions提交的是mutations而不是直接变更状态actions中可以包含异步操作, mutations中绝对不允许出现异步actions中的回调函数的第一个参数是context, 是一个与store实例具有相同属性和方法的对象 此时,我们在store中添加actions属性, 其中minusPriceAsync采用setTimeout来模拟异步操作,延迟2s执行 该方法用于异步改变我们刚才在mutaions中定义的minusPrice123456789101112131415161718192021222324252627282930313233343536//main.jsconst store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125;, getters:&#123; saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map( product =&gt; &#123; return &#123; name: product.name, price: product.price / 2 &#125; &#125;) return saleProducts; &#125; &#125;, mutations:&#123; minusPrice (state, payload ) &#123; let newPrice = state.products.forEach( product =&gt; &#123; product.price -= payload &#125;) &#125; &#125;, actions:&#123; //添加actions minusPriceAsync( context, payload ) &#123; setTimeout( () =&gt; &#123; context.commit( 'minusPrice', payload ); //context提交 &#125;, 2000) &#125; &#125;&#125;) 在ProductListTwo.vue中添加一个按钮,为其添加一个点击事件, 给点击事件触发minusPriceAsync方法 12345678910111213&lt;template&gt; &lt;div id="product-list-two"&gt; &lt;h2&gt;Product List Two&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="product in products"&gt; &lt;span class="name"&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class="price"&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;button @click="minusPrice"&gt;减少价格&lt;/button&gt; &lt;button @click="minusPriceAsync"&gt;异步减少价格&lt;/button&gt; //添加按钮 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 在ProductListTwo.vue中注册minusPriceAsync方法, 在该方法中dispatchactions中的minusPriceAsync这个回调函数123456789101112131415export default &#123; data () &#123; return &#123; products: this.$store.state.products &#125; &#125;, methods: &#123; minusPrice() &#123; this.$store.commit('minusPrice', 2); &#125;, minusPriceAsync() &#123; this.$store.dispatch('minusPriceAsync', 5); //分发actions中的minusPriceAsync这个异步函数 &#125; &#125;&#125; 添加按钮, 可以发现, Product List Two中的价格延迟2s后减少了5 Modules由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 ..mapactions&amp;&amp; …mapgetters]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局]]></title>
    <url>%2F2019%2F03%2F08%2FCSS3%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[转载： 阮一峰：Flex 布局教程：语法篇 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex布局是什么？ Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。123.box&#123; display: felx;&#125; 行内元素也可以使用 Flex 布局。123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。基本概念 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性 以下6个属性设置在容器上。123456flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content flex-direction属性 flex-direction属性决定主轴的方向（即项目的排列方向）123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。1234row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。 flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性 justify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。12345flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性 align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 建立在主轴为水平方向时测试，即 flex-direction: row默认值为 stretch 即如果项目未设置高度或者设为 auto，将占满整个容器的高度。假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。12345flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。123456flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。123456orderflex-growflex-shrinkflex-basisflexalign-self order属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis属性 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: | auto; / default auto /}它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto)` 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>页面布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页从输入网址到渲染完成经历了哪些过程]]></title>
    <url>%2F2019%2F02%2F23%2FHTTP%2F%E7%BD%91%E9%A1%B5%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[过程概述 从输入域名到网页打开的简单过程如下：1. DNS域名解析 客户端输入域名后，由DNS服务器来将域名解析成对应服务器的IP地址2. 建立TCP连接 客户端得到IP地址以后,会根据所获得的IP地址以及要访问的端口号发起网络连接， 即tcp三次握手连接， 建立起TCP/IP网络连接， 具体过程如下： 第一次握手： 主机向服务器发送一个建立连接的请求（您好，我想认识您） 建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认 第二次握手： 服务器接到请求后发送同意连接的信号（好的，很高兴认识您） 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器 进入SYN_RECV状态； 第三次握手： 主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。补充说明: TCP 协议：三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号。3. 发送HTTP请求 与服务器建立连接之后，就可以向服务器发送请求了，请求需要遵循http协议4.服务器处理请求； 被请求的服务器解析用户请求的有哪些资源，通过服务器返回数据给客户端5.返回响应结果； 给客户端返回请求的状态码，通过状态码可以知道服务器端的处理是否正常6.浏览器渲染： 返回成功之后，浏览器拿到请求页面的代码，将其解析渲染出来。解析和渲染的过程主要由浏览器的渲染引擎实现。 根据域名查找 IP 地址概念解释 IP 地址：IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址； 域名(DN)：IP 地址由四个数字组成，中间用点号连接，在使用过程中难记忆且易输入错误，所以用我们熟悉的字母和数字组合来代替纯数字的 IP 地址，比如我们只会记住 www.baidu.com（百度域名） 而不是 220.181.112.244（百度的其中一个 IP 地址）； DNS： 每个域名都对应一个或多个提供相同服务服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。 知道了上面的概念，大概就知道了想要获得服务器的门牌号码，需要先将域名转换成 IP 地址。转换过程如下（以查询 www.baidu.com 的 IP 地址为例，其中2、3、4步均在上一步未查询成功的情况下进行）： 查找过程 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）； 操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求； LDNS 向 Root Name Server（根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server返回 com 域的顶级域名服务器的地址； LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com域名服务器地址； LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com的 IP 地址； LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来； 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来； 至此，浏览器已经得到了域名对应的 IP 地址。 补充说明 域名与 URL 是两个概念：域名是一台或一组服务器的名称，用来确定服务器在 Internet 上的位置；URL 是统一资源定位符，用来确定某一个文件的具体位置，例如，zhihu.com 是 知乎的域名，根据这个域名可以找到知乎的服务器，zhihu.com/people/CompileYouth 是 URL ，可以根据这个 URL 定位我的知乎主页； IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限； 网页请求与显示 当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件； 服务器将得到的 HTML 文件发送给浏览器； 在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页； 在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML 断开连接–四次挥手 主机向服务器发送一个断开连接的请求（不早了，我该走了）； 服务器接到请求后发送确认收到请求的信号（知道了）； 服务器向主机发送断开通知（我也该走了）； 主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接； URL 一个完整的URL地址由：协议、服务器地址(主机)、端口、资源路径(文件)。其中网络地址指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；协议是从 该计算机获取资源的方式，常见的是HTTP、FTP，不同协议有不同的通讯内容格式；资源路径指示从服务器上获取哪一项资源。例如：http://www.guokr.com/question/554991/超文本传输协议：http服务器地址：www.guokr.com端口： http协议的默认端口为80资源路径：是指要活的的文件的路径 -&gt;/question/554991/ 转载： 一个页面从输入url,到页面显示加载完成,这个过程中都发生了什么? 从输入 URL 到页面加载完成的过程中都发生了什么参考文章： 从键入网址到页面显示经历了那些过程]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>网页从输入网址到渲染完成经历了哪些过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM开发模式的理解]]></title>
    <url>%2F2019%2F02%2F23%2FVue%2FMVVM%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[MVVM MVVM（模型视图ViewModel 是一种基于MVC和MVP的架构模式，它试图更清楚地将用户界面（UI）的开发与应用程序中的业务逻辑和行为的开发分开。为此，此模式的许多实现都使用声明性数据绑定，以允许将视图上的工作与其他层分离。 Model、View、ViewModel MVVM分为Model、View、ViewModel三者。 Model 代表数据模型，数据和业务逻辑都在Model层中定义； View 代表UI视图，负责数据的展示，是用户在屏幕上看到的结构； ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作； Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom。 设计模式编辑 因为WPF技术出现，从而使MVC架构模式有所改进，MVVM 模式便是使用的是数据绑定基础架构。它们可以轻松构建UI的必要元素。可以参考The Composite Application Guidance for WPF(prism)View绑定到ViewModel，然后执行一些命令在向它请求一个动作。而反过来，ViewModel跟Model通讯，告诉它更新来响应UI。这样便使得为应用构建UI非常的容易。往一个应用程序上贴一个界面越容易，外观设计师就越容易使用Blend来创建一个漂亮的界面。同时，当UI和功能越来越松耦合的时候，功能的可测试性就越来越强。在MVP模式中，为了让UI层能够从逻辑层上分离下来，设计师们在UI层与逻辑层之间加了一层interface。无论是UI开发人员还是数据开发人员，都要尊重这个契约、按照它进行设计和开发。这样，理想状态下无论是Web UI还是Window UI就都可以使用同一套数据逻辑了。借鉴MVP的IView层，养成习惯。View Model听起来比Presenter要贴切得多；会把一些跟事件、命令相关的东西放在MVC的’C’,或者是MVVM的’Vm’。 优点和缺点优点 MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点: 低耦合: 视图（View）可以独立于 Model 变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可重用性: 你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 独立开发:开发人员可以专注于业务逻辑和数据的开发(ViewModel), 设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。 可测试:界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。 MVVM有助于更轻松地并行开发UI以及为其提供支持的构建块 抽象视图，从而减少其背后的代码所需的业务逻辑（或粘合剂）的数量 ViewModel比事件驱动的代码更容易进行单元测试 可以在不关心UI自动化和交互的情况下测试ViewModel（比View更多的模型） 缺点 对于更简单的UI，MVVM可能过度 虽然数据绑定可以是声明性的并且很好用，但它们比我们简单设置断点的命令式代码更难调试 非平凡应用程序中的数据绑定可以创建大量的簿记。您也不希望在绑定比绑定的对象更重的情况下结束 在较大的应用程序中，预先设计ViewModel以获得必要的泛化量可能更加困难 参考文章： 前后端分手大师——MVVM 模式 简单理解MVVM–实现Vue的MVVM模式 了解MVVM - JavaScript开发人员指南]]></content>
      <categories>
        <category>开发模式</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stylus基础]]></title>
    <url>%2F2019%2F02%2F22%2FCSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%2Fstylus%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>stylus</category>
      </categories>
      <tags>
        <tag>stylus基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis基础]]></title>
    <url>%2F2019%2F02%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fredis%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoose]]></title>
    <url>%2F2019%2F02%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmongoose%2F</url>
    <content type="text"><![CDATA[mongoosemongodb 的概念 &amp; 安装mongod mongodb 可视化工具 RoRo 3T 安装及应用mongoose 的作用mongoose 的应用]]></content>
      <categories>
        <category>mongoose</category>
      </categories>
      <tags>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa2基础]]></title>
    <url>%2F2019%2F02%2F21%2FKoa2%2FKoa2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Koa官网《Koa2进阶学习笔记》已完结 使用koa-generator生成koa2项目全局安装koa-generator: npm install -g koa-generator使用koa-generator生成koa2项目: koa2 -e koa2-learn -e 添加ejs模板引擎支持(默认是jade) koa2-learn 项目名123456789101112131415161718192021222324$ koa2 -e koa2-learning create : koa2-learning create : koa2-learning/package.json create : koa2-learning/app.js create : koa2-learning/public/javascripts create : koa2-learning/routes create : koa2-learning/routes/index.js create : koa2-learning/routes/users.js create : koa2-learning/public/images create : koa2-learning/public/stylesheets create : koa2-learning/public/stylesheets/style.css create : koa2-learning/public create : koa2-learning/views create : koa2-learning/views/index.ejs create : koa2-learning/views/error.ejs create : koa2-learning/bin create : koa2-learning/bin/www install dependencies: $ cd koa2-learning &amp;&amp; npm install run the app: $ DEBUG=koa2-learning:* npm start PS: 如果出现 npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.7: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;}) 不用担心。出现原因：fsevents 不在 package.json里，但是仍然安装了，是因为你的系统是Windows系统，fsevents是苹果系统的可选依赖,你的项目有可能是团队项目，别人在他的mac上安装了fsevents相关依赖库，所以到这边你也就安装到你的windows上边了。你可以检查你的package.json 文件中是不是有fsevents相关依赖，删除即好！如果没有，其他的npm包也会有依赖fsevents的！！！这是warning错误，是因为mac下需要fsevents，这里是在windows环境，所以可以忽略这个警告，对你没什么影响的。运行: DEBUG=koa2-learning:* npm start || npm run dev效果： 出现 node bin/www 访问 http://localhost:3000/注意： npm start 、 npm test 、 npm run dev 、 npm run prd async 和 await 语法异步概念 是指一个进程在执行某个请求的时候，如果这个请求没有执行完毕，进程不会等待，而是继续执行下面的请求。 理解async 和 awaitKoa2 中间件koa2 中间件的原理 自定义 koa2 中间件koa2 路由路由写法接口举例cookie 和 sessioncookie 和 session 的定义cookie 和 session 的作用推荐： 从头实现一个koa框架 浅析koa的洋葱模型实现]]></content>
      <categories>
        <category>Koa2</category>
      </categories>
      <tags>
        <tag>Koa2基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2019%2F02%2F15%2FVue%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Vue.js基础，模块化，单文件组件，路由，与服务器通信，状态管理，单元测试与生产发布，服务端渲染SSR与Nuxt.js，基于Vue.js企业级项目开发(Mint UI, Element UI)等132131]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局]]></title>
    <url>%2F2019%2F02%2F15%2FCSS3%2Fcss%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[转载： 知乎专栏：CSS布局十八般武艺都在这里了参考：掘金：CSS 常见布局方式 常用居中方法 居中在布局中很常见，我们假设DOM文档结构如下，子元素要在父元素中居中：123&lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt;&lt;/div&gt; 水平居中 子元素为行内元素还是块状元素，宽度一定还是宽度未定，采取的布局方案不同。子元素为: 行内元素：对父元素设置text-align:center;定宽块状元素: 设置左右margin值为auto;不定宽块状元素: 设置子元素为display:inline,然后在父元素上设置text-align:center;通用方案: flex布局，对父元素设置display:flex;justify-content:center;` 例子：固定宽度 这种方式是绝对定位居中，除了使用 margin，我们还可以使用 transform（注意浏览器兼容性，只适用于 ie9+，移动开发请忽略）1234567891011121314151617.container&#123; width: 300px; height: 200px; background: pink; position: relative;&#125;.inner&#123; width: 100px; height: 50px; position: absolute; top: 50%; left: 50%; margin-top: -25px; margin-left: -50px; background: #fff; text-align: center;&#125; 1234567891011121314151617.container&#123; width: 300px; height: 200px; background: pink; position: relative;&#125;.inner&#123; width: 100px; height: 50px; position: absolute; top: 50%; left: 50%; /* transform: translate(-50%, -50%); */ transform: translate(-50px, -25px); background: #fff; text-align: center;&#125; 宽度未知 将子元素设置为行内元素，然后父元素设置 text-align: center。12345678910.container&#123; width: 300px; height: 200px; background: pink; position: relative; text-align: center;&#125;.inner&#123; display: inline-block;&#125; 多个块状元素 上面的方式即使子元素不止一个也想实现水平居中也是有效的，（宽度固定不固定都可，不固定的话就不需要设置宽度，会被自动撑开，但是要考虑到撑爆的情况）例如：12345678910111213141516.container&#123; width: 250px; height: 200px; background: pink; position: relative; text-align: center; padding: 20px;&#125;.inner&#123; display: inline-block; width: 50px; height: 150px; margin: 0 auto; background: #fff; text-align: center;&#125; 当然也可以使用我们刚刚介绍的 flex，我们只需要让子元素在主轴上的对齐方式设置为居中就可以1234567891011121314.container&#123; width: 250px; height: 200px; background: pink; display: flex; justify-content: center; padding: 20px;&#125;.inner&#123; background: #fff; width: 50px; height: 150px; margin-left: 10px;&#125; 垂直居中 垂直居中对于子元素是单行内联文本、多行内联文本以及块状元素采用的方案是不同的。父元素一定，子元素为单行内联文本:设置父元素的height等于行高line-height父元素一定，子元素为多行内联文本:设置父元素的display:table-cell或inline-block，再设置vertical-align:middle;块状元素:设置子元素position:absolute并设置top、bottom为0，父元素要设置定位为static以外的值，margin:auto;通用方案:flex布局，给父元素设置{display:flex; align-items:center;}。 单列布局 特征：定宽、水平居中常见的单列布局有两种： 一种是header、content、footer宽度都相同，其一般不会占满浏览器的最宽宽度，但当浏览器宽度缩小低于其最大宽度时，宽度会自适应。 一种是header、footer宽度为浏览器宽度，但content以及header和footer里的内容却不会占满浏览器宽度。对于第一种，对header、content、footer统一设置width或max-width，并通过margin:auto实现居中。DOM文档:12345&lt;div class="layout"&gt; &lt;div id="header"&gt;头部&lt;/div&gt; &lt;div id="content"&gt;内容&lt;/div&gt; &lt;div id="footer"&gt;尾部&lt;/div&gt;&lt;/div&gt; CSS清单:12345.layout&#123;/* width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/ max-width: 960px; margin: 0 auto;&#125; 对于第二种，header、footer的内容宽度为100%，但header、footer的内容区以及content统一设置width 或 max-width，并通过margin:auto实现居中。DOM文档:1234567&lt;div id="header"&gt; &lt;div class="layout"&gt;头部&lt;/div&gt;&lt;/div&gt;&lt;div id="content" class="layout"&gt;内容&lt;/div&gt;&lt;div id="footer"&gt; &lt;div class="layout"&gt;尾部&lt;/div&gt;&lt;/div&gt; CSS清单:12345.layout&#123;/* width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/ max-width: 960px; margin: 0 auto;&#125; 二列&amp;三列布局 二列布局的特征是侧栏固定宽度，主栏自适应宽度。三列布局的特征是两侧两列固定宽度，中间列自适应宽度。 之所以将二列布局和三列布局写在一起，是因为二列布局可以看做去掉一个侧栏的三列布局，其布局的思想有异曲同工之妙。对于传统的实现方法，主要讨论上图中前三种布局，经典的带有侧栏的二栏布局以及带有左右侧栏的三栏布局，对于flex布局，实现了上图的五种布局。 float + margin 原理说明：设置两个侧栏分别向左向右浮动，中间列通过外边距给两个侧栏腾出空间，中间列的宽度根据浏览器窗口自适应。 DOM文档:12345&lt;div id="content"&gt; &lt;div class="sub"&gt;sub&lt;/div&gt; &lt;div class="extra"&gt;extra&lt;/div&gt; &lt;div class="main"&gt;main&lt;/div&gt;&lt;/div&gt; 布局步骤: 对两边侧栏分别设置宽度，并对左侧栏添加左浮动，对右侧栏添加有浮动。对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。CSS清单:123456789101112.sub&#123; width: 100px; float: left;&#125;.extra&#123; width: 200px; float: right;&#125;.main&#123; margin-left: 100px; margin-right: 200px;&#125; 一些说明: 注意DOM文档的书写顺序，先写两侧栏，再写主面板，更换后则侧栏会被挤到下一列（圣杯布局和双飞翼布局都会用到）。 这种布局方式比较简单明了，但缺点是渲染时先渲染了侧边栏，而不是比较重要的主面板。 二列的实现方法 如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。 position + margin 原理说明：通过绝对定位将两个侧栏固定，同样通过外边距给两个侧栏腾出空间，中间列自适应。 DOM文档:123&lt;div class="sub"&gt;left&lt;/div&gt;&lt;div class="main"&gt;main&lt;/div&gt;&lt;div class="extra"&gt;right&lt;/div&gt; 布局步骤: 对两边侧栏分别设置宽度，设置定位方式为绝对定位。设置两侧栏的top值都为0，设置左侧栏的left值为0， 右侧栏的right值为0。对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。CSS清单:1234567891011121314.sub, .extra &#123; position: absolute; top: 0; width: 200px;&#125;.sub &#123; left: 0;&#125;.extra &#123; right: 0; &#125;.main &#123; margin: 0 200px;&#125; 一些说明: 本方法不限制DOM书写顺序，先写主面板会使主面板部分优先渲染（一般主面板会比侧栏内容重要）。与上一种方法相比，本种方法是通过定位来实现侧栏的位置固定。如果中间栏含有最小宽度限制，或是含有宽度的内部元素，则浏览器窗口小到一定程度，主面板与侧栏会发生重叠。二列的实现方法 如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。 圣杯布局 (float + 负margin)原理说明： 主面板设置宽度为100%，主面板与两个侧栏都设置浮动，常见为左浮动，这时两个侧栏会被主面板挤下去。通过负边距将浮动的侧栏拉上来，左侧栏的负边距为100%，刚好是窗口的宽度，因此会从主面板下面的左边跑到与主面板对齐的左边，右侧栏此时浮动在主面板下面的左边，设置负边距为负的自身宽度刚好浮动到主面板对齐的右边。为了避免侧栏遮挡主面板内容，在外层设置左右padding值为左右侧栏的宽度，给侧栏腾出空间，此时主面板的宽度减小。由于侧栏的负margin都是相对主面板的，两个侧栏并不会像我们理想中的停靠在左右两边，而是跟着缩小的主面板一起向中间靠拢。此时使用相对布局，调整两个侧栏到相应的位置。 DOM文档:12345 &lt;div id="bd"&gt; &lt;div class="main"&gt;center&lt;/div&gt; &lt;div class="sub"&gt;left&lt;/div&gt; &lt;div class="extra"&gt;right&lt;/div&gt; &lt;/div&gt; 布局步骤:三者都设置向左浮动。设置main宽度为100%，设置两侧栏的宽度。设置 负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。设置main的padding值给左右两个子面板留出空间。设置两个子面板为相对定位，sub的left值为负的sub宽度，extra的right值为负的extra宽度。CSS清单:123456789101112131415161718192021.main &#123; float: left; width: 100%; &#125; .sub &#123; float: left; width: 190px; margin-left: -100%; position: relative; left: -190px; &#125; .extra &#123; float: left; width: 230px; margin-left: -230px; position: relative; right: -230px; &#125;#bd &#123; padding: 0 230px 0 190px; &#125; 一些说明 DOM元素的书写顺序不得更改。主面板部分优先渲染（一般主面板会比侧栏内容重要）。当面板的main内容部分比两边的子面板宽度小的时候，布局就会乱掉。可以通过设置main的min-width属性或使用双飞翼布局避免问题。二列的实现方法如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的padding-right值，其他操作相同。反之亦然。 双飞翼布局 (float + 负margin) 原理说明：双飞翼布局和圣杯布局的思想有些相似，都利用了浮动和负边距，但双飞翼布局在圣杯布局上做了改进，在main元素上加了一层div, 并设置margin,由于两侧栏的负边距都是相对于main-wrap而言，main的margin值变化便不会影响两个侧栏，因此省掉了对两侧栏设置相对布局的步骤。 DOM文档:12345&lt;div class="main-wrap"&gt; &lt;div class="main"&gt;#main&lt;/div&gt;&lt;/div&gt;&lt;div class="sub"&gt;left&lt;/div&gt;&lt;div class="extra"&gt;right&lt;/div&gt; 布局步骤:三者都设置向左浮动。设置main-wrap宽度为100%，设置两个侧栏的宽度。设置负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。设置main的margin值给左右两个子面板留出空间。CSS清单:1234567891011121314151617.main-wrap &#123; float: left; width: 100%; &#125; .sub &#123; float: left; width: 190px; margin-left: -100%; &#125; .extra &#123; float: left; width: 230px; margin-left: -230px; &#125;.main &#123; margin: 0 230px 0 190px;&#125; 一些说明 主面板部分优先渲染（一般主面板会比侧栏内容重要）。圣杯采用的是padding，而双飞翼采用的margin，解决了圣杯布局main的最小宽度不能小于左侧栏的缺点。双飞翼布局不用设置相对布局，以及对应的left和right值。通过引入相对布局，可以实现三栏布局的各种组合，例如对右侧栏设置position: relative; left: 190px;,可以实现sub+extra+main的布局。二列的实现方法如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置main-wrap的margin-right值，其他操作相同。反之亦然。 flex布局 以下是五种布局的flex布局代码：DOM文档：1234567891011121314151617181920212223&lt;div class="layout"&gt; &lt;aside class="aside"&gt;侧边栏宽度固定&lt;/aside&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="aside"&gt;侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;aside class="aside"&gt;左侧边栏宽度固定&lt;/aside&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="aside"&gt;右侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;aside class="aside"&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class="aside"&gt;第2个侧边栏宽度固定&lt;/aside&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="aside"&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class="aside"&gt;第2个侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt; CSS清单123456789.layout &#123; display: flex;&#125;.main &#123; flex: 1;&#125;.aside &#123; width: 200px;&#125; 与之前所讲的几种传统布局方案相比，flex布局的代码可谓异常简洁，而且非常通用，利用简单的三行CSS即实现了常见的五种布局。 总结 传统的布局方法基于盒状模型，依赖 display属性 + position属性 + float属性，逻辑相对复杂，对于实现一些特殊效果，例如垂直居中，尤其复杂繁琐。而flex布局中的flex容器可以根据实际可用空间动态调整子元素的宽高比和顺序，使元素能够尽可能地利用可用空间，同时也能通过缩小来避免超出。flex布局提供了一套简便、完整、响应式的布局方案。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>页面布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[像素：(px、pt、em、rem、rpx)]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%83%8F%E7%B4%A0%2F%E5%83%8F%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[参考资料：px、em、rem区别介绍字体大小之px、em、rem、pt,字号详解 px: px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。 PX特点: 1. IE无法调整那些使用px作为单位的字体大小； 2. 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位； 3. Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。pt: pt(point，磅)：是一个物理长度单位，指的是72分之一英寸。表示绝对长度。em: em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 em特点： 1. em的值并不是固定的； 2. em会继承父级元素的字体大小。 注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。所以我们在写CSS的时候，需要注意两点： 1. body选择器中声明Font-size=62.5%； 2. 将你的原来的px数值除以10，然后换上em作为单位； 3. 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。也就是避免1.2 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。 rem: rem（root em，根em）：是CSS3新增的一个相对单位，相对的只是HTML根元素，可以只修改根元素就可以成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。兼容性IE9+都可以兼容，对于不兼容的浏览器写一个绝对单位的声明就可以了。rpx: rpx单位是微信小程序中css的尺寸单位，rpx可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>像素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重绘(repaint)与回流(reflow)]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E9%87%8D%E7%BB%98(repaint)%E4%B8%8E%E5%9B%9E%E6%B5%81(reflow)%2F</url>
    <content type="text"><![CDATA[文章转载： 浏览器重绘和重排文章参考： 重构与回流 浏览器的重绘与重排 探讨css中repaint和reflow 前言： 页面设计中，不可避免的需要浏览器进行repaint和reflow。那到底什么是repaint和reflow呢。下面谈谈自己对repaint和reflow的理解，以及结合其他技术牛的讲解，谈谈如何优化repaint和reflow。 概述： 重排(回流), 顾名思义就是重新排版的意思; 重绘, 就是浏览器重新绘制。理解重排和重绘的含义十分重要, 因为在评审页面交互效果的时候, 重绘和重排是必须考虑的因素。并不是说交互效果实现了就可以了, 必须同时考虑到这样做会引发什么性能问题。也就是说, 浏览器在进行重绘和重排的时候是要付出高昂的性能代价的。 只有静态页面才会不存在repaint和reflow。repaint主要是针对某一个DOM元素进行的重绘，reflow则是回流，针对整个页面的重排。字面意思来说：repaint就是重绘，reflow就是回流。回流必将引起重绘，而重绘不一定会引起回流，repaint和reflow的目的是：展示一个新的页面样貌。 浏览器执行流： 浏览器每次从服务器下载完页面后就会对页面进行渲染(Render), 这里面就包含了重绘以及重排。每种浏览器虽然工作原理略有差别, 但也遵循以下流程: 览器引擎会解析HTML文档来构建DOM树。树的每个节点都是标签, 有大小边距等等的属性, 这是因为每个HTML元素都遵循盒子模型(隐藏元素不包括在文档树中, 浏览器不会将其渲染)。 渲染树构建完毕后, 浏览器就能够确定每个元素的位置并将元素放到正确的位置上, 再根据树节点的样式属性绘制出页面元素。 由于浏览器的流布局的方式, 对渲染树的计算通常只需要遍历一遍即可。但table及其内部元素除外, 可能需要执行多次计算才能确定好在渲染树中的属性,这个过程通常要耗费3倍以上的时间。 这也是我们要避免使用table标签的其中一个原因。 简言之浏览器执行顺序为： 1. 首先获取html，然后构建dom树 ，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。 2. 浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。 3. DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，render tree不包含隐藏的节点 (比如display:none的节点，还有head节点)，因为这些节点不会用于呈现。 4. 一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。 严重性： 在性能优先的前提下，性能消耗 reflow大于repaint。 体现： repaint是某个DOM元素进行重绘；reflow是整个页面进行重排，也就是页面所有DOM元素渲染。 如何触发： style变动造成repaint和reflow。 不涉及任何DOM元素的排版问题的变动为repaint，例如元素的color/text-align/text-decoration等等属性的变动。 除上面所提到的DOM元素style的修改基本为reflow。例如元素的任何涉及长、宽、行高、边框、display等style的修改。 常见触发场景： 重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。重排(回流)是更明显的一种改变，可以理解为渲染树需要重新计算。 触发repaint： color的修改，如color=#ddd； text-align的修改，如text-align=center； a:hover也会造成重绘。 :hover引起的颜色等不导致页面回流的style变动。 触发reflow： width/height/border/margin/padding的修改，如width=778px； 动画，:hover等伪类引起的元素表现改动，display=none等造成页面回流； appendChild等DOM元素操作； font类style的修改； background的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分background的修改只触发repaint，当然IE不用考虑； scroll页面，这个不可避免； resize页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize程序窗口大小的多窗口操作系统。 读取元素的属性(这个无法理解，但是技术达人是这么说的，那就把它当做定理吧)：读取元素的某些属性(offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE)) 如何避免： 说避免那是不可能的，不然就是以前古老的静态页面了，没有交互，那在现在看来，就是一个失败的作品。所以，在我们进行网页设计的时候，就必须尽量减少页面的repaint和reflow。repaint和reflow的目的是为了展示一个新的页面，那么我们在进行页面交互时，尽量通过各种方法减少repaint和reflow但又能展示一个新的页面的目的。所以下面将结合其他技术达人的建议，通过自己的理解，给大家讲解如何避免和优化repaint和reflow： 尽可能在DOM末梢通过改变class来修改元素的style属性： 将多次改变样式属性的操作合并成一次操作，尽可能的减少受影响的DOM元素。 避免设置多项内联样式：使用常用的class的方式进行设置样式，以避免设置样式时访问DOM的低效率。 设置动画元素position属性为fixed或者absolute：由于当前元素从DOM流中独立出来，因此受影响的只有当前元素，元素repaint。 牺牲平滑度满足性能：动画精度太强，会造成更多次的repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。 避免使用table进行布局：table的每个元素的大小以及内容的改动，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以进行针对性的repaint和避免不必要的reflow。 避免在CSS中使用运算式：学习CSS的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。]]></content>
      <categories>
        <category>前端优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[转载：前端性能优化–yahoo前端性能团队总结的35条黄金定律参考文章：Web前端应该从哪些方面来优化网站? - 斯迪的回答 - 知乎WEB前端性能优化常见方法 前端是庞大的，包括 HTML、 CSS、 Javascript、Image 、Flash等等各种各样的资源。前端优化是复杂的，针对方方面面的资源都有不同的方式。那么，为什么要进行前端性能优化？ 怎么进行优化？ 优化到达的效果是什么？ 为什么需要前端性能优化[优化的好处/目的]好处： 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。 前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。 怎么进行优化 内容优化 减少Http请求次数 原因: 这条策略是最重要最有效的，因为一个完整的请求要经过DNS寻址，与服务器建立连接，发送数据，等待服务器响应，接收数据这样一个消耗时间成本和资源成本的复杂的过程。 使用方法： 从设计实现层面简化页面 合并多个CSS文件和js文件 利用CSS Sprites整合图像 Inline Images(使用 data：URL scheme在实际的页面嵌入图像数据 ) 合理设置HTTP缓存等。 使用懒加载进行图片的加载 减少DNS查询 原因: DNS查询也消耗响应时间，如果我们的网页内容来自各个不同的domain (比如嵌入了开放广告，引用了外部图片或脚本)，那么客户端首次解析这些domain也需要消耗一定的时间。DNS查询结果缓存在本地系统和浏览器中一段时间，所以DNS查询一般是对首次访问响应速度有所影响。 使用方法: 优化网站设计（九）：减少DNS查找的次数 减少DNS查找次数，最理想的方法就是将所有的内容资源都放在同一个域(Domain)下面，这样访问整个网站就只需要进行一次DNS查找，这样可以提高性能。 但理想总归是理想，上面的理想做法会带来另外一个问题，就是由于这些资源都在同一个域，而HTTP /1.1 中推荐客户端针对每个域只有一定数量的并行度（它的建议是2），那么就会出现下载资源时的排队现象，这样就会降低性能。 所以，折衷的做法是：建议在一个网站里面使用至少2个域，但不多于4个域来提供资源。我认为这条建议是很合理的，也值得我们在项目实践中去应用。 避免重定向 当客户端收到服务器的跳转回复时，客户端再次根据服务器回复中的location指定的地址再次发送请求，例如以下跳转回复: 123HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html 当客户端遇到这种回复的时候，用户只能等待客户端再次发送请求，有的网站甚至会一直跳n次，跳到他想带你去的地方…当然在这个时候用户看不到任何页面内容，只有浏览器的进度条一直在刷新。 使用Ajax缓存 Ajax可以帮助我们异步的下载网页内容，但是有些网页内容即使是异步的，用户还是在等待它的返回结果，例如ajax的返回是用户联系人的下拉列表。所以我们还是要注意尽量应用以下规则提高ajax的响应速度。 使用方法： 添加Expires 或 Cache-Control报文头使回复可以被客户端缓存 压缩回复内容 减少dns查询 精简javascript 避免跳转 配置Etags 延迟加载组件,预加载组件 延迟加载 这里讨论延迟加载需要我们知道我们的网页最初加载需要的最小内容集是什么。剩下的内容就可以推到延迟加载的集合中。 Javascript是典型的可以延迟加载内容。一个比较激进的做法是开发网页时先确保网页在没有Javascript的时候也可以基本工作，然后通过延迟加载脚本来完成一些高级的功能。 预加载 与延迟加载目的相反，提前加载的是为了提前加载接下来网页中访问的资源，下面是提前加载的类型 无条件提前加载：当前网页加载完成后，马上去下载一些其他的内容。例如google会在页面加载成功之后马上去下载一个所有结果中会用到的image sprite。 有预期的的加载：这种情况一般发生在网页重新设计时，由于用户经常访问旧网页，本地对旧的网页内容缓存充分从而显得旧网页速度很快，而新的网页内容却没有缓存，设计者可以在旧网页的内容中预先加载一些新网页中可能用到的内容，这样新的网页就会生下来一些需要下载的资源。 减少DOM元素数量: 页面中存在大量DOM元素,会导致javascript遍历DOM的效率变慢。 网页中元素过多对网页的加载和脚本的执行都是沉重的负担，500个元素和5000个元素在加载速度上会有很大差别。 想知道你的网页中有多少元素，通过在浏览器中的一条简单命令就可以算出document.getElementsByTagName(&#39;*&#39;).length 最小化iframe的数量： iframes 提供了一个简单的方式把一个网站的内容嵌入到另一个网站中。但其创建速度比其他包括JavaScript和CSS的DOM元素的创建慢了1-2个数量级。 优点 可以用来加载速度较慢的内容，例如广告。 安全沙箱保护。浏览器会对iframe中的内容进行安全控制。 脚本可以并行下载 缺点 即使iframe内容为空也消耗加载时间 会阻止页面加载 没有语义 避免404：HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。 404我们都不陌生，代表服务器没有找到资源，我们要特别要注意404的情况不要在我们提供的网页资源上，客户端发送一个请求但是服务器却返回一个无用的结果，时间浪费掉了。更糟糕的是我们网页中需要加载一个外部脚本，结果返回一个404，不仅阻塞了其他脚本下载，下载回来的内容(404)客户端还会将其当成Javascript去解析。 服务器优化 (1)使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。 再次强调第一条黄金定律，减少网页内容的下载时间。提高下载速度还可以通过CDN(内容分发网络)来提升。CDN通过部署在不同地区的服务器来提高客户的下载速度。如果你的网站上有大量的静态内容，世界各地的用户都在访问，我说的是youtube么？那CDN是必不可少的。事实上大多数互联网中的巨头们都有自己的CDN。我们自己的网站可以先通过免费的CDN供应商来分发网页资源。 添加Expires 或Cache-Control报文头(这条规则分为两个方面) 对于静态内容添加Expires，将静态内容设为永不过期，或者很长时间以后。在IIS中设置Expires可以看Configure the HTTP Expires Response Header (IIS 7)。 对于动态内容应用合适的Cache-Control，让浏览器根据条件来发送请求。关于asp.net的caching，可以看asp.net cache feature和asp.net caching best practices。 (2)GZIP压缩 Gzip通常可以减少70%网页内容的大小，包括脚本、样式表、图片等文件。Gzip比deflate更高效，主流服务器都有相应的压缩支持模块。 (3)设置ETag：ETags（Entity tags，实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。 虽然标题叫配制ETags，但是这里你要根据具体情况进行一些判断。首先Etag简单来说是通过一个文件版本标识使得服务器可以轻松判断该请求的内容是否有所更新，如果没有就回复304 (not modified)，从而避免下载整个文件。 (4)提前刷新缓冲区+ (5)对Ajax请求使用GET方法 浏览器在实现XMLHttpRequest POST的时候分成两步，先发header，然后发送数据。而GET却可以用一个TCP报文完成请求。另外GET从语义上来讲是去服务器取数据，而POST则是向服务器发送数据，所以我们使用Ajax请求数据的时候尽量通过GET来完成。 (6)避免空的图像src 空的图片src仍然会使浏览器发送请求到服务器，这样完全是浪费时间，而且浪费服务器的资源。尤其是你的网站每天被很多人访问的时候，这种空请求造成的伤害不容忽略。 Cookie优化 (1)减小Cookie大小 去除没有必要的cookie，如果网页不需要cookie就完全禁掉 将cookie的大小减到最小 注意cookie设置的domain级别，没有必要情况下不要影响到sub-domain 设置合适的过期时间，比较长的过期时间可以提高响应速度。 (2)针对Web组件使用域名无关的Cookie 大多数网站的静态资源都没必要cookie，我们可以采用不同的domain来单独存放这些静态文件，这样做不仅可以减少cookie大小从而提高响应速度，还有一个好处是有些proxy拒绝缓存带有cookie的内容，如果能将这些静态资源cookie去除，那就可以得到这些proxy的缓存支持。 常见的划分domain的方式是将静态文件放在static.example.com，动态内容放在www.example.com。 也有一些网站需要在二级域名上应用cookie，所有的子域都会继承，这种情况下一般会再购买一个专门的域名来存放cookie-free的静态资源。例如Yahoo!的yimg.com，YouTube的ytimg.com等。 CSS优化 (1)将CSS代码放在HTML页面的顶部 经样式表(css)放在网页的HEAD中会让网页显得加载速度更快，因为这样做可以使浏览器逐步加载已将下载的网页内容。这对内容比较多的网页尤其重要，用户不用一直等待在一个白屏上，而是可以先看已经下载的内容。 如果将样式表放在底部，浏览器会拒绝渲染已经下载的网页，因为大多数浏览器在实现时都努力避免重绘，样式表中的内容是绘制网页的关键信息，没有下载下来之前只好对不起观众了。 (2)避免使用CSS表达式 CSS表达式可以动态的设置CSS属性，在IE5-IE8中支持，其他浏览器中表达式会被忽略。例如下面表达式在不同时间设置不同的背景颜色。 CSS表达式的问题在于它被重新计算的次数远比我们想象的要多，不仅在网页绘制或大小改变时计算，即使我们滚动屏幕或者移动鼠标的时候也在计算，因此我们还是尽量避免使用它来防止使用不当而造成的性能损耗。 (3)使用来代替@import 避免使用@import的原因很简单，因为它相当于将css放在网页内容底部。 (4)避免使用Filters AlphaImageLoad也是IE5.5 - IE8中支持，这种滤镜的使用会导致图片在下载的时候阻塞网页绘制，另外使用这种滤镜会导致内存使用量的问题。IE9中已经不再支持。 JS优化 (1)将JavaScript脚本放在页面的底部。 HTTP/1.1 specification建议浏览器对同一个hostname不要超过两个并行下载连接， 所以当你从多个domain下载图片的时候可以提高并行下载连接数量。但是当脚本在下载的时候，即使是来自不同的hostname浏览器也不会下载其他资源，因为浏览器要在脚本下载之后依次解析和执行。 因此对于脚本提速，我们可以考虑以下方式， 把脚本置底，这样可以让网页渲染所需要的内容尽快加载显示给用户。 现在主流浏览器都支持defer关键字，可以指定脚本在文档加载后执行。 HTML5中新加了async关键字，可以让脚本异步执行。 (2)将JavaScript和CSS作为外部文件来引用： 使用外部Javascript和CSS文件可以使这些文件被浏览器缓存，从而在不同的请求内容之间重用。 同时将Javascript和CSS从inline变为external也减小了网页内容的大小。 使用外部Javascript和CSS文件的决定因素在于这些外部文件的重用率，如果用户在浏览我们的页面时会访问多次相同页面或者可以重用脚本的不同页面，那么外部文件形式可以为你带来很大的好处。但对于用户通常只会访问一次的页面，例如microsoft.com首页，那inline的javascript和css相对来说可以提供更高的效率。 (3)缩小JavaScript和CSS 精简就是将Javascript或CSS中的空格和注释全去掉， (4)删除重复的脚本 重复的脚本不仅浪费浏览器的下载时间，而且浪费解析和执行时间。一般用来避免引入重复脚本的做法是使用统一的脚本管理模块，这样不仅可以避免重复脚本引入，还可以兼顾脚本依赖管理和版本管理。 (5)最小化DOM的访问：使用JavaScript访问DOM元素比较慢。 通过Javascript访问DOM元素没有我们想象中快，元素多的网页尤其慢，对于Javascript对DOM的访问我们要注意 缓存已经访问过的元素 Offline更新节点然后再加回DOM Tree 避免通过Javascript修复layout (6)开发智能的事件处理程序 这里说智能的事件处理需要开发者对事件处理有更深入的了解，通过不同的方式尽量少去触发事件，如果必要就尽早的去处理事件。 比如一个div中10个按钮都需要事件句柄，那么我们可以将事件放在div上，在事件冒泡过程中捕获该事件然后判断事件来源。 (7)javascript代码注意： 谨慎使用with,避免使用eval Function函数,减少作用域链查找。 with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的 执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。 因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。 图像优化 (1)优化图片大小 检查GIF图片中图像颜色的数量是否和调色板规格一致。如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。可以使用imagemagick检查：identify -verbose image.gif 尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。下面这条简单的命令可以安全地把GIF格式转换为PNG格式： convert image.gif image.png 在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如： pngcrush image.png -rem alla -reduce -brute result.png 在所有的JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息 jpegtran -copy none -optimize -perfect src.jpg dest.jpg (2)通过CSS Sprites优化图片 Spirite中水平排列图片，垂直排列会增加文件大小； Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式； 不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小,但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100×100的图片为1万像素，1000×1000就是100万像素。 (3)不要在HTML中使用缩放图片 不要通过图片缩放来适应页面，如果你需要小图片，就直接使用小图片吧。 (4)favicon.ico要小而且可缓存 网站图标文件favicon.ico，不管你服务器有还是没有，浏览器都会去尝试请求这个图标。所以我们要确保这个图标 存在 文件尽量小，最好小于1k 设置一个长的过期时间 移动客户端 保持单个内容小于25KB 这限制是因为iphone，他只能缓存小于25K，注意这是解压后的大小。所以单纯gzip不一定够用，精简文件工具要用上了。 打包组建成符合文档 把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组建。当你使用这条规则时，首先要确定用户代理是否支持（iPhone不支持）。 待解决的方面 转载别人，如有错误请指出。]]></content>
      <categories>
        <category>前端优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪元素和伪类]]></title>
    <url>%2F2018%2F11%2F16%2FCSS3%2F%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[伪元素和伪类伪类包含两种：状态伪类和结构性伪类。状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。当元素处于某状态时会呈现该样式，而进入另一状态后，该样式也会失去。常见的状态伪类主要包括： :link 应用于未被访问过的链接；:hover 应用于鼠标悬停到的元素；:active 应用于被激活的元素；:visited 应用于被访问过的链接，与:link互斥。:focus 应用于拥有键盘输入焦点的元素。结构性伪类是css3新增选择器，利用dom树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少class和id属性的定义，使文档结构更简洁。常见的包括： :first-child 选择某个元素的第一个子元素；:last-child 选择某个元素的最后一个子元素；:nth-child() 选择某个元素的一个或多个特定的子元素；:nth-last-child() 选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算；:nth-of-type() 选择指定的元素；:nth-last-of-type() 选择指定的元素，从元素的最后一个开始计算；:first-of-type 选择一个上级元素下的第一个同类子元素；:last-of-type 选择一个上级元素的最后一个同类子元素；:only-child 选择的元素是它的父元素的唯一一个子元素；:only-of-type 选择一个元素是它的上级元素的唯一一个相同类型的子元素；:empty 选择的元素里面没有任何内容。 伪元素是对元素中的特定内容进行操作，而不是描述状态。它的操作层次比伪类更深一层，因此动态性比伪类低很多。实际上，伪元素就是选取某些元素前面或后面这种普通选择器无法完成的工作。控制的内容和元素是相同的，但它本身是基于元素的抽象，并不存在于文档结构中！常见的伪元素选择器包括： :first-letter 选择元素文本的第一个字（母）。:first-line 选择元素文本的第一行。:before 在元素内容的最前面添加新内容。:after 在元素内容的最后面添加新内容。 注意事项有时你会发现伪类元素使用了两个冒号 (::) 而不是一个冒号 (:)，这是 CSS3 规范中的一部分要求，目的是为了区分伪类和伪元素，大多数浏览器都支持这两种表示方式。单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。对于 CSS2 中已经有的伪元素，例如 :before，单冒号和双冒号的写法 ::before 作用是一样的。 所以，如果你的网站只需要兼容 webkit、firefox、opera 等浏览器，建议对于伪元素采用双冒号的写法，如果不得不兼容 IE 浏览器，还是用 CSS2 的单冒号写法比较安全。 参考文章： 谈谈css伪类与伪元素]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒子模型]]></title>
    <url>%2F2018%2F11%2F06%2FCSS3%2F%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[盒子样式介绍 width和height：内容的宽度、高度（不是盒子的宽度、高度） padding：内边距。 border：边框。 margin：外边距。 盒子模型的分类与概念 盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是IE盒子模型和标准 w3c 盒子模型。他们对盒子模型的解释各不相同: IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。 标准 W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。 ps: 1. ie8以上都是w3c标准盒模型 2. ie5极其以下都是ie盒子模型，ie6、ie7、ie8在混杂模式下ie盒模型， 3. 在标准模式下是w3c标准盒模型 4. 注意：ie6在混杂模式下一定是Ie盒模型，而ie7、ie8在混杂模式下不一定是ie盒模型 box-sizing 属性可以被用来调整这些表现: 1. content-box 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。 2. border-box 告诉浏览器去理解你设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px,那么这100px会包含其它的border和padding，内容区的实际宽度会是width减去border + padding的计算值。大多数情况下这使得我们更容易的去设定一个元素的宽高。 3. border-box定义的盒子，不会随着padding和boder的加入而增大盒子的占用空间 border-box width 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。注意，填充和边框将在盒子内 。例如, .box {width: 350px; border: 10px solid black;} 导致在浏览器中呈现的宽度为350px的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。这里的维度计算为：width = border + padding + 内容的 width，height = border + padding + 内容的 height。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F06%2FH5%2FH5%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5语义化标签]]></title>
    <url>%2F2018%2F11%2F06%2FCSS3%2F%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[H5中关于语义化的标签有哪些，语义化标签有什么作用？为什么要使用语义化标签? 1. H5中关于语义化的标签有哪些 title 简短、描述性、唯一（提升搜索引擎排名）header 页眉通常包括网站标志、主导航、全站链接以及搜索框。section 具有相似主题的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。footer 页脚，只有当父级是body时，才是整个页面的页脚。article 包含像报纸一样的内容= =||是这么理解的，表示文档、页面、应用或一个独立的容器ahgroup 标签用于对网页或区段（section）的标题进行组合nav 标记导航，仅对文档中重要的链接群使用。aside 指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。address 作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）mark 突出显示文本（yellow），提醒读者。time 标记时间。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式figure 创建图（默认有40px左右margin）figcaption figure的标题，必须是figure内嵌的第一个或者最后一个元素。datailstdetailssummarydialogddprogress 完成进度。可通过js动态更新valuekeygensmall 指定细则，输入免责声明、注解、署名、版权。 2. 语义化标签有什么作用？为什么要使用语义化标签？ 在HTML5出现之前，我们一般采用div+css布局我们的页面。但是这样的布局方式不仅使我们的文档结构不够清晰，而且不利于搜索引擎爬虫对我们页面的爬取。为了解决上述缺点，HTML5新增了很多新的语义化标签。 引入语义化标签的好处主要有 比div标签有更加丰富的含义，方便开发与维护 搜索引擎能更方便的识别页面的每个部分 方便其他设备解析（如移动设备、盲人阅读器等） H5新增的语义化标签headerfooterarticleaside 定义页面的侧边栏内容timedetails 用于描述文档或者文档某一部分细节，summary是details元素的标题ruby 加注释，ruby标签有两个子元素，rt注释的内容，rp是该标签不显示时显示的文字mark 定义带有几号的文本，它会给你想要突出显示的文本加个 背景色navprogresssectionvideo 定义视频，属性src引入资源，controls视频的控制控件audio 该标签可定义声音，及其他的音频文件，不加controls不显示音频的控制界面datalist 提示可能的值，datalist及其选项不会被显示出来，它仅仅是合法输入值的列表使用input元素的list属性来邦定datalistembed 定义插入的内容，如插件，flash，标签中间不要加内容会显现出来canvas canvas画布只是个容器，你可以通过控制坐标在canvas上绘制图形，一般配合js可以实现非常复杂的动画效果]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[块级元素行内元素]]></title>
    <url>%2F2018%2F11%2F06%2FCSS3%2F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[行内元素指的是书写完成后不会自动换行，并且元素没有宽和高。块级元素写完后会自动换行，有宽高可以修改。还有一种特殊的元素叫做行内联元素。行内元素有：span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button（默认display：inline-block块级元素有：div、p、h1~h6、ul、ol、dl、li、dd、table、hr、blockquote、address、table、menu、pre，HTML5新增的header、section、aside、footer内联元素： a , b , br , em , font , img , input , label , select , small , span , textarea]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[README]]></title>
    <url>%2F2018%2F10%2F22%2FREADME%2FREADME%2F</url>
    <content type="text"><![CDATA[It just a test music, but i like it var ap = new APlayer({ element: document.getElementById("aplayer-XEKATKOT"), narrow: false, autoplay: true, showlrc: false, music: { title: "起风了", author: "买辣椒也用券", url: "/assets/music/music.mp3", pic: "/assets/music/music.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深浅拷贝]]></title>
    <url>%2F2018%2F10%2F16%2FJavaScript%2F%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[转载： js 深浅拷贝 笔记总结、[JS]深拷贝与浅拷贝的区别，实现深拷贝的几种方法 JS 数据类型JavaScript的数据类型有： 数值类型(number) 、 字符串类型(string) 、 布尔类型(boolean) 、 null 、undefined 、对象(数组、正则表达式、日期、函数)大致分为两种： 基本数据类型 和 引用数据类型基本数据类型： 数字类型(number)、字符串类型(string)、布尔类型(boolean)、null、undefined引用数据类型： 常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等 深浅拷贝区别如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。 浅拷贝浅拷贝只是拷贝基本类型的数据，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，因此存在父对象被篡改的可能，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存 深拷贝深拷贝就是能够实现真正意义上的数组和对象的拷贝。递归调用”浅拷贝”。（深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象） 浅拷贝例子：12345let a=[0,1,2,3,4], b=a;console.log(a===b);a[0]=1;console.log(a,b); 运行结果：嗯？明明b复制了a，为啥修改数组a，数组b也跟着变了，这里我不禁陷入了沉思。那么这里，就得引入基本数据类型与引用数据类型的概念了。 a.基本类型–名值存储在栈内存中，例如let a=1;当你b=a复制时，栈内存会新开辟一个内存，例如这样：所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。 b.引用数据类型–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，起步就达到深拷贝的效果了 1.我们怎么去实现深拷贝呢，这里可以递归递归去复制所有层级属性。这么我们封装一个深拷贝的函数 123456789101112131415161718192021function deepClone(obj)&#123; let objClone = Array.isArray(obj)?[]:&#123;&#125;; if(obj &amp;&amp; typeof obj==="object")&#123; for(key in obj)&#123; if(obj.hasOwnProperty(key))&#123; //判断ojb子元素是否为对象，如果是，递归复制 if(obj[key]&amp;&amp;typeof obj[key] ==="object")&#123; objClone[key] = deepClone(obj[key]); &#125;else&#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125; let a=[1,2,3,4], b=deepClone(a);a[0]=2;console.log(a,b); 运行结果:跟之前想象的一样，现在b脱离了a的控制，不再受a影响了。这里再次强调，深拷贝，是拷贝对象各个层级的属性，可以看个例子。JQ里有一个extend方法也可以拷贝对象，我们来看看1234let a=[1,2,3,4], b=a.slice();a[0]=2;console.log(a,b); 运行结果：那是不是说slice方法也是深拷贝了，毕竟b也没受a的影响，上面说了，深拷贝是会拷贝所有层级的属性，还是这个例子，我们把a改改12345let a=[0,1,[2,3],4], b=a.slice();a[0]=1;a[2][0]=1;console.log(a,b); 拷贝的不彻底啊，b对象的一级属性确实不受影响了，但是二级属性还是没能拷贝成功，仍然脱离不了a的控制，说明slice根本不是真正的深拷贝。这里引用知乎问答里面的一张图 第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。 同理，concat方法与slice也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。 2.除了递归，我们还可以借用JSON对象的parse和stringify 12345678910function deepClone(obj)&#123; let _obj = JSON.stringify(obj), objClone = JSON.parse(_obj); return objClone&#125; let a=[0,1,[2,3],4], b=deepClone(a);a[0]=1;a[2][0]=1;console.log(a,b); 可以看到，这下b是完全不受a的影响了。 附带说下，JSON.stringify与JSON.parse除了实现深拷贝，还能结合localStorage实现对象数组存储 3.除了上面两种方法之外，我们还可以借用JQ的extend方法。 $.extend( [deep ], target, object1 [, objectN ] ) deep表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝 target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。 object1 objectN可选。 Object类型 第一个以及第N个被合并的对象。12345let a=[0,1,[2,3],4], b=$.extend(true,[],a);a[0]=1;a[2][0]=1;console.log(a,b); 可以看到，效果与上面方法一样，只是需要依赖JQ库。 说了这么多，了解深拷贝也不仅仅是为了应付面试题，在实际开发中也是非常有用的。例如后台返回了一堆数据，你需要对这堆数据做操作，但多人开发情况下，你是没办法明确这堆数据是否有其它功能也需要使用，直接修改可能会造成隐性问题，深拷贝能帮你更安全安心的去操作数据，根据实际情况来使用深拷贝，大概就是这个意思。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-思维]]></title>
    <url>%2F2018%2F10%2F16%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[题目： 给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值方法一：123a = a + b;b = a - b;a = a - b; 方法二：123a = a^b;b = a^b;a = a^b; 题目： 给两个杯子，一个5升，一个6升，水随便用，最后取出3升水方法： 6升装满倒入5升杯子，6升杯子里剩1升水； 6升杯子中的1升倒入5升杯子； 6升杯子装满水倒入5升杯子，6升杯子里剩2升水；把5升杯子水倒掉； 6升杯子中的2升倒入5升杯子； 6升杯子装满水倒入5升杯子，6升杯子里剩3升水，完成。 题目： 给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子方法：二分法：用天平左右各五个进行称量，10 =&gt; 5较轻的一组留下一个，继续进行分开称量，如果左右相等，则剩余的那一个为最轻的，否则剩下的两个继续进行比较5 =&gt; 1 || 5 =&gt; 2最后一次比较 2 =&gt; 1]]></content>
      <categories>
        <category>思维能力</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP和HTTPS的区别]]></title>
    <url>%2F2018%2F10%2F15%2FHTTP%2FHTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[&nbsp; &nbsp; &nbsp;超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。&nbsp; &nbsp; &nbsp;为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPHTTP的基本概念HTTP: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTP: 是超文本传输协议，信息是明文传输 HTTP的优点HTTP的缺点HTTPSHTTPS的基本概念HTTPS(Secure Hypertext Transfer Protocol)是安全超文本传输协议,HTTPS: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。https: 是具有安全性的ssl加密传输协议；HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 HTTPS的工作原理 客户端发起HTTPS请求用户在浏览器里输入一个https网址，然后连接到server的443端口。 服务端的配置采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 客户端解析证书这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 传送加密信息这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务段解密信息服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 传输加密后的信息这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 客户端解密信息客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。 HTTPS的优点 SEO方面谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 安全性 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本 HTTPS的缺点 SEO方面据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 经济方面 SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。 HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。 HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去。 HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。 HTTP和HTTPS的区别 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443； 、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全； https协议需要到ca申请证书，一般免费证书很少，需要交费。 参考文章：HTTP和HTTPS的区别、HTTP与HTTPS的区别 、HTTP详解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http连接性能优化]]></title>
    <url>%2F2018%2F10%2F14%2FHTTP%2Fhttp%E8%BF%9E%E6%8E%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[HTTP和TCP/IP的关系HTTP—&gt;(TSL/SSL)—&gt;TCP—&gt;IPHTTP处于应用层、TCP处于传输层、IP处于网络层 HTTP将所需要传输的数据以流的形式传递给TCP程序 TCP解析数据中的IP地址和端口号，将数据流分割成数据段，并添加上TCP段首部，如TCP握手（ACK、SYNC等），源端口，目的端口、TCP校验和等 TCP程序将包装好的TCP数据段叫给IP程序，IP程序在此基础上封装进去IP分组首部，如源IP地址、目的IP地址，数据报总长度、分组ID、首部长度、首部校验和等等 最后交给数据链路层去发送这个IP分组数据段 TCP性能的考虑HTTP紧挨着TCP，所以TCP的链接性能考虑直接影响的HTTP事务的性能。 HTTP事务时延一次HTTP请求可分为 DNS查询、连接、请求、事务处理、响应、关闭连接。每一步都会产生时延。其中，相对于连接、请求所消耗的时间，事务处理的时间是很短的。 对HTTP程序员产生影响的时延 TCP握手建立链接 TCP慢启动拥塞控制 数据聚集的Nagle算法 用于捎带确认的TCP延迟确认算法 TIME_WAIT 时延和端口耗尽 HTTP连接处理Connection首部真正用途HTTP允许客户端和源服务器之间存在多个代理服务器或高速缓存服务器，进行HTTP连接通信时，可以将HTTP首部逐跳的经过这些设备。这个时候，怎么在相邻的HTTP应用程序之间的连接应用一些特殊的选项呢？— Connection首部，可以承载3种不同类型的标签，这些标签不会传播到其它连接中去。a、HTTP首部字段名，列出了只与此连接有关的选项b、任意标签，用于描述此连接的非标准选项c、值close，说明操作完成之后需关闭这条持久连接由于添加Connection首部的其它首部字段，不能随着报文转发出去。因此将逐跳首部放入Connection首部，就可以达到对首部的保护。例：1234HTTP/1.1 200 OKCache-control: max-age=3600Connection: meter,close,bill-my-credit-cardMeter: max-uses=3,max-refuses=6,dont-report 实例说明：不应该转发Meter首部，要应用假想的bill-my-credit-card选项，且本次事务后应关闭持久连接。 串行事务处理延迟如果只对HTTP事务进行简单管理，TCP的性能时延可能会叠加起来，包括多次的建立连接和断开连接。 提高HTTP连接性能的四个方法：并行连接通过多条TCP连接发起并发的HTTP请求并行连接从理论上回提高页面的加载速度，因为多个请求同时发出，时延可以重叠起来。但并行连接并不是一点更快，原因可能是：客户端带宽限制、消耗更多的内存和计算资源。现代浏览器确实使用并行连接，但会限制连接数在一个较小的值（通常是4），并且服务器可以关闭来自特定客户端的超量连接。 持久连接重用TCP连接，以消除连接及关闭的时延重用连接：HTTP/1.1(HTTP/1.0增强版)允许HTTP设备在事务处理结束后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接。 持久连接+并行连接持久的连接的管理很重要，不小心会累积出大量的空闲连接 HTTP/1.0 + Keep-alive连接Connection： Keep-alive属性出现在1996年HTTP/1.0版本中，当初也是被当做实验型持久连接。 可以用通用首部Keep-Alive属性指定由逗号分隔的选项来调节keep-alive的行为。例：12Connection：Keep-aliveKeep-Alive: max=5,timeout=120 说明：服务器还会为另外5个事务保持连接的打开状态，或者将打开状态保持到连接空闲后2分钟。 Connection属于逐跳首部，只适用于单条传输链路。 现在HTTP/1.1不再需要此属性，默认开启持久连接的。 HTTP/1.1 持久连接HTTP/1.1逐渐停止了对keep-alive连接的支持，用一种名为持久连接(persistentconnection)的改进型设计取代了它。 必须显示指定Connection: close才会指定TCP连接在响应后立即关闭。当客户端发送了Connection: close请求首部之后，客户端就无法在那条连接上发送更多请求了。只有当连接上所有的报文都有正确的、自定义报文长度时，连接才能持久保持。 管道化连接通过共享的TCP连接发起并发的HTTP请求 HTTP/1.1 允许在持久连接上可选的使用请求管道。在响应到达之前，可以将多条请求放入队列，降低网络回环时间。 注：HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST），因为出错时，无法安全的重试POST这样的非幂请求。 复用的连接交替传送请求和相应报文（实验阶段） HTTP1.1 的特点持久连接每个TCP连接开始都有三次握手，要经历一次客户端与服务器间完整的往返，而开启了持久连接就不需要每次都要握手在连接中有这个属性的就是打开了持久化连接。下图展示了通过持久 TCP 连接取得 HTML 和 CSS 文件： HTTP2.0 的特点HTTP 长连接与短连接HTTP 是无状态的也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话.http1.0中默认是关闭的，需要在http头加入”Connection: Keep-Alive”，才能启用Keep-Alivehttp 1.1中默认启用Keep-Alive，如果加入”Connection: close”才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。下图是普通模式和长连接模式的请求对比： 开启Keep-Alive的优缺点优点： Keep-Alive模式更加高效，因为避免了连接建立和释放的开销缺点： 长时间的Tcp连接容易导致资源无效占用，浪费系统资源 当保持长连接时，如何判断一次请求已经完成？当保持长连接时，如何判断一次请求已经完成？ Content-LengthContent-Length表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。所以，当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置Content-Length来控制请求的结束。但当服务器并不知道请求结果的长度时，如一个动态的页面或者数据，Content-Length就无法解决上面的问题，这个时候就需要用到Transfer-Encoding字段。 Transfer-EncodingTransfer-Encoding是指传输编码，在上面的问题中，当服务端无法知道实体内容的长度时，就可以通过指定Transfer-Encoding: chunked来告知浏览器当前的编码是将数据分成一块一块传递的。当然, 还可以指定Transfer-Encoding: gzip, chunked表明实体内容不仅是gzip压缩的，还是分块传递的。最后，当浏览器接收到一个长度为0的chunked时， 知道当前请求内容已全部接收。 Keep-Alive timeout：Httpd守护进程，一般都提供了keep-alive timeout时间设置参数。比如nginx的keepalive_timeout，和Apache的KeepAliveTimeout。这个keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住keepalive_timeout秒后，才开始关闭这个连接。当httpd守护进程发送完一个响应后，理应马上主动关闭相应的tcp连接，设置 keepalive_timeout后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到浏览器发过来http请求，则关闭这个http连接。 Tcp的Keepalive：连接建立之后，如果客户端一直不发送数据，或者隔很长时间才发送一次数据，当连接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，连接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文（侦测包）给对方，如果对方回应了这个报文，说明对方还在线，连接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持连接。 tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。tcp keep-alive保鲜定时器，支持三个系统内核配置参数：net.ipv4.tcp_keepalive_intvl = 15net.ipv4.tcp_keepalive_probes = 5net.ipv4.tcp_keepalive_time = 1800keepalive是TCP保鲜定时器，当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）了tcp_keepalive_time后，服务器就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 tcp_keepalive_intvl后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试tcp_keepalive_probes,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。 参考文章： 浅谈Http长连接和Keep-Alive以及Tcp的Keepalive、http性能优化]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F10%2F12%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git 常用命令个人学习经历 从认识到使用git命令已有两年多的时间了，记得刚刚认识它的时候很是害怕，害怕那看不懂的命令，以至于每次提交代码都要用github客户端进行提交。当然了，那是的我对客户端也是晦涩难懂（现在也是），以至于要彻底放弃。有时每次提交代码都要把文件拉到网页上面进行提交，很是麻烦。后来跟着老师的课程渐渐地认识了git，才发现是如此的好用，慢慢的发现自己已经离不开它了。虽然以前已经整理过一些关于git的命令，但却凌乱不堪，以至于自己常常自惭形秽。今天我根据阮一峰老师的博客对自己的这篇文章进行重构，让自己的博客文章慢慢的有自己的思想和见解。 –2019-3-8 GIT命令1.新建代码库12345678910# 在当前目录新建一个Git代码库git init# 新建一个目录，将其初始化为Git代码库git init [project-name]# 下载一个项目和它的整个代码历史git clone [url]# 例： git clone git@github.com:aLittleLittleStar/Travel.git 2.配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置git config --list# 编辑Git配置文件git config -e [--global]# 设置提交代码时的用户信息git config [--global] user.name "[name]"git config [--global] user.email "[email address]" 3.增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 4.代码提交123456789101112131415161718192021# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -a# 提交并添加注释git commit -am "init"# 提交时显示所有diff信息git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 5.分支123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 查看本地所有分支，当前分支会被星号标示出git branch# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 可以看见每一个分支的最后一次提交git branch -v# 可以查看本地分支对应的远程分支git branch -vv# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到dev分支git checkout dev# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支git merge [branch]# 将分支dev与当前分支进行合并git merge origin/dev# 选择一个commit，合并进当前分支git cherry-pick [commit]# 给分支重命名git branch -m oldName newName# 删除分支，如果在分支中有一些未merge的提交，那么会删除分支失败git branch -d [branch-name]# 强制删除dev分支git branch -D dev# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 6.标签1234567891011121314151617181920212223242526# 列出所有taggit tag# 新建一个tag在当前commitgit tag [tag]# 新建一个tag在指定commitgit tag [tag] [commit]# 删除本地taggit tag -d [tag]# 删除远程taggit push origin :refs/tags/[tagName]# 查看tag信息git show [tag]# 提交指定taggit push [remote] [tag]# 提交所有taggit push [remote] --tags# 新建一个分支，指向某个taggit checkout -b [branch] [tag] 7.查看信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 显示有变更的文件git status# 查询repo的状态. -s表示short, -s的输出标记会有两列,# 第一列是对staging区域而言,第二列是对working目录而言.git status -s# 显示当前分支的版本历史git log# 显示commit历史，以及每次commit发生变更的文件git log --stat# 搜索提交历史，根据关键词git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]# 显示指定文件相关的每一次diffgit log -p [file]# 显示过去5次提交git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序git shortlog -sn# 显示指定文件是什么人在什么时间修改过git blame [file]# 显示暂存区和工作区的差异git diff# 显示暂存区和上一个commit的差异git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异git diff HEAD# 显示两次提交之间的差异git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码git diff --shortstat "@&#123;0 day ago&#125;"# 显示某次提交的元数据和内容变化git show [commit]# 显示某次提交发生变化的文件git show --name-only [commit]# 显示某次提交时，某个文件的内容git show [commit]:[filename]# 显示当前分支的最近几次提交git reflog 8.远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force# 推送所有分支到远程仓库git push [remote] --all 9撤销123456789101112131415161718192021222324252627282930313233343536373839# git撤销本地所有未提交的更改# 第一个命令只删除所有untracked的文件，如果文件已经被tracked,# 修改过的文件不会被回退。而第二个命令把tracked的文件revert到# 前一个版本，对于untracked的文件(比如编译的临时文件)都不会被删除。git clean -dfgit reset --hard# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop 10.其他1234567891011121314151617181920# 生成一个可供发布的压缩包git archive# 看你commit的日志git log --oneline# 查看帮助git checkout --help# 查看目录ls# 查看所有目录ls -al# 查看文件内容cat git.md# 查看git的版本信息git --version Git fetch &amp;&amp; Git pull 详解123456789101112```__git fetch__是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。__git pull__ 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。__分支的概念：__分支是用来标记特定代码的提交，每一个分支通过SHA1sum值来标识，所以对分支的操作是轻量级的，你改变的仅仅是SHA1sum值。如下图所示，当前有2个分支，A,C,E属于master分支，而A,B，D,F属于dev分支``` jsA----C----E（master） \ B---D---F(dev) 它们的head指针分别指向E和F，对上述做如下操作：12git checkout master //选择or切换到master分支git merge dev //将dev分支合并到当前分支(master)中 之后的情形是这样的：123A---C---E---G(master) \ / B---D---F（dev） 现在A，B,C,D,E,F,G属于master，G是一次合并后的结果，是将E和Ｆ的代码合并后的结果，可能会出现冲突。而A,B，D,F依然属于dev分支。可以继续在dev的分支上进行开发:123A---C---E---G---H(master) \ / B---D---F---I（dev） 理解gitfetch,关键是理解FETCH_HEAD，FETCH_HEAD指的是：某个branch在服务器上的最新状态。 git fetch 用法1git fetch &lt;远程主机名&gt; //这个命令将某个远程主机的更新全部取回本地 如果只想取回特定分支的更新，可以指定分支名：1git fetch &lt;远程主机名&gt; &lt;分支名&gt; //注意之间有空格 最常见的命令如取回origin 主机的master 分支：1git fetch origin master 取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息： 1git log -p FETCH_HEAD git pull 用法前面提到，git pull 的过程可以理解为：12git fetch origin master //从远程主机的master分支拉取最新内容 git merge FETCH_HEAD //将拉取下来的最新内容合并到当前所在的分支中 即将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为：1git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程分支是与当前分支合并，则冒号后面的部分可以省略：1git pull origin next git fetch 更新远程代码到本地仓库 理解 fetch 的关键, 是理解 FETCH_HEAD，FETCH_HEAD指的是: 某个branch在服务器上的最新状态’。 这个列表保存在 .Git/FETCH_HEAD 文件中, 其中每一行对应于远程服务器的一个分支。当前分支指向的FETCH_HEAD, 就是这个文件第一行对应的那个分支.一般来说, 存在两种情况:如果没有显式的指定远程分支, 则远程分支的master将作为默认的FETCH_HEAD.如果指定了远程分支, 就将这个远程分支作为FETCH_HEAD.git fetch origin branch1这个操作是git pull origin branch1的第一步, 而对应的pull操作,并不会在本地创建新的branch。设定当前分支的 FETCH_HEAD’ 为远程服务器的branch1分支`。 这个命令可以用来测试远程主机的远程分支branch1是否存在, 如果存在, 返回0, 如果不存在, 返回128, 抛出一个异常.git fetch origin branch1:branch2首先执行上面的fetch操作，使用远程branch1分支在本地创建branch2(但不会切换到该分支),如果本地不存在branch2分支, 则会自动创建一个新的branch2分支, 如果本地存在branch2分支, 并且是`fast forward’, 则自动合并两个分支, 否则, 会阻止以上操作.fetch更新本地仓库两种方式： 123456789101112131415//方法一$ git fetch origin master //从远程的origin仓库的master分支下载代码到本地的origin master$ git log -p master.. origin/master//比较本地的仓库和远程参考的区别$ git merge origin/master//把远程下载下来的代码合并到本地仓库，远程的和本地的合并//方法二$ git fetch origin master:temp //从远程的origin仓库的master分支下载到本地并新建一个分支temp$ git diff temp//比较master分支和temp分支的不同$ git merge temp//合并temp分支到master分支$ git branch -d temp//删除temp 1、git reset 没有push，这种情况发生在你的本地代码仓库,可能你add ,commit 以后发现代码有点问题. 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交commit_id(79f673d631b08907496ce792f429e1f00da25b73)，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard 79f673d631b08907496ce792f429e1f00da25b73。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。2、git revert已经push，对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令 git revert用一个新提交来消除一个历史提交所做的任何修改. revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题) revert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看. git revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c613、两者区别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit看似达到的效果是一样的,其实完全不同. 第一:上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突（或git push -f强制推送）.但是revert 并不会. 第二:如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里. 第三:reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的. 转载： 常用 Git 命令清单参考文章: git fetch 更新远程代码到本地仓库 Git 常用命令总结 git常用命令大全 Git常用命令解说 Git fetch &amp; pull 详解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的状态响应码]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码大类 状态码 说明 解释 1XX 响应中——表示请求已经接受，继续处理 消息：一般是告诉客户端请求已经收到了，正在处理，别急 2XX 成功——表示请求已经被成功接收、理解、接受。 处理成功：一般表示请求收悉、我明白你要的、请求已受理、已经处理完成等信息 3XX 重定向——要完成请求必须进行更进一步的操作 重定向到其它地方：它让客户端再发起一个请求以完成整个处理 4XX 客户端错误——请求有语法错误或请求无法实现 处理发生错误，责任在客户端：如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。 5XX 服务器端错误——服务器未能实现合法的请求。 处理发生错误，责任在服务端：如服务端抛出异常，路由出错，HTTP版本不支持等 HTTP响应状态码有很多，但是实际经常使用的大概只有14个。 状态码 200 OK //表示从客户端发来的请求在服务器端被正常处理了。 204 No Content该状态码表示服务器接收的请求已成功处理 ，但在返回的响应报文中不含实体的主体部分。 比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。 206 Partial Content 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。 301 Moved Permanently 永久性重定向。该状态码表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。 像下方给出的请求URI，当指定的资源路径的最后忘记添加斜杠”/“，就会产生301状态码 302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户(本次)能使用新的URI访问。 303 Other //我把你redirect到其它的页面，目标的URL通过响应报文头的Location告诉你。 See Other 该状态码表示由于请求对应的资源存在另外一个URI，应使用GET方法定向获取请求的资源。 303状态码和302状态码有着相同的功能，但303状态码明确表明客户端应当采用GET方法获取资源。 当301，302，303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文的主体，之后请求会自动再次发送。 301，302标准是禁止将POST方法改变成GET方法的，但实际上使用时大家都会这么做。 304 Not Modified // 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。 304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。 307 Temporary Redirect 临时重定向。该状态码与302 Found有着相同的含义。307会遵照浏览器标准，不会从POST变成GET 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 该状态码表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过1此请求，则表示用户认证失败。 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 500 Internal Server Error //该状态码表明服务器端在执行请求时发生了错误。 503 Server Unavailable //该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 参考文章 常见的HTTP响应状态码解析、常见的响应状态码]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡和捕获]]></title>
    <url>%2F2018%2F10%2F10%2FJavaScript%2F%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[事件冒泡 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是p -&gt; div -&gt; body -&gt; html -&gt; document 事件捕获捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)上面的例子在事件捕获的概念下发生click事件的顺序应该是document -&gt; html -&gt; body -&gt; div -&gt; p IE只支持事件冒泡，Chrome,Mozilla, Opera 7 和 Konqueror两种都支持，旧版本的Opera’s 和 iCab两种都不支持 。 捕获和冒泡过程图 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;event&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="obj1"&gt; welcome &lt;h5 id="obj2"&gt;hello&lt;/h5&gt; &lt;h5 id="obj3"&gt;world&lt;/h5&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var obj1=document.getElementById('obj1'); var obj2=document.getElementById('obj2'); obj1.addEventListener('click',function()&#123; alert('hello'); &#125;,false); obj2.addEventListener('click',function()&#123; alert('world'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 并且分别在obj1,obj2上绑定了一个点击事件，由于addEventListener的第三个参数为false,所以页面是在冒泡阶段处理绑定事件。此时整个页面可以有三种行为出现 点击文字welcome时，弹出hello。此时就只触发了绑定在obj1上的点击事件。具体冒泡实现过程如下：welcome 属于文本节点，点击后，开始从文本节点查找，当前文本节点没有绑定点击事件，继续向上找，找到父级（id为obj1的div），有绑定的点击事件，执行，再向上找，body，没有绑定点击事件，再到html,document,都没再有绑定的点击事件，好，整个冒泡过程结束。 点击文字hello时，先弹出world，再弹出hello 点击world时，弹出hello。 addEventListener的第三个参数1lement.addEventListener(event, function, useCapture) 第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。 我们想要在点击每个h5标签时，弹出对应的innerHTML 。常规做法是遍历每个h5,然后在每个h5上绑定一个点击事件，这种做法在h5较少的时候可以使用，但如果有一万个h5，那就会导致性能降低。这时就需要事件代理出场了。 事件代理使用事件代理的好处不仅在于将多个事件处理函数减为一个，而且对于不同的元素可以有不同的处理方法 123456obj1.addEventListener('click',function(e)&#123; var e=e||window.event; if(e.target.nodeName.toLowerCase()=='h5')&#123; alert(e.target.innerHTML); &#125;&#125;,false); 由于事件冒泡机制，点击了h5后会冒泡到div,此时就会触发绑定在div上的点击事件，再利用target找到事件实际发生的元素，就可以达到预期的效果。 问题阻止冒泡的方法，阻止默认事件的方法(兼容IE)w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true阻止事件的传播兼容 123456789101112131415function(e)&#123; var e=e||window.event; // window.event 这是IE浏览器 e.stopPropagation();//阻止事件的传播(包括捕获也包括冒泡) // 兼容处理 if (e &amp;&amp; e.stopPropagation) &#123; //这是其他浏览器 e.stopPropagation(); //阻止冒泡事件 e.preventDefault();//阻止默认事件 &#125;else&#123; // IE浏览器 e.cancelBubble=true; //阻止冒泡事件 e.returnValue=false;//阻止默认事件 &#125;&#125; 阻止冒泡事件的兼容性处理1234567function stopBubble(e) &#123; if(e &amp;&amp; e.stopPropagation) &#123; //非IE e.stopPropagation(); &#125; else &#123; //IE window.event.cancelBubble = true; &#125; &#125; 阻止默认事件w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false; 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，会执行几次事件，会先执行冒泡还是捕获？ 首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段 参考文章 终于弄懂了事件冒泡和事件捕获浅谈事件冒泡与事件捕获]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[get和post请求]]></title>
    <url>%2F2018%2F10%2F10%2FHTTP%2Fget%E5%92%8Cpost%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[在HTTP中，与服务器交互的方法，最常用的有4种：即Put（增）、Delete（删）、Post（改）、Get（查）。get是获取数据，post是修改数据。 get 和 post 的区别get把请求的数据放在url上，即HTTP协议头上，其格式为： 以?分割URL和传输数据，参数之间以&amp;相连。 数据如果是英文字母/数字，原样发送， 如果是空格，转换为+， 如果是中文/其他字符，则直接把字符串用BASE64加密，及“%”加上“字符串的16进制ASCII码”。post把数据放在HTTP的包体内（requrest body）。 get提交的数据最大是2k（原则上url长度无限制，那么get提交的数据也没有限制咯？限制实际上取决于浏览器，(大多数)浏览器通常都会限制url长度在2K个字节，即使(大多数)服务器最多处理64K大小的url。也没有卵用。）。post理论上没有限制。实际上IIS4中最大量为80KB，IIS5中为100KB。 GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 GET在浏览器回退时是无害的，POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET只接受ASCII字符的参数的数据类型，而POST没有限制 那么，post那么好为什么还用get？get效率高！。 其他 HTTP 请求方法 参考文章HTTP 方法：GET 对比 POST 、get和post的区别–面试经常被问到！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渐进增强和优雅降级]]></title>
    <url>%2F2018%2F10%2F10%2FCSS3%2F%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[渐进增强 一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。 123456.transition &#123; /*渐进增强写法*/ -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s;&#125; 优雅降级 一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。 123456.transition &#123; /*优雅降级写法*/ transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; 渐进增强和优雅降级的区别 渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的 常见问题 渐进增强和优雅降级如何抉择 如果你采用渐进增强的开发流程，先做一个基本功能版，然后针对各个浏览器进行渐进增加，增加各种功能。相对于优雅降级来说，开发周期长，初期投入资金大。 那采用优雅降级呢，这样可以在较短时间内开发出一个只用于一个浏览器的完整功能版，然后就可以拿给PM找客户谈呀，可以拿去测试，市场试水呀，对于功能尚未确定的 产品，优雅降级不失为一种节约成本的方法。 采用优雅降级的写法，如果一个浏览器同时支持前缀写法和正常写法，后面的旧版浏览器样式就覆盖了新版样式，出现一些奇怪的问题 ，但是用渐进增强的写法就不存在这个问题。这种属性不止border-radius一个，所以为了避免这个不必要的错误，建议大家都采用渐进增强的写法。 绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。 参考文章 渐进增强和优雅降级之间有什么不同?]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css模块化]]></title>
    <url>%2F2018%2F10%2F10%2FCSS3%2Fcss%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[未完成ing… 设计原则 可复用能继承要完整 周期性迭代 优秀的代码是模仿/设计/重构出来的 设计方法 先整体后部分再颗粒化 布局-&gt; 页面 -&gt; 功能-&gt;业务 先抽象再具体 css模块化设计 reset.scss：浏览器不同，对默认的标签有默认的样式，为了表现统一化，要加一个这个。layout.scss:布局抽象成这个element.scss:列表、按钮 global的方式引用，比如说直接把某个模块引用进来，然后就可以写具体的样式了。scope就是用的module方法。比如说两个组件都叫做.btn，这样在之前会导致两个样式的名称一致，会被覆盖，如果想用相同的名称，样式不一样，就要用css module这样就不一致，因为编译出来的class带了一串编码。 优点： 提高代码重用率 提高开发效率、减少沟通成本 降低耦合 降低发布风险 减少Bug定位时间和Fix成本 提高页面容错 更好的实现快速迭代 更好的支持灰度发布 参考: CSS模块化如何实现？]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动]]></title>
    <url>%2F2018%2F10%2F10%2FCSS3%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[转载：CSS-清除浮动 为什么要清除浮动 浮动的元素是脱离文档标准流的，如果我们不清楚浮动，那么就会造成父元素高度塌陷，影响页面布局。 清除浮动的方法使用带clear属性的空元素 div、hr、br都可以123456789# html&lt;div class="clear"&gt;&lt;/div&gt;&lt;br class="clear" /&gt;&lt;hr class="clear" /&gt;#css.clear &#123; clear: both;&#125; 优点：通俗易懂，容易掌握 缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。 使用CSS的overflow属性给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发hasLayout，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。 12345678910111213141516171819.news &#123; background-color: gray; border: solid 1px black; overflow: hidden; *zoom: 1; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;&lt;div class="news"&gt;&lt;img src="news-pic.jpg" /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 优点：不存在结构和语义化问题，代码量极少 缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；04年POPO就发现overflow:hidden会导致中键失效，这是我作为一个多标签浏览控所不能接受的。所以还是不要使用. 父元素也设置浮动(给浮动的元素的容器添加浮动)优点：不存在结构和语义化问题，代码量极少缺点：给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。 使用邻接元素处理什么都不做，给浮动元素后面的元素添加clear属性。12345678910111213141516171819202122.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.content&#123; clear:both; &#125;&lt;div class="news"&gt;&lt;img src="news-pic.jpg" /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;div class="content"&gt;***&lt;/div&gt;&lt;/div&gt; 使用:after 伪元素结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。 123456789101112131415161718192021222324252627282930.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;# 清除浮动.clearfix:after&#123; content: " "; display: block; height: 0; clear: both; visibility: hidden; &#125;.clearfix &#123; /* 触发 hasLayout */ zoom: 1; &#125;&lt;div class="news clearfix"&gt;&lt;img src="news-pic.jpg" /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 清除浮动：清除对应的单词是 clear，对应CSS中的属性是 clear：left | right | both | none；闭合浮动：更确切的含义是使浮动元素闭合，从而减少浮动带来的影响。其中涉及的原理有：hasLayout 和 Block formatting contexts 。 通过上面的例子，我们不难发现清除浮动的方法可以分成两类： 一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。 二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。 在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。 最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语义化标签]]></title>
    <url>%2F2018%2F10%2F10%2FH5%2F%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[H5中关于语义化的标签有哪些，语义化标签有什么作用？为什么要使用语义化标签? H5中关于语义化的标签有哪些title 简短、描述性、唯一（提升搜索引擎排名）header 页眉通常包括网站标志、主导航、全站链接以及搜索框。section 具有相似主题的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。 footer 页脚，只有当父级是body时，才是整个页面的页脚。article 包含像报纸一样的内容= =||是这么理解的，表示文档、页面、应用或一个独立的容器ahgroup 标签用于对网页或区段（section）的标题进行组合nav 标记导航，仅对文档中重要的链接群使用。aside 指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。address 作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）mark 突出显示文本（yellow），提醒读者。time 标记时间。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式figure 创建图（默认有40px左右margin）figcaption figure的标题，必须是figure内嵌的第一个或者最后一个元素。datailstdetailssummarydialogddprogress 完成进度。可通过js动态更新valuekeygensmall 指定细则，输入免责声明、注解、署名、版权。 语义化标签有什么作用？为什么要使用语义化标签？在HTML5出现之前，我们一般采用div+css布局我们的页面。但是这样的布局方式不仅使我们的文档结构不够清晰，而且不利于搜索引擎爬虫对我们页面的爬取。为了解决上述缺点，HTML5新增了很多新的语义化标签。 引入语义化标签的好处主要有 比div标签有更加丰富的含义，方便开发与维护 搜索引擎能更方便的识别页面的每个部分 方便其他设备解析（如移动设备、盲人阅读器等） H5新增的语义化标签 headerfooterarticleaside 定义页面的侧边栏内容timedetails 用于描述文档或者文档某一部分细节，summary是details元素的标题ruby 加注释，ruby标签有两个子元素，rt注释的内容，rp是该标签不显示时显示的文字mark 定义带有几号的文本，它会给你想要突出显示的文本加个 背景色navprogresssectionvideo 定义视频，属性src引入资源，controls视频的控制控件audio 该标签可定义声音，及其他的音频文件，不加controls不显示音频的控制界面datalist 提示可能的值，datalist及其选项不会被显示出来，它仅仅是合法输入值的列表使用input元素的list属性来邦定datalistembed 定义插入的内容，如插件，flash，标签中间不要加内容会显现出来canvas canvas画布只是个容器，你可以通过控制坐标在canvas上绘制图形，一般配合js可以实现非常复杂的动画效果]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bind、apply和call的区别]]></title>
    <url>%2F2018%2F10%2F10%2FJavaScript%2Fbind%E5%92%8Ccall%2F</url>
    <content type="text"><![CDATA[ing…bind和call的作用都是将某个函数的this指向绑定到另外一个作用域中，他们的参数调用都是相同的，第一个参数为绑定的作用域对象是什么，接下来就是可以添加不限的参数，而区别就是call在绑定的同时调用函数，bind是返回一个改变this指向的函数。apply方法和call方法有些相似，它也可以改变this的指向同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域的方法]]></title>
    <url>%2F2018%2F10%2F10%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookit和session]]></title>
    <url>%2F2018%2F10%2F10%2FJavaScript%2Fcookit%E5%92%8Csession%2F</url>
    <content type="text"><![CDATA[cookie cookie机制采用的是在客户端保持状态的方案Cookie的主要内容包括：名字，值，过期时间，路径和域。使用Fiddler抓包就可以看见. session session机制采用的是在服务器端保持状态的方案存在服务器的一种用来存放用户数据的类HashTable结构。浏览器第一次发送请求时，服务器自动生成了一HashTable和一SessionID来唯一标识这个HashTable，并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应的 Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的HashTable。 cookie 和 session 的区别 cookie数据存放在客户的浏览器上，session数据放在服务器上。 session 中保存的是对象，cookie 中保存的是字符串。 session 不能区分路径，同一个用户在访问一个网站期间，所有的session在任何地方都可以访问到。而 cookie 中如果设置了路径参数，那么同一个网站不同路径下的 cookie 互相是不可以访问的。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 cookie 和 webStorage 的区别 webStorage 的优势 从容量上讲WebStorage一般浏览器提供5M的存储空间。 安全性上WebStorage 并不作为 HTTP header 发送的浏览器，所以相对安全。 从流量上讲，因为WebStorage不传送到服务器，所以不必要的流量可以节省。 Cookie和webstorage区别 数据的有效期不同 Webstorage:1.localstorage 2.sessionstorage sessionStorage：仅在当前的浏览器窗口关闭有效； localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据,除非手动删除； cookie：只在设置的cookie过期时间之前一直有效，即使窗口和浏览器关闭 作用域不同 sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面； localStorage：在所有同源窗口都是共享的； cookie：也是在所有同源窗口中共享的 webStorage支持事件通知机制，可以将数据更新的通知发生给监听者 如果 cookie 被篡改了怎么办？ 预防 Cookie 被篡改set-cookie时加上防篡改验证码。 参考文章 cookie和session, cookie和webStorage的区别]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>cookit session 面试题</tag>
      </tags>
  </entry>
</search>
