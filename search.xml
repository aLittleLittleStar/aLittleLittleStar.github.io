<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用的状态响应码]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码大类 状态码 说明 解释 1XX 响应中——表示请求已经接受，继续处理 消息：一般是告诉客户端请求已经收到了，正在处理，别急 2XX 成功——表示请求已经被成功接收、理解、接受。 处理成功：一般表示请求收悉、我明白你要的、请求已受理、已经处理完成等信息 3XX 重定向——要完成请求必须进行更进一步的操作 重定向到其它地方：它让客户端再发起一个请求以完成整个处理 4XX 客户端错误——请求有语法错误或请求无法实现 处理发生错误，责任在客户端：如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。 5XX 服务器端错误——服务器未能实现合法的请求。 处理发生错误，责任在服务端：如服务端抛出异常，路由出错，HTTP版本不支持等 HTTP响应状态码有很多，但是实际经常使用的大概只有14个。 状态码 200 OK //表示从客户端发来的请求在服务器端被正常处理了。 204 No Content该状态码表示服务器接收的请求已成功处理 ，但在返回的响应报文中不含实体的主体部分。 比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。 206 Partial Content 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。 301 Moved Permanently 永久性重定向。该状态码表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。 像下方给出的请求URI，当指定的资源路径的最后忘记添加斜杠”/“，就会产生301状态码 302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户(本次)能使用新的URI访问。 303 Other //我把你redirect到其它的页面，目标的URL通过响应报文头的Location告诉你。 See Other 该状态码表示由于请求对应的资源存在另外一个URI，应使用GET方法定向获取请求的资源。 303状态码和302状态码有着相同的功能，但303状态码明确表明客户端应当采用GET方法获取资源。 当301，302，303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文的主体，之后请求会自动再次发送。 301，302标准是禁止将POST方法改变成GET方法的，但实际上使用时大家都会这么做。 304 Not Modified // 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。 304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。 307 Temporary Redirect 临时重定向。该状态码与302 Found有着相同的含义。307会遵照浏览器标准，不会从POST变成GET 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 该状态码表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过1此请求，则表示用户认证失败。 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 500 Internal Server Error //该状态码表明服务器端在执行请求时发生了错误。 503 Server Unavailable //该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 参考文章 常见的HTTP响应状态码解析、常见的响应状态码]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡和捕获]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。123&lt;div id="outer"&gt; &lt;p id="inner"&gt;Click me!&lt;/p&gt;&lt;/div&gt; 上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？ 事件冒泡 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是p -&gt; div -&gt; body -&gt; html -&gt; document 事件捕获捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)上面的例子在事件捕获的概念下发生click事件的顺序应该是document -&gt; html -&gt; body -&gt; div -&gt; p IE只支持事件冒泡，Chrome,Mozilla, Opera 7 和 Konqueror两种都支持，旧版本的Opera’s 和 iCab两种都不支持 。 捕获和冒泡过程图 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;event&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="obj1"&gt; welcome &lt;h5 id="obj2"&gt;hello&lt;/h5&gt; &lt;h5 id="obj3"&gt;world&lt;/h5&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var obj1=document.getElementById('obj1'); var obj2=document.getElementById('obj2'); obj1.addEventListener('click',function()&#123; alert('hello'); &#125;,false); obj2.addEventListener('click',function()&#123; alert('world'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 并且分别在obj1,obj2上绑定了一个点击事件，由于addEventListener的第三个参数为false,所以页面是在冒泡阶段处理绑定事件。此时整个页面可以有三种行为出现 点击文字welcome时，弹出hello。此时就只触发了绑定在obj1上的点击事件。具体冒泡实现过程如下：welcome 属于文本节点，点击后，开始从文本节点查找，当前文本节点没有绑定点击事件，继续向上找，找到父级（id为obj1的div），有绑定的点击事件，执行，再向上找，body，没有绑定点击事件，再到html,document,都没再有绑定的点击事件，好，整个冒泡过程结束。 点击文字hello时，先弹出world，再弹出hello 点击world时，弹出hello。 addEventListener的第三个参数1lement.addEventListener(event, function, useCapture) 第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。 我们想要在点击每个h5标签时，弹出对应的innerHTML 。常规做法是遍历每个h5,然后在每个h5上绑定一个点击事件，这种做法在h5较少的时候可以使用，但如果有一万个h5，那就会导致性能降低。这时就需要事件代理出场了。 事件代理使用事件代理的好处不仅在于将多个事件处理函数减为一个，而且对于不同的元素可以有不同的处理方法 123456obj1.addEventListener('click',function(e)&#123; var e=e||window.event; if(e.target.nodeName.toLowerCase()=='h5')&#123; alert(e.target.innerHTML); &#125;&#125;,false); 由于事件冒泡机制，点击了h5后会冒泡到div,此时就会触发绑定在div上的点击事件，再利用target找到事件实际发生的元素，就可以达到预期的效果。 问题阻止冒泡的方法，阻止默认事件的方法(兼容IE)阻止事件的传播兼容 12345678910111213function(e)&#123; var e=e||window.event; e.stopPropagation();//阻止事件的传播(包括捕获也包括冒泡) // 兼容处理 if (e.stopPropagation) &#123; e.stopPropagation(); &#125;else&#123; // IE浏览器 e.cancelBubble=true; &#125;&#125; 阻止冒泡事件的兼容性处理1234567function stopBubble(e) &#123; if(e &amp;&amp; e.stopPropagation) &#123; //非IE e.stopPropagation(); &#125; else &#123; //IE window.event.cancelBubble = true; &#125; &#125; 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，会执行几次事件，会先执行冒泡还是捕获？ 首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段 参考文章 终于弄懂了事件冒泡和事件捕获、浅谈事件冒泡与事件捕获]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[get和post请求]]></title>
    <url>%2F2018%2F10%2F10%2Fget%E5%92%8Cpost%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[在HTTP中，与服务器交互的方法，最常用的有4种：即Put（增）、Delete（删）、Post（改）、Get（查）。get是获取数据，post是修改数据。 get 和 post 的区别get把请求的数据放在url上，即HTTP协议头上，其格式为： 以?分割URL和传输数据，参数之间以&amp;相连。 数据如果是英文字母/数字，原样发送， 如果是空格，转换为+， 如果是中文/其他字符，则直接把字符串用BASE64加密，及“%”加上“字符串的16进制ASCII码”。post把数据放在HTTP的包体内（requrest body）。 get提交的数据最大是2k（原则上url长度无限制，那么get提交的数据也没有限制咯？限制实际上取决于浏览器，(大多数)浏览器通常都会限制url长度在2K个字节，即使(大多数)服务器最多处理64K大小的url。也没有卵用。）。post理论上没有限制。实际上IIS4中最大量为80KB，IIS5中为100KB。 GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 GET在浏览器回退时是无害的，POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET只接受ASCII字符的参数的数据类型，而POST没有限制 那么，post那么好为什么还用get？get效率高！。 其他 HTTP 请求方法 参考文章 HTTP 方法：GET 对比 POST 、get和post的区别–面试经常被问到！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渐进增强和优雅降级]]></title>
    <url>%2F2018%2F10%2F10%2F%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[渐进增强 一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。 123456.transition &#123; /*渐进增强写法*/ -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s;&#125; 优雅降级 一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。 123456.transition &#123; /*优雅降级写法*/ transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; 渐进增强和优雅降级的区别 渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的 常见问题 渐进增强和优雅降级如何抉择 如果你采用渐进增强的开发流程，先做一个基本功能版，然后针对各个浏览器进行渐进增加，增加各种功能。相对于优雅降级来说，开发周期长，初期投入资金大。 那采用优雅降级呢，这样可以在较短时间内开发出一个只用于一个浏览器的完整功能版，然后就可以拿给PM找客户谈呀，可以拿去测试，市场试水呀，对于功能尚未确定的 产品，优雅降级不失为一种节约成本的方法。 采用优雅降级的写法，如果一个浏览器同时支持前缀写法和正常写法，后面的旧版浏览器样式就覆盖了新版样式，出现一些奇怪的问题 ，但是用渐进增强的写法就不存在这个问题。这种属性不止border-radius一个，所以为了避免这个不必要的错误，建议大家都采用渐进增强的写法。 绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。 参考文章 渐进增强和优雅降级之间有什么不同?]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域的方法]]></title>
    <url>%2F2018%2F10%2F10%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookit和session]]></title>
    <url>%2F2018%2F10%2F10%2Fcookit%E5%92%8Csession%2F</url>
    <content type="text"><![CDATA[cookie cookie机制采用的是在客户端保持状态的方案Cookie的主要内容包括：名字，值，过期时间，路径和域。使用Fiddler抓包就可以看见. session session机制采用的是在服务器端保持状态的方案存在服务器的一种用来存放用户数据的类HashTable结构。浏览器第一次发送请求时，服务器自动生成了一HashTable和一SessionID来唯一标识这个HashTable，并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应的 Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的HashTable。 cookie 和 session 的区别 cookie数据存放在客户的浏览器上，session数据放在服务器上。 session 中保存的是对象，cookie 中保存的是字符串。 session 不能区分路径，同一个用户在访问一个网站期间，所有的session在任何地方都可以访问到。而 cookie 中如果设置了路径参数，那么同一个网站不同路径下的 cookie 互相是不可以访问的。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 cookie 和 webStorage 的区别 webStorage 的优势 从容量上讲WebStorage一般浏览器提供5M的存储空间。 安全性上WebStorage 并不作为 HTTP header 发送的浏览器，所以相对安全。 从流量上讲，因为WebStorage不传送到服务器，所以不必要的流量可以节省。 Cookie和webstorage区别 数据的有效期不同 Webstorage:1.localstorage 2.sessionstorage sessionStorage：仅在当前的浏览器窗口关闭有效； localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据,除非手动删除； cookie：只在设置的cookie过期时间之前一直有效，即使窗口和浏览器关闭 作用域不同 sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面； localStorage：在所有同源窗口都是共享的； cookie：也是在所有同源窗口中共享的 webStorage支持事件通知机制，可以将数据更新的通知发生给监听者 如果 cookie 被篡改了怎么办？ 预防 Cookie 被篡改set-cookie时加上防篡改验证码。 参考文章 cookie和session, cookie和webStorage的区别]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>cookit session 面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F10%2F10%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[page随笔]]></title>
    <url>%2F2018%2F09%2F29%2Fpage%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[[TOC] 排序算法]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那年那个大三]]></title>
    <url>%2F2018%2F09%2F28%2F%E9%82%A3%E5%B9%B4%E9%82%A3%E4%B8%AA%E5%A4%A7%E4%B8%89%2F</url>
    <content type="text"></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>案例</tag>
      </tags>
  </entry>
</search>
