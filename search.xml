<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深浅拷贝]]></title>
    <url>%2F2018%2F10%2F16%2FJS%2F%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[转载： js 深浅拷贝 笔记总结、JS]深拷贝与浅拷贝的区别，实现深拷贝的几种方法 JS 数据类型JavaScript的数据类型有： 数值类型(number) 、 字符串类型(string) 、 布尔类型(boolean) 、 null 、undefined 、对象(数组、正则表达式、日期、函数)大致分为两种： 基本数据类型 和 引用数据类型基本数据类型： 数字类型(number)、字符串类型(string)、布尔类型(boolean)、null、undefined引用数据类型： 常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等 深浅拷贝区别如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。 浅拷贝浅拷贝只是拷贝基本类型的数据，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，因此存在父对象被篡改的可能，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存 深拷贝深拷贝就是能够实现真正意义上的数组和对象的拷贝。递归调用”浅拷贝”。（深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象） 浅拷贝例子：12345let a=[0,1,2,3,4], b=a;console.log(a===b);a[0]=1;console.log(a,b); 运行结果：嗯？明明b复制了a，为啥修改数组a，数组b也跟着变了，这里我不禁陷入了沉思。那么这里，就得引入基本数据类型与引用数据类型的概念了。 a.基本类型–名值存储在栈内存中，例如let a=1;当你b=a复制时，栈内存会新开辟一个内存，例如这样：所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。 b.引用数据类型–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，起步就达到深拷贝的效果了 1.我们怎么去实现深拷贝呢，这里可以递归递归去复制所有层级属性。这么我们封装一个深拷贝的函数 123456789101112131415161718192021function deepClone(obj)&#123; let objClone = Array.isArray(obj)?[]:&#123;&#125;; if(obj &amp;&amp; typeof obj==="object")&#123; for(key in obj)&#123; if(obj.hasOwnProperty(key))&#123; //判断ojb子元素是否为对象，如果是，递归复制 if(obj[key]&amp;&amp;typeof obj[key] ==="object")&#123; objClone[key] = deepClone(obj[key]); &#125;else&#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125; let a=[1,2,3,4], b=deepClone(a);a[0]=2;console.log(a,b); 运行结果:跟之前想象的一样，现在b脱离了a的控制，不再受a影响了。这里再次强调，深拷贝，是拷贝对象各个层级的属性，可以看个例子。JQ里有一个extend方法也可以拷贝对象，我们来看看1234let a=[1,2,3,4], b=a.slice();a[0]=2;console.log(a,b); 运行结果：那是不是说slice方法也是深拷贝了，毕竟b也没受a的影响，上面说了，深拷贝是会拷贝所有层级的属性，还是这个例子，我们把a改改12345let a=[0,1,[2,3],4], b=a.slice();a[0]=1;a[2][0]=1;console.log(a,b); 拷贝的不彻底啊，b对象的一级属性确实不受影响了，但是二级属性还是没能拷贝成功，仍然脱离不了a的控制，说明slice根本不是真正的深拷贝。这里引用知乎问答里面的一张图 第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。 同理，concat方法与slice也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。 2.除了递归，我们还可以借用JSON对象的parse和stringify 12345678910function deepClone(obj)&#123; let _obj = JSON.stringify(obj), objClone = JSON.parse(_obj); return objClone&#125; let a=[0,1,[2,3],4], b=deepClone(a);a[0]=1;a[2][0]=1;console.log(a,b); 可以看到，这下b是完全不受a的影响了。 附带说下，JSON.stringify与JSON.parse除了实现深拷贝，还能结合localStorage实现对象数组存储 3.除了上面两种方法之外，我们还可以借用JQ的extend方法。 $.extend( [deep ], target, object1 [, objectN ] ) deep表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝 target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。 object1 objectN可选。 Object类型 第一个以及第N个被合并的对象。12345let a=[0,1,[2,3],4], b=$.extend(true,[],a);a[0]=1;a[2][0]=1;console.log(a,b); 可以看到，效果与上面方法一样，只是需要依赖JQ库。 说了这么多，了解深拷贝也不仅仅是为了应付面试题，在实际开发中也是非常有用的。例如后台返回了一堆数据，你需要对这堆数据做操作，但多人开发情况下，你是没办法明确这堆数据是否有其它功能也需要使用，直接修改可能会造成隐性问题，深拷贝能帮你更安全安心的去操作数据，根据实际情况来使用深拷贝，大概就是这个意思。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-思维]]></title>
    <url>%2F2018%2F10%2F16%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[题目： 给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值方法一：123a = a + b;b = a - b;a = a - b; 方法二：123a = a^b;b = a^b;a = a^b; 题目： 给两个杯子，一个5升，一个6升，水随便用，最后取出3升水方法： 6升装满倒入5升杯子，6升杯子里剩1升水； 6升杯子中的1升倒入5升杯子； 6升杯子装满水倒入5升杯子，6升杯子里剩2升水；把5升杯子水倒掉； 6升杯子中的2升倒入5升杯子； 6升杯子装满水倒入5升杯子，6升杯子里剩3升水，完成。 题目： 给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子方法：二分法：用天平左右各五个进行称量，10 =&gt; 5较轻的一组留下一个，继续进行分开称量，如果左右相等，则剩余的那一个为最轻的，否则剩下的两个继续进行比较5 =&gt; 1 || 5 =&gt; 2最后一次比较 2 =&gt; 1]]></content>
      <categories>
        <category>思维能力</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP和HTTPS的区别]]></title>
    <url>%2F2018%2F10%2F15%2FHTTP%2FHTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[&nbsp; &nbsp; &nbsp;超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。&nbsp; &nbsp; &nbsp;为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPHTTP的基本概念HTTP: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTP: 是超文本传输协议，信息是明文传输 HTTP的优点HTTP的缺点HTTPSHTTPS的基本概念HTTPS(Secure Hypertext Transfer Protocol)是安全超文本传输协议,HTTPS: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。https: 是具有安全性的ssl加密传输协议；HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 HTTPS的工作原理 客户端发起HTTPS请求用户在浏览器里输入一个https网址，然后连接到server的443端口。 服务端的配置采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 客户端解析证书这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 传送加密信息这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务段解密信息服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 传输加密后的信息这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 客户端解密信息客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。 HTTPS的优点 SEO方面谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 安全性 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本 HTTPS的缺点 SEO方面据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 经济方面 SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。 HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。 HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去。 HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。 HTTP和HTTPS的区别 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443； 、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全； https协议需要到ca申请证书，一般免费证书很少，需要交费。 参考文章：HTTP和HTTPS的区别、HTTP与HTTPS的区别]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http连接性能优化]]></title>
    <url>%2F2018%2F10%2F14%2FHTTP%2Fhttp%E8%BF%9E%E6%8E%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[HTTP和TCP/IP的关系HTTP—&gt;(TSL/SSL)—&gt;TCP—&gt;IPHTTP处于应用层、TCP处于传输层、IP处于网络层 HTTP将所需要传输的数据以流的形式传递给TCP程序 TCP解析数据中的IP地址和端口号，将数据流分割成数据段，并添加上TCP段首部，如TCP握手（ACK、SYNC等），源端口，目的端口、TCP校验和等 TCP程序将包装好的TCP数据段叫给IP程序，IP程序在此基础上封装进去IP分组首部，如源IP地址、目的IP地址，数据报总长度、分组ID、首部长度、首部校验和等等 最后交给数据链路层去发送这个IP分组数据段 TCP性能的考虑HTTP紧挨着TCP，所以TCP的链接性能考虑直接影响的HTTP事务的性能。 HTTP事务时延一次HTTP请求可分为 DNS查询、连接、请求、事务处理、响应、关闭连接。每一步都会产生时延。其中，相对于连接、请求所消耗的时间，事务处理的时间是很短的。 对HTTP程序员产生影响的时延 TCP握手建立链接 TCP慢启动拥塞控制 数据聚集的Nagle算法 用于捎带确认的TCP延迟确认算法 TIME_WAIT 时延和端口耗尽 HTTP连接处理Connection首部真正用途HTTP允许客户端和源服务器之间存在多个代理服务器或高速缓存服务器，进行HTTP连接通信时，可以将HTTP首部逐跳的经过这些设备。这个时候，怎么在相邻的HTTP应用程序之间的连接应用一些特殊的选项呢？— Connection首部，可以承载3种不同类型的标签，这些标签不会传播到其它连接中去。a、HTTP首部字段名，列出了只与此连接有关的选项b、任意标签，用于描述此连接的非标准选项c、值close，说明操作完成之后需关闭这条持久连接由于添加Connection首部的其它首部字段，不能随着报文转发出去。因此将逐跳首部放入Connection首部，就可以达到对首部的保护。例：1234HTTP/1.1 200 OKCache-control: max-age=3600Connection: meter,close,bill-my-credit-cardMeter: max-uses=3,max-refuses=6,dont-report 实例说明：不应该转发Meter首部，要应用假想的bill-my-credit-card选项，且本次事务后应关闭持久连接。 串行事务处理延迟如果只对HTTP事务进行简单管理，TCP的性能时延可能会叠加起来，包括多次的建立连接和断开连接。 提高HTTP连接性能的四个方法：并行连接通过多条TCP连接发起并发的HTTP请求并行连接从理论上回提高页面的加载速度，因为多个请求同时发出，时延可以重叠起来。但并行连接并不是一点更快，原因可能是：客户端带宽限制、消耗更多的内存和计算资源。现代浏览器确实使用并行连接，但会限制连接数在一个较小的值（通常是4），并且服务器可以关闭来自特定客户端的超量连接。 持久连接重用TCP连接，以消除连接及关闭的时延重用连接：HTTP/1.1(HTTP/1.0增强版)允许HTTP设备在事务处理结束后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接。 持久连接+并行连接持久的连接的管理很重要，不小心会累积出大量的空闲连接 HTTP/1.0 + Keep-alive连接Connection： Keep-alive属性出现在1996年HTTP/1.0版本中，当初也是被当做实验型持久连接。 可以用通用首部Keep-Alive属性指定由逗号分隔的选项来调节keep-alive的行为。例：12Connection：Keep-aliveKeep-Alive: max=5,timeout=120 说明：服务器还会为另外5个事务保持连接的打开状态，或者将打开状态保持到连接空闲后2分钟。 Connection属于逐跳首部，只适用于单条传输链路。 现在HTTP/1.1不再需要此属性，默认开启持久连接的。 HTTP/1.1 持久连接HTTP/1.1逐渐停止了对keep-alive连接的支持，用一种名为持久连接(persistentconnection)的改进型设计取代了它。 必须显示指定Connection: close才会指定TCP连接在响应后立即关闭。当客户端发送了Connection: close请求首部之后，客户端就无法在那条连接上发送更多请求了。只有当连接上所有的报文都有正确的、自定义报文长度时，连接才能持久保持。 管道化连接通过共享的TCP连接发起并发的HTTP请求 HTTP/1.1 允许在持久连接上可选的使用请求管道。在响应到达之前，可以将多条请求放入队列，降低网络回环时间。 注：HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST），因为出错时，无法安全的重试POST这样的非幂请求。 复用的连接交替传送请求和相应报文（实验阶段） HTTP1.1 的特点持久连接每个TCP连接开始都有三次握手，要经历一次客户端与服务器间完整的往返，而开启了持久连接就不需要每次都要握手在连接中有这个属性的就是打开了持久化连接。下图展示了通过持久 TCP 连接取得 HTML 和 CSS 文件： HTTP2.0 的特点HTTP 长连接与短连接HTTP 是无状态的也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话.http1.0中默认是关闭的，需要在http头加入”Connection: Keep-Alive”，才能启用Keep-Alivehttp 1.1中默认启用Keep-Alive，如果加入”Connection: close”才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。下图是普通模式和长连接模式的请求对比： 开启Keep-Alive的优缺点优点： Keep-Alive模式更加高效，因为避免了连接建立和释放的开销缺点： 长时间的Tcp连接容易导致资源无效占用，浪费系统资源 当保持长连接时，如何判断一次请求已经完成？当保持长连接时，如何判断一次请求已经完成？ Content-LengthContent-Length表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。所以，当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置Content-Length来控制请求的结束。但当服务器并不知道请求结果的长度时，如一个动态的页面或者数据，Content-Length就无法解决上面的问题，这个时候就需要用到Transfer-Encoding字段。 Transfer-EncodingTransfer-Encoding是指传输编码，在上面的问题中，当服务端无法知道实体内容的长度时，就可以通过指定Transfer-Encoding: chunked来告知浏览器当前的编码是将数据分成一块一块传递的。当然, 还可以指定Transfer-Encoding: gzip, chunked表明实体内容不仅是gzip压缩的，还是分块传递的。最后，当浏览器接收到一个长度为0的chunked时， 知道当前请求内容已全部接收。 Keep-Alive timeout：Httpd守护进程，一般都提供了keep-alive timeout时间设置参数。比如nginx的keepalive_timeout，和Apache的KeepAliveTimeout。这个keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住keepalive_timeout秒后，才开始关闭这个连接。当httpd守护进程发送完一个响应后，理应马上主动关闭相应的tcp连接，设置 keepalive_timeout后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到浏览器发过来http请求，则关闭这个http连接。 Tcp的Keepalive：连接建立之后，如果客户端一直不发送数据，或者隔很长时间才发送一次数据，当连接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，连接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文（侦测包）给对方，如果对方回应了这个报文，说明对方还在线，连接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持连接。 tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。tcp keep-alive保鲜定时器，支持三个系统内核配置参数：net.ipv4.tcp_keepalive_intvl = 15net.ipv4.tcp_keepalive_probes = 5net.ipv4.tcp_keepalive_time = 1800keepalive是TCP保鲜定时器，当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）了tcp_keepalive_time后，服务器就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 tcp_keepalive_intvl后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试tcp_keepalive_probes,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。 参考文章： 浅谈Http长连接和Keep-Alive以及Tcp的Keepalive、http性能优化]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F10%2F12%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git 常用命令 123456789101112131415161718192021222324252627282930313233343536ls // 查看目录ls -al //查看所有目录cat git.md //查看文件内容git --version //查看git的版本信息git clone git@github.com:aLittleLittleStar/Vue-Music-App.git //从服务器上将代码给拉下来git init //本地初始化git branch //查看本地所有分支，当前分支会被星号标示出git branch -r //查看远程所有分支git branch -a //查看所有分支git branch -v //可以看见每一个分支的最后一次提交.git branch dev //新建分支devgit branch -d (branchname) //删除一个分支, 如果在分支 //中有一些未merge的提交，那么会删除分支失败git branch -D dev //强制删除dev分支git push origin --delete &lt;BranchName&gt; //删除远程分支git branch -vv //可以查看本地分支对应的远程分支git branch -m oldName newName //给分支重命名git status //查看当前状态[组件、删除、修改了哪些]git status -s // 查询repo的状态. -s表示short, // -s的输出标记会有两列,第一列是 // 对staging区域而言,第二列是对working目录而言.git commit //提交git commit -am "init" //提交并添加注释git checkout dev // 切换到dev分支git checkout -b dev //建立一个新的本地分支dev并切换到该分支git merge origin/dev //将分支dev与当前分支进行合并git checkout dev //切换到本地dev分支git log --online //看你commit的日志git checkout --help // 查看帮助 Git fetch &amp;&amp; Git pull 详解git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。分支的概念：分支是用来标记特定代码的提交，每一个分支通过SHA1sum值来标识，所以对分支的操作是轻量级的，你改变的仅仅是SHA1sum值。 如下图所示，当前有2个分支，A,C,E属于master分支，而A,B，D,F属于dev分支123A----C----E（master） \ B---D---F(dev) 它们的head指针分别指向E和F，对上述做如下操作：12git checkout master //选择or切换到master分支git merge dev //将dev分支合并到当前分支(master)中 之后的情形是这样的：123A---C---E---G(master) \ / B---D---F（dev） 现在A，B,C,D,E,F,G属于master，G是一次合并后的结果，是将E和Ｆ的代码合并后的结果，可能会出现冲突。而A,B，D,F依然属于dev分支。可以继续在dev的分支上进行开发:123A---C---E---G---H(master) \ / B---D---F---I（dev） 理解gitfetch,关键是理解FETCH_HEAD，FETCH_HEAD指的是：某个branch在服务器上的最新状态。 git fetch 用法1git fetch &lt;远程主机名&gt; //这个命令将某个远程主机的更新全部取回本地 如果只想取回特定分支的更新，可以指定分支名：1git fetch &lt;远程主机名&gt; &lt;分支名&gt; //注意之间有空格 最常见的命令如取回origin 主机的master 分支：1git fetch origin master 取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息： 1git log -p FETCH_HEAD git pull 用法前面提到，git pull 的过程可以理解为：12git fetch origin master //从远程主机的master分支拉取最新内容 git merge FETCH_HEAD //将拉取下来的最新内容合并到当前所在的分支中 即将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为：1git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程分支是与当前分支合并，则冒号后面的部分可以省略：1git pull origin next 参考文章: Git 常用命令总结、git常用命令大全、Git fetch &amp; pull 详解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的状态响应码]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码大类 状态码 说明 解释 1XX 响应中——表示请求已经接受，继续处理 消息：一般是告诉客户端请求已经收到了，正在处理，别急 2XX 成功——表示请求已经被成功接收、理解、接受。 处理成功：一般表示请求收悉、我明白你要的、请求已受理、已经处理完成等信息 3XX 重定向——要完成请求必须进行更进一步的操作 重定向到其它地方：它让客户端再发起一个请求以完成整个处理 4XX 客户端错误——请求有语法错误或请求无法实现 处理发生错误，责任在客户端：如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。 5XX 服务器端错误——服务器未能实现合法的请求。 处理发生错误，责任在服务端：如服务端抛出异常，路由出错，HTTP版本不支持等 HTTP响应状态码有很多，但是实际经常使用的大概只有14个。 状态码 200 OK //表示从客户端发来的请求在服务器端被正常处理了。 204 No Content该状态码表示服务器接收的请求已成功处理 ，但在返回的响应报文中不含实体的主体部分。 比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。 206 Partial Content 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。 301 Moved Permanently 永久性重定向。该状态码表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。 像下方给出的请求URI，当指定的资源路径的最后忘记添加斜杠”/“，就会产生301状态码 302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户(本次)能使用新的URI访问。 303 Other //我把你redirect到其它的页面，目标的URL通过响应报文头的Location告诉你。 See Other 该状态码表示由于请求对应的资源存在另外一个URI，应使用GET方法定向获取请求的资源。 303状态码和302状态码有着相同的功能，但303状态码明确表明客户端应当采用GET方法获取资源。 当301，302，303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文的主体，之后请求会自动再次发送。 301，302标准是禁止将POST方法改变成GET方法的，但实际上使用时大家都会这么做。 304 Not Modified // 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。 304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。 307 Temporary Redirect 临时重定向。该状态码与302 Found有着相同的含义。307会遵照浏览器标准，不会从POST变成GET 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 该状态码表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过1此请求，则表示用户认证失败。 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 500 Internal Server Error //该状态码表明服务器端在执行请求时发生了错误。 503 Server Unavailable //该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 参考文章 常见的HTTP响应状态码解析、常见的响应状态码]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡和捕获]]></title>
    <url>%2F2018%2F10%2F10%2FJS%2F%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[事件冒泡 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是p -&gt; div -&gt; body -&gt; html -&gt; document 事件捕获捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)上面的例子在事件捕获的概念下发生click事件的顺序应该是document -&gt; html -&gt; body -&gt; div -&gt; p IE只支持事件冒泡，Chrome,Mozilla, Opera 7 和 Konqueror两种都支持，旧版本的Opera’s 和 iCab两种都不支持 。 捕获和冒泡过程图 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;event&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="obj1"&gt; welcome &lt;h5 id="obj2"&gt;hello&lt;/h5&gt; &lt;h5 id="obj3"&gt;world&lt;/h5&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var obj1=document.getElementById('obj1'); var obj2=document.getElementById('obj2'); obj1.addEventListener('click',function()&#123; alert('hello'); &#125;,false); obj2.addEventListener('click',function()&#123; alert('world'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 并且分别在obj1,obj2上绑定了一个点击事件，由于addEventListener的第三个参数为false,所以页面是在冒泡阶段处理绑定事件。此时整个页面可以有三种行为出现 点击文字welcome时，弹出hello。此时就只触发了绑定在obj1上的点击事件。具体冒泡实现过程如下：welcome 属于文本节点，点击后，开始从文本节点查找，当前文本节点没有绑定点击事件，继续向上找，找到父级（id为obj1的div），有绑定的点击事件，执行，再向上找，body，没有绑定点击事件，再到html,document,都没再有绑定的点击事件，好，整个冒泡过程结束。 点击文字hello时，先弹出world，再弹出hello 点击world时，弹出hello。 addEventListener的第三个参数1lement.addEventListener(event, function, useCapture) 第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。 我们想要在点击每个h5标签时，弹出对应的innerHTML 。常规做法是遍历每个h5,然后在每个h5上绑定一个点击事件，这种做法在h5较少的时候可以使用，但如果有一万个h5，那就会导致性能降低。这时就需要事件代理出场了。 事件代理使用事件代理的好处不仅在于将多个事件处理函数减为一个，而且对于不同的元素可以有不同的处理方法 123456obj1.addEventListener('click',function(e)&#123; var e=e||window.event; if(e.target.nodeName.toLowerCase()=='h5')&#123; alert(e.target.innerHTML); &#125;&#125;,false); 由于事件冒泡机制，点击了h5后会冒泡到div,此时就会触发绑定在div上的点击事件，再利用target找到事件实际发生的元素，就可以达到预期的效果。 问题阻止冒泡的方法，阻止默认事件的方法(兼容IE)w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true阻止事件的传播兼容 123456789101112131415function(e)&#123; var e=e||window.event; // window.event 这是IE浏览器 e.stopPropagation();//阻止事件的传播(包括捕获也包括冒泡) // 兼容处理 if (e &amp;&amp; e.stopPropagation) &#123; //这是其他浏览器 e.stopPropagation(); //阻止冒泡事件 e.preventDefault();//阻止默认事件 &#125;else&#123; // IE浏览器 e.cancelBubble=true; //阻止冒泡事件 e.returnValue=false;//阻止默认事件 &#125;&#125; 阻止冒泡事件的兼容性处理1234567function stopBubble(e) &#123; if(e &amp;&amp; e.stopPropagation) &#123; //非IE e.stopPropagation(); &#125; else &#123; //IE window.event.cancelBubble = true; &#125; &#125; 阻止默认事件w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false; 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，会执行几次事件，会先执行冒泡还是捕获？ 首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段 参考文章 终于弄懂了事件冒泡和事件捕获浅谈事件冒泡与事件捕获]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[get和post请求]]></title>
    <url>%2F2018%2F10%2F10%2FHTTP%2Fget%E5%92%8Cpost%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[在HTTP中，与服务器交互的方法，最常用的有4种：即Put（增）、Delete（删）、Post（改）、Get（查）。get是获取数据，post是修改数据。 get 和 post 的区别get把请求的数据放在url上，即HTTP协议头上，其格式为： 以?分割URL和传输数据，参数之间以&amp;相连。 数据如果是英文字母/数字，原样发送， 如果是空格，转换为+， 如果是中文/其他字符，则直接把字符串用BASE64加密，及“%”加上“字符串的16进制ASCII码”。post把数据放在HTTP的包体内（requrest body）。 get提交的数据最大是2k（原则上url长度无限制，那么get提交的数据也没有限制咯？限制实际上取决于浏览器，(大多数)浏览器通常都会限制url长度在2K个字节，即使(大多数)服务器最多处理64K大小的url。也没有卵用。）。post理论上没有限制。实际上IIS4中最大量为80KB，IIS5中为100KB。 GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 GET在浏览器回退时是无害的，POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET只接受ASCII字符的参数的数据类型，而POST没有限制 那么，post那么好为什么还用get？get效率高！。 其他 HTTP 请求方法 参考文章 HTTP 方法：GET 对比 POST 、get和post的区别–面试经常被问到！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渐进增强和优雅降级]]></title>
    <url>%2F2018%2F10%2F10%2FCSS3%2F%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[渐进增强 一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。 123456.transition &#123; /*渐进增强写法*/ -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s;&#125; 优雅降级 一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。 123456.transition &#123; /*优雅降级写法*/ transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; 渐进增强和优雅降级的区别 渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的 常见问题 渐进增强和优雅降级如何抉择 如果你采用渐进增强的开发流程，先做一个基本功能版，然后针对各个浏览器进行渐进增加，增加各种功能。相对于优雅降级来说，开发周期长，初期投入资金大。 那采用优雅降级呢，这样可以在较短时间内开发出一个只用于一个浏览器的完整功能版，然后就可以拿给PM找客户谈呀，可以拿去测试，市场试水呀，对于功能尚未确定的 产品，优雅降级不失为一种节约成本的方法。 采用优雅降级的写法，如果一个浏览器同时支持前缀写法和正常写法，后面的旧版浏览器样式就覆盖了新版样式，出现一些奇怪的问题 ，但是用渐进增强的写法就不存在这个问题。这种属性不止border-radius一个，所以为了避免这个不必要的错误，建议大家都采用渐进增强的写法。 绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。 参考文章 渐进增强和优雅降级之间有什么不同?]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动]]></title>
    <url>%2F2018%2F10%2F10%2FCSS3%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[转载：CSS-清除浮动 清除浮动的方法 使用带clear属性的空元素 div、hr、br都可以123&lt;div class="clear"&gt;&lt;/div&gt;&lt;br class="clear" /&gt;&lt;hr class="clear" /&gt; 123.clear &#123; clear: both;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859优点：通俗易懂，容易掌握缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。2. 使用CSS的overflow属性给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发hasLayout，例如为父元素设置容器宽高或设置 zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。``` css.news &#123; background-color: gray; border: solid 1px black; overflow: hidden; *zoom: 1; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;``` 优点：不存在结构和语义化问题，代码量极少缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；04年POPO就发现overflow:hidden会导致中键失效，这是我作为一个多标签浏览控所不能接受的。所以还是不要使用.3. 父元素也设置浮动(给浮动的元素的容器添加浮动)优点：不存在结构和语义化问题，代码量极少缺点：给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。4. 使用邻接元素处理什么都不做，给浮动元素后面的元素添加clear属性。``` css.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.content&#123; clear:both; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;div class=&quot;content&quot;&gt;***&lt;/div&gt;&lt;/div&gt; 使用:after 伪元素结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。 123456789101112131415161718192021222324252627282930.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.clearfix:after&#123; content: "020"; display: block; height: 0; clear: both; visibility: hidden; &#125;.clearfix &#123; /* 触发 hasLayout */ zoom: 1; &#125;&lt;div class="news clearfix"&gt;&lt;img src="news-pic.jpg" /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 清除浮动：清除对应的单词是 clear，对应CSS中的属性是 clear：left | right | both | none；闭合浮动：更确切的含义是使浮动元素闭合，从而减少浮动带来的影响。其中涉及的原理有：hasLayout 和 Block formatting contexts 。 通过上面的例子，我们不难发现清除浮动的方法可以分成两类： 一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。 二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。 在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。 最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域的方法]]></title>
    <url>%2F2018%2F10%2F10%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookit和session]]></title>
    <url>%2F2018%2F10%2F10%2FJS%2Fcookit%E5%92%8Csession%2F</url>
    <content type="text"><![CDATA[cookie cookie机制采用的是在客户端保持状态的方案Cookie的主要内容包括：名字，值，过期时间，路径和域。使用Fiddler抓包就可以看见. session session机制采用的是在服务器端保持状态的方案存在服务器的一种用来存放用户数据的类HashTable结构。浏览器第一次发送请求时，服务器自动生成了一HashTable和一SessionID来唯一标识这个HashTable，并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应的 Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的HashTable。 cookie 和 session 的区别 cookie数据存放在客户的浏览器上，session数据放在服务器上。 session 中保存的是对象，cookie 中保存的是字符串。 session 不能区分路径，同一个用户在访问一个网站期间，所有的session在任何地方都可以访问到。而 cookie 中如果设置了路径参数，那么同一个网站不同路径下的 cookie 互相是不可以访问的。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 cookie 和 webStorage 的区别 webStorage 的优势 从容量上讲WebStorage一般浏览器提供5M的存储空间。 安全性上WebStorage 并不作为 HTTP header 发送的浏览器，所以相对安全。 从流量上讲，因为WebStorage不传送到服务器，所以不必要的流量可以节省。 Cookie和webstorage区别 数据的有效期不同 Webstorage:1.localstorage 2.sessionstorage sessionStorage：仅在当前的浏览器窗口关闭有效； localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据,除非手动删除； cookie：只在设置的cookie过期时间之前一直有效，即使窗口和浏览器关闭 作用域不同 sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面； localStorage：在所有同源窗口都是共享的； cookie：也是在所有同源窗口中共享的 webStorage支持事件通知机制，可以将数据更新的通知发生给监听者 如果 cookie 被篡改了怎么办？ 预防 Cookie 被篡改set-cookie时加上防篡改验证码。 参考文章 cookie和session, cookie和webStorage的区别]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>cookit session 面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F10%2F10%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[page随笔]]></title>
    <url>%2F2018%2F09%2F29%2Fpage%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[[TOC] 排序算法]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[喂！内个大三]]></title>
    <url>%2F2018%2F09%2F28%2F%E9%82%A3%E5%B9%B4%E9%82%A3%E4%B8%AA%E5%A4%A7%E4%B8%89%2F</url>
    <content type="text"></content>
      <categories>
        <category>README</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>案例</tag>
      </tags>
  </entry>
</search>
