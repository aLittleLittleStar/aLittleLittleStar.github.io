<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>昨夜小楼又东风</title>
  
  <subtitle>纵豆蔻词工，青楼好梦，难赋深情</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-31T05:47:28.659Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LittleStar</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue中使用Axios</title>
    <link href="http://yoursite.com/2019/03/30/Ajax/Axios/"/>
    <id>http://yoursite.com/2019/03/30/Ajax/Axios/</id>
    <published>2019-03-30T13:06:58.000Z</published>
    <updated>2019-03-31T05:47:28.659Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://www.jianshu.com/p/df464b26ae58" target="_blank" rel="noopener">axios</a><br>参考：<br>　　<a href="https://github.com/axios/axios/blob/master/README.md" target="_blank" rel="noopener">axio github</a><br>　　<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">Axios中文</a></p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>安装: <code>npm install axios --save</code><br>设置全局都可以使用axios<br>设置在 main.js 中引入 axios:<br>　　<code>import axios from &#39;axios&#39;</code><br>axios 改写为 Vue 的原型属性（不推荐这样用）<br>　　<code>Vue.prototype.$http= axios</code><br>在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $http命令<br>例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">    this.<span class="variable">$http</span>(&#123;</span><br><span class="line">      method: <span class="string">'get'</span>,</span><br><span class="line">      url: <span class="string">'/user'</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        name: <span class="string">'virus'</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><h5 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过给定的ID来发送请求</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(response)&#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="keyword">function</span>(err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment"># 以上请求也可以通过这种方式来发送</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>,&#123;</span><br><span class="line">  params:&#123;</span><br><span class="line">    ID:12345</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="keyword">function</span>(response)&#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="keyword">function</span>(err)&#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>,&#123;</span><br><span class="line">  firstName:<span class="string">'Fred'</span>,</span><br><span class="line">  lastName:<span class="string">'Flintstone'</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="keyword">function</span>(res)&#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="keyword">function</span>(err)&#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="一次性并发多个请求"><a href="#一次性并发多个请求" class="headerlink" title="一次性并发多个请求"></a>一次性并发多个请求</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getUserAccount</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getUserPermissions</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line">axios.all([getUserAccount(),getUserPermissions()])</span><br><span class="line">  .<span class="keyword">then</span>(axios.spread(<span class="keyword">function</span>(acct,perms)&#123;</span><br><span class="line">    <span class="comment"># 当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果</span></span><br><span class="line">  &#125;))</span><br></pre></td></tr></table></figure><h4 id="axios的API"><a href="#axios的API" class="headerlink" title="axios的API"></a>axios的API</h4><h5 id="axios可以通过配置（config）来发送请求"><a href="#axios可以通过配置（config）来发送请求" class="headerlink" title="axios可以通过配置（config）来发送请求"></a>axios可以通过配置（config）来发送请求</h5><h6 id="axios-config"><a href="#axios-config" class="headerlink" title="axios(config)"></a>axios(config)</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送一个`POST`请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">    method:<span class="string">"POST"</span>,</span><br><span class="line">    url:<span class="string">'/user/12345'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        firstName:<span class="string">"Fred"</span>,</span><br><span class="line">        lastName:<span class="string">"Flintstone"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="axios-url-config"><a href="#axios-url-config" class="headerlink" title="axios(url[,config])"></a>axios(url[,config])</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送一个`GET`请求（默认的请求方式）</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>);</span><br></pre></td></tr></table></figure><h5 id="请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名"><a href="#请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名" class="headerlink" title="请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名"></a>请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.request(config);</span><br><span class="line">axios.get(url[,config]);</span><br><span class="line">axios.delete(url[,config]);</span><br><span class="line">axios.head(url[,config]);</span><br><span class="line">axios.post(url[,data[,config]]);</span><br><span class="line">axios.put(url[,data[,config]])</span><br><span class="line">axios.patch(url[,data[,config]])</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明</p><h5 id="并发请求（concurrency）-即是帮助处理并发请求的辅助函数"><a href="#并发请求（concurrency）-即是帮助处理并发请求的辅助函数" class="headerlink" title="并发请求（concurrency）,即是帮助处理并发请求的辅助函数"></a>并发请求（concurrency）,即是帮助处理并发请求的辅助函数</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iterable是一个可以迭代的参数如数组等</span></span><br><span class="line">axios.all(iterable)</span><br><span class="line"><span class="comment"># callback要等到所有请求都完成才会执行</span></span><br><span class="line">axios.spread(callback)</span><br></pre></td></tr></table></figure><h5 id="创建一个axios实例，并且可以自定义其配置"><a href="#创建一个axios实例，并且可以自定义其配置" class="headerlink" title="创建一个axios实例，并且可以自定义其配置"></a>创建一个axios实例，并且可以自定义其配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># axios.create([config])</span></span><br><span class="line">var instance = axios.create(&#123;</span><br><span class="line">  baseURL:<span class="string">"https://some-domain.com/api/"</span>,</span><br><span class="line">  timeout:1000,</span><br><span class="line">  headers: &#123;<span class="string">'X-Custom-Header'</span>:<span class="string">'foobar'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例的方法</span></span><br><span class="line"><span class="comment"># 一下是实例方法，注意已经定义的配置将和利用create创建的实例的配置合并</span></span><br><span class="line">axios<span class="comment">#request(config)</span></span><br><span class="line">axios<span class="comment">#get(url[,config])</span></span><br><span class="line">axios<span class="comment">#delete(url[,config])</span></span><br><span class="line">axios<span class="comment">#head(url[,config])</span></span><br><span class="line">axios<span class="comment">#post(url[,data[,config]])</span></span><br><span class="line">axios<span class="comment">#put(url[,data[,config]])</span></span><br><span class="line">axios<span class="comment">#patch(url[,data[,config]])</span></span><br></pre></td></tr></table></figure><h4 id="请求的配置（request-config）"><a href="#请求的配置（request-config）" class="headerlink" title="请求的配置（request config）"></a>请求的配置（request config）</h4><p>　　以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment"># `url`是请求的服务器地址</span></span><br><span class="line">  url:<span class="string">'/user'</span>,</span><br><span class="line">  <span class="comment"># `method`是请求资源的方式</span></span><br><span class="line">  method:<span class="string">'get'</span><span class="comment"># default</span></span><br><span class="line">  <span class="comment"># 如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面</span></span><br><span class="line">  <span class="comment"># 当`url`是相对地址的时候，设置`baseURL`会非常的方便</span></span><br><span class="line">  baseURL:<span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line">  <span class="comment"># `transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动</span></span><br><span class="line">  <span class="comment"># 该选项只适用于以下请求方式：`put/post/patch`</span></span><br><span class="line">  <span class="comment"># 数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream`</span></span><br><span class="line">  transformRequest:[<span class="keyword">function</span>(data)&#123;</span><br><span class="line">    <span class="comment"># 在这里根据自己的需求改变数据</span></span><br><span class="line">    <span class="built_in">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="comment"># `transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动</span></span><br><span class="line">  transformResponse:[<span class="keyword">function</span>(data)&#123;</span><br><span class="line">    <span class="comment"># 在这里根据自己的需求改变数据</span></span><br><span class="line">    <span class="built_in">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="comment"># `headers`选项是需要被发送的自定义请求头信息</span></span><br><span class="line">  headers: &#123;<span class="string">'X-Requested-With'</span>:<span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line">  <span class="comment"># `params`选项是要随请求一起发送的请求参数----一般链接在URL后面</span></span><br><span class="line">  <span class="comment"># 他的类型必须是一个纯对象或者是URLSearchParams对象</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID:12345</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化</span></span><br><span class="line">  <span class="comment"># 例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param)</span></span><br><span class="line">  paramsSerializer: <span class="keyword">function</span>(params)&#123;</span><br><span class="line">    <span class="built_in">return</span> Qs.stringify(params,&#123;arrayFormat:<span class="string">'brackets'</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `data`选项是作为一个请求体而需要被发送的数据</span></span><br><span class="line">  <span class="comment"># 该选项只适用于方法：`put/post/patch`</span></span><br><span class="line">  <span class="comment"># 当没有设置`transformRequest`选项时dada必须是以下几种类型之一</span></span><br><span class="line">  <span class="comment"># string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams</span></span><br><span class="line">  <span class="comment"># 仅仅浏览器：FormData/File/Bold</span></span><br><span class="line">  <span class="comment"># 仅node:Stream</span></span><br><span class="line">  data &#123;</span><br><span class="line">    firstName:<span class="string">"Fred"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `timeout`选项定义了请求发出的延迟毫秒数</span></span><br><span class="line">  <span class="comment"># 如果请求花费的时间超过延迟的时间，那么请求会被终止</span></span><br><span class="line"></span><br><span class="line">  timeout:1000,</span><br><span class="line">  <span class="comment"># `withCredentails`选项表明了是否是跨域请求</span></span><br><span class="line">  </span><br><span class="line">  withCredentials:<span class="literal">false</span>,<span class="comment"># default</span></span><br><span class="line">  <span class="comment"># `adapter`适配器选项允许自定义处理请求，这会使得测试变得方便</span></span><br><span class="line">  <span class="comment"># 返回一个promise,并提供验证返回</span></span><br><span class="line">  adapter: <span class="keyword">function</span>(config)&#123;</span><br><span class="line">    /*..........*/</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `auth`表明HTTP基础的认证应该被使用，并提供证书</span></span><br><span class="line">  <span class="comment"># 这会设置一个authorization头（header）,并覆盖你在header</span></span><br><span class="line">  <span class="comment"># 设置的Authorization头信息</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username:<span class="string">"zhangsan"</span>,</span><br><span class="line">    password: <span class="string">"s00sdkf"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># 返回数据的格式</span></span><br><span class="line">  <span class="comment"># 其可选项是arraybuffer,blob,document,json,text,stream</span></span><br><span class="line">  responseType:<span class="string">'json'</span>,<span class="comment"># default</span></span><br><span class="line">  <span class="comment"># </span></span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>,<span class="comment"># default</span></span><br><span class="line">  xsrfHeaderName:<span class="string">'X-XSRF-TOKEN'</span>,<span class="comment"># default</span></span><br><span class="line">  <span class="comment"># `onUploadProgress`上传进度事件</span></span><br><span class="line">  onUploadProgress:<span class="keyword">function</span>(progressEvent)&#123;</span><br><span class="line">    <span class="comment"># 下载进度的事件</span></span><br><span class="line">onDownloadProgress:<span class="keyword">function</span>(progressEvent)&#123;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># 相应内容的最大值</span></span><br><span class="line">  maxContentLength:2000,</span><br><span class="line">  <span class="comment"># `validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise</span></span><br><span class="line">  <span class="comment"># 如果`validateStatus`返回true(或者设置为`null`或者`undefined`),</span></span><br><span class="line">  <span class="comment"># 那么promise的状态将会是resolved,否则其状态就是rejected</span></span><br><span class="line">  validateStatus:<span class="keyword">function</span>(status)&#123;</span><br><span class="line">    <span class="built_in">return</span> status &gt;= 200 &amp;&amp; status &lt;300;<span class="comment"># default</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `maxRedirects`定义了在nodejs中重定向的最大数量</span></span><br><span class="line">  maxRedirects: 5,<span class="comment"># default</span></span><br><span class="line">  <span class="comment"># `httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理</span></span><br><span class="line">  <span class="comment"># keeyAlive在选项中没有被默认激活</span></span><br><span class="line">  httpAgent: new http.Agent(&#123;keeyAlive:<span class="literal">true</span>&#125;),</span><br><span class="line">  httpsAgent: new https.Agent(&#123;keeyAlive:<span class="literal">true</span>&#125;),</span><br><span class="line">  <span class="comment"># proxy定义了主机名字和端口号，</span></span><br><span class="line">  <span class="comment"># `auth`表明http基本认证应该与proxy代理链接，并提供证书</span></span><br><span class="line">  <span class="comment"># 这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的</span></span><br><span class="line">  <span class="comment"># Proxy-Authorization  header</span></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host:<span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: 9000,</span><br><span class="line">    auth: &#123;</span><br><span class="line">      username:<span class="string">'skda'</span>,</span><br><span class="line">      password:<span class="string">'radsd'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `cancelToken`定义了一个用于取消请求的cancel token</span></span><br><span class="line">  <span class="comment"># 详见cancelation部分</span></span><br><span class="line">  cancelToken: new cancelToken(<span class="keyword">function</span>(cancel)&#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="请求返回的内容"><a href="#请求返回的内容" class="headerlink" title="请求返回的内容"></a>请求返回的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  data:&#123;&#125;,</span><br><span class="line">  status:200,</span><br><span class="line">  <span class="comment"># 从服务器返回的http状态文本</span></span><br><span class="line">  statusText:<span class="string">'OK'</span>,</span><br><span class="line">  <span class="comment"># 响应头信息</span></span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line">  <span class="comment"># `config`是在请求的时候的一些配置信息</span></span><br><span class="line">  config: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你可以这样来获取响应信息</span></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(res)&#123;</span><br><span class="line">    console.log(res.data);</span><br><span class="line">    console.log(res.status);</span><br><span class="line">    console.log(res.statusText);</span><br><span class="line">    console.log(res.headers);</span><br><span class="line">    console.log(res.config);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><p>你可以设置默认配置，对所有请求都有效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、 全局默认配置</span><br><span class="line">axios.defaults.baseURL = <span class="string">'http://api.exmple.com'</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'content-Type'</span>] = <span class="string">'appliction/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure></p><p>2、 自定义的实例默认设置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当创建实例的时候配置默认配置</span></span><br><span class="line">var instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'https://api.example.com'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当实例创建时候修改配置</span></span><br><span class="line">instance.defaults.headers.common[<span class="string">"Authorization"</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure></p><p>3、 配置中的有优先级<br>　　config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个实例的时候会使用libray目录中的默认配置</span></span><br><span class="line"><span class="comment"># 在这里timeout配置的值为0，来自于libray的默认值</span></span><br><span class="line">var instance = axios.create();</span><br><span class="line"><span class="comment"># 回覆盖掉library的默认值</span></span><br><span class="line"><span class="comment"># 现在所有的请求都要等2.5S之后才会发出</span></span><br><span class="line">instance.defaults.timeout = 2500;</span><br><span class="line"><span class="comment"># 这里的timeout回覆盖之前的2.5S变成5s</span></span><br><span class="line">instance.get(<span class="string">'/longRequest'</span>,&#123;</span><br><span class="line">  timeout: 5000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>你可以在请求、响应在到达then/catch之前拦截他们<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加一个请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="keyword">function</span>(config)&#123;</span><br><span class="line">  <span class="comment"># 在请求发出之前进行一些操作</span></span><br><span class="line">  <span class="built_in">return</span> config;</span><br><span class="line">&#125;,<span class="keyword">function</span>(err)&#123;</span><br><span class="line">  <span class="comment"># Do something with request error</span></span><br><span class="line">  <span class="built_in">return</span> Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment"># 添加一个响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="keyword">function</span>(res)&#123;</span><br><span class="line">  <span class="comment"># 在这里对返回的数据进行处理</span></span><br><span class="line">  <span class="built_in">return</span> res;</span><br><span class="line">&#125;,<span class="keyword">function</span>(err)&#123;</span><br><span class="line">  <span class="comment"># Do something with response error</span></span><br><span class="line">  <span class="built_in">return</span> Promise.reject(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>2、取消拦截器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myInterceptor = axios.interceptor.request.use(<span class="function"><span class="title">function</span></span>()&#123;/*....*/&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure></p><p>3、 给自定义的axios实例添加拦截器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="title">function</span></span>()&#123;&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .catch(<span class="keyword">function</span>(error)&#123;</span><br><span class="line">    <span class="keyword">if</span>(error.response)&#123;</span><br><span class="line">      <span class="comment"># 请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内</span></span><br><span class="line">      console.log(error.response.data);</span><br><span class="line">      console.log(error.response.status);</span><br><span class="line">      console.log(error.response.header);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment"># 一些错误是在设置请求的时候触发</span></span><br><span class="line">      console.log(<span class="string">'Error'</span>,error.message);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(error.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h4><p>1、你可以通过一个cancel token来取消一个请求<br>你可以通过CancelToken.source工厂函数来创建一个cancel token<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var CancelToken = axios.CancelToken;</span><br><span class="line">var <span class="built_in">source</span> = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>,&#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(thrown)&#123;</span><br><span class="line">  <span class="keyword">if</span>(axios.isCancel(thrown))&#123;</span><br><span class="line">    console.log(<span class="string">'Request canceled'</span>,thrown.message);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment"># handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消请求（信息的参数可以设置的）</span></span><br><span class="line">source.cance(<span class="string">"操作被用户取消"</span>);</span><br></pre></td></tr></table></figure></p><p>2、你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var cancelToken = axios.CancelToken;</span><br><span class="line">var cance;</span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>,&#123;</span><br><span class="line">  cancelToken: new CancelToken(<span class="keyword">function</span>(c)&#123;</span><br><span class="line">    <span class="comment"># 这个executor函数接受一个cancel function作为参数</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment"># 取消请求</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure></p><h4 id="创建axios实例"><a href="#创建axios实例" class="headerlink" title="创建axios实例"></a>创建axios实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># helpers.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"># 定义常量ERR_OK</span><br><span class="line"><span class="keyword">const</span> ERR_OK = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 导出一个getDate方法</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getDate(url) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(url, &#123;</span><br><span class="line">      params</span><br><span class="line">      # 成功之后的.then方法</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      # 通过结构赋值的方法难道error和data的数值</span><br><span class="line">      <span class="keyword">const</span> &#123; error, data&#125; = res.data</span><br><span class="line">      # 如果成功的话，返回data数据</span><br><span class="line">      <span class="keyword">if</span>(error === ERR_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">      &#125;</span><br><span class="line">      # 如果失败的话打印失败的原因</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) =&gt; </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"error:"</span>, error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 出口文件</span><br><span class="line"># index.js</span><br><span class="line"><span class="keyword">import</span> &#123; getDate &#125; <span class="keyword">from</span> <span class="string">'./helpers'</span></span><br><span class="line"></span><br><span class="line"># 定义getSeller方法</span><br><span class="line"><span class="keyword">const</span> getSeller = getDate(<span class="string">'./api/seller'</span>)</span><br><span class="line"></span><br><span class="line"># 导出getSeller方法</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  getSeller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="AJAX" scheme="http://yoursite.com/categories/AJAX/"/>
    
    
      <category term="AJAX" scheme="http://yoursite.com/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>AJAX</title>
    <link href="http://yoursite.com/2019/03/30/Ajax/AJAX/"/>
    <id>http://yoursite.com/2019/03/30/Ajax/AJAX/</id>
    <published>2019-03-30T03:19:04.000Z</published>
    <updated>2019-03-30T12:13:42.107Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h3 id="AJAX简介"><a href="#AJAX简介" class="headerlink" title="AJAX简介"></a>AJAX简介</h3><p>　　AJAX全称为“Asynchronous Javascript And XML”， 即“异步JavaScript和XML”的意思。通过AJAX我们可以向服务器发送请求，在不阻塞页面的情况下进行数据交互，也可以理解为异步数据传输。在AJAX的帮助下我们的网页只需局部刷新即可更新数据的显示，减少了不必要的数据量，大大提高了用户体验，缩短了用户等待的时间，使得web应用程序更小、更快，更友好。<a id="more"></a></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>页面无刷新，用户体验好。<br>异步通信，更加快的响应能力。<br>减少冗余请求，减轻了服务器负担<br>基于标准化的并被广泛支持的技术，不需要下载插件或者小程序</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>ajax干掉了back按钮，即对浏览器后退机制的破坏。<br>存在一定的安全问题。<br>对搜索引擎的支持比较弱。<br>破坏了程序的异常机制。<br>无法用URL直接访问</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>场景 1. 数据验证<br>场景 2. 按需取数据<br>场景 3. 自动更新页面</p><h3 id="AJAX的核心-XMLHttpRequest对象"><a href="#AJAX的核心-XMLHttpRequest对象" class="headerlink" title="AJAX的核心 XMLHttpRequest对象"></a>AJAX的核心 XMLHttpRequest对象</h3><p>创建XML对象的实例：<code>const xhr = new XMLHttpRequest()</code></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备启动一个AJAX请求</span></span><br><span class="line">.open()</span><br><span class="line"><span class="comment"># 设置请求头部信息</span></span><br><span class="line">.setRequestHeader()</span><br><span class="line"><span class="comment"># 发送AJAX请求</span></span><br><span class="line">.send()</span><br><span class="line"><span class="comment"># 获得响应头部信息</span></span><br><span class="line">.getResponseHeader()</span><br><span class="line"><span class="comment"># 获得一个包含所有头部信息的长字符串</span></span><br><span class="line">.getAllResponseHeader()</span><br><span class="line"><span class="comment"># 取消异步请求</span></span><br><span class="line">.abort()</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含响应主体返回文本</span></span><br><span class="line">.responseText</span><br><span class="line"><span class="comment"># 如果响应的内容类型时text/xml或application/xml，</span></span><br><span class="line"><span class="comment"># 该属性将保存包含着相应数据的XML DOM文档</span></span><br><span class="line">.responseXML</span><br><span class="line"><span class="comment"># 响应的HTTP状态</span></span><br><span class="line">.status</span><br><span class="line"><span class="comment"># HTTP状态的说明</span></span><br><span class="line">.statusText</span><br><span class="line"><span class="comment"># 表示“请求”/“响应”过程的当前活动阶段</span></span><br><span class="line">.readyState</span><br></pre></td></tr></table></figure><h3 id="发送AJAX请求"><a href="#发送AJAX请求" class="headerlink" title="发送AJAX请求"></a>发送AJAX请求</h3><h4 id="设置请求头部信息"><a href="#设置请求头部信息" class="headerlink" title="设置请求头部信息"></a>设置请求头部信息</h4><p>　　每个HTTP请求和响应都会带有相应的头部信息，包含一些与数据，收发者网络环境与状态等相关信息。XMLHttpRequest对象提供的.setRequestHeader()方法为开发者提供了一个操作这两种头部信息的方法，并允许开发者自定义请求头的头部信息。<br>默认情况下，当发送AJAX请求时，会附带以下头部信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浏览器能够处理的内容类型</span></span><br><span class="line">Accept</span><br><span class="line"><span class="comment"># 浏览器能够显示的字符集</span></span><br><span class="line">Accept-Charset</span><br><span class="line"><span class="comment"># 浏览器能够处理的压缩编码</span></span><br><span class="line">Accept-Encoding</span><br><span class="line"><span class="comment"># 浏览器当前设置的语言</span></span><br><span class="line">Accept-Language</span><br><span class="line"><span class="comment"># 浏览器与服务器之间连接的类型</span></span><br><span class="line">Connection</span><br><span class="line"><span class="comment"># 当前页面设置的任何Cookie</span></span><br><span class="line">Cookie</span><br><span class="line"><span class="comment"># 发出请求的页面所在的域</span></span><br><span class="line">Host</span><br><span class="line"><span class="comment"># 发出请求的页面URI</span></span><br><span class="line">Referer</span><br><span class="line"><span class="comment"># 浏览器的用户代理字符串</span></span><br><span class="line">User-Agent</span><br></pre></td></tr></table></figure></p><p><strong>注意:</strong><br>　　部分浏览器不允许使用<code>.setRequestHeader()</code>方法重写默认请求头信息，因此自定义请求头信息是更加安全的方法：<br><code># 自定义请求头</code><br><code>xhr.setRequestHeader(&quot;myHeader&quot;, &quot;MyValue&quot;)</code></p><h4 id="发送AJAX请求-1"><a href="#发送AJAX请求-1" class="headerlink" title="发送AJAX请求"></a>发送AJAX请求</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送AJAX请求</span></span><br><span class="line"><span class="comment"># 使用get方法发送同步请求(false)</span></span><br><span class="line"><span class="built_in">let</span> xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.php'</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">'myHeader'</span>, <span class="string">'goodHeader'</span>)</span><br><span class="line">xhr.send(null)</span><br><span class="line"></span><br><span class="line"><span class="comment"># POST请求</span></span><br><span class="line"><span class="built_in">let</span> xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'example.php'</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">'myHeader'</span>, <span class="string">'goodHeader'</span>)</span><br><span class="line">shr.send(some_data)</span><br></pre></td></tr></table></figure><h4 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h4><p>同步的GET请求响应：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"example.php"</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">"myHeader"</span>, <span class="string">"goodHeader"</span>)</span><br><span class="line">xhr.send(null)</span><br><span class="line"><span class="comment"># 由于是同步的AJAX请求，因此只有当服务器响应后才会继续执行下面的代码</span></span><br><span class="line"><span class="comment"># 因此xhr.status的值一定不为默认值</span></span><br><span class="line"><span class="keyword">if</span>((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;</span><br><span class="line">  console.log(<span class="string">"xhr.responseText:"</span>, xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  console.log(<span class="string">"Request was unsuccessful:"</span>, xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　上面的代码不难理解，我们通过之前提到的<code>xhr.status</code>属性（如果你忘记了，它存储着响应的HTTP状态）判断请求是否成功，如果成功的话，我们将读取<code>xhr.responseText</code>属性中存储的返回值。但是，当我们的请求为异步时，问题就稍微变得复杂了，由于是异步的请求，在<code>xhr.send(null)</code>语句被执行后，<code>JavaScript</code>引擎会紧接着执行下面的判断语句，而这时由于尚未来得及响应，我们注定会得到一个默认的<code>xhr.status</code>值，因此，我们永远都不可能获取请求的资源了。<br>如何解决这个问题？答案是通过为<code>XMLHTTPRequest</code>实例添加<code>onreadystatechange</code>事件处理程序（当然你也可以直接使用DOM2级规范规定的<code>.addEventListener()</code>方法，但是注意，IE8是不支持该方法的）。<br>　　xhr实例的<code>readystatechange</code>事件会监听<code>xhr.readyState</code>属性的变化，你可以将这个属性想象为一个计数器，随着AJAX流程的推进而不断累加，其可取的值如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　0：未初始化 -- 尚未调用.open()方法</span><br><span class="line">　　1：启动 -- 已经调用.open()方法，但尚未调用.send()方法</span><br><span class="line">　　2：发送 -- 已经调用.send()方法，但尚未接收到响应</span><br><span class="line">　　3：接收 -- 已经接收到部分响应数据</span><br><span class="line">　　4：完成 -- 已经接收到全部响应数据，而且已经可以在客户端使用了</span><br></pre></td></tr></table></figure></p><p>有了这个时间处理程序对AJAX进程做监听，剩下的事就简单多了，一个<code>异步</code>的<code>GET</code>请求代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest()</span><br><span class="line"><span class="comment"># 等价于 xhr.onreadystatechange = function()&#123;&#125;</span></span><br><span class="line"><span class="comment"># 利用onreadystatechange监测状态</span></span><br><span class="line">xhr.onreadystatechange = () =&gt; &#123;</span><br><span class="line">  <span class="comment"># readyState为4表示请求响应完成</span></span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState == 4) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;</span><br><span class="line">      console.log(<span class="string">"xhr.responseText:"</span>, xhr.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      console.log(<span class="string">"Request was unsuccessful:"</span>, xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'example.php'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(null)</span><br></pre></td></tr></table></figure></p><h3 id="其他库框架中的AJAX"><a href="#其他库框架中的AJAX" class="headerlink" title="其他库框架中的AJAX"></a>其他库框架中的AJAX</h3><h4 id="jQuery中的AJAX"><a href="#jQuery中的AJAX" class="headerlink" title="jQuery中的AJAX"></a>jQuery中的AJAX</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    method: <span class="string">'GET'</span>, <span class="comment"># 1.9.0本版前用'type'</span></span><br><span class="line">    url: <span class="string">"/test/"</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">done</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'执行成功'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.fail(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'执行出错'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Vue-js中的AJAX"><a href="#Vue-js中的AJAX" class="headerlink" title="Vue.js中的AJAX"></a>Vue.js中的AJAX</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.get(<span class="string">'/test/'</span>).<span class="keyword">then</span>((response) =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'执行成功'</span>);</span><br><span class="line">&#125;, (response) =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'执行出错'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>转载：<br>　　<a href="https://juejin.im/post/5a20b1f1f265da432529179c" target="_blank" rel="noopener">使用AJAX</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h3 id=&quot;AJAX简介&quot;&gt;&lt;a href=&quot;#AJAX简介&quot; class=&quot;headerlink&quot; title=&quot;AJAX简介&quot;&gt;&lt;/a&gt;AJAX简介&lt;/h3&gt;&lt;p&gt;　　AJAX全称为“Asynchronous Javascript And XML”， 即“异步JavaScript和XML”的意思。通过AJAX我们可以向服务器发送请求，在不阻塞页面的情况下进行数据交互，也可以理解为异步数据传输。在AJAX的帮助下我们的网页只需局部刷新即可更新数据的显示，减少了不必要的数据量，大大提高了用户体验，缩短了用户等待的时间，使得web应用程序更小、更快，更友好。&lt;/p&gt;
    
    </summary>
    
      <category term="AJAX" scheme="http://yoursite.com/categories/AJAX/"/>
    
    
      <category term="AJAX" scheme="http://yoursite.com/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>DOM结构</title>
    <link href="http://yoursite.com/2019/03/30/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/DOM%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/30/前端性能优化/DOM结构/</id>
    <published>2019-03-30T01:12:02.000Z</published>
    <updated>2019-03-30T03:17:41.115Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>DOM是个缩写，全称是<code>Document Object Model</code>。<br>D表示Document，就是DOM将HTML页面解析为一个文档，同时提供了document对象。<br>O表示Object，就是DOM将HTML页面中每一个元素解析为一个对象。<br>M表示Model，就是DOM中表示各个对象之间的关系。<a id="more"></a></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于解析HTML页面文档，方便JavaScript语言通过DOM访问和操作HTML页面中的内容。</p><h4 id="DOM结构"><a href="#DOM结构" class="headerlink" title="DOM结构"></a>DOM结构</h4><h5 id="DOM树结构"><a href="#DOM树结构" class="headerlink" title="DOM树结构"></a>DOM树结构</h5><p>DOM可以访问和更新HTML中的内容、结构和样式，是因为DOM将HTML解析为一个树状结构。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">'en'</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">      &lt;meta charset=<span class="string">'UTF-8'</span>&gt;</span><br><span class="line">      &lt;title&gt;示例页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">       &lt;h2&gt;这是一个示例页面&lt;/h2&gt;</span><br><span class="line">       &lt;p id=<span class="string">"p"</span> title=<span class="string">"this is p."</span>&gt;这是一个段落内容。&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>将上面的 HTML 页面绘制成 DOM 树结构，如下效果:<br><img src="/assets/images/dom2.png" alt="DOM"><br>　　通过上面的 DOM 树结构，我们可以看到，Document 对象是作为 DOM树结构的入口。再根据 DOM 树结构的特点，我们就可以定位到 HTML 页面中任意一个元素、属性或文本内容。</p><p>　　浏览器加载并运行 HTML 页面时，会创建 DOM 树结构这个模型。并且 DOM 树结构模型会被存储在浏览器的内存中。<br><code>当 HTML 页面内容过于庞大和复杂时，生成的 DOM 树结构就越复杂。进而，浏览器加载 HTML 页面的耗时就越长。</code><br><img src="/assets/images/dom.png" alt="DOM"></p><h5 id="DOM树中的节点"><a href="#DOM树中的节点" class="headerlink" title="DOM树中的节点"></a>DOM树中的节点</h5><p>在 DOM 树结构中，主要由以下 4 种节点组成:</p><table><thead><tr><th>节点名称</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>文档节点</td><td>表示整个HTML页面(相当于document对象)</td><td>当需要访问任何标签、属性或文本时，都可以通过文档节点进行导航</td></tr><tr><td>元素节点</td><td>表示HTML页面中的标签(即HTML页面结构)</td><td>访问DOM树时，需要从查找元素节点开始</td></tr><tr><td>属性节点</td><td>表示HTML页面中的开始标签包含的属性</td><td></td></tr><tr><td>文本节点</td><td>表示整个HTML页面中的标签所包含的文本内容</td></tr></tbody></table><p>节点（Node）作为DOM树结构中的连接点，最终构成了完整的DOM树结构<br><img src="/assets/images/dom1.png" alt="DOM"></p><h5 id="节点树结构"><a href="#节点树结构" class="headerlink" title="节点树结构"></a>节点树结构</h5><p>通过节点概念，我们可以将原本的 DOM 树结构改成 DOM 节点树结构进行表示。<br><img src="/assets/images/dom3.jpg" alt="DOM"></p><h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><p>1、获取节点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、标准DOM API</span></span><br><span class="line">document.getElementById</span><br><span class="line">document.getElementsByTagName</span><br><span class="line">document.getElementsByName</span><br><span class="line">document.getElemensByClassName</span><br><span class="line"><span class="comment"># 功能强大，但是也许会有浏览器不兼容的情况存在</span></span><br><span class="line">document.querySelectorAll </span><br><span class="line"></span><br><span class="line">2、 亲属访问</span><br><span class="line"></span><br><span class="line">3、 属性获取</span><br><span class="line">getAttribute</span><br><span class="line">getAttributeNode</span><br></pre></td></tr></table></figure></p><p>2、 创建<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建元素</span></span><br><span class="line">document.createElement </span><br><span class="line"><span class="comment"># 创建文本节点</span></span><br><span class="line">document.createTesxtNode </span><br><span class="line"><span class="comment"># 属性节点</span></span><br><span class="line">document.createAttribute </span><br><span class="line">innerHTML</span><br><span class="line">innerText</span><br><span class="line">node.cloneNode()</span><br></pre></td></tr></table></figure></p><p>3、 加入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 追加到结尾处</span></span><br><span class="line">appendChild </span><br><span class="line">innerHTML</span><br><span class="line"><span class="comment"># 用法：将元素插入到某一个元素的前面 父元素.insertBefore(新元素, 旧元素);</span></span><br><span class="line">insertBefore</span><br></pre></td></tr></table></figure></p><p>4、 其他<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">style 的操作</span><br><span class="line">setAttribute(属性名， 属性值)</span><br></pre></td></tr></table></figure></p><p>5、 删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用法：父元素.removeChild()</span></span><br><span class="line">removeChild </span><br><span class="line">removeAttributeNode</span><br></pre></td></tr></table></figure></p><p>6、 修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.修改节点</span><br><span class="line">删除节点再加入</span><br><span class="line"></span><br><span class="line">2.修改样式</span><br><span class="line">style.xxx = vvv;</span><br><span class="line">setAttribute</span><br><span class="line"></span><br><span class="line">3.修改文本</span><br><span class="line">innerHTML</span><br><span class="line">innerText</span><br><span class="line">节点操作</span><br><span class="line">nodeValue</span><br><span class="line"></span><br><span class="line">4.修改属性</span><br><span class="line">.xxx = vvv</span><br><span class="line">setAttribute</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;DOM是个缩写，全称是&lt;code&gt;Document Object Model&lt;/code&gt;。&lt;br&gt;D表示Document，就是DOM将HTML页面解析为一个文档，同时提供了document对象。&lt;br&gt;O表示Object，就是DOM将HTML页面中每一个元素解析为一个对象。&lt;br&gt;M表示Model，就是DOM中表示各个对象之间的关系。&lt;/p&gt;
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器渲染流程" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染流程</title>
    <link href="http://yoursite.com/2019/03/30/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/03/30/前端性能优化/浏览器渲染流程/</id>
    <published>2019-03-30T01:12:02.000Z</published>
    <updated>2019-03-30T02:19:03.093Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://blog.csdn.net/xiaozhuxmen/article/details/52014901" target="_blank" rel="noopener">浏览器加载、解析、渲染的过程</a><br>　　<a href="https://juejin.im/post/5a8e242c5188257a6b060000" target="_blank" rel="noopener">【干货】十分钟读懂浏览器渲染流程</a></p><h4 id="为什么要了解浏览器加载、解析、渲染这个过程"><a href="#为什么要了解浏览器加载、解析、渲染这个过程" class="headerlink" title="为什么要了解浏览器加载、解析、渲染这个过程"></a>为什么要了解浏览器加载、解析、渲染这个过程</h4><p>　　了解浏览器如何进行加载，可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。<br>　　了解浏览器如何进行解析，可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。<br>　　了解浏览器如何进行渲染，明白渲染的过程，在设置元素属性，编写js文件时，可以减少”reflow“”repaint“的消耗。</p><h4 id="浏览器的主要功能"><a href="#浏览器的主要功能" class="headerlink" title="浏览器的主要功能"></a>浏览器的主要功能</h4><p>　　浏览器的主要功能是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式。用户用URI（Uniform Resource Identifier统一资源标识符）来指定所请求资源的位置，通过DNS查询，将网址转换为IP地址。整个浏览器工作的流程为：<br>　　1、 输入网址。<br>　　2、 浏览器查找域名的IP地址。<br>　　3、 浏览器给web服务器发送一个HTTP请求<br>　　4、 网站服务的永久重定向响应<br>　　5、 浏览器跟踪重定向地址。现在，浏览器知道了要访问的正确地址，所以它会发送另一个获取请求。<br>　　6、 服务器“处理”请求，服务器接收到获取请求，然后处理并返回一个响应。<br>　　7、 服务器发回一个HTML响应<br>　　8、 浏览器开始显示HTML<br>　　9、 浏览器发送请求，以获取嵌入在HTML中的对象。在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。这些文件就包括CSS/JS/图片等资源，这些资源的地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…</p><p>　　那么，一个页面，究竟是如何从我们输入一个网址到最后完整的呈现在我们面前的呢？还需要了解一下浏览器是如何渲染的：</p><h4 id="浏览器的渲染"><a href="#浏览器的渲染" class="headerlink" title="浏览器的渲染"></a>浏览器的渲染</h4><p>渲染引擎在取得内容之后的基本流程：<br><code>解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</code><br>所以，浏览器会解析三个东西：<br>（1） HTML/SVG/XHTML，解析这三种文件会产生一个 DOM Tree。<br>（2） CSS，解析 CSS 会产生 CSS 规则树。<br>（3） Javascript脚本，主要是通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree.</p><h5 id="关键渲染路径"><a href="#关键渲染路径" class="headerlink" title="关键渲染路径"></a>关键渲染路径</h5><p>　　关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。</p><p>当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。<br>解析：<br>　　1、 <code>DOM Tree</code>: 浏览器会将HTML解析成一个DOM树。DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。<br>　　2、 <code>CSS Rule Tree</code>: 将CSS解析成 CSS Rule Tree 。<br>　　3、 <code>Render Tree</code>: 根据DOM树和CSSOM来构造 Rendering Tree。<br>　　注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header<br>　　或 display:none 的东西就没必要放在渲染树中了。<br>　　4、 <code>layout</code>: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。 （<code>遍历渲染树开始布局，计算每个节点的位置大小信息</code>）<br>　　5、 <code>painting</code>: 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。<br>　　(<code>将渲染树每个节点绘制到屏幕</code>。)</p><h6 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h6><p>　　当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。<br>需要注意的是，DOM树的生成过程中可能会被CSS和JS的加载执行阻塞。渲染阻塞问题下文会讲。</p><h6 id="构建CSSOM规则树"><a href="#构建CSSOM规则树" class="headerlink" title="构建CSSOM规则树"></a>构建CSSOM规则树</h6><p>　　浏览器解析CSS文件并生成CSS规则树，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。</p><h6 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h6><p>　　当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建DOM。每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。<br>　　所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：<br><code>CSS 优先</code>：引入顺序上，CSS 资源先于 JavaScript资源。<br><code>JS置后</code>：我们通常把JS代码放到<code>页面底部</code>，且JavaScript 应尽量少影响 DOM 的构建。当解析html的时候，会把新来的元素插入dom树里面，同时去查找css，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。例如： div p {font-size: 16px}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染）。所以，我们平时写CSS时，尽量用id和class，千万不要过渡层叠。</p><h6 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h6><p>　　通过DOM树和CSS规则树我们便可以构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的CSS样式规则并应用。渲染树构建完成后，每个节点都是可见节点并且都含有其内容和对应规则的样式。这也是渲染树与DOM树的最大区别所在。渲染树是用于显示，那些不可见的元素当然就不会在这棵树中出现了，譬如。除此之外，display等于none的也不会被显示在这棵树里头，但是visibility等于hidden的元素是会显示在这棵树里头的。</p><h6 id="渲染树布局"><a href="#渲染树布局" class="headerlink" title="渲染树布局"></a>渲染树布局</h6><p>　　布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。</p><h6 id="渲染树绘制"><a href="#渲染树绘制" class="headerlink" title="渲染树绘制"></a>渲染树绘制</h6><p>　　在绘制阶段，遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。</p><h5 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h5><p>　　上述这个过程是<code>逐步完成</code>的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。<br><strong>几个概念： </strong><br>　　（1）Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。<br>　　（2）Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。<br>Reflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。</p><h6 id="reflow"><a href="#reflow" class="headerlink" title="reflow"></a>reflow</h6><p>　　（1）页面初始化的时候；<br>　　（2）操作DOM时；<br>　　（3）某些元素的尺寸变了；<br>　　（4）如果 CSS 的属性发生变化了。</p><h6 id="减少reflow-repaint"><a href="#减少reflow-repaint" class="headerlink" title="减少reflow/repaint"></a>减少reflow/repaint</h6><p>　　（1）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。<br>　　（2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。<br>　　（3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。<br>　　（4）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p>注意：<br>　　　(1)<code>display:none</code> 的节点不会被加入<code>Render Tree</code>，而<code>visibility: hidden</code> 则会，所以，如果某个节点最开始是不显示的，设为<code>display:none</code>是更优的。<br>　　　(2)<code>display:none</code> 会触发 <code>reflow</code>，而 <code>visibility:hidden</code> 只会触发 <code>repaint</code>，因为没有发现位置变化。<br>　　　(3)有些情况下，比如修改了元素的样式，浏览器并不会立刻<code>reflow</code> 或 <code>repaint</code> 一次，而是会把这样的操作积攒一批，然后做一次 <code>reflow</code>，这又叫异步<code>reflow</code> 或增量异步 <code>reflow</code>。但是在有些情况下，比如<code>resize</code> 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 <code>reflow</code>。</p><h6 id="HTML页面加载和解析流程"><a href="#HTML页面加载和解析流程" class="headerlink" title="HTML页面加载和解析流程"></a>HTML页面加载和解析流程</h6><ol><li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件； </li><li>浏览器开始载入<code>html</code>代码，发现<code>＜head＞</code>标签内有一个<code>＜link＞</code>标签引用外部<code>CSS</code>文件； </li><li>浏览器又发出<code>CSS</code>文件的请求，服务器返回这个<code>CSS</code>文件； </li><li>浏览器继续载入<code>html</code>中<code>＜body＞</code>部分的代码，并且<code>CSS</code>文件已经拿到手了，可以开始渲染页面了； </li><li>浏览器在代码中发现一个<code>＜img＞</code>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； </li><li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； </li><li>浏览器发现了一个包含一行<code>Javascript</code>代码的<code>＜script＞</code>标签，赶快运行它； </li><li><code>Javascript</code>脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （<code>style.display=”none”</code>）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码； </li><li>终于等到了<code>＜/html＞</code>的到来，浏览器泪流满面…… </li><li>等等，还没完，用户点了一下界面中的“换肤”按钮，<code>Javascript</code>让浏览器换了一下<code>＜link＞</code>标签的CSS路径； </li><li>浏览器召集了在座的各位<code>＜div＞＜span＞＜ul＞＜li＞</code>们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</li></ol><h6 id="编写CSS时应该注意"><a href="#编写CSS时应该注意" class="headerlink" title="编写CSS时应该注意"></a>编写CSS时应该注意</h6><p>　　CSS选择符是从右到左进行匹配的。从右到左！所以，#nav li 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的li，然后再去确定它的父元素是不是#nav。，因此，写css的时候需要注意：<br>　　1、dom深度尽量浅。<br>　　2、减少<code>inline javascript、css</code>的数量。<br>　　3、使用现代合法的css属性。<br>　　4、不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。<br>　　5、避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;<code>#tp p{}</code>子选择符：<code>#tp&gt;p{}`</code><br>　　6、避免使用通配符，举一个例子，<code>.mod .hd *{font-size:14px;}</code>根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配<code>.hd</code>（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知.</p><h6 id="关于Script标签位置"><a href="#关于Script标签位置" class="headerlink" title="关于Script标签位置"></a>关于Script标签位置</h6><p><strong>Javascript的加载和执行的特点： </strong><br>　　（1）载入后马上执行；<br>　　（2）执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）。原因：因为浏览器需要一个稳定的DOM树结构，而JS中很有可能有 代码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修 改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现。</p><h6 id="减少JavaScript对性能的影响"><a href="#减少JavaScript对性能的影响" class="headerlink" title="减少JavaScript对性能的影响"></a>减少JavaScript对性能的影响</h6><p>　　（1）将所有的script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染。<br>　　（2）尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。<br>　　（3）采用无阻塞下载 JavaScript 脚本的方法：<br>　　　　（1）使用script标签的 defer 属性（仅适用于 IE 和 Firefox 3.5 以上版本）；<br>　　　　（2）使用动态创建的script元素来下载并执行代码；</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器渲染流程" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>BFC&amp;IFC&amp;GFC&amp;FFC</title>
    <link href="http://yoursite.com/2019/03/29/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/BFC&amp;IFC/"/>
    <id>http://yoursite.com/2019/03/29/页面布局/BFC&amp;IFC/</id>
    <published>2019-03-29T06:59:04.000Z</published>
    <updated>2019-03-29T12:40:16.580Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>　　对CSS有了解的道友们肯定都知道盒式模型这个概念，对一个元素设置CSS，首先需要知道这个元素是block还是inline类型。而BFC就是用来格式化块级盒子，同样管理inline类型的盒子还有IFC，以及其他的FC。那首先我们就来看一下FC的概念。<br>　　<code>Formatting Context</code>：指页面中的一个渲染区域，并且拥有一套渲染规则，他<code>决定了其子元素如何定位</code>，以及<code>与其他元素的相互关系和作用</code>。<br>　　BFC：<code>块级格式化上下文</code>，它是指一个独立的块级渲染区域，只有Block-level BOX参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。</p><h4 id="BFC生成"><a href="#BFC生成" class="headerlink" title="BFC生成"></a>BFC生成</h4><p>BFC(Block Formatting Context)是Web页面中盒模型布局的CSS渲染模式。它属于常规文档流。<br>CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC:<br>（1）float的值不为none<br>（2）position的值为<code>absolute</code>或者<code>fixed</code><br>（3）display的值为<code>table-cell</code>、<code>table-caption</code>、<code>inline-block</code>、<code>flex</code>或者<code>inline-flex</code>的其中一个<br>（4）overflow的值不为<code>visible</code></p><h4 id="BFC的约束规则"><a href="#BFC的约束规则" class="headerlink" title="BFC的约束规则"></a>BFC的约束规则</h4><p>浏览器对于BFC这块区域的约束规则如下：<br>　　生成BFC元素的子元素会一个接一个的放置。垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的margin特性。在BFC中相邻的块级元素外边距会折叠。<br>　　生成BFC元素的子元素中，每一个子元素做外边距与包含块的左边界相接触，（对于从右到左的格式化，右外边距接触右边界），即使浮动元素也是如此（尽管子元素的内容区域会由于浮动而压缩），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。<br>有道友对它做了分解，我们直接拿来：<br>　　（1）内部的Box会在<code>垂直方向</code>上一个接一个的放置<br>　　（2）垂直方向上的距离由<code>margin</code>决定。（完整的说法是：<code>属于同一个BFC的两个相邻Box的margin会发生重叠</code>，<code>与方向无关</code>。）<br>　　（3）每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）<br>　　（4）BFC的区域不会与<code>float box</code>的元素区域重叠<br>　　（5）计算BFC的高度时，浮动子元素也参与计算<br>　　（6）BFC就是页面上的一个<code>隔离的独立容器</code>，容器里面的子元素<code>不会影响</code>到外面元素，反之亦然</p><h4 id="BFC的用处"><a href="#BFC的用处" class="headerlink" title="BFC的用处"></a>BFC的用处</h4><h5 id="防止发生因浮动导致的高度塌陷"><a href="#防止发生因浮动导致的高度塌陷" class="headerlink" title="防止发生因浮动导致的高度塌陷"></a>防止发生因浮动导致的高度塌陷</h5><h6 id="防止margin重叠"><a href="#防止margin重叠" class="headerlink" title="防止margin重叠"></a>防止margin重叠</h6><p>　　同一个BFC中的两个相邻Box才会发生重叠与方向无关，不过由于上文提到的第一条限制，我们甚少看到水平方向的margin重叠。这在IE中是个例外，IE可以设置write-mode<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">"first-block"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"second-block"</span>&gt;</span><br><span class="line">    &lt;h2&gt;DDFE&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># css</span></span><br><span class="line">.first-block &#123;</span><br><span class="line">    background: <span class="comment">#F44336;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.second-block &#123;</span><br><span class="line">    background: <span class="comment">#00BCD4;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    overflow: hidden;   //添加溢出隐藏</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>first-block和second-block之间存在间距，这个间距是 h2 的上外边距引起的<br>通过把 overflow 把 second-block 元素形成一个 BFC，完美解决！</p><p><strong>CSS 里面关于折叠的条件：</strong><br>两个块元素要产生折叠现象，必须满足一个必备条件：这两个元素的 margin 必须是 相邻 的；那么如果定义相邻呢，w3c 规范，两个 margin 是邻接的必须满足以下条件：<br>必须是处于常规文档流（非float和绝对定位）的块级盒子,并且处于同一个 BFC 当中。<br>没有inline盒子，没有空隙，没有 padding 和 border 将他们分隔开。</p><h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><p>　　在一个IFC中，从父级元素的顶部开始，盒子一个接一个横向排列。此时，横向的margin、borders、padding在这些盒子中都是有效的。这些盒子有可能通过不同的方式垂直对齐：1、他们底部或者顶部可以对齐，2、或者可以他们内部的文字基线可以对齐。如果一个矩形区域，包含着一些排成一条线的盒子，称为line box。</p><h4 id="什么是IFC"><a href="#什么是IFC" class="headerlink" title="什么是IFC"></a>什么是IFC</h4><p>　　IFC(Inline Formatting Contexts)直译为”<code>行内格式化上下文</code>“，IFC的line box（线框）<code>高度由其包含行内元素中最高的实际高度计算而来</code>(不受到竖直方向的 padding/margin 影响)</p><h4 id="IFC特性"><a href="#IFC特性" class="headerlink" title="IFC特性"></a>IFC特性</h4><p>　　IFC中的linebox一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。<br>　　IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。</p><h4 id="IFC的应用"><a href="#IFC的应用" class="headerlink" title="IFC的应用"></a>IFC的应用</h4><p>　　水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。<br>　　垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</p><p>参考文章：<br>　　<a href="https://www.cnblogs.com/dojo-lzz/p/3999013.html" target="_blank" rel="noopener">我对BFC的理解</a><br>　　<a href="https://juejin.im/post/583bb606a22b9d006c141286" target="_blank" rel="noopener">细说CSS中的BFC</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="页面布局" scheme="http://yoursite.com/tags/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/29/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2019/03/29/页面布局/流式布局/</id>
    <published>2019-03-29T06:50:47.529Z</published>
    <updated>2019-03-29T06:50:49.470Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端知识点</title>
    <link href="http://yoursite.com/2019/03/27/JavaScript/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2019/03/27/JavaScript/前端知识点/</id>
    <published>2019-03-27T09:31:52.000Z</published>
    <updated>2019-03-27T13:48:49.776Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><ul><li>HTML+CSS布局<ul><li>内容+样式 基础<ul><li>重点了解布局、流</li><li>less、sass、stylus</li></ul></li></ul></li><li>CSS<ul><li>px、em、rem、vw、vh</li><li>设置html的font-size大小，统一标准</li><li>小程序单位rpx</li></ul></li><li>布局<ul><li>相对、绝对</li><li>流式、响应式布局</li><li>flex布局</li></ul></li><li>CSS3<ul><li>透明度、文字阴影、圆角、渐变色</li><li>盒阴影、边框图片、媒体查询</li><li>transition过渡、transform变形、animation动画</li></ul></li><li>CSS优化<ul><li>选择器原理: 从右向左</li><li>避免后台、链式、重复</li><li>避免!important</li></ul></li><li>BFC &amp; IFC<ul><li>float不是none，绝对定位，表格，overflow不是visable，flex盒子</li><li>创建BFC后，元素会一个个的摆放</li><li>外边距折叠<ul><li>最常见的：<code>overflow:hidden</code>、 <code>float:left/right</code>、 <code>position: absolut、</code></li></ul></li></ul></li><li>ES6 &amp; ES7<ul><li>let、const、解构(结构)、</li><li>箭头函数、SymboL、Set</li><li>Proxy、Class、generator、模块化</li></ul></li><li>函数<ul><li>默认参数、返回值、原型链</li><li>箭头函数、this、作用域、闭包、bind、apply</li><li>高阶函数、递归、Decorator、Compose、Currying…</li></ul></li><li>面向对象<ul><li>class、实例方法、静态属性和方法</li><li>构造函数、super</li><li>继承</li></ul></li><li>JS异步<ul><li>解决回调<ul><li>Promise</li><li>Generator</li><li>Async + await</li></ul></li></ul></li><li>模块化<ul><li>最早期AMD、CMD、commonjs</li><li>import export</li><li>ES6加载原理和node加载原理</li></ul></li><li>面试题<ul><li>Promise相当于一个状态机<ul><li>pending、rejected、fulfilled状态</li><li>维护callback队列</li><li><a href="https://juejin.im/post/5c41297cf265da613356d4ec" target="_blank" rel="noopener">掘金</a></li></ul></li></ul></li><li>Vue<ul><li>Vue-cli3.0+</li><li>组件化通讯<ul><li>父子组件 props $emit 兄弟组件可以让父母代理中转</li><li>祖先后代关系eventbus 或者自己实现dispath&amp;boardcast</li><li>没关系eventbus或者Vuex</li></ul></li><li>生命周期</li><li>组件化设计</li><li>源码</li><li>全家桶、服务端渲染</li><li>复用.Vue组件<ul><li>props、event、slot</li><li>手动挂载的组件$emit</li><li>递归组件和动态组件</li></ul></li><li>双向绑定<ul><li>Object.defineProperty</li><li>依赖机制</li><li>异步更新队列</li></ul></li><li>Vuex + vue-router<ul><li>单页应用 依赖加载模块</li><li>vue单行数据流</li><li>数据交给专门的store管理，全局数据中心、</li></ul></li><li>服务端渲染<ul><li>服务端解析vue组件成html渲染首屏<ul><li>速度</li><li>SEO</li><li>nuxt.js</li></ul></li></ul></li></ul></li><li>Typescript<br>+ </li><li>Webpack<ul><li>基础配置</li><li>性能优化，缩小搜索范围，DllPlugin，多进程、tree-shaking，代码抽取，按需加载</li><li>定制loader和plugin<ul><li>loader定义自己的转换规则</li><li>plugin 整个webpack工作流程定义，有一个apply方法获取compiler对象</li><li>loader单一职责，链式组合，模块化，无状态</li></ul></li><li>plugin<ul><li>修改输出资源</li><li>读取模块和依赖</li><li>监听文件变化</li></ul></li></ul></li><li>异步</li><li>浏览器</li><li>性能优化<ul><li>抛开场景谈优化，就是耍流氓</li><li>常见性能优化策略,文件少加载，代码少执行，多用缓存，少计算，</li><li>性能如何分析 devtools代码打包压缩，图片压缩，gzip，缓存，<br>cdn，SSR，框架对应的优化策略，lazy-load,节流防抖</li></ul></li></ul><p>服务端渲染</p><ul><li>安全<ul><li>常见漏洞，如何防御</li><li>XSS、CSRF、Cookie劫持、点击劫持</li><li>传输安全、接入层</li><li>Oauth</li></ul></li><li>多端（Node，小程序，App）<ul><li>微信小程序</li><li>测试</li><li>微服务</li><li>Node.js </li><li>监控</li><li>部署</li><li>自动化</li><li>云开发</li><li>RN flutter</li><li>小程序生态</li></ul></li><li>nodejs<ul><li>Node核心概念<ul><li>events，fs，stream，buffer</li><li>IO，event-loop，线程池</li><li>libuv，V8</li></ul></li><li>Node应用场景<ul><li>Express、Koa等web开方</li><li>自动化，微服务</li><li>express/koa网站</li><li>前端工具 </li><li>webpack/ gulp</li><li>API/hapi</li><li>跨平台/ electron</li><li>区块链/ ipfs</li><li>命令行工具/ </li><li>shell.js</li><li>Express/koa代理</li><li>硬件/ ruff</li><li>微服务 </li><li>企业级框架eggj</li><li>实时/socket.io</li></ul></li></ul></li><li>Event-loop<ul><li>代码到底咋执行的<ul><li>执行微任务 比如promise</li><li>同步代码，完事之后查询是否有异步</li><li>执行宏任务，setTimeout,SetImmediate,等</li></ul></li></ul></li><li>自动化测试</li><li>代码的健壮性，改代码不再胆战心惊<ul><li>E2E测试Puppeteer，代码覆盖率istanbul</li><li>单元测试，mocha，jest ，jasmine </li><li>测试驱动开发TDD，先写测试，再写代码</li></ul></li><li>前端监控<ul><li>对运行状况了然于胸<ul><li>前端错误监控 onerror Sentry</li><li>前端性能监控 性能参数 berserkJS 屏幕补货，网络监控</li><li>上报 img 的src</li></ul></li></ul></li><li>浏览器<ul><li>最重要的一端<ul><li>缓存机制<ul><li>性能优化重要策略</li><li>memory cache，disk cache</li><li>网络请求，强缓存弱缓存</li></ul></li><li>如何渲染的<ul><li>收到html=》解析dom树</li><li>css =&gt; css 树 和dom结合 形成render tree 开始渲染</li><li>少操作dom，重绘回流</li></ul></li><li>输入url发生了啥</li></ul></li></ul></li><li>部署<ul><li>项目总要上线<ul><li>Nginx</li><li>Pm2</li><li>Docker + 自动化</li></ul></li></ul></li><li>特殊场景<ul><li>不算通用能力，但是特殊业务需求<ul><li>可视化 echarts (canvas)，d3(svg)，three.js(webgl)</li><li>小游戏</li><li>PS切图</li></ul></li></ul></li><li>软件工程师<ul><li>算法<ul><li>排序 搜索 遍历</li><li>贪婪</li><li>动态规划</li></ul></li><li>编译原理</li><li>设计模式</li><li>网络协议</li><li>数据库</li><li>数据结构<ul><li>数组、字符串、队列、堆、链表</li><li>二叉树</li><li>图</li></ul></li><li>软件工程</li><li>数学基础</li><li>编码</li></ul></li><li>网络协议<ul><li>IP</li><li>TCP/UDP</li><li>HTTP / HTTPS / SSH / FTP </li></ul></li><li>设计模式<ul><li>常见设计模式，单例，装饰器，代理，观察者，发布订阅</li><li>前端常用的设计模式</li><li>如何使用、不要滥用</li></ul></li><li>数据库<ul><li>Mysql 关系型数据库，多表join</li><li>Mongodb json数据库</li><li>Redis 内存数据库 速度快</li></ul></li><li><p>面试题</p><ul><li>跨域方案</li><li>强缓存弱缓存</li><li>输入url发生啥<ul><li>DNS解析 ， 三次握手，建立链接</li><li>接受相应，查库查文件，等待数据返回，拼接响应报文</li><li>浏览器接受报文，解析html 渲染页面</li></ul></li><li>渲染原理</li><li>业余干啥</li><li>可访问性</li><li>箭头函数优点</li><li>前后端分离JWT</li><li>垃圾回收</li></ul></li><li><p>基础vuejs</p><ul><li>组件通讯<ul><li>prop<ul><li>父组件通过 Prop 往子组件传递数据</li><li>Prop 让组件更加灵活</li><li>不要直接修改 Prop</li></ul></li><li>event<ul><li>子组件往当前实例上派发事件</li><li>子组件在父组件中使用，可以监听到该事件，并做出响应</li></ul></li><li>golbal event bus<ul><li>非父子组件通讯</li><li>可以基于新的 Vue 实例实现</li></ul></li><li>Vuex<ul><li>非父子组件通讯（数据共享）</li><li>数据状态管理</li></ul></li></ul></li><li>插槽<ul><li>普通插槽<ul><li>组件的实现更加灵活</li><li>内容分发</li><li>插槽访问的数据作用域是父组件</li></ul></li><li>作用域插槽<ul><li>插槽可以访问到子组件中的数据</li></ul></li></ul></li><li>过度动画<ul><li>触发条件<ul><li>Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡：<ul><li>条件渲染 (使用 v-if)</li><li>动态组件</li><li>条件展示 (使用 v-show)</li><li>组件根节点</li></ul></li></ul></li><li>过渡类名<ul><li>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <code>&lt;transition&gt;</code>，则 v- 是这些类名的默认前缀。如果你使用了 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code>，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code></li><li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除</li><li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li><li><code>v-enter-to</code>：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时<code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li><li><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li><li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li><li><code>v-leave-to</code>：定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除</li></ul></li><li>JavaScript 钩子<ul><li>可以在属性中声明J<code>avaScript</code> </li><li>当只用 <code>JavaScript</code> 过渡的时候，在 <code>enter</code> 和 <code>leave</code> 中必须使用<code>done</code> 进行回调。否则，它们将被同步调用，过渡会立即完成。</li><li>推荐对于仅使用 <code>JavaScript</code> 过渡的元素添加 <code>v-bind:css=&quot;false&quot;</code>，<code>Vue</code> 会跳过 <code>CSS</code> 的检测。这也可以避免过渡过程中 <code>CSS</code> 的影响。</li></ul></li></ul></li><li>DOM操作<ul><li>操作CSS<ul><li>某些交互可以通过手动操作CSS 做精细的控制</li></ul></li><li>配合原生JS库使用<ul><li>与原生 JS 库配合使用，再做一层 Vue 化的封装</li><li>cube-ui 对 better-scroll 的封装</li><li>element-ui 对 popper.js 的封装</li></ul></li></ul></li><li>组件封装<ul><li>就近管理<ul><li>单文件开发</li><li>依赖的静态资源放在同级目录</li><li>相关联组件也放在同级目录</li></ul></li><li>分层设计<ul><li>通过分层设计的思想设计复杂组件</li></ul></li><li>高度复用<ul><li>页面级别的复用（基础组件）</li><li>项目级别的复用 —私有组件库（业务组件）</li><li>公司级别的复用 —开源组件库（element-ui、cube-ui）</li></ul></li><li>灵活扩展<ul><li>组件设计要尽量灵活可扩展，除了提供丰富的 Props，还可以利用 slot插槽完成用户个性化定制需求）</li></ul></li></ul></li><li>Keep-alive<ul><li>使用场景<ul><li>保留组件状态或避免重新渲染</li><li>可以配合路由组件使用</li></ul></li><li>生命周期<ul><li>activated：组件激活时触发</li><li>deactivate：组件失活时触发</li></ul></li></ul></li><li>内存泄漏<ul><li>产生的原因<ul><li>未清理的定时器</li><li>未清理的全局注册的自定义事件</li><li>未清理的全局注册的 DOM 事件</li></ul></li><li>如何避免<ul><li>编写组件要有相关意识</li><li>检查是否有上述造成内存泄漏的可能</li><li>利用 beforeDestroy 生命周期函数，做对应的内存清理工作</li></ul></li></ul></li><li>错误回调<ul><li>常见的错误<ul><li>深层对象数据访问问题</li><li>对计算属性赋值</li><li>对 Prop 直接修改</li><li>使用了未注册的组件</li></ul></li><li>调试工具<ul><li>Chrome 开发者工具，学会查找错误堆栈</li><li>vue-devtools <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener">https://github.com/vuejs/vue-devtools</a></li><li>vConsole <a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">https://github.com/Tencent/vConsole</a></li></ul></li></ul></li><li>性能优化<ul><li>数据定义<ul><li>不需要把所有的数据都定义在 data 上，可以直接挂载到实例上</li></ul></li><li>按需加载<ul><li>对于首次渲染，我们只需要加载首屏渲染所需的资源，其他资源可以异步按需加载。这样可以减少首屏加载的资源包大小，加速渲染</li><li>异步组件<ul><li>异步组件——比如我们使用一些图标库，如 echart，我们可以考虑做成异步组件，单独打包</li></ul></li><li>异步路由<ul><li>异步路由——比如单页应用，我们的导航切换是基于路由切换，那么其他页面可以考虑做成异步路由</li></ul></li></ul></li><li>预渲染<ul><li>由于基于 Vue.js 的单页应用是由 Vue.js 渲染页面，所以页面下载后到渲染会有一定白屏时间</li><li>我们可以不依赖 JS，在页面下载后先渲染一张 Loading图片或者是骨架屏结构</li><li>当主页面渲染时，把这张占位图片或者结构隐藏</li><li>用户看到的不是白屏，有等待预期</li></ul></li><li>后编译<ul><li>编译代码冗余？</li><li>依赖包本身不编译，它的编译交给应用来做。通过修改 webpack 配置 rules 中的 include</li><li>后编译依赖嵌套？<ul><li>webpack-post-compile-plugin需要后编译的依赖包在 package.json 中声明<code>&quot;postCompile&quot;: true</code></li></ul></li><li>性能优化<ul><li>一份编译代码</li><li>主题定制</li><li>一份 ployfill</li><li>rem布局</li><li>NPM包无需编译发布</li></ul></li></ul></li></ul></li></ul></li><li>深入理解Vue.js<ul><li>Vue.js渲染原理</li><li>响应式实现原理</li><li>组件化实现原理</li></ul></li><li>前端工程<ul><li>脚手架<ul><li>Vue-cli 3.0<ul><li>是一个基于 Vue.js 进行快速开发的完整系统</li><li>通过 @vue/cli 搭建交互式的项目脚手架</li><li>通过 @vue/cli + @vue/cli-service-global 快速开始零配置原型开发</li><li>一个运行时依赖 (@vue/cli-service)</li><li>一个丰富的官方插件集合，集成了前端生态中最好的工具。</li><li>一套完全图形化的创建和管理 Vue.js 项目的用户界面</li></ul></li><li>插件化机制<ul><li>Vue CLI 使用了一套基于插件的架构。在项目创建的过程中，绝大部分列出的特性都是通过插件来实现的</li><li>插件可以帮助我们生成初始化代码， 安装指定的依赖包</li></ul></li><li>webpack 配置<ul><li>调整 webpack 配置最简单的方式就是在 vue.config.js中的 configureWebpack 选项提供一个对象</li><li>因为 @vue/cli-service 对 webpack 配置进行了抽象，所以理解配置中包含的东西会比较困难，可以通过下面命令查看 webpack 配置<code>vue inspect &gt; output.js</code></li></ul></li></ul></li><li>webpack<ul><li>现代 JavaScript 应用程序的静态模块打包器<ul><li>module<ul><li>开发者将程序分解成离散功能块（discrete chunks offunctionality），并称之为模块</li><li>每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。</li><li>精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的</li><li>前端模块化面对的挑战 —处理JS之外的静态资源、资源的依赖关系加载顺序、资源的请求和加载是异步的</li><li>ES2015 import 语句</li><li>CommonJS require() 语句</li><li>AMD define 和 require 语句</li><li>css/sass/less 文件中的 @import 语句</li><li>样式<code>(url(...))</code>或 HTML 文件<code>(&lt;img src=...&gt;)</code>中的图片链接<code>(image url)</code></li></ul></li><li>entry<ul><li>入口起点(entry point)指示 webpack应该使用哪个模块，来作为构建其内部依赖图的开始，webpack会找出有哪些模块和 library是入口起点（直接和间接）依赖的</li><li>多入口：数组结构</li><li>多入口：对象结构</li><li>多页面应用程序</li></ul></li><li>output<ul><li>配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。即使可以存在多个入口起点，也只指定一个输出配置</li><li>如果配置创建了多个单独的 “chunk”，则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。</li><li>线上运行时需要通过设置 public path 指向 CDN 地址</li></ul></li><li>loader<ul><li>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件</li><li><code>Typescript -&gt; JavaScript</code></li><li><code>Image -&gt; data URL</code></li><li><code>JavaScript import CSS</code></li><li>loader 支持链式传递</li><li>loader 可以是同步的，也可以是异步的</li><li>loader 运行在 Node.js 中，并且能够执行任何可能的操作</li><li>loader 能够使用options 对象进行配置</li><li>babel-loader 加载ES2015+ 代码，然后使用 Babel 转译为 ES5</li><li>style-loader 将模块的导出作为样式添加到 DOM 中</li><li>css-loader 解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码</li><li>less-loader 加载和转译 LESS 文件</li><li>file-loader 将文件发送到输出文件夹，并返回（相对）URL</li><li>url-loader 像 file loader 一样工作，但如果文件小于限制，可以返回 data URL</li><li>vue-loader 加载和转译 Vue 组件</li></ul></li><li>plugins<ul><li>插件比 loader 更加强大，可以帮助用户直接触及到编译过程。 插件可以将处理函数注册到编译过程中的不同时间点上运行的生命周期钩子函数上。</li><li>打包优化</li><li>资源管理</li><li>注入环境变量</li><li>CommonsChunkPlugin 提取 chunks 之间共享的通用模块</li><li>DefinePlugin 允许在编译时(compile time)配置的全局常量</li><li>ExtractTextWebpackPlugin 从 bundle 中提取文本（CSS）到单独的文件</li><li>UglifyjsWebpackPlugin 使用 UglifyJS 压缩 JS</li><li>HtmlWebpackPlugin 创建HTML文件来服务打包文件</li></ul></li></ul></li></ul></li><li>开发&amp;部署</li><li>开发阶段<ul><li>需求阶段<ul><li>前后端共同参与产品需求评审，并做一轮技术评审</li><li>技术评审过程中，梳理所有交互通讯的接口</li><li>把接口落地成文档，并约定好所有字段</li></ul></li><li>开发阶段<ul><li>前后端独立开发</li><li>前端伪造 mock 数据</li><li>可以使用 mock webpack 插件</li></ul></li><li>联调阶段<ul><li>预留联调的时间</li><li>前后端开发完成后开始联调</li><li>前端把接口请求指向后端的联调地址（可自动完成）</li></ul></li><li>上线阶段<ul><li>前端把接口请求指向后端的线上地址（可自动完成）</li><li>一定要后端先上线</li></ul></li></ul></li><li>部署流程<ul><li>预留联调的时间后端先上线 API 接口（若需要）</li><li>前端项目最终编译生成静态资源文件（HTML、JS、CSS 等）</li><li>增量发布，前端先全量上线 JS、CSS 等静态资源</li><li>前端接着上线模板 HTML，先发布到一台 pre 机器，QA 回归</li><li>回归通过后，逐步放量模板直至全量</li></ul></li></ul></li><li>知识点<ul><li>HTPP相关<ul><li>常见 HTTP 状态码</li><li>浏览器缓存原理</li><li>抓包工具（fiddler、charles）</li></ul></li><li>跨域<ul><li>CORS</li><li>JSONP</li></ul></li><li>性能优化<ul><li>性能监测：<a href="https://github.com/GoogleChrome/lighthouse" target="_blank" rel="noopener">https://github.com/GoogleChrome/lighthouse</a></li><li>数据埋点</li><li>雅虎军规：<a href="https://developer.yahoo.com/performance/rules.html、https://juejin.im/post/5b73ef38f265da281e048e51" target="_blank" rel="noopener">https://developer.yahoo.com/performance/rules.html、https://juejin.im/post/5b73ef38f265da281e048e51</a></li></ul></li><li>Web安全<ul><li>XSS</li><li>CSRF</li><li>HTTPS </li><li><a href="https://zhuanlan.zhihu.com/p/561228" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/561228</a></li></ul></li><li>数据结构&amp;算法<ul><li>栈/队列/树/ 图</li><li>排序/递归</li><li>算法设计技巧</li></ul></li><li>浏览器渲染原理<ul><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></li></ul></li><li>正则表达式<ul><li>匹配原理</li><li>基本语法</li><li>实用技巧</li></ul></li><li>设计模式<ul><li>订阅发布模式</li><li>工厂模式</li><li>适配器模式</li></ul></li><li>后端语言<ul><li>PHP</li><li>JAVA</li><li>Node.js</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端知识点" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>数据类型</title>
    <link href="http://yoursite.com/2019/03/27/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/27/JavaScript/数据类型/</id>
    <published>2019-03-27T07:25:30.000Z</published>
    <updated>2019-03-27T08:26:30.584Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>参考：<br>　　<a href="https://www.yuque.com/hoxz/frontend-map/vbfeaf" target="_blank" rel="noopener">类型检测</a></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p><code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Undefined</code>、<code>Null</code><br><strong>Number</strong><br>　　Number类型包含整数和浮点数（浮点数数值必须包含一个小数点，且小数点后面至少有一位数字）两种值。<a id="more"></a><br>NaN:非数字类型。特点：① 涉及到的 任何关于NaN的操作，都会返回NaN   ② NaN不等于自身。<br>isNaN() 函数用于检查其参数是否是非数字值。<br><code>isNaN(123)  //false   isNaN(&quot;hello&quot;)  //true</code><br><strong>String</strong><br>　　字符串有length属性。<br>字符串转换：转型函数String(),适用于任何数据类型（null,undefined 转换后为null和undefined）；toString()方法（null,defined没有toString()方法）。<br><strong>Boolean</strong><br>　　该类型只有两个值，true和false<br><strong>Undefined</strong><br>　　只有一个值，即undefined值。使用var声明了变量，但未给变量初始化值，那么这个变量的值就是undefined。<br><strong>Null</strong><br>　　null类型被看做空对象指针，前文说到null类型也是空的对象引用。</p><h5 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h5><p><code>Object</code><br>Object本质上是由一组无序的名值对组成的.<br>js中对象是一组属性与方法的集合。这里就要说到引用类型了，引用类型是一种数据结构，用于将数据和功能组织在一起。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p><code>Object</code>、<code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>等</p><h5 id="基本类型与引用类型"><a href="#基本类型与引用类型" class="headerlink" title="基本类型与引用类型"></a>基本类型与引用类型</h5><p>基本类型又叫原始类型（primitive type）<br>栈：原始数据类型（Undefined，Null，Boolean，Number、String）<br>堆：引用数据类型（Object、Array、Function）<br>两种类型的区别是：存储位置不同：<br>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>　　ECMAScript中用var关键字来定义变量，因为js是弱类型的，所以无法确定变量一定会存储什么值，也就不知道变量到底会是什么类型，而且变量的类型可以随时改变。<br>这就是ECMAScript是松散类型的来由，所谓松散类型就是可以用来保存任何类型的数据。<br>ps:<br>es6中新增了let命令来声明变量、const命令声明一个只读的常量。<br>let的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。<br>const一旦声明，常量的值就不能改变。</p><h4 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h4><p><code>typeof</code>、<code>Object.prototype.toString()</code></p><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof   2      输出   number</span><br><span class="line">typeof   null   输出   object</span><br><span class="line">typeof   &#123;&#125;    输出  object</span><br><span class="line">typeof   []    输出  object</span><br><span class="line">typeof   (<span class="function"><span class="title">function</span></span>()&#123;&#125;)   输出  <span class="keyword">function</span></span><br><span class="line">typeof   undefined        输出  undefined</span><br><span class="line">typeof   <span class="string">'222'</span>            输出  string</span><br><span class="line">typeof    <span class="literal">true</span>            输出   boolean</span><br></pre></td></tr></table></figure><h5 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h5><p>　　toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]]。<br>这是一个内部属性，其格式为 [object xxx] ，其中 xxx 就是对象的类型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var gettype=Object.prototype.toString;</span><br><span class="line"></span><br><span class="line">gettype.call(<span class="string">'aaaa'</span>)      输出     [object String]</span><br><span class="line">gettype.call(2222)        输出     [object Number]</span><br><span class="line">gettype.call(<span class="literal">true</span>)        输出     [object Boolean]</span><br><span class="line">gettype.call(undefined)   输出     [object Undefined]</span><br><span class="line">gettype.call(null)        输出     [object Null]</span><br><span class="line">gettype.call(&#123;&#125;)          输出     [object Object]</span><br><span class="line">gettype.call([])          输出     [object Array]</span><br><span class="line">gettype.call(<span class="function"><span class="title">function</span></span>()&#123;&#125;)     输出   [object Function]</span><br></pre></td></tr></table></figure></p><h5 id="封装可以分辨所有数据类型的方法"><a href="#封装可以分辨所有数据类型的方法" class="headerlink" title="封装可以分辨所有数据类型的方法"></a>封装可以分辨所有数据类型的方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> typeName = &#123;</span><br><span class="line">  <span class="string">'[object Function]'</span>: <span class="string">'function'</span>,</span><br><span class="line">  <span class="string">'[object Boolean]'</span>: <span class="string">'boolean - object'</span>,</span><br><span class="line">  <span class="string">'[object Number]'</span>: <span class="string">'number - object'</span>,</span><br><span class="line">  <span class="string">'[object String]'</span>: <span class="string">'string - object'</span>,</span><br><span class="line">  <span class="string">'[object Object]'</span>: <span class="string">'object'</span>,</span><br><span class="line">  <span class="string">'[object RegExp]'</span>: <span class="string">'regExp'</span>,</span><br><span class="line">  <span class="string">'[object Array]'</span>: <span class="string">'array'</span>,</span><br><span class="line">  <span class="string">'[object Error]'</span>: <span class="string">'error'</span>,</span><br><span class="line">  <span class="string">'[object Date]'</span> : <span class="string">'date'</span>  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Object的toString方法，通过call调用</span></span><br><span class="line"><span class="keyword">var</span> toStringFn = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkType</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( obj == <span class="literal">null</span> )&#123;</span><br><span class="line">    <span class="comment">//js自带的的String方法，用于检测null和undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>( obj );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//safari5及之前版本，Chrome7, typeof RegExp返回的是function</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span> ? typeName[toStringFn.call(obj)]:<span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">checkType(<span class="string">"123"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;参考：&lt;br&gt;　　&lt;a href=&quot;https://www.yuque.com/hoxz/frontend-map/vbfeaf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;类型检测&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h4&gt;&lt;h5 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h5&gt;&lt;p&gt;&lt;code&gt;Number&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;Undefined&lt;/code&gt;、&lt;code&gt;Null&lt;/code&gt;&lt;br&gt;&lt;strong&gt;Number&lt;/strong&gt;&lt;br&gt;　　Number类型包含整数和浮点数（浮点数数值必须包含一个小数点，且小数点后面至少有一位数字）两种值。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="数据类型" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>媒体查询</title>
    <link href="http://yoursite.com/2019/03/26/CSS3/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"/>
    <id>http://yoursite.com/2019/03/26/CSS3/媒体查询/</id>
    <published>2019-03-26T06:49:49.000Z</published>
    <updated>2019-03-26T09:31:29.509Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>css的媒体查询允许通过@media标签为特定媒体的浏览器设定样式，其中包含众多筛选，功能强大。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>　　HTML4和CSS2支持为不同的媒体类型指定专用的样式表，<code>screen</code>和<code>print</code>, <code>projection</code>是已定义的媒体类型<br>媒体查询由 媒体类型 和 一个或多个检测媒体特性的的条件表达式组成。<a id="more"></a><br>相对于CSS2只支持对媒体类型进行判断，<code>媒体查询</code>增加了<code>媒体特性</code>的判断，能够更准确地根据设备特性指定专用的样式。</p><h4 id="语法逻辑"><a href="#语法逻辑" class="headerlink" title="语法逻辑"></a>语法逻辑</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和</span></span><br><span class="line">and</span><br><span class="line"><span class="comment"># 也就是 or 的逻辑</span></span><br><span class="line">,</span><br><span class="line"><span class="comment"># 对查询结果取反</span></span><br><span class="line">not</span><br><span class="line"><span class="comment"># only操作符仅在媒体查询匹配成功的情况下被用于应用一个样式，</span></span><br><span class="line"><span class="comment"># 这对于防止让选中的样式在老式浏览器中被应用到。</span></span><br><span class="line">only</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>　　媒体查询包含一个可选的媒体类型和媒体特性表达式(0或多个)最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示文档所使用的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># link元素中的CSS媒体查询</span></span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> media=<span class="string">"(max-width: 800px)"</span> href=<span class="string">"example.css"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 样式表中的CSS媒体查询</span></span><br><span class="line">&lt;style&gt;</span><br><span class="line">@media (max-width: 600px) &#123;</span><br><span class="line">  .facet_sidebar &#123;</span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h5 id="使用媒体类型"><a href="#使用媒体类型" class="headerlink" title="使用媒体类型"></a>使用媒体类型</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> href=<span class="string">"site.css"</span> media=<span class="string">"screen"</span> /&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> href=<span class="string">"print.css"</span> media=<span class="string">"print"</span> /&gt;</span><br></pre></td></tr></table></figure><p><strong>media 属性定义了应该用于指定每种媒体类型的样式表：</strong><br>　　<code>screen</code> 适用于计算机彩色屏幕。<br>　　<code>print</code> 适用于打印预览模式下查看的内容或者打印机打印的内容。<br>　　作为 CSS v3 规范的一部分，可以扩展媒体类型函数，并允许在样式表中使用更精确的显示规则。媒体查询 是评估 True 或 False 的一种表达。如果为 True，则继续使用样式表。如果为 False，则不能使用样式表。这种简单逻辑通过表达式变得更加强大，使您能够更灵活地对特定的设计场景使用自定义的显示规则。</p><h5 id="媒体查询规则"><a href="#媒体查询规则" class="headerlink" title="媒体查询规则"></a>媒体查询规则</h5><p><code>@media all and (min-width: 800px) { ... }</code><br><code>@media all</code> 是媒体类型，也就是说，将此 <code>CSS</code> 应用于所有媒体类型<br><code>(min-width:800px)</code> 是包含媒体查询的表达式，如果浏览器的最小宽度为 800 像素，则会告诉浏览器只运用下列 <code>CSS</code>。<br><strong>请注意</strong>:可以省略关键词 <code>all</code> 和 <code>and</code>。在将某个媒体查询应用于所有媒体类型时，会省略<code>all</code>。后面的 <code>and</code> 也是可选的。使用简写语法重新编写媒体查询</p><h5 id="简写语法"><a href="#简写语法" class="headerlink" title="简写语法"></a>简写语法</h5><p><code>@media (min-width:800px) { ... }</code></p><h5 id="复杂表达式"><a href="#复杂表达式" class="headerlink" title="复杂表达式"></a>复杂表达式</h5><p>创建一个仅在最小宽度为 800 像素且最大宽度为 1200 像素时应用的样式<br><code>@media (min-width:800px) and (max-width:1200px) { ... }</code></p><h5 id="and-条件"><a href="#and-条件" class="headerlink" title="and 条件"></a>and 条件</h5><p>在您的表达式中，您可以根据自己的喜好使用任意数量的 and 条件。如果您想要增加其他条件来检查特定的屏幕方向，只需添加另一个 and 关键词，后跟 orientation 媒体查询.<br><code>@media (min-width:800px) and (max-width:1200px) and (orientation:portrait) { ... }</code><br>仅在宽度为 800 到 1200 像素且方向是纵向时才能激活.</p><h5 id="or-关键词"><a href="#or-关键词" class="headerlink" title="or 关键词"></a>or 关键词</h5><p>and 关键词的反义词是 or 关键词。和 and 一样，这些条件组合在一起会构成复杂表达式。如果其中有一个条件为 True，那么整个表达式或分离的两个条件都会为 True，如清单 6 所示。<br><code>@media (min-width:800px) or (orientation:portrait) { ... }</code><br>如果宽度至少是 800 像素或方向是纵向的，则会应用该规则。</p><h5 id="使用-not"><a href="#使用-not" class="headerlink" title="使用 not"></a>使用 not</h5><p><code>@media not all and (min-width: 800px) { ... }</code><br><code>@media not (all and (min-width: 800px)) { ... }</code><br>当最小宽度不是 800 像素时，会应用下列 CSS 规则。这些示例只是将像素作为媒体查询中的测量单位，但是测量单位并不仅限于像素。您可以使用任何有效的 CSS 测量单位，比如厘米 (cm)、英寸 (in)、毫米 (mm) 等。</p><h5 id="only"><a href="#only" class="headerlink" title="only"></a>only</h5><p><code>@media only (min-width: 300px) { ... }</code></p><h4 id="有用的媒体特性"><a href="#有用的媒体特性" class="headerlink" title="有用的媒体特性"></a>有用的媒体特性</h4><h5 id="orientation-媒体查询"><a href="#orientation-媒体查询" class="headerlink" title="orientation 媒体查询"></a>orientation 媒体查询</h5><p>方向： <code>orientation</code><br>值为：横排方向（ <code>landscape</code>）竖排方向（<code>portrait</code>）<br><code>@media (orientation: portrait) { ... }</code><br>高度和宽度行为十分相似，都支持以 min- 和 max- 为前缀</p><h5 id="高度和宽度媒体查询"><a href="#高度和宽度媒体查询" class="headerlink" title="高度和宽度媒体查询"></a>高度和宽度媒体查询</h5><p><code>@media (min-width:800px) and (min-height:400px) { ... }</code></p><h5 id="不带-min-和-max-前缀"><a href="#不带-min-和-max-前缀" class="headerlink" title="不带 min- 和 max- 前缀"></a>不带 min- 和 max- 前缀</h5><p><code>@media (width:800px) and (height:400px) { ... }</code></p><h4 id="媒体属性特征"><a href="#媒体属性特征" class="headerlink" title="媒体属性特征"></a>媒体属性特征</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前缀`min-`表示“至少”，即“大于等于”的意思。</span><br><span class="line">前缀`max-`表示“至多”，即“小于等于”的意思。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">width: 视口宽度</span><br><span class="line">height: 视口高度</span><br><span class="line">device-width: 渲染表面的高度(设备高度)</span><br><span class="line">device-height: 渲染表面的宽度(设备宽度)</span><br><span class="line">orientation: 检测设备是处于横向(landscape)还是纵向(portrait)</span><br><span class="line">aspect-ratio: 基于视口宽度和高度的宽高比</span><br><span class="line">device-aspect-ratio: 基于设备渲染表面的宽度和高度的宽高比</span><br><span class="line">color: 每种颜色的位数</span><br><span class="line">color-index: 设备的颜色索引表中的颜色数</span><br><span class="line">monochrome: 检测单色帧缓冲区中每像素所使用的位数</span><br><span class="line">resoluion: 用来检测屏幕和打印机的分辨率,dpi/dpcm</span><br><span class="line">scan: 电视机的扫描方式,逐行扫描(progressive)或隔行扫描(interlace)</span><br><span class="line">grid: 用来检测输出设备是网格设备还是位图设备</span><br></pre></td></tr></table></figure><p>参考：<br>　　<a href="https://www.ibm.com/developerworks/cn/web/wa-cssqueries/" target="_blank" rel="noopener">使用 CSS 媒体查询创建响应式网站</a><br>　　<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#-moz-device-pixel-ratio" target="_blank" rel="noopener">CSS媒体查询</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;css的媒体查询允许通过@media标签为特定媒体的浏览器设定样式，其中包含众多筛选，功能强大。&lt;/p&gt;
&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;　　HTML4和CSS2支持为不同的媒体类型指定专用的样式表，&lt;code&gt;screen&lt;/code&gt;和&lt;code&gt;print&lt;/code&gt;, &lt;code&gt;projection&lt;/code&gt;是已定义的媒体类型&lt;br&gt;媒体查询由 媒体类型 和 一个或多个检测媒体特性的的条件表达式组成。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>mate标签</title>
    <link href="http://yoursite.com/2019/03/26/H5/mate%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2019/03/26/H5/mate标签/</id>
    <published>2019-03-26T01:38:01.000Z</published>
    <updated>2019-03-26T02:34:04.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载:<br>　　<a href="https://juejin.im/post/5b94d8965188255c5a0cdc02#heading-4" target="_blank" rel="noopener">2018前端面试总结，看完弄懂，工资少说加3K | 掘金技术征文</a><br>参考:<br>　　<a href="https://www.cnblogs.com/2050/p/3877280.html" target="_blank" rel="noopener">移动前端开发之viewport的深入理解</a><br><code>&lt;mate&gt;</code>标签: 提供页面的元信息但和内容无关，元数据可以被浏览器、搜索引擎和其他web服务器使用。<a id="more"></a></p><p>mate两种属性：http-equiv和name<br>　　<code>http-equiv</code> 相当于HTTP头<br>　　<code>content-type</code> 定义文档的字符集<br>　　<code>&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</code><br>　　<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code><br>　　<code>expires</code>网页到期时间<br>　　<code>&lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri, 12 Jan 2001 18:18:18 GMT&quot;&gt;</code><br>　　<code>X-UA-Compatible</code> 浏览器采取何种版本渲染当前页面<br>　　<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;</code><br>　　指定IE和Chrome使用最新版本渲染当前页面<br>　　<code>cache-control</code> 指定请求和响应遵循的缓存机制<br>　　<code>refresh</code> 自动刷新，病指向某个页面<br>　　<code>&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2; URL=http://www.root.net&quot;&gt;</code><br>　　<code>set-cookie</code> 设置cookie<br>　　<code>&lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx; expires=Friday, 12-Jan-2001 18:18:18 GMT; path=/&quot;&gt;</code><br>　　<code>cleartype</code>只对IE有用，用于平滑字体,不推荐使用<br>　　<code>&lt;!--[if IEMobile]&gt;&lt;meta http-equiv=&quot;cleartype&quot; content=&quot;on&quot;&gt;&lt;![endif]--&gt;`</code><br><code>name</code> 描述网页<br>　　<code>author</code> 作者<br>　　<code>&lt;meta name=&quot;author&quot; content=&quot;xx@xx&quot;&gt;</code><br>　　<code>description</code> 描述，网站主要内容<br>　　<code>&lt;meta name=&quot;description&quot; content=&quot;This page is about&quot;&gt;</code><br>　　<code>keywords</code> 关键字，搜索引擎会使用这些关键字分类<br>　　<code>&lt;meta name =&quot;keywords&quot; content=&quot;science, education&quot;&gt;</code><br>　　<code>renderer</code> 双核浏览器渲染方式，指定以哪种渲染方式<br>　　<code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</code><br>　　<code>viewport</code>视口，定义设备的大小<br>　　<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</code><br>　　<code>HandheldFriendly</code>针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓<br>　　<code>&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;True&quot;&gt;</code><br>　　<code>MobileOptimized</code> 微软为IE Mobile版设置的定义宽度标记<br>　　<code>&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;</code><br>　　<code>apple-mobile-web-app-capable</code> 是否启动webapp功能（全屏），会删除默认的苹果工具栏和菜单栏。<br>　　<code>apple-mobile-web-app-capable</code><br>　　<code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</code><br>　　<code>apple-mobile-web-app-status-bar-style</code> 当启动webapp功能时，手机顶部导航栏的颜色<br>　　<code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;</code><br>　　<code>apple-mobile-web-app-title</code> 添加到主屏后的标题<br>　　<code>&lt;meta name=&quot;apple-mobile-we-app-title&quot; content=&quot;&quot;&gt;</code><br>　　<code>format-detection</code> 格式检测，识别页面中的电话号码<br>　　<code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</code><br>　　<code>format-detection</code> 格式检测，识别页面中的email<br>　　<code>&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;&gt;</code></p><p><strong>viewPort</strong><br>|属性|作用|<br>|—-|—–|<br>|width| 设置layout viewport  的宽度，为一个正整数，或字符串”width-device”|<br>|initial-scale| 设置页面的初始缩放值，为一个数字，可以带小数|<br>|minimum-scale| 允许用户的最小缩放值，为一个数字，可以带小数|<br>|maximum-scale| 允许用户的最大缩放值，为一个数字，可以带小数|<br>|height | 设置layout viewport  的高度，这个属性对我们并不重要，很少使用|<br>|user-scalable | 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许|</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># H5标准声明，使用 HTML5 doctype，不区分大小写</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="comment"># 标准的 lang 属性写法</span></span><br><span class="line">&lt;head lang=”en”&gt;</span><br><span class="line"><span class="comment"># 声明文档使用的字符编码</span></span><br><span class="line">&lt;meta charset=’utf-8′&gt;</span><br><span class="line"><span class="comment"># 优先使用 IE 最新版本和 Chrome</span></span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt;   </span><br><span class="line"><span class="comment"># 页面描述</span></span><br><span class="line">&lt;meta name=”description” content=”不超过150个字符”/&gt;</span><br><span class="line"><span class="comment"># 页面关键词</span></span><br><span class="line">&lt;meta name=”keywords” content=””/&gt;</span><br><span class="line"><span class="comment"># 网页作者</span></span><br><span class="line">&lt;meta name=”author” content=”name, email@gmail.com”/&gt;</span><br><span class="line"><span class="comment"># 搜索引擎抓取</span></span><br><span class="line">&lt;meta name=”robots” content=”index,follow”/&gt;</span><br><span class="line"><span class="comment"># 为移动设备添加 viewport</span></span><br><span class="line">&lt;meta name=”viewport” content=”initial-scale=1,</span><br><span class="line">maximum-scale=3, minimum-scale=1, user-scalable=no”&gt;</span><br><span class="line"><span class="comment"># iOS 设备 begin</span></span><br><span class="line">&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt;</span><br><span class="line"><span class="comment"># 添加到主屏后的标题（iOS 6 新增）</span></span><br><span class="line">&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt;</span><br><span class="line"><span class="comment"># 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏</span></span><br><span class="line">&lt;meta name=”apple-itunes-app” </span><br><span class="line">content=”app-id=myAppStoreID,</span><br><span class="line"> 1affiliate-data=myAffiliateData, app-argument=myURL”&gt;</span><br><span class="line"><span class="comment"># 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）</span></span><br><span class="line">&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;</span><br><span class="line"><span class="comment"># 设置苹果工具栏颜色</span></span><br><span class="line">&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt;  </span><br><span class="line"><span class="comment"># 启用360浏览器的极速模式(webkit)</span></span><br><span class="line">&lt;meta name=”renderer” content=”webkit”&gt; </span><br><span class="line"><span class="comment"># 避免IE使用兼容模式</span></span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt;</span><br><span class="line"><span class="comment"># 不让百度转码</span></span><br><span class="line">&lt;meta name=”HandheldFriendly” content=”<span class="literal">true</span>”&gt;</span><br><span class="line"><span class="comment"># 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓</span></span><br><span class="line">&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt;</span><br><span class="line"><span class="comment"># 微软的老式浏览器</span></span><br><span class="line">&lt;meta name=”MobileOptimized” content=”320″&gt;</span><br><span class="line"><span class="comment"># uc强制竖屏</span></span><br><span class="line">&lt;meta name=”screen-orientation” content=”portrait”&gt;</span><br><span class="line"><span class="comment"># QQ强制竖屏</span></span><br><span class="line">&lt;meta name=”x5-orientation” content=”portrait”&gt;</span><br><span class="line"><span class="comment"># UC强制全屏</span></span><br><span class="line">&lt;meta name=”full-screen” content=”yes”&gt;</span><br><span class="line"><span class="comment"># QQ强制全屏</span></span><br><span class="line">&lt;meta name=”x5-fullscreen” content=”<span class="literal">true</span>”&gt;</span><br><span class="line"><span class="comment"># UC应用模式</span></span><br><span class="line">&lt;meta name=”browsermode” content=”application”&gt;</span><br><span class="line"><span class="comment"># QQ应用模式</span></span><br><span class="line">&lt;meta name=”x5-page-mode” content=”app”&gt;</span><br><span class="line"><span class="comment"># windows phone 点击无高光</span></span><br><span class="line">&lt;meta name=”msapplication-tap-highlight” content=”no”&gt;</span><br><span class="line">设置页面不缓存</span><br><span class="line">&lt;meta http-equiv=”pragma” content=”no-cache”&gt;</span><br><span class="line">&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;</span><br><span class="line">&lt;meta http-equiv=”expires” content=”0″&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载:&lt;br&gt;　　&lt;a href=&quot;https://juejin.im/post/5b94d8965188255c5a0cdc02#heading-4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2018前端面试总结，看完弄懂，工资少说加3K | 掘金技术征文&lt;/a&gt;&lt;br&gt;参考:&lt;br&gt;　　&lt;a href=&quot;https://www.cnblogs.com/2050/p/3877280.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移动前端开发之viewport的深入理解&lt;/a&gt;&lt;br&gt;&lt;code&gt;&amp;lt;mate&amp;gt;&lt;/code&gt;标签: 提供页面的元信息但和内容无关，元数据可以被浏览器、搜索引擎和其他web服务器使用。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/25/HTTP/TCP%E3%80%81UDP%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E3%80%81DNS/"/>
    <id>http://yoursite.com/2019/03/25/HTTP/TCP、UDP、套接字、DNS/</id>
    <published>2019-03-25T07:45:35.303Z</published>
    <updated>2019-03-27T08:31:13.655Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载：<br>　　<a href="https://juejin.im/post/5bbaa549e51d450e827b6b13#heading-0" target="_blank" rel="noopener">一篇文章搞定前端面试</a></p><p>TCP<br>UDP<br>套接字socket<br>HTTP协议<br>DNS解<br>HTTP请求发起和响应<br>页面渲染的过程<br>页面的性能优化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/25/JavaScript/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/25/JavaScript/面试题/</id>
    <published>2019-03-25T07:11:32.199Z</published>
    <updated>2019-03-27T09:23:21.253Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一行代码实现数组去重？<br><code>[...new Set([1,2,3,1,&#39;a&#39;,1,&#39;a&#39;])]</code><br>怎么判断两个对象相等？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">obj=&#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:2</span><br><span class="line">&#125;</span><br><span class="line">obj2=&#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:2</span><br><span class="line">&#125;</span><br><span class="line">obj3=&#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:&apos;2&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JSON.stringify(obj)==JSON.stringify(obj2);//true</span><br><span class="line">JSON.stringify(obj)==JSON.stringify(obj3);//false</span><br></pre></td></tr></table></figure></p><p>CommonJS 中的 require/exports 和 ES6 中的 import/export 区别？</p><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。<br>ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。<br>import/export 最终都是编译为 require/exports 来执行的。<br>CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。<br>export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><p>浏览器缓存<br>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：</p><p>先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；<br>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；<br>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；<br>区别是，强缓存不对发送请求到服务器，但协商缓存会。<br>当协商缓存也没命中时，服务器就会将资源发送回客户端。<br>当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；<br>当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；</p><p>强缓存</p><p>Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）<br>Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）</p><p>协商缓存</p><p>Last-Modified（值为资源最后更新时间，随服务器response返回）<br>If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）<br>ETag（表示资源内容的唯一标识，随服务器response返回）<br>If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</p><p>页面渲染的完整流程是怎样的？</p><h3 id="图片里的-alt-属性是做什么的？"><a href="#图片里的-alt-属性是做什么的？" class="headerlink" title="图片里的 alt 属性是做什么的？"></a>图片里的 alt 属性是做什么的？</h3><p>查看答案<br>如果用户看不到图像，alt 属性可以提供替代信息。alt 属性应该用于描述，而那些仅仅是装饰目的图像，可以为空</p><p>小贴士<br>装饰性的图像应该有一个空的 alt 属性<br>web 爬虫可以通过 alt 属性理解图像的信息，因此认为它对于搜索引擎优化（SEO）非常重要<br>在 alt 末尾加 . 可以提高访问性</p><h3 id="不采用缓存的目的是什么，你如何实现它？"><a href="#不采用缓存的目的是什么，你如何实现它？" class="headerlink" title="不采用缓存的目的是什么，你如何实现它？"></a>不采用缓存的目的是什么，你如何实现它？</h3><p>查看答案<br>浏览器有一个临时的存储网站文件的缓存，所以他们不需要在切换或重新加载同一个页面时再次重新下载。服务器设置发送头信息告诉浏览器在给定的一段时间内使用存储文件。这极大加快了网站的速度和节省了带宽</p><p>然而，当开发人员网站更新时，因为用户的缓存依然指向旧的文件，这会造成问题。如果缓存的 CSS 和 JavaScript 文件引用的元素不再存在，已移除或已重命名时，它会保留原有功能或破坏网站</p><p>禁用缓存是一个强制浏览器下载新文件的过程。通过命名来区分于旧文件</p><p>一个常用的强制浏览器重新下载文件的技术是在文件的结尾处增加一个查询字符串</p><p>src=”js/script.js” =&gt; src=”js/script.js?v=2”<br>浏览器认为这是一个不同的文件但是避免了修改文件名的必要</p><h3 id="一个页面里是否可以包含多个-元素，-元素呢？"><a href="#一个页面里是否可以包含多个-元素，-元素呢？" class="headerlink" title="一个页面里是否可以包含多个  元素，  元素呢？"></a>一个页面里是否可以包含多个 <header> 元素， <footer> 元素呢？</footer></header></h3><p>查看答案<br>都可以。W3C 文档声明这些标签代表离它们最近祖先区域的页眉（<header>）和页脚（<footer>）。因此，不只是可以在页面的 <body> 里包含页眉和页脚，而且每一个 <article> 和 <section> 元素都可以包含</section></article></body></footer></header></p><p>小贴士<br>W3C 推荐你想用多少就用多少，但是每一个页面的区域只能有一个，即，body，section 等等</p><h3 id="lt-script-gt-标签的-defer-和-async-是什么？"><a href="#lt-script-gt-标签的-defer-和-async-是什么？" class="headerlink" title="&lt;script&gt; 标签的 defer 和 async 是什么？"></a><code>&lt;script&gt;</code> 标签的 defer 和 async 是什么？</h3><p>查看答案<br>如果两个属性都没有的话，脚本将同步下载和执行，并且会阻塞 document 解析，直到脚本执行完成（默认行为）。脚本下载和执行按它们书写的顺序进行</p><p>defer 属性在 document 解析的过程中下载脚本，但是在 document 解析完成之前执行，等价于执行了一个内置的事件监听器 DOMContentLoaded。defer 脚本顺序执行</p><p>async 属性在 document 解析过程中下载脚本，但是会暂停解析器，直到脚本解析执行完成。async 不一定按顺序执行</p><p>注意：两个属性必须在脚本拥有 src 属性时才起作用（即，在内联脚本不起作用）</p><p><script src="myscript.js"></script></p><p><script src="myscript.js" defer></script></p><p><script src="myscript.js" async></script><br>小贴士<br>请用 <head> 中放置一个 defer，允许浏览器在页面还在解析过程中下载脚本，因此把脚本放到 body 之前是更好的选择<br>如果脚本之间相互依赖，请用 defer.<br>如果脚本是独立的，请用 async.<br>如果 DOM 必须加载完并且内容还未放置到 DOMContentLoaded 监听器中时，请用 defer</head></p><h3 id="相比-HTML，XHTML-有哪些不同？"><a href="#相比-HTML，XHTML-有哪些不同？" class="headerlink" title="相比 HTML，XHTML 有哪些不同？"></a>相比 HTML，XHTML 有哪些不同？</h3><p>查看答案<br>有一些关键区别：</p><p>一个 XHTML 元素必须要有一个 XHTML <doctype><br>属性值必须用引号包裹<br>禁止属性简写（例如，checked=”checked” 不能简写为 checked）<br>元素必须正确的被嵌套<br>元素必须闭合<br>特殊字符必须被转义<br>小贴士<br>任何被标签都是自闭合<br>标签和属性区分大小写，通常小写</doctype></p><h3 id="你能说出-media-属性的四种类型吗？"><a href="#你能说出-media-属性的四种类型吗？" class="headerlink" title="你能说出 @media 属性的四种类型吗？"></a>你能说出 @media 属性的四种类型吗？</h3><p>查看答案<br>all，适用于所有媒体设备<br>print，仅适用于打印机<br>screen，仅适用于屏幕设备（台式电脑、平板电脑、移动设备等）<br>speech，仅适用于屏幕阅读器</p><p>如何统计网页里出现多少种html标签<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有标签</span></span><br><span class="line">var doms = document.getElementsByTagName(<span class="string">"*"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#去重</span></span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">var ret = []</span><br><span class="line"><span class="keyword">for</span> (var j = 0; j &lt; doms.length; i++) &#123;</span><br><span class="line">  var name = doms[j].nodeName</span><br><span class="line">  <span class="keyword">if</span>(!obj[name]) &#123;</span><br><span class="line">    ret.push(name)</span><br><span class="line">    obj[name] = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(ret.length);</span><br><span class="line"></span><br><span class="line"><span class="comment"># ES6方法</span></span><br><span class="line">const names = [...document.getElementsByTagName(<span class="string">"*"</span>)].map(v=&gt;v.nodeName)</span><br><span class="line"></span><br><span class="line">console.log(new Set(names).size);</span><br></pre></td></tr></table></figure></p><p>手写bind call<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> result = context.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个高阶函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>定位</title>
    <link href="http://yoursite.com/2019/03/22/CSS3/%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2019/03/22/CSS3/定位/</id>
    <published>2019-03-22T10:09:02.000Z</published>
    <updated>2019-03-22T10:22:56.422Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>position<br>static<br>表示没有定位，元素出现在正常的文档流中。<br>为静态定位的元素设置 top|bottom|left|right 不起作用。<a id="more"></a><br>fixed<br>元素的位置相对于浏览器窗口是固定位置。<br>即使浏览器的窗口是滚动的它也不会移动。<br>fixed定位使得元素脱离了文档流，因而不占据空间。<br>设置了固定定位的元素宽高由其内部元素撑起。<br>relative<br>相对定位的元素是相对其正常位置。<br>1.使用了相对定位元素的元素，其参照物是其本身，其偏移量由TRBL(top，right,bottom,left)的值确定。<br>2.使用了相对定位的元素，仍然会在标准流中占据原来的位置，它对父元素和兄弟元素没有影响。<br>3.相对定位的使用场景往往是作为绝对定位元素的参照物。<br>absolute<br>绝对定位的元素的位置是相对其最近的已定位父元素（也就是除static之外），如果找不到已定位的父元素，那么就相对于<code>&lt;html&gt;</code>元素。<br>absolute定位使得元素脱离了文档流，因而不占据空间。<br>设置了绝对定位的元素宽高由其内部元素撑起。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;position&lt;br&gt;static&lt;br&gt;表示没有定位，元素出现在正常的文档流中。&lt;br&gt;为静态定位的元素设置 top|bottom|left|right 不起作用。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/22/Vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/03/22/Vue/Vue生命周期/</id>
    <published>2019-03-22T09:02:49.704Z</published>
    <updated>2019-03-22T09:13:58.586Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.cnblogs.com/happ0/p/8075562.html" target="_blank" rel="noopener">vue 生命周期 详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络安全(SQL、XSS、CSRF)</title>
    <link href="http://yoursite.com/2019/03/21/JavaScript/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2019/03/21/JavaScript/网络安全/</id>
    <published>2019-03-21T12:40:40.000Z</published>
    <updated>2019-03-21T13:34:55.904Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载：<br>　　<a href="http://netsecurity.51cto.com/art/201901/590563.htm" target="_blank" rel="noopener">3大Web安全漏洞防御详解：XSS、CSRF、以及SQL注入解决方案</a><br>参考：<br>　　<a href="https://www.cnblogs.com/443855539-wind/p/6055816.html" target="_blank" rel="noopener">前端安全（XSS、CSRF防御）</a><br>　　<a href="https://segmentfault.com/a/1190000007059639" target="_blank" rel="noopener">用大白话谈谈XSS与CSRF</a><br>常见的Web安全分为两种前端安全(XSS攻击、CSRF攻击)和后端安全(SQL注入)</p><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>　　XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。<code>这类攻击通常包含了HTML以及用户端脚本语言</code>。<a id="more"></a><br>　　XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码。</p><h4 id="XSS攻击的危害"><a href="#XSS攻击的危害" class="headerlink" title="XSS攻击的危害"></a>XSS攻击的危害</h4><p>　　1. 盗取用户资料，比如：登录帐号、网银帐号等<br>　　2. 利用用户身份，读取、篡改、添加、删除数据等<br>　　3. 盗窃重要的具有商业价值的资料<br>　　4. 非法转账<br>　　5. 强制发送电子邮件<br>　　6. 网站挂马<br>　　7. 控制受害者机器向其它网站发起攻击</p><h4 id="防止XSS的解决方法"><a href="#防止XSS的解决方法" class="headerlink" title="防止XSS的解决方法"></a>防止XSS的解决方法</h4><p><code>XSS</code>的根源主要是没完全过滤客户端提交的数据 ，所以重点是要过滤用户提交的信息。<br>　　1. 将重要的cookie标记为<code>http only</code>, 这样的话js 中的<code>document.cookie</code>语句就不能获取到<code>cookie</code>了.<br>　　2. 只允许用户输入我们期望的数据。 例如：<code>age</code>用户年龄只允许用户输入数字，而数字之外的字符都过滤掉。<br>　　3. 对数据进行<code>Html Encode</code>处理：用户将数据提交上来的时候进行<code>HTML</code>编码，将相应的符号转换为实体名称再进行下一步的处理。<br>　　4. 过滤或移除特殊的<code>Html</code>标签。<br>　　5. 过滤<code>js</code>事件的标签。例如 <code>&quot;onclick=&quot;</code>, <code>&quot;onfocus&quot;</code>等等。</p><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>　　CSRF:跨站请求伪造（英语：<code>Cross-site request forgery</code>），也被称为 <code>one-click attack</code> 或者 <code>session riding</code>，通常缩写为 <code>CSRF</code> 或者 <code>XSRF</code>，是一种挟制用户在当前已登录的Web应用程序上<code>执行非本意的操作的攻击方法</code>。<br>　　XSS主要是利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求，来利用受信任的网站。与XSS攻击相比，CSRF更具危险性。</p><h4 id="CSRF攻击危害"><a href="#CSRF攻击危害" class="headerlink" title="CSRF攻击危害"></a>CSRF攻击危害</h4><p>　　主要的危害来自于，攻击者盗用用户身份，发送恶意请求。比如：模拟用户发送邮件，发消息，以及支付、转账等。</p><h4 id="防止CSRF的解决方法"><a href="#防止CSRF的解决方法" class="headerlink" title="防止CSRF的解决方法"></a>防止CSRF的解决方法</h4><p>　　1. 重要数据交互采用POST进行接收，当然是用POST也不是万能的，伪造一个form表单即可破解。<br>　　2. 使用验证码，只要是涉及到数据交互就先进行验证码验证，这个方法可以完全解决CSRF。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。<br>　　3. 验证HTTP Referer字段，该字段记录了此次HTTP请求的来源地址，最常见的应用是图片防盗链。<br>　　4. 为每个表单添加令牌token并验证。</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>　　SQL注入是比较常见的网络攻击方式之一，主要是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，实现无帐号登录，甚至篡改数据库。</p><h4 id="SQL注入的危害"><a href="#SQL注入的危害" class="headerlink" title="SQL注入的危害"></a>SQL注入的危害</h4><p>　　1. 数据库信息泄漏：数据库中存放的用户的隐私信息的泄露<br>　　2. 网页篡改：通过操作数据库对特定网页进行篡改<br>　　3. 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改<br>　　4. 服务器被远程控制，被安装后门<br>　　5. 删除和修改数据库表信息</p><h4 id="SQL注入的方式"><a href="#SQL注入的方式" class="headerlink" title="SQL注入的方式"></a>SQL注入的方式</h4><p>通常情况下，SQL注入的位置包括：<br>　　1. 表单提交，主要是POST请求，也包括GET请求;<br>　　2. URL参数提交，主要为GET请求参数;<br>　　3. Cookie参数提交;<br>　　4. HTTP请求头部的一些可修改的值，比如Referer、User_Agent等;</p><h4 id="防止SQL注入的解决方法"><a href="#防止SQL注入的解决方法" class="headerlink" title="防止SQL注入的解决方法"></a>防止SQL注入的解决方法</h4><p>　　1. 对用户的输入进行校验，使用正则表达式过滤传入的参数<br>　　2. 使用参数化语句，不要拼接sql，也可以使用安全的存储过程<br>　　3. 不要使用管理员权限的数据库连接，为每个应用使用权限有限的数据库连接<br>　　4. 检查数据存储类型<br>　　5. 重要的信息一定要加密</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;转载：&lt;br&gt;　　&lt;a href=&quot;http://netsecurity.51cto.com/art/201901/590563.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;3大Web安全漏洞防御详解：XSS、CSRF、以及SQL注入解决方案&lt;/a&gt;&lt;br&gt;参考：&lt;br&gt;　　&lt;a href=&quot;https://www.cnblogs.com/443855539-wind/p/6055816.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端安全（XSS、CSRF防御）&lt;/a&gt;&lt;br&gt;　　&lt;a href=&quot;https://segmentfault.com/a/1190000007059639&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;用大白话谈谈XSS与CSRF&lt;/a&gt;&lt;br&gt;常见的Web安全分为两种前端安全(XSS攻击、CSRF攻击)和后端安全(SQL注入)&lt;/p&gt;
&lt;h3 id=&quot;XSS攻击&quot;&gt;&lt;a href=&quot;#XSS攻击&quot; class=&quot;headerlink&quot; title=&quot;XSS攻击&quot;&gt;&lt;/a&gt;XSS攻击&lt;/h3&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;　　XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。&lt;code&gt;这类攻击通常包含了HTML以及用户端脚本语言&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/21/JavaScript/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/21/JavaScript/面试题总结/</id>
    <published>2019-03-21T11:42:26.566Z</published>
    <updated>2019-03-22T10:59:29.857Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>. vue的生命周期?<br>Mvvm响应式原理？<br>常见设计模式及其应用场景？<br>原型链？<br>闭包？应用场景？<br>Es6的新特性？<br>Css position相关？<br>Html语义化？<br>冒泡排序？<br> Html大纲？<br> 浏览器兼容性？<br>腾讯二面（视频，24min左右）：<br>vue的生命周期？</p><p>Js数据类型，堆和栈的区别？</p><p>Vue的diff算法？怎么样才算samenode（源码相关）？比较子节点的时候顺序比较行不行？</p><p>用defineProperty进行数据劫持的缺点？怎么办（考察vue3.0数据劫持的方式proxy）？</p><p>手写二分查找</p><p>Css盒子模型？</p><p>Express中间件？</p><p>Symbol？作用？<br>三面约的19：10，结果前面面试的同学太多了，到19：45才面上<br>腾讯三面（电话，20min左右）：</p><ol><li><p>从输入url到显示页面的过程？</p></li><li><p>这个过程中有哪些会影响性能？</p></li><li><p>闭包原理？适用场景？</p></li></ol><p>5、闭包的优点<br>（1）逻辑连续，当闭包作为另一个函数调用参数时，避免脱离当前逻辑而单独编写额外逻辑。</p><p>（2）方便调用上下文的局部变量。</p><p>（3）加强封装性，是第2点的延伸，可以达到对变量的保护作用。</p><p>6、使用闭包的注意点（缺点）<br>（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><p>7、闭包的特性<br>（1）作为函数变量的一个引用。当函数返回时，其处于激活状态。</p><p>（2）闭包就是当一个函数返回时，并没有释放资源的栈区。</p><ol start="4"><li>Es6有哪些了解？</li></ol><p>1.自我介绍<br>2.做过什么项目？<br>3.了解es6吗<br>4.promise原理<br>5.了解什么算法？<br>6.堆排序过程，时间复杂度（nlogn,他还让我再想一下？？），应用场景（没答出来，哭）。<br>7.用过的技术栈<br>8.怎么学习前端<br>9.问题：公司主要用react，vue哪个，为什么用它呢？</p><p>什么时候开始学习的前端？<br>==和===的区别<br>JS 继承（ES6 extends、ES5 各种继承）<br>怎么判断参数是数组还是对象？（Array.isArray、toString、instanceOf）<br>问项目，技术方案，话题转 Vue<br>Vue 生命周期有哪些？（Create、Mount、Active、Update、Deactive、Destory）<br>DOM 结点在什么时候挂载？<br>Vue 能不能挂载到body或html标签上，为什么？<br>项目开发联调方式？<br>自我介绍</p><p>写一个两边定宽，中间自适应的布局（dispaly: flex、双飞翼/圣杯、position: absolute）<br>垂直居中方案（line-height、transform）<br>JS 怎么对象的属性是数组还是对象（参考一面第 8 问），解释下每个方法怎么判断（数组 Object.prototype.toString.call之后是[object, Array]，对象toString之后是[object, object]，instanceOf就是返回true还是false）<br>JS 继承（ES6 extends、原型链、构造），解释下原型链和构造哪个好，好在哪里，原型链继承的时候，可不可以直接A.prototype = B()，而不是A.prototype = new B()，为什么<br>构造继承为什么用call，而不是apply？（参数不同，一个数组，一个不定参数），追问哪个参数是数组？（apply）<br>实现一个数组去重（Array.from(new Set(arr))），不用 ES6 实现一个对所有数组有可以调用的去重（forindexOf，添加到Array.prototype），面试官说i</p><p>跨域的方式<br>websocket和Http的区别<br>长轮询<br>cookie和session，没有cookie的话session能不能使用<br>浏览器缓存机制，304是协商缓存还是强缓存<br>类数组变成数组<br>let和var的区别<br>CSRF以及Token验证的Token放在哪里<br>TCP三次握手，如果没有三次握手会怎样<br>Vue用watch实现数据双向绑定<br>重绘和重排，什么操作会造成重排<br>LESS怎么遍历一个列表<br>await语法<br>JS继承有哪几种，具体的实现及原理<br>常见的HTTP状态码各个是什么意思<br>介绍浏览器缓存？各个响应头优先级？以及之间的区别，可以取的值，分别是什么意思<br>介绍浏览器时间<br>介绍一下跨域，各个跨域的具体实现方法？以及JSONP实现方式中服务器是怎样交互的<br>介绍一下网络安全（xss以及csrf具体防范方法）</p><p>行内元素和块级元素二者区别<br>css选择器有哪些，怎么样计算<br>JS面向对象的理解<br>盒子模型，box-sizing<br>常用的设计模式，<br>封装一个函数判断数据类型，数组还是对象<br>状态码404 400 502 304<br>http底层协议<br>http协议用在tcp还是udp<br>三次握手，四次握手，两次握手，<br>time wait 2ml 的原因<br>浏览器缓存，硬盘（持久化）<br>数据结构，快速排序，稳定的还是不稳定的。最差的时间复杂度<br>内存存不下，很多个数据，找出最大的10个或者100个<br>哈希<br>操作系统 nio, i/o操作<br>计算机组成原理，数据用什么码储存的，正负数的储存，负数的源码补码<br>基址寻址和变址寻址<br>get，post请求最本质的区别<br>多路复用<br>事件代理。常规做法的优势体现在哪里<br>session。分布式集群，如何保障session可以保持相同<br>浏览器cookie禁掉session是哪一端session特别多怎么办</p><p>OSI七层模型及作用<br>http。tcp三次握手四次挥手、http和https<br>tcp、cdp<br>post和get<br>进程和线层的区别<br>输入一个url发生了什么<br>内存分配<br>闭包、作用域链<br>vue生命周期<br>css3动画，怎么做<br>单行文本溢出，多行文本溢出代码实现<br>bfc布局<br>js类型，封装一个类型鉴定函数<br>闭包，哪里用到立即执行函数解决闭包中访问变量的问题<br>时间轮询机制<br>原生js实现bind函数<br>一个函数，然后让你说他们的值是多少，为什么<br>预编译、严格模式、作用域链<br>算法 快排 选择排序<br>浏览器渲染原理</p><p>实现一个构造函数new的时候每次加一<br>计算机网络tcp与udp区别，tcp拥塞机制，tcp三次握手四次挥手<br>css性能优化</p><p>js作用域链怎么来的<br>this<br>url到浏览器解析过程<br>dns解析<br>tcp连接<br>http和https。ssl层在哪里加入<br>浏览器解析过程<br>cdn有存在的必要吗</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>主流浏览器内核</title>
    <link href="http://yoursite.com/2019/03/19/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/"/>
    <id>http://yoursite.com/2019/03/19/前端性能优化/主流浏览器内核/</id>
    <published>2019-03-19T05:26:48.000Z</published>
    <updated>2019-03-19T06:11:42.947Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p>　　浏览器内核可以分为两部分：<strong>渲染引擎</strong>(<code>layout engineer</code> 或者 <code>Rendering Engine</code>)和<strong>JS引擎</strong><a id="more"></a><br>　　浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p><h5 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h5><p>　　渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等）、以及计算网页的显示方式，然后会输出至显示器或打印机。</p><h5 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h5><p>　　JS 引擎则是解析<code>Javascript</code>语言，执行<code>javascript</code>语言来实现网页的动态效果。<br>　　最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 <code>JS引擎越来越独立，内核就倾向于只指渲染引擎</code>。</p><h4 id="主流浏览器内核"><a href="#主流浏览器内核" class="headerlink" title="主流浏览器内核"></a>主流浏览器内核</h4><p><code>Trident</code>内核：IE<br><code>Gecko</code>内核：NETSCAPE6及以上版本，火狐(Mozilla FireFox)<br><code>Presto</code>内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink;]<br><code>Webkit</code>内核：Safari，Chrome等。<br>Chrome的：<code>Blink</code>（WebKit的分支）</p><h4 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h4><p>移动端的浏览器内核主要说的是<code>系统内置浏览器的内核</code>。<br>目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 。<br>1、iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit。<br>2、Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink。<br>3、Windows Phone 8 系统浏览器内核是 Trident。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h4 id=&quot;浏览器内核&quot;&gt;&lt;a href=&quot;#浏览器内核&quot; class=&quot;headerlink&quot; title=&quot;浏览器内核&quot;&gt;&lt;/a&gt;浏览器内核&lt;/h4&gt;&lt;p&gt;　　浏览器内核可以分为两部分：&lt;strong&gt;渲染引擎&lt;/strong&gt;(&lt;code&gt;layout engineer&lt;/code&gt; 或者 &lt;code&gt;Rendering Engine&lt;/code&gt;)和&lt;strong&gt;JS引擎&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSS3新特性</title>
    <link href="http://yoursite.com/2019/03/18/CSS3/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/03/18/CSS3/CSS3新特性/</id>
    <published>2019-03-18T13:17:09.000Z</published>
    <updated>2019-03-26T09:37:11.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>实现圆角<code>border-radius</code>，<br>阴影<code>box-shadow</code>，<br>边框图片<code>border-image</code><br>对文字加特效<code>text-shadow</code>，<br>强制文本换行<code>word-wrap</code>，<br>线性渐变<code>linear-gradient</code><a id="more"></a><br>实现旋转<code>transform:rotate(90deg)</code>,<br>缩放<code>scale(0.85,0.90)</code>,<br>定位<code>translate(0px,-30px)</code>,<br>倾斜<code>skew(-9deg,0deg)</code>;<br>增加了更多的<code>CSS</code>选择器、多背景、<code>rgba()</code><br>唯一引入的伪元素是<code>::selection</code>；<br>实现媒体查询<code>@media</code>，多栏布局<code>flex</code><br>过渡<code>transition</code><br>动画<code>animation</code><br><code>text-overflow</code>(文本溢出隐藏)<br><code>CSS3</code>中，<code>text-shadow</code>可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。<br><code>CSS3</code>新增了几个关于背景的属性，分别是<code>background-clip</code>、<code>background-origin</code>、<code>background-size</code>和<code>background-break</code>。<br><code>text-decoration</code>:CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：<br>　　<code>text-fill-color</code>: 设置文字内部填充颜色<br>　　<code>text-stroke-color</code>: 设置文字边界填充颜色<br>　　<code>text-stroke-width</code>: 设置文字边界宽度</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现圆角&lt;code&gt;border-radius&lt;/code&gt;，&lt;br&gt;阴影&lt;code&gt;box-shadow&lt;/code&gt;，&lt;br&gt;边框图片&lt;code&gt;border-image&lt;/code&gt;&lt;br&gt;对文字加特效&lt;code&gt;text-shadow&lt;/code&gt;，&lt;br&gt;强制文本换行&lt;code&gt;word-wrap&lt;/code&gt;，&lt;br&gt;线性渐变&lt;code&gt;linear-gradient&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>Url、Href、Src、Link详解</title>
    <link href="http://yoursite.com/2019/03/18/CSS3/Url%E3%80%81Href%E3%80%81Src%E3%80%81Link/"/>
    <id>http://yoursite.com/2019/03/18/CSS3/Url、Href、Src、Link/</id>
    <published>2019-03-18T11:49:44.000Z</published>
    <updated>2019-03-26T03:00:04.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载：<br>　　<a href="https://segmentfault.com/a/1190000002877022" target="_blank" rel="noopener">url、href、src 详解</a><br><a id="more"></a></p><h4 id="Url"><a href="#Url" class="headerlink" title="Url"></a>Url</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>　　<code>URL</code>(<code>Uniform Resource Locator</code>)统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的<code>URL</code>，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><h5 id="Url格式"><a href="#Url格式" class="headerlink" title="Url格式"></a>Url格式</h5><p><strong>标准格式</strong><br>　　协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名?查询<br><strong>完整格式</strong><br>　　协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名?查询</p><h6 id="Url语法规则"><a href="#Url语法规则" class="headerlink" title="Url语法规则"></a>Url语法规则</h6><p>　　比如网址<code>http://segmentfault.com/html/index.asp</code>必须遵守以下的语法规则:<br><code>scheme://host.domain:port/path/filename</code><br><strong>说明</strong><br>　　<code>scheme</code> - 定义因特网服务的类型。最常见的类型是 http<br>　　<code>host</code> - 定义域主机（http 的默认主机是 www）<br>　　<code>domain</code> - 定义因特网域名，比如 w3school.com.cn<br>　　<code>:port</code> - 定义主机上的端口号（http 的默认端口号是 80）<br>　　<code>path</code> - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。<br>　　<code>filename</code> - 定义文档/资源的名称</p><h6 id="URL-Schemes"><a href="#URL-Schemes" class="headerlink" title="URL Schemes"></a>URL Schemes</h6><table><thead><tr><th style="text-align:left">Scheme</th><th style="text-align:left">访问</th><th style="text-align:center">用于</th></tr></thead><tbody><tr><td style="text-align:left">http</td><td style="text-align:left">超文本传输协议</td><td style="text-align:center">以 http:// 开头的普通网页。不加密。</td></tr><tr><td style="text-align:left">https</td><td style="text-align:left">安全超文本传输协议</td><td style="text-align:center">安全网页。加密所有信息交换。</td></tr><tr><td style="text-align:left">ftp</td><td style="text-align:left">文件传输协议</td><td style="text-align:center">用于将文件下载或上传至网站。</td></tr><tr><td style="text-align:left">file</td><td style="text-align:left"></td><td style="text-align:center">您计算机上的文件。</td></tr></tbody></table><h6 id="URL的类型"><a href="#URL的类型" class="headerlink" title="URL的类型"></a>URL的类型</h6><p><strong>绝对URL</strong><br>　　绝对<code>URL</code>（<code>absolute URL</code>）显示文件的完整路径，这意味着绝对<code>URL</code>本身所在的位置与被引用的实际文件的位置无关。<br><strong>相对URL</strong><br>　　相对<code>URL</code>（<code>relative URL</code>）以包含<code>URL</code>本身的文件夹的位置为参考点，描述目标文件夹的位置。<br>　　一般来说，对于同一服务器上的文件，应该总是使用相对<code>URL</code>，它们更容易输入，而且在将页面从本地系统转移到服务器上时更方便，只要每个文件的相对位置保持不变，链接就仍然是有效地。<br><code>.</code>：代表目前所在的目录，相对路径。<br>例： <code>&lt;a href=&quot;./abc&quot;&gt;文本&lt;/a&gt;</code> 或 <code>&lt;img src=&quot;./abc&quot; /&gt;</code><br><code>..</code>：代表上一层目录，相对路径。<br>例： <code>&lt;a href=&quot;../abc&quot;&gt;文本&lt;/a&gt;</code>或 <code>&lt;img src=&quot;../abc&quot; /&gt;</code><br><code>../../</code>：代表的是上一层目录的上一层目录，相对路径。<br>例： <code>&lt;img src=&quot;../../abc&quot; /&gt;</code><br><code>/</code>：代表根目录，绝对路径。<br>例： <code>&lt;a href=&quot;/abc&quot;&gt;文本&lt;/a&gt;</code> 或 <code>&lt;img src=&quot;/abc&quot; /&gt;</code></p><h4 id="Href"><a href="#Href" class="headerlink" title="Href"></a>Href</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>　　<code>href</code> (<code>Hypertext Reference</code>)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。</p><h5 id="通俗理解"><a href="#通俗理解" class="headerlink" title="通俗理解"></a>通俗理解</h5><p>　　<code>href</code>: 目的不是为了引用资源，而是为了建立这个标签与外部资源之间的关系，让当前标签能够链接到目标地址。<br><code>&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;</code>浏览器加载到这里的时候，html的渲染和解析不会暂停，css文件的加载是同时进行的</p><h4 id="Src"><a href="#Src" class="headerlink" title="Src"></a>Src</h4><p>　　<code>src</code>用于替代这个元素: <code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code>当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个js文件</p><h4 id="Href和Src的区别"><a href="#Href和Src的区别" class="headerlink" title="Href和Src的区别"></a>Href和Src的区别</h4><p><strong>请求资源类型不同</strong><br>　　href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。<br>　　在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；<br><strong>作用结果不同</strong><br>　　href 用于在当前文档和引用资源之间确立联系；<br>　　src 用于替换当前内容；<br><strong>浏览器解析方式不同</strong><br>　　若在文档中添加 <code>&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;/&gt;</code>，浏览器会识别该文档为 <code>CSS</code> 文件，就会并行下载资源并且<code>不会停止</code>对当前文档的处理。这也是为什么建议使用 <code>link</code> 方式加载 <code>CSS</code>，而不是使用<code>@import</code> 方式。<br>　　当浏览器解析到 <code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code>，会<code>暂停</code>其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 <code>js</code> 脚本放在底部而不是头部的原因。</p><h4 id="Link和-import的区别"><a href="#Link和-import的区别" class="headerlink" title="Link和@import的区别"></a>Link和@import的区别</h4><p>两者都是外部引用 <code>CSS</code> 的方式，但是存在一定的区别：<br>（1）<code>link</code>是<code>XHTML</code>标签，除了能够加载<code>CSS</code>，还可以定义<code>RSS</code>等其他事务；而<code>@import</code>属于<code>CSS</code>范畴，只可以加载<code>CSS</code>。<br>（2）<code>link</code>引用<code>CSS</code>时，在页面载入时同时加载；<code>@import</code>需要页面完全载入以后再加载。<br>（3）<code>link</code>是<code>XHTML</code>标签，无兼容问题；<code>@import</code>则是在<code>CSS2.1</code>提出的，低版本的浏览器不支持。<br>（4）<code>link</code>支持使用<code>Javascript</code>控制<code>DOM</code>改变样式；而<code>@import</code>不支持。</p><h4 id="为什么尽量不要使用-import加载css"><a href="#为什么尽量不要使用-import加载css" class="headerlink" title="为什么尽量不要使用@import加载css"></a>为什么尽量不要使用@import加载css</h4><p>使用<code>@import</code>会导致和预期不一致的下载顺 序。<br>我们确实要避免使用<code>css @import，</code>但原因却不是什么相当于放在了页面底部，而是这样做会导致<code>css</code>无法并行下载，因为使用<code>@import</code>引用的文件只有在引用它的那个<code>css</code>文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建<code>render tree</code>等一系列操作。 浏览器在页面所有<code>css</code>下载并解析完成后才会开始渲染页面（<code>Before a browser can begin to render a web page, it mustdownload and parse any stylesheets that are required to lay out thepage. Even if a stylesheet is in an external file that is cached,rendering is blocked until the browser loads the stylesheet from disk.</code>），因此<code>css @import</code>引起的<code>css</code>解析延迟会加长页面留白期。 所以，要尽量避免使用<code>css @import</code>而尽量采用<code>link</code>标签的方式引入。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;转载：&lt;br&gt;　　&lt;a href=&quot;https://segmentfault.com/a/1190000002877022&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;url、href、src 详解&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>同源策略和跨域</title>
    <link href="http://yoursite.com/2019/03/17/Ajax/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/03/17/Ajax/同源策略和跨域/</id>
    <published>2019-03-17T08:56:03.000Z</published>
    <updated>2019-03-17T12:46:35.362Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载:<br>　　<a href="https://segmentfault.com/a/1190000012469713" target="_blank" rel="noopener">ajax跨域，这应该是最全的解决方案了</a><br>参考:<br>　　<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法</a><br>　　<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>同源即指：协议相同、域名相同、端口号相同。<br><a id="more"></a><br>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/dir2/other.html：同源</span><br><span class="line">http://example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://v2.www.example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://www.example.com:81/dir/other.html：不同源（端口不同）</span><br></pre></td></tr></table></figure></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>　　同源政策的目的，是为了<strong>为了保证使用者信息的安全，防止恶意网站篡改用户数据</strong>。<br>　　设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的<code>Cookie</code>，会发生什么？<br>　　很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，<code>Cookie</code> 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。<br>　　由此可见，”同源政策”是必需的，否则 <code>Cookie</code> 可以共享，互联网就毫无安全可言了。</p><h3 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h3><p>　　随着互联网的发展，”同源政策”越来越严格。目前，非同源的网站之间，共有四种行为受到限制。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1） Cookie、LocalStorage 和 IndexDB 无法读取。</span><br><span class="line">（2） DOM 无法获得。</span><br><span class="line">（3） AJAX 请求不能发送。</span><br><span class="line">（4）无法通过 flash 发送 http 请求</span><br></pre></td></tr></table></figure></p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>　　同源策略做了很严格的限制，但是在实际的场景中，又确实有很多地方需要突破同源策略的限制，也就是我们常说的跨域。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>　　同源策略最早被提出的时候，为的就是防止不同域名的网页之间共享 <code>cookie</code>。<code>Cookie</code>是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享<code>Cookie</code>。<br>举个例子，<br><code>https://market.douban.com</code>和<code>https://book.douban.com</code>，这两个网页的一级域名都是 <code>douban.com</code>，如果我在 <code>market.douban.com</code>中执行了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#A、B页面设置相同的document.domain</span></span><br><span class="line">document.domain = <span class="string">'douban.com'</span></span><br><span class="line"><span class="comment"># A页面通过脚本设置一个Cookie</span></span><br><span class="line">document.cookie = <span class="string">'cross=yes'</span></span><br><span class="line">或</span><br><span class="line">document.cookie = <span class="string">'cross=yes;path=/;domain=douban.com'</span></span><br><span class="line"><span class="comment"># B页面就可以读取到Cookie</span></span><br><span class="line">var allCookie = document.cookie</span><br></pre></td></tr></table></figure></p><p>这样设置了 <code>cookie</code>之后，在<code>book.douban.com</code>中是可以取到这个<code>cookie</code>的。<br>除了在前端设置之外，也可以直接在<code>response</code>里将<code>cookie</code>的<code>domain</code>设置成 <code>.douban.com</code>。</p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="什么是Ajax跨域"><a href="#什么是Ajax跨域" class="headerlink" title="什么是Ajax跨域"></a>什么是Ajax跨域</h4><h5 id="ajax跨域的原理"><a href="#ajax跨域的原理" class="headerlink" title="ajax跨域的原理"></a>ajax跨域的原理</h5><p>　　<code>ajax</code>出现请求跨域错误问题,主要原因就是因为浏览器的“同源策略”,可以参考</p><h5 id="ajax跨域的表现"><a href="#ajax跨域的表现" class="headerlink" title="ajax跨域的表现"></a>ajax跨域的表现</h5><p>　　<code>ajax</code>请求时,如果存在跨域现象,并且没有进行解决,会有如下表现:(注意，是<code>ajax</code>请求，请不要说为什么<code>http</code>请求可以，而<code>ajax</code>不行，因为<code>ajax</code>是伴随着跨域的，所以仅仅是<code>http</code>请求<code>ok</code>是不行的)<br><strong>第一种现象</strong>:<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>,并且<code>The response had HTTP status code 404</code><br><img src="/assets/images/ajax001.png" alt="ajax001"><br>出现这种情况的原因如下：<br>　　本次ajax请求是“非简单请求”,所以请求前会发送一次预检请求(<code>OPTIONS</code>)<br>　　服务器端后台接口没有允许<code>OPTIONS</code>请求,导致无法找到对应接口地址<br>解决方案: 后端允许options请求<br><strong>第二种现象</strong>:<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>,并且<code>The response had HTTP status code 405</code><br><img src="/assets/images/ajax002.png" alt="ajax001"><br>这种现象和第一种有区别,这种情况下，后台方法允许<code>OPTIONS</code>请求,但是一些配置文件中(如安全配置),阻止了<code>OPTIONS</code>请求,才会导致这个现象<br>解决方案: 后端关闭对应的安全配置<br><strong>第三种现象</strong>:<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>,并且<code>status 200</code><br><img src="/assets/images/ajax003.png" alt="ajax001"><br>这种现象和第一种和第二种有区别,这种情况下，服务器端后台允许<code>OPTIONS</code>请求,并且接口也允许<code>OPTIONS</code>请求,但是头部匹配时出现不匹配现象<br>比如<code>origin</code>头部检查不匹配,比如少了一些头部的支持(如常见的<code>X-Requested-With</code>头部),然后服务端就会将<code>response</code>返回给前端,前端检测到这个后就触发<code>XHR.onerror</code>,导致前端控制台报错<br>解决方案: 后端增加对应的头部支持<br><strong>第四种现象</strong>:<code>heade contains multiple values &#39;*,*&#39;</code><br><img src="/assets/images/ajax004.jpg" alt="ajax001"><br>表现现象是，后台响应的http头部信息有两个<code>Access-Control-Allow-Origin:*</code><br>说实话，这种问题出现的主要原因就是进行跨域配置的人不了解原理，导致了重复配置，如:<br>常见于<code>.net</code>后台(一般在<code>web.config</code>中配置了一次<code>origin</code>,然后代码中又手动添加了一次<code>origin</code>(比如代码手动设置了返回<code>*</code>))<br>常见于<code>.net</code>后台(在<code>IIS</code>和项目的<code>webconfig</code>中同时设置<code>Origin:*</code>)<br>解决方案(一一对应):<br>　　建议删除代码中手动添加的<code>*</code>，只用项目配置中的即可<br>　　建议删除IIS下的配置<code>*</code>，只用项目配置中的即可</p><h4 id="如何解决ajax跨域"><a href="#如何解决ajax跨域" class="headerlink" title="如何解决ajax跨域"></a>如何解决ajax跨域</h4><p>　　一般ajax跨域解决就是通过<code>JSONP</code>解决或者<code>CORS</code>解决,如以下:(注意，现在已经几乎不会再使用<code>JSONP</code>了，所以<code>JSONP</code>了解下即可)</p><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p>jsonp 其实算是一种 hack 形式的请求。<br>jsonp 的本质其实是请求一段 js 代码，是对静态文件资源的请求，所以并不遵循同源策略。但是因为是对静态文件资源的请求，所以只能支持 GET 请求，对于其他方法没有办法支持。</p><h5 id="设置CORS"><a href="#设置CORS" class="headerlink" title="设置CORS"></a>设置CORS</h5><p>　　<code>CORS</code>是一个<code>W3C</code>标准，全称是”跨域资源共享”（<code>Cross-origin resource sharing</code>）。<br>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了<code>AJAX</code>只能同源使用的限制。<br>本文详细介绍CORS的内部机制。</p><h6 id="CORS简介"><a href="#CORS简介" class="headerlink" title="CORS简介"></a>CORS简介</h6><p>　　<code>CORS</code>需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于<code>IE10</code>。<br>　　整个<code>CORS</code>通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现<code>AJAX</code>请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><h6 id="CORS两种请求"><a href="#CORS两种请求" class="headerlink" title="CORS两种请求"></a>CORS两种请求</h6><p>浏览器将CORS请求分成两类：简单请求（<code>simple request</code>）和非简单请求（<code>not-so-simple request</code>）。<br>只要同时满足以下两大条件，就属于简单请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">（1) 请求方法是以下三种方法之一：</span><br><span class="line">  HEAD</span><br><span class="line">  GET</span><br><span class="line">  POST</span><br><span class="line">（2）HTTP的头信息不超出以下几种字段：</span><br><span class="line">  Accept</span><br><span class="line">  Accept-Language</span><br><span class="line">  Content-Language</span><br><span class="line">  Last-Event-ID</span><br><span class="line">  Content-Type：只限于三个值</span><br><span class="line">                application/x-www-form-urlencoded、</span><br><span class="line">                multipart/form-data、</span><br><span class="line">                text/plain</span><br></pre></td></tr></table></figure></p><p>凡是不同时满足上面两个条件，就属于<code>非简单请求</code>。<br>浏览器对这两种请求的处理，是不一样的。</p><h6 id="CORS简单请求"><a href="#CORS简单请求" class="headerlink" title="CORS简单请求"></a>CORS简单请求</h6><p>对于简单请求，浏览器直接发出<code>CORS</code>请求。具体来说，就是在头信息之中，增加一个<code>Origin(protocal + host + path + port)</code>字段,来标明这个请求是来自哪里。<br>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>　　如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest的onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。<br>　　如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。<br>（1）Access-Control-Allow-Origin<br>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。<br>（2）Access-Control-Allow-Credentials<br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。<br>（3）Access-Control-Expose-Headers<br>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。<br>withCredentials 属性<br>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。<br><code>Access-Control-Allow-Credentials: true</code><br>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>否则，即使服务器同意发送<code>Cookie</code>，浏览器也不会发送。或者，服务器要求设置<code>Cookie</code>，浏览器也不会处理。<br>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送<code>Cookie</code>。这时，可以显式关闭<code>withCredentials</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，如果要发送<code>Cookie</code>，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，<code>Cookie</code>依然遵循同源政策，只有用服务器域名设置的<code>Cookie</code>才会上传，其他域名的<code>Cookie</code>并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的<code>Cookie</code>。</p><h6 id="CORS非简单请求"><a href="#CORS非简单请求" class="headerlink" title="CORS非简单请求"></a>CORS非简单请求</h6><p>与<code>简单请求</code>最大的不同在于，<code>非简单请求</code>实际上是发送了两个请求。<br><strong>预请求</strong><br>首先，在正式请求之前，会先发送一个预请求(preflight-request)，这个请求的作用是尽可能少的携带信息，供服务端判断是否响应该请求。<br><strong>浏览器</strong><br>浏览器发送预请求，请求的 Request Method 会设置为 options。<br>另外，还会带上这几个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin: 同简单请求的origin</span><br><span class="line">Access-Control-Request-Method: 请求将要使用的方法</span><br><span class="line">Access-Control-Request-Headers: 浏览器会额外发送哪些头信息</span><br></pre></td></tr></table></figure></p><p><strong>服务端</strong><br>服务端收到预请求之后会根据request中的origin,Access-Control-Request-Method和Access-Control-Request-Headers判断是否响应该请求。<br>如果判断响应这个请求，返回的response中将会携带：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: origin</span><br><span class="line">Access-Control-Allow-Methods: like request</span><br><span class="line">Access-Control-Allow-Headers: like request</span><br></pre></td></tr></table></figure></p><p>如果否定这个请求，直接返回不带这三个字段的response就可以，浏览器将会把这种返回判断为失败的返回，触发onerror方法<br><strong>正式响应</strong><br>如果预请求被正确响应，接下来就会发送正式请求，正式请求的request和正常的 ajax 请求基本没有区别，只是会携带 origin 字段；response和简单请求一样，会携带上Access-Control-*这些字段</p><h5 id="WebScoket"><a href="#WebScoket" class="headerlink" title="WebScoket"></a>WebScoket</h5><p>websocket 不遵循同源策略。</p><p>但是在 websocket 请求头中会带上 origin 这个字段，服务端可以通过这个字段来判断是否需要响应，在浏览器端并没有做任何限制。</p><h5 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h5><h5 id="代理请求方式"><a href="#代理请求方式" class="headerlink" title="代理请求方式"></a>代理请求方式</h5>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;转载:&lt;br&gt;　　&lt;a href=&quot;https://segmentfault.com/a/1190000012469713&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ajax跨域，这应该是最全的解决方案了&lt;/a&gt;&lt;br&gt;参考:&lt;br&gt;　　&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浏览器同源政策及其规避方法&lt;/a&gt;&lt;br&gt;　　&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/cors.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;跨域资源共享 CORS 详解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;同源即指：协议相同、域名相同、端口号相同。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ajax" scheme="http://yoursite.com/categories/Ajax/"/>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
</feed>
