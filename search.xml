<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>vue-router 使用方法及实现原理</title>
      <link href="/2019/09/27/Vue/vue-router%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2019/09/27/Vue/vue-router%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载： <a href="https://segmentfault.com/a/1190000018584560" target="_blank" rel="noopener">vue-router实现原理</a><br><a href="https://www.cnblogs.com/tiedaweishao/p/9144531.html" target="_blank" rel="noopener">前端路由简介以及vue-router实现原理</a></p><h3 id="路由简介"><a href="#路由简介" class="headerlink" title="路由简介"></a>路由简介</h3><h4 id="后端路由简介"><a href="#后端路由简介" class="headerlink" title="后端路由简介"></a>后端路由简介</h4><p>　　路由这个概念最先是后端出现的。在以前用模板引擎开发页面时，经常会看到这样</p><blockquote><p><a href="http://www.xxx.com/login" target="_blank" rel="noopener">http://www.xxx.com/login</a></p></blockquote><p>大致流程可以看成这样：<br>　　浏览器发出请求<br>　　服务器监听到80端口（或443）有请求过来，并解析url路径<br>　　根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）<br>　　浏览器根据数据包的 Content-Type 来决定如何解析数据</p><p>　　简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。</p><h4 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h4><h4 id="1-hash-模式"><a href="#1-hash-模式" class="headerlink" title="1. hash 模式"></a>1. hash 模式</h4><p>　　随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。<br>　　类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。但是这样存在一个问题，就是 url 每次变化的时候，都会造成页面的刷新。那解决问题的思路便是在改变 url 的情况下，保证页面的不刷新。在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：</p><blockquote><p><a href="http://www.xxx.com/#/login" target="_blank" rel="noopener">http://www.xxx.com/#/login</a></p></blockquote><p>这种<code>#</code>。后面<code>hash</code>值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 <code>hash</code> 值的变化，还会触发<code>hashchange</code> 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听hashchange来实现更新页面部分内容的操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">matchAndUpdate</span></span> () &#123;</span><br><span class="line">   // todo 匹配 <span class="built_in">hash</span> 做 dom 更新操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">'hashchange'</span>, matchAndUpdate)</span><br></pre></td></tr></table></figure></p><h4 id="2-history-模式"><a href="#2-history-模式" class="headerlink" title="2. history 模式"></a>2. history 模式</h4><p>　　14年后，因为HTML5标准发布。多了两个 API，pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求。同时还有popstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 HTML5 的实现，单页路由的 url 就不会多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">matchAndUpdate</span></span> () &#123;</span><br><span class="line">   // todo 匹配路径 做 dom 更新操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">'popstate'</span>, matchAndUpdate)</span><br></pre></td></tr></table></figure></p><h3 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h5><h6 id="使用router的name属性也就是params来传递参数"><a href="#使用router的name属性也就是params来传递参数" class="headerlink" title="使用router的name属性也就是params来传递参数"></a>使用router的name属性也就是params来传递参数</h6><p>这个方法有一个bug就是当你传参过去的时候，再次刷新页面时参数就会丢失。解决方法下边会说到。</p><p>　　step:1,首先需要在router/index.js里边配置每个页面的路径，name属性，看例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import Router from <span class="string">'vue-router'</span></span><br><span class="line">const _import = require(<span class="string">'./_import_'</span> + process.env.NODE_ENV)</span><br><span class="line">Vue.use(Router)</span><br><span class="line"><span class="built_in">export</span> const constantRouterMap = [&#123;</span><br><span class="line">        path: <span class="string">'/login/:userId/:id'</span>,</span><br><span class="line">        name:<span class="string">'Message'</span>,    //就是要在路由配置里边配置这个属性，用来知道你要跳转到那个页面的名字</span><br><span class="line">    /***</span><br><span class="line">     * 如果想做到页面刷新，参数不丢失，就必须在path后面加上这个参数</span><br><span class="line">     * 但是这样做的话就会导致参数显示在url的后面，（在这一点上）跟query没什么区别了。</span><br><span class="line">    *  多个参数也可以一直往后边追加</span><br><span class="line">     */</span><br><span class="line">        component: _import(<span class="string">'login/index'</span>),</span><br><span class="line">        hidden: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">''</span>,</span><br><span class="line">        component: Layout,</span><br><span class="line">        redirect: <span class="string">'dashboard'</span>,</span><br><span class="line">        icon: <span class="string">'dashboard'</span>,</span><br><span class="line">        hidden: <span class="literal">true</span>,</span><br><span class="line">        noDropDown: <span class="literal">true</span>,</span><br><span class="line">        children: [&#123;</span><br><span class="line">            path: <span class="string">'dashboard'</span>,</span><br><span class="line">            name: <span class="string">'首页'</span>,</span><br><span class="line">            component: _import(<span class="string">'main/index'</span>),</span><br><span class="line">            meta: &#123;</span><br><span class="line">                title: <span class="string">'dashboard'</span>,</span><br><span class="line">                icon: <span class="string">'dashboard'</span>,</span><br><span class="line">                noCache: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default new Router(&#123;</span><br><span class="line">    routes: constantRouterMap</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>　　step:2,在传值页面的写法：<br>//用这种方法传参，必须这么些，不能写path,否则你在取参数的时候this.$router.params.userId就是undefined.这是因为，params只能用name来引入路由，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="variable">$router</span>.push(&#123;</span><br><span class="line">    name:<span class="string">"'Message'"</span>,//这个name就是你刚刚配置在router里边的name</span><br><span class="line">    params:&#123;</span><br><span class="line">          userId:<span class="string">"10011"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>　　step:3,在取值页面的写法：<br>切记，再取参数的时候一定是this.route 不是 this.router，切记。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$route.params.userId</span><br></pre></td></tr></table></figure></p><h6 id="使用query来传递参数"><a href="#使用query来传递参数" class="headerlink" title="使用query来传递参数"></a>使用query来传递参数</h6><p>　　step:1,在传值页面的写法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="variable">$router</span>.push(&#123;</span><br><span class="line">    path:<span class="string">"/login"</span>,//这个path就是你在router/index.js里边配置的路径</span><br><span class="line">    query:&#123;</span><br><span class="line">          userId:<span class="string">"10011"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>　　step:2,在取值页面的写法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">this.<span class="variable">$router</span>.currentRoute.query.userId</span><br><span class="line">第二种：</span><br><span class="line">这种方法再取参数的时候一定是this.<span class="variable">$route</span>   不是   this.<span class="variable">$router</span>，切记。</span><br><span class="line">this.<span class="variable">$route</span>.query.userId</span><br></pre></td></tr></table></figure></p><h6 id="使用vue里的标签来传递参数"><a href="#使用vue里的标签来传递参数" class="headerlink" title="使用vue里的标签来传递参数"></a>使用vue里的<router-link>标签来传递参数</router-link></h6><p>　　step:1,在传值页面的写法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link target=<span class="string">"_blank"</span></span><br><span class="line">   :to=<span class="string">"&#123;path:'/login',query:&#123;userId: "</span>33333<span class="string">"&#125;&#125;"</span>&gt;</span><br><span class="line"> &lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p><p>　　step:2,在取值页面的写法：同第二种。<br>其实，router-link也可以使用name的方法传参<br>　　同样，这种方法也需要在<code>router/index.js</code>里边配置每个页面的路径，name属性<br><code>name:&#39;Message&#39;</code>,    //就是要在路由配置里边配置这个属性，用来知道你要跳转到那个页面的名字<br><code>&lt;router-link :to=&quot;{name:&#39;&#39;Message&#39;&#39;,params:{userId:&#39;1234&#39;}}&quot;&gt;Hi页面1&lt;/router-link&gt;</code><br>取参方法：<br><code>this.$route.params.userId</code></p><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><p><code>更新视图但不重新请求页面</code><br>　　vue-router实现单页面路由跳转，提供了三种方式：hash模式、history模式、abstract模式，根据mode参数来决定采用哪一种方式。</p><h5 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h5><p>vue-router 提供了三种运行模式：<br>　　● hash: 使用 URL hash 值来作路由。默认模式。<br>　　● history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。<br>　　● abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端</p><h6 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h6><p>　　hash即浏览器url中#后面的内容，包含#。hash是URL中的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会加载相应位置的内容，不会重新加载页面。<br>也就是说<br>　　1. 即#是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中，不包含#。<br>　　2.每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置。</p><p>所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。</p><h6 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h6><p>　　<code>HTML5 History API</code>提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 <code>history.pushState API</code> 来完成 URL 跳转而无须重新加载页面；<br>　　由于hash模式会在url中自带#，如果不想要很丑的 <code>hash</code>，我们可以用路由的 <code>history</code> 模式，只需要在配置路由规则时，加入”<code>mode</code>: ‘<code>history</code>‘“,这种模式充分利用 <code>history.pushState API</code> 来完成 <code>URL</code> 跳转而无须重新加载页面。<br>　　有时，history模式下也会出问题：<br>eg:<br>hash模式下：<code>xxx.com/#/id=5</code> 请求地址为 <code>xxx.com</code>,没有问题。<br>history模式下：<code>xxx.com/id=5</code> 请求地址为 <code>xxx.com/id=5</code>，如果后端没有对应的路由处理，就会返回404错误；<br>　　为了应对这种情况，需要后台配置支持：<br>在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 <code>index.html</code> 页面，这个页面就是你 app 依赖的页面。</p><h6 id="abstract模式"><a href="#abstract模式" class="headerlink" title="abstract模式"></a>abstract模式</h6><p>　　abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。<br>根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 （当然，你也可以明确指定在所有情况下都使用 abstract 模式）。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>我们来看一下<code>vue-router</code>是如何定义的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from <span class="string">'vue-router'</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>　　可以看出来vue-router是通过 Vue.use的方法被注入进 Vue 实例中，在使用的时候我们需要全局用到 vue-router的router-view和router-link组件，以及this.$router/$route这样的实例对象。那么是如何实现这些操作的呢？下面我会分几个章节详细的带你进入vue-router的世界。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vue-router 实现 -- install</span><br><span class="line">vue-router 实现 -- new VueRouter(options)</span><br><span class="line">vue-router 实现 -- HashHistory</span><br><span class="line">vue-router 实现 -- HTML5History</span><br><span class="line">vue-router 实现 -- 路由变更监听</span><br></pre></td></tr></table></figure></p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>　　经过上面的阐述，相信您已经对前端路由以及vue-router有了一些大致的了解。那么这里我们为了贯彻无解肥，我们来手把手撸一个下面这样的数据驱动的 router：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">new Router(&#123;</span><br><span class="line">  id: <span class="string">'router-view'</span>, // 容器视图</span><br><span class="line">  mode: <span class="string">'hash'</span>, // 模式</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'home'</span>,</span><br><span class="line">      component: <span class="string">'&lt;div&gt;Home&lt;/div&gt;'</span>,</span><br><span class="line">      beforeEnter: (next) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'before enter home'</span>)</span><br><span class="line">        next()</span><br><span class="line">      &#125;,</span><br><span class="line">      afterEnter: (next) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'enter home'</span>)</span><br><span class="line">        next()</span><br><span class="line">      &#125;,</span><br><span class="line">      beforeLeave: (next) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'start leave home'</span>)</span><br><span class="line">        next()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/bar'</span>,</span><br><span class="line">      name: <span class="string">'bar'</span>,</span><br><span class="line">      component: <span class="string">'&lt;div&gt;Bar&lt;/div&gt;'</span>,</span><br><span class="line">      beforeEnter: (next) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'before enter bar'</span>)</span><br><span class="line">        next()</span><br><span class="line">      &#125;,</span><br><span class="line">      afterEnter: (next) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'enter bar'</span>)</span><br><span class="line">        next()</span><br><span class="line">      &#125;,</span><br><span class="line">      beforeLeave: (next) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'start leave bar'</span>)</span><br><span class="line">        next()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      name: <span class="string">'foo'</span>,</span><br><span class="line">      component: <span class="string">'&lt;div&gt;Foo&lt;/div&gt;'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h6 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h6><p>　　首先是数据驱动，所以我们可以通过一个route对象来表述当前路由状态，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">current = &#123;</span><br><span class="line">    path: <span class="string">'/'</span>, // 路径</span><br><span class="line">    query: &#123;&#125;, // query</span><br><span class="line">    params: &#123;&#125;, // params</span><br><span class="line">    name: <span class="string">''</span>, // 路由名</span><br><span class="line">    fullPath: <span class="string">'/'</span>, // 完整路径</span><br><span class="line">    route: &#123;&#125; // 记录当前路由属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　current.route内存放当前路由的配置信息，所以我们只需要监听current.route的变化来动态render页面便可。<br>接着我么需要监听不同的路由变化，做相应的处理。以及实现hash和history模式。</p><h6 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h6><p>　　这里我们延用vue数据驱动模型，实现一个简单的数据劫持，并更新视图。首先定义我们的observer<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">class Observer &#123;</span><br><span class="line">  constructor (value) &#123;</span><br><span class="line">    this.walk(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk (obj) &#123;</span><br><span class="line">    Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class="line">      // 如果是对象，则递归调用walk，保证每个属性都可以被defineReactive</span><br><span class="line">      <span class="keyword">if</span> (typeof obj[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">        this.walk(obj[key])</span><br><span class="line">      &#125;</span><br><span class="line">      defineReactive(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> defineReactive(obj, key, value) &#123;</span><br><span class="line">  <span class="built_in">let</span> dep = new Dep()</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    get: () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        // 依赖收集</span><br><span class="line">        dep.add()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: (newValue) =&gt; &#123;</span><br><span class="line">      value = newValue</span><br><span class="line">      // 通知更新，对应的更新视图</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> observer(value) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Observer(value)</span><br><span class="line">&#125;</span><br><span class="line">再接着，我们需要定义Dep和Watcher:</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> class Dep &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span> () &#123;</span><br><span class="line">    this.deppend = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">add</span></span> () &#123;</span><br><span class="line">    // 收集watcher</span><br><span class="line">    this.deppend.push(Dep.target)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span></span> () &#123;</span><br><span class="line">    this.deppend.forEach((target) =&gt; &#123;</span><br><span class="line">      // 调用watcher的更新函数</span><br><span class="line">      target.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.target = null</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> setTarget (target) &#123;</span><br><span class="line">  Dep.target = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">cleanTarget</span></span>() &#123;</span><br><span class="line">  Dep.target = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Watcher</span><br><span class="line"><span class="built_in">export</span> class Watcher &#123;</span><br><span class="line">  constructor (vm, expression, callback) &#123;</span><br><span class="line">    this.vm = vm</span><br><span class="line">    this.callbacks = []</span><br><span class="line">    this.expression = expression</span><br><span class="line">    this.callbacks.push(callback)</span><br><span class="line">    this.value = this.getVal()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getVal</span></span> () &#123;</span><br><span class="line">    setTarget(this)</span><br><span class="line">    // 触发 get 方法，完成对 watcher 的收集</span><br><span class="line">    <span class="built_in">let</span> val = this.vm</span><br><span class="line">    this.expression.split(<span class="string">'.'</span>).forEach((key) =&gt; &#123;</span><br><span class="line">      val = val[key]</span><br><span class="line">    &#125;)</span><br><span class="line">    cleanTarget()</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更新动作</span><br><span class="line">  <span class="function"><span class="title">update</span></span> () &#123;</span><br><span class="line">    this.callbacks.forEach((cb) =&gt; &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　到这里我们实现了一个简单的订阅-发布器，所以我们需要对<code>current.route</code>做数据劫持。一旦<code>current.route</code>更新，我们可以及时的更新当前页面：</p><p>  // 响应式数据劫持<br>  <code>observer(this.current)</code></p><p>  // 对 current.route 对象进行依赖收集，变化时通过 render 来更新<br>  <code>new Watcher(this.current, &#39;route&#39;, this.render.bind(this))</code><br>恩….到这里，我们似乎已经完成了一个简单的响应式数据更新。其实render也就是动态的为页面指定区域渲染对应内容，这里只做一个简化版的render:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> i</span><br><span class="line">  <span class="keyword">if</span> ((i = this.history.current) &amp;&amp; (i = i.route) &amp;&amp; (i = i.component)) &#123;</span><br><span class="line">    document.getElementById(this.container).innerHTML = i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="hash-和-history"><a href="#hash-和-history" class="headerlink" title="hash 和 history"></a>hash 和 history</h6><p>　　接下来是hash和history模式的实现，这里我们可以沿用vue-router的思想，建立不同的处理模型便可。来看一下我实现的核心代码：<br><code>this.history = this.mode === &#39;history&#39; ? new HTML5History(this) : new HashHistory(this)</code><br>当页面变化时，我们只需要监听hashchange和popstate事件，做路由转换transitionTo:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 路由转换</span><br><span class="line">   * @param target 目标路径</span><br><span class="line">   * @param cb 成功后的回调</span><br><span class="line">   */</span><br><span class="line">  transitionTo(target, cb) &#123;</span><br><span class="line">    // 通过对比传入的 routes 获取匹配到的 targetRoute 对象</span><br><span class="line">    const targetRoute = match(target, this.router.routes)</span><br><span class="line">    this.confirmTransition(targetRoute, () =&gt; &#123;</span><br><span class="line">      // 这里会触发视图更新</span><br><span class="line">      this.current.route = targetRoute</span><br><span class="line">      this.current.name = targetRoute.name</span><br><span class="line">      this.current.path = targetRoute.path</span><br><span class="line">      this.current.query = targetRoute.query || getQuery()</span><br><span class="line">      this.current.fullPath = getFullPath(this.current)</span><br><span class="line">      cb &amp;&amp; cb()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 确认跳转</span><br><span class="line">   * @param route</span><br><span class="line">   * @param cb</span><br><span class="line">   */</span><br><span class="line">  confirmTransition (route, cb) &#123;</span><br><span class="line">    // 钩子函数执行队列</span><br><span class="line">    <span class="built_in">let</span> queue = [].concat(</span><br><span class="line">      this.router.beforeEach,</span><br><span class="line">      this.current.route.beforeLeave,</span><br><span class="line">      route.beforeEnter,</span><br><span class="line">      route.afterEnter</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    // 通过 step 调度执行</span><br><span class="line">    <span class="built_in">let</span> i = -1</span><br><span class="line">    const step = () =&gt; &#123;</span><br><span class="line">      i ++</span><br><span class="line">      <span class="keyword">if</span> (i &gt; queue.length) &#123;</span><br><span class="line">        cb()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue[i]) &#123;</span><br><span class="line">        queue[i](step)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        step()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    step(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这样我们一方面通过<code>this.current.route = targetRoute</code>达到了对之前劫持数据的更新，来达到视图更新。另一方面我们又通过任务队列的调度，实现了基本的钩子函数<code>beforeEach、beforeLeave、beforeEnter、afterEnter</code>。<br>到这里其实也就差不多了，接下来我们顺带着实现几个API吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 跳转，添加历史记录</span><br><span class="line"> * @param location </span><br><span class="line"> * @example this.push(&#123;name: <span class="string">'home'</span>&#125;)</span><br><span class="line"> * @example this.push(<span class="string">'/'</span>)</span><br><span class="line"> */</span><br><span class="line">push (location) &#123;</span><br><span class="line">  const targetRoute = match(location, this.router.routes)</span><br><span class="line"></span><br><span class="line">  this.transitionTo(targetRoute, () =&gt; &#123;</span><br><span class="line">    changeUrl(this.router.base, this.current.fullPath)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 跳转，添加历史记录</span><br><span class="line"> * @param location</span><br><span class="line"> * @example this.replaceState(&#123;name: <span class="string">'home'</span>&#125;)</span><br><span class="line"> * @example this.replaceState(<span class="string">'/'</span>)</span><br><span class="line"> */</span><br><span class="line">replaceState(location) &#123;</span><br><span class="line">  const targetRoute = match(location, this.router.routes)</span><br><span class="line"></span><br><span class="line">  this.transitionTo(targetRoute, () =&gt; &#123;</span><br><span class="line">    changeUrl(this.router.base, this.current.fullPath, <span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go (n) &#123;</span><br><span class="line">  window.history.go(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> changeUrl(path, replace) &#123;</span><br><span class="line">  const href = window.location.href</span><br><span class="line">  const i = href.indexOf(<span class="string">'#'</span>)</span><br><span class="line">  const base = i &gt;= 0 ? href.slice(0, i) : href</span><br><span class="line">  <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">    window.history.replaceState(&#123;&#125;, <span class="string">''</span>, `<span class="variable">$&#123;base&#125;</span><span class="comment">#/$&#123;path&#125;`)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    window.history.pushState(&#123;&#125;, <span class="string">''</span>, `<span class="variable">$&#123;base&#125;</span><span class="comment">#/$&#123;path&#125;`)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里也就基本上结束了</p>]]></content>
      
      
      <categories>
          
          <category> vue-router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue图片懒加载原理及实现</title>
      <link href="/2019/09/25/JavaScript/Vue%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/09/25/JavaScript/Vue%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转：<br>　　<a href="https://www.jianshu.com/p/57e1055cc3fb" target="_blank" rel="noopener">Vue图片懒加载原理和实现</a><br>　　<a href="https://blog.csdn.net/Tom__cy/article/details/90299757" target="_blank" rel="noopener">Vue 中实现图片预加载 + 懒加载原理实现</a></p><h3 id="Vue图片懒加载原理及实现"><a href="#Vue图片懒加载原理及实现" class="headerlink" title="Vue图片懒加载原理及实现"></a>Vue图片懒加载原理及实现</h3><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>　　<code>先将img标签的src链接设为同一张图片(默认图片)，当js监听到该图片进入可视窗口时，再将实际地址应用。</code></p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><h5 id="1-判断元素是否在可视范围"><a href="#1-判断元素是否在可视范围" class="headerlink" title="1.判断元素是否在可视范围"></a>1.判断元素是否在可视范围</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断元素是否在可视范围</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> isVisible(ele)&#123;</span><br><span class="line">  <span class="built_in">let</span> windowHeight = window.innerHeight</span><br><span class="line">  <span class="built_in">let</span> position = ele.getBoundingClientRect()</span><br><span class="line">  // 当元素的top偏移量小于页面大小并且大于高度的负数</span><br><span class="line">  <span class="keyword">if</span>(position.top&lt;windowHeight &amp;&amp; position.top&gt;-position.height)&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-对图片实现懒加载"><a href="#2-对图片实现懒加载" class="headerlink" title="2.对图片实现懒加载"></a>2.对图片实现懒加载</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 对图片进行懒加载</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> lazyLoad(img, src)&#123;</span><br><span class="line">  <span class="keyword">if</span>(img &amp;&amp; src &amp;&amp; isVisible(img))&#123; // 元素存在，元素未被加载，元素可见</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">      img.setAttribute(<span class="string">'src'</span>, src)</span><br><span class="line">    &#125;, 1000) // 模拟网络请求</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-添加滚动监听"><a href="#3-添加滚动监听" class="headerlink" title="3.添加滚动监听"></a>3.添加滚动监听</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 窗口滚动</span><br><span class="line">window.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  lazyLoad(img, src)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Vue插件实现代码"><a href="#Vue插件实现代码" class="headerlink" title="Vue插件实现代码"></a>Vue插件实现代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断元素可见</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> isVisible(el)&#123;</span><br><span class="line">  <span class="built_in">let</span> windowHeight = window.innerHeight</span><br><span class="line">  <span class="built_in">let</span> position = el.getBoundingClientRect()</span><br><span class="line">  // 当元素的top偏移量小于页面大小并且大于高度的负数</span><br><span class="line">  <span class="keyword">if</span>(position.top&lt;windowHeight &amp;&amp; position.top&gt;-position.height)&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对图片进行懒加载</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> lazyLoad(img, src)&#123;</span><br><span class="line">  <span class="keyword">if</span>(img &amp;&amp; src &amp;&amp; isVisible(img))&#123; // 元素存在，元素未被加载，元素可见</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">      img.setAttribute(<span class="string">'src'</span>, src)</span><br><span class="line">    &#125;, 1000) // 模拟网络请求慢的情况</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  install(Vue, options)&#123;</span><br><span class="line">    Vue.directive(<span class="string">'lazy'</span>, &#123;</span><br><span class="line">      <span class="built_in">bind</span>: <span class="keyword">function</span>(el, binding, vnode)&#123;</span><br><span class="line">        el.setAttribute(<span class="string">'src'</span>, options.loading)</span><br><span class="line">        window.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">          lazyLoad(el, binding.value)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      inserted: <span class="keyword">function</span>(el, binding, vnode)&#123;</span><br><span class="line">        lazyLoad(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　main.js<br><code>Vue.use(myPlugin, {loading: defaultImg})</code></p><h4 id="在Vue中使用-vue-lazyload插件"><a href="#在Vue中使用-vue-lazyload插件" class="headerlink" title="在Vue中使用 vue-lazyload插件"></a>在Vue中使用 vue-lazyload插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.安装插件</span><br><span class="line">npm install vue-lazyload --save-dev</span><br><span class="line"></span><br><span class="line">2.在入口文件main.js中引入并使用</span><br><span class="line">import VueLazyload from <span class="string">'vue-lazyload'</span></span><br><span class="line"></span><br><span class="line">直接使用</span><br><span class="line">Vue.use(VueLazyload)</span><br><span class="line"></span><br><span class="line">或者添加自定义选项</span><br><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">  preLoad: 1.3,</span><br><span class="line">  error: <span class="string">'dist/error.png'</span>,</span><br><span class="line">  loading: <span class="string">'dist/loading.gif'</span>,</span><br><span class="line">  attempt: 1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">3.修改图片显示方式为懒加载（将 :src 属性直接改为v-lazy）</span><br><span class="line">&lt;a href=<span class="string">"javascript:;"</span>&gt;</span><br><span class="line">  &lt;img v-lazy=<span class="string">"'/static/img/' + item.productImage"</span>&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>移动端适配</title>
      <link href="/2019/09/23/JavaScript/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
      <url>/2019/09/23/JavaScript/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p><a href="https://juejin.im/post/5b6cfcffe51d453a1d27080b" target="_blank" rel="noopener">移动端常见兼容性问题解决方案</a><br><a href="https://juejin.im/post/5add7a44f265da0b886d05f8#heading-0" target="_blank" rel="noopener">移动端适配问题解决方案</a><br><a href="https://www.jianshu.com/p/2a091bd289ba" target="_blank" rel="noopener">解决vue移动端适配问题</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AJAX</title>
      <link href="/2019/09/23/Ajax/AJAX/"/>
      <url>/2019/09/23/Ajax/AJAX/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h3 id="AJAX简介"><a href="#AJAX简介" class="headerlink" title="AJAX简介"></a>AJAX简介</h3><p>　　AJAX全称为“Asynchronous Javascript And XML”， 即“异步JavaScript和XML”的意思。通过AJAX我们可以向服务器发送请求，在不阻塞页面的情况下进行数据交互，也可以理解为异步数据传输。在AJAX的帮助下我们的网页只需局部刷新即可更新数据的显示，减少了不必要的数据量，大大提高了用户体验，缩短了用户等待的时间，使得web应用程序更小、更快，更友好。<a id="more"></a></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>　　页面无刷新，用户体验好。<br>　　异步通信，更加快的响应能力。<br>　　减少冗余请求，减轻了服务器负担<br>　　基于标准化的并被广泛支持的技术，不需要下载插件或者小程序</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>　　ajax干掉了back按钮，即对浏览器后退机制的破坏。<br>　　存在一定的安全问题。<br>　　对搜索引擎的支持比较弱。<br>　　破坏了程序的异常机制。<br>　　无法用URL直接访问</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>　　场景 1. 数据验证<br>　　场景 2. 按需取数据<br>　　场景 3. 自动更新页面</p><h3 id="AJAX的核心-XMLHttpRequest对象"><a href="#AJAX的核心-XMLHttpRequest对象" class="headerlink" title="AJAX的核心 XMLHttpRequest对象"></a>AJAX的核心 XMLHttpRequest对象</h3><p>创建XML对象的实例：<code>const xhr = new XMLHttpRequest()</code></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备启动一个AJAX请求</span></span><br><span class="line">.open()</span><br><span class="line"><span class="comment"># 设置请求头部信息</span></span><br><span class="line">.setRequestHeader()</span><br><span class="line"><span class="comment"># 发送AJAX请求</span></span><br><span class="line">.send()</span><br><span class="line"><span class="comment"># 获得响应头部信息</span></span><br><span class="line">.getResponseHeader()</span><br><span class="line"><span class="comment"># 获得一个包含所有头部信息的长字符串</span></span><br><span class="line">.getAllResponseHeader()</span><br><span class="line"><span class="comment"># 取消异步请求</span></span><br><span class="line">.abort()</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个JavaScript函数对象，当readyState属性改变时会调用它。</span></span><br><span class="line"><span class="comment"># 回调函数会在user interface线程中调用。</span></span><br><span class="line">onreadystatechange</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示“请求”/“响应”过程的当前活动阶段</span></span><br><span class="line"><span class="comment"># HTTP 请求的状态.当一个 XMLHttpRequest 初次创建时，</span></span><br><span class="line"><span class="comment"># 这个属性的值从 0 开始，直到接收到完整的 HTTP 响应，这个值增加到 4。</span></span><br><span class="line"><span class="comment"># 0 Uninitialized 初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。</span></span><br><span class="line"><span class="comment"># 1 Open open() 方法已调用，但是 send() 方法未调用。请求还没有被发送。</span></span><br><span class="line"><span class="comment"># 2 Sent Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。</span></span><br><span class="line"><span class="comment"># 3 Receiving   所有响应头部都已经接收到。响应体开始接收但未完成。</span></span><br><span class="line"><span class="comment"># 4 Loaded      HTTP 响应已经完全接收。</span></span><br><span class="line"><span class="comment"># readyState 的值不会递减，除非当一个请求在处理过程中的时候调用了</span></span><br><span class="line"><span class="comment">#  abort() 或 open() 方法。每次这个属性的值增加的时候，都会触发 </span></span><br><span class="line"><span class="comment"># onreadystatechange 事件句柄。</span></span><br><span class="line">.readyState</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前为止为服务器接收到的响应体（不包括头部），或者如果还没有接收到数据的话，</span></span><br><span class="line"><span class="comment"># 就是空字符串。</span></span><br><span class="line"><span class="comment"># 如果 readyState 小于 3，这个属性就是一个空字符串。当 readyState 为 3，</span></span><br><span class="line"><span class="comment"># 这个属性返回目前已经接收的响应部分。如果 readyState 为 4，这个属性保存</span></span><br><span class="line"><span class="comment"># 了完整的响应体。</span></span><br><span class="line">.responseText</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果响应的内容类型时text/xml或application/xml，</span></span><br><span class="line"><span class="comment"># 该属性将保存包含着相应数据的XML DOM文档</span></span><br><span class="line">.responseXML</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应的HTTP状态</span></span><br><span class="line">.status</span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP状态的说明</span></span><br><span class="line">.statusText</span><br></pre></td></tr></table></figure><h5 id="XMLHttpRequest-方法"><a href="#XMLHttpRequest-方法" class="headerlink" title="XMLHttpRequest 方法"></a>XMLHttpRequest 方法</h5><h6 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h6><p>取消当前响应，关闭连接并且结束任何未决的网络活动。<br>　　这个方法把 <code>XMLHttpRequest</code> 对象重置为 <code>readyState</code>为 0 的状态，并且取消所有未决的网络活动。例如，如果请求用了太长时间，而且响应不再必要的时候，可以调用这个方法。</p><h6 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders()"></a>getAllResponseHeaders()</h6><p>把 HTTP 响应头部作为未解析的字符串返回。<br>　　如果 <code>readyState</code> 小于 3，这个方法返回 null。否则，它返回服务器发送的所有 HTTP 响应的头部。头部作为单个的字符串返回，一行一个头部。每行用换行符 <code>&quot;\r\n&quot;</code> 隔开。</p><h6 id="getResponseHeader"><a href="#getResponseHeader" class="headerlink" title="getResponseHeader()"></a>getResponseHeader()</h6><p>　　返回指定的 HTTP 响应头部的值。其参数是要返回的 <code>HTTP</code> 响应头部的名称。可以使用任何大小写来制定这个头部名字，和响应头部的比较是不区分大小写的。<br>　　该方法的返回值是指定的 HTTP 响应头部的值，如果没有接收到这个头部或者 readyState 小于 3 则为空字符串。如果接收到多个有指定名称的头部，这个头部的值被连接起来并返回，使用逗号和空格分隔开各个头部的值。</p><h6 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h6><p>初始化一个请求. 该方法用于JavaScript代码中;如果是本地代码, 使用 openRequest())方法代替.</p><blockquote><p>注意: 在一个已经激活的request下（已经调用open()或者openRequest()方法的request）再次调用这个方法相当于调用了abort（）方法。</p></blockquote><p>参数：<br><code>method</code><br>　　请求所使用的HTTP方法; 例如 “GET”, “POST”, “PUT”, “DELETE”等. 如果下个参数是非HTTP(S)的URL,则忽略该参数.<br><code>url</code><br>　　该请求所要访问的URL<br><code>async</code><br>　　一个可选的布尔值参数，默认为true,意味着是否执行异步操作，如果值为false,则send()方法不会返回任何东西，直到接受到了服务器的返回数据。如果为值为true，一个对开发者透明的通知会发送到相关的事件监听者。这个值必须是true,如果multipart 属性是true，否则将会出现一个意外。<br><code>user</code><br>　　用户名,可选参数,为授权使用;默认参数为空string.<br><code>password</code><br>　　密码,可选参数,为授权使用;默认参数为空string.</p><h6 id="sned"><a href="#sned" class="headerlink" title="sned()"></a>sned()</h6><p>发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体。</p><h6 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader()"></a>setRequestHeader()</h6><p>向一个打开但未发送的请求设置或添加一个 HTTP 请求(设置请求头)。<br>参数：<br><code>header</code><br>　　将要被赋值的请求头名称<br><code>value</code><br>　　给指定的请求头赋的值</p><h3 id="发送AJAX请求"><a href="#发送AJAX请求" class="headerlink" title="发送AJAX请求"></a>发送AJAX请求</h3><h4 id="设置请求头部信息"><a href="#设置请求头部信息" class="headerlink" title="设置请求头部信息"></a>设置请求头部信息</h4><p>　　每个HTTP请求和响应都会带有相应的头部信息，包含一些与数据，收发者网络环境与状态等相关信息。XMLHttpRequest对象提供的.setRequestHeader()方法为开发者提供了一个操作这两种头部信息的方法，并允许开发者自定义请求头的头部信息。<br>默认情况下，当发送AJAX请求时，会附带以下头部信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浏览器能够处理的内容类型</span></span><br><span class="line">Accept</span><br><span class="line"><span class="comment"># 浏览器能够显示的字符集</span></span><br><span class="line">Accept-Charset</span><br><span class="line"><span class="comment"># 浏览器能够处理的压缩编码</span></span><br><span class="line">Accept-Encoding</span><br><span class="line"><span class="comment"># 浏览器当前设置的语言</span></span><br><span class="line">Accept-Language</span><br><span class="line"><span class="comment"># 浏览器与服务器之间连接的类型</span></span><br><span class="line">Connection</span><br><span class="line"><span class="comment"># 当前页面设置的任何Cookie</span></span><br><span class="line">Cookie</span><br><span class="line"><span class="comment"># 发出请求的页面所在的域</span></span><br><span class="line">Host</span><br><span class="line"><span class="comment"># 发出请求的页面URI</span></span><br><span class="line">Referer</span><br><span class="line"><span class="comment"># 浏览器的用户代理字符串</span></span><br><span class="line">User-Agent</span><br></pre></td></tr></table></figure></p><p><strong>注意:</strong><br>　　部分浏览器不允许使用<code>.setRequestHeader()</code>方法重写默认请求头信息，因此自定义请求头信息是更加安全的方法：<br><code># 自定义请求头</code><br><code>xhr.setRequestHeader(&quot;myHeader&quot;, &quot;MyValue&quot;)</code></p><h4 id="发送AJAX请求-1"><a href="#发送AJAX请求-1" class="headerlink" title="发送AJAX请求"></a>发送AJAX请求</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送AJAX请求</span></span><br><span class="line"><span class="comment"># 使用get方法发送同步请求(false)</span></span><br><span class="line"><span class="built_in">let</span> xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.php'</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">'myHeader'</span>, <span class="string">'goodHeader'</span>)</span><br><span class="line">xhr.send(null)</span><br><span class="line"></span><br><span class="line"><span class="comment"># POST请求</span></span><br><span class="line"><span class="built_in">let</span> xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'example.php'</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">'myHeader'</span>, <span class="string">'goodHeader'</span>)</span><br><span class="line">shr.send(some_data)</span><br></pre></td></tr></table></figure><h4 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h4><p>同步的GET请求响应：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"example.php"</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">"myHeader"</span>, <span class="string">"goodHeader"</span>)</span><br><span class="line">xhr.send(null)</span><br><span class="line"><span class="comment"># 由于是同步的AJAX请求，因此只有当服务器响应后才会继续执行下面的代码</span></span><br><span class="line"><span class="comment"># 因此xhr.status的值一定不为默认值</span></span><br><span class="line"><span class="keyword">if</span>((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;</span><br><span class="line">  console.log(<span class="string">"xhr.responseText:"</span>, xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  console.log(<span class="string">"Request was unsuccessful:"</span>, xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　上面的代码不难理解，我们通过之前提到的<code>xhr.status</code>属性（如果你忘记了，它存储着响应的HTTP状态）判断请求是否成功，如果成功的话，我们将读取<code>xhr.responseText</code>属性中存储的返回值。但是，当我们的请求为异步时，问题就稍微变得复杂了，由于是异步的请求，在<code>xhr.send(null)</code>语句被执行后，<code>JavaScript</code>引擎会紧接着执行下面的判断语句，而这时由于尚未来得及响应，我们注定会得到一个默认的<code>xhr.status</code>值，因此，我们永远都不可能获取请求的资源了。<br>如何解决这个问题？答案是通过为<code>XMLHTTPRequest</code>实例添加<code>onreadystatechange</code>事件处理程序（当然你也可以直接使用DOM2级规范规定的<code>.addEventListener()</code>方法，但是注意，IE8是不支持该方法的）。<br>　　xhr实例的<code>readystatechange</code>事件会监听<code>xhr.readyState</code>属性的变化，你可以将这个属性想象为一个计数器，随着AJAX流程的推进而不断累加，其可取的值如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　0：未初始化 -- 尚未调用.open()方法</span><br><span class="line">　　1：启动 -- 已经调用.open()方法，但尚未调用.send()方法</span><br><span class="line">　　2：发送 -- 已经调用.send()方法，但尚未接收到响应</span><br><span class="line">　　3：接收 -- 已经接收到部分响应数据</span><br><span class="line">　　4：完成 -- 已经接收到全部响应数据，而且已经可以在客户端使用了</span><br></pre></td></tr></table></figure></p><p>有了这个时间处理程序对AJAX进程做监听，剩下的事就简单多了，一个<code>异步</code>的<code>GET</code>请求代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest()</span><br><span class="line"><span class="comment"># 等价于 xhr.onreadystatechange = function()&#123;&#125;</span></span><br><span class="line"><span class="comment"># 利用onreadystatechange监测状态</span></span><br><span class="line">xhr.onreadystatechange = () =&gt; &#123;</span><br><span class="line">  <span class="comment"># readyState为4表示请求响应完成</span></span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState == 4) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;</span><br><span class="line">      console.log(<span class="string">"xhr.responseText:"</span>, xhr.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      console.log(<span class="string">"Request was unsuccessful:"</span>, xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'example.php'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(null)</span><br></pre></td></tr></table></figure></p><h3 id="其他库框架中的AJAX"><a href="#其他库框架中的AJAX" class="headerlink" title="其他库框架中的AJAX"></a>其他库框架中的AJAX</h3><h4 id="jQuery中的AJAX"><a href="#jQuery中的AJAX" class="headerlink" title="jQuery中的AJAX"></a>jQuery中的AJAX</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    method: <span class="string">'GET'</span>, <span class="comment"># 1.9.0本版前用'type'</span></span><br><span class="line">    url: <span class="string">"/test/"</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">done</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'执行成功'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.fail(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'执行出错'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Vue-js中的AJAX"><a href="#Vue-js中的AJAX" class="headerlink" title="Vue.js中的AJAX"></a>Vue.js中的AJAX</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.get(<span class="string">'/test/'</span>).<span class="keyword">then</span>((response) =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'执行成功'</span>);</span><br><span class="line">&#125;, (response) =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'执行出错'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="状态值和状态码"><a href="#状态值和状态码" class="headerlink" title="状态值和状态码"></a>状态值和状态码</h3><h4 id="状态值于状态码："><a href="#状态值于状态码：" class="headerlink" title="状态值于状态码："></a>状态值于状态码：</h4><blockquote><p>在ajax时间运行过程中，对于访问XMLHttpRequest不是一次就完成的，而是经历多种状态后获取的结果。<br>对于这种状态在ajax中分为5中状态：<br>0: (未初始化)还没有调用send()方法。<br>1: (载入)已经调用send()方法，正在派发请求。<br>2: (载入完成)send()已经执行完成，已经接收到全部的响应内容。<br>3: (交互)正在解析响应内容。<br>4: (完成)响应内容已经解析完成，用户可以调用。</p></blockquote><blockquote><p>ajax状态值和状态码的区别：<br>ajax的状态值指，运行ajax时运行的几种状态，无论是成功还是失败都要响应的步骤。如：正在派发，正在响应等，由ajax对象和<br>服务器之间交互是所得。使用ajax.readyState获得（0~4）<br>ajax状态码是值，ajax无论请求是否成功，根据http所提及的用户信息，用服务器返回http头信息代码，使用ajax.state来获得</p></blockquote><blockquote><p>这就是我们在使用AJAX时为什么采用下面的方式判断所获得的信息是否正确的原因。<br>if(ajax.readyState == 4 &amp;&amp; ajax.status == 200) {<br>    putData(ajax.responseText);<br>}</p></blockquote><h4 id="ajax状态码："><a href="#ajax状态码：" class="headerlink" title="ajax状态码："></a>ajax状态码：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">AJAX状态码说明</span><br><span class="line"></span><br><span class="line">1**：请求收到，继续处理</span><br><span class="line">2**：操作成功收到，分析、接受</span><br><span class="line">3**：完成此请求必须进一步处理</span><br><span class="line">4**：请求包含一个错误语法或不能完成</span><br><span class="line">5**：服务器执行一个完全有效请求失败</span><br><span class="line">100——客户必须继续发出请求</span><br><span class="line">101——客户要求服务器根据请求转换HTTP协议版本</span><br><span class="line">200——交易成功</span><br><span class="line">201——提示知道新文件的URL</span><br><span class="line">202——接受和处理、但处理未完成</span><br><span class="line">203——返回信息不确定或不完整</span><br><span class="line">204——请求收到，但返回信息为空</span><br><span class="line">205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</span><br><span class="line">206——服务器已经完成了部分用户的GET请求</span><br><span class="line">300——请求的资源可在多处得到</span><br><span class="line">301——删除请求数据</span><br><span class="line">302——在其他地址发现了请求数据</span><br><span class="line">303——建议客户访问其他URL或访问方式</span><br><span class="line">304——客户端已经执行了GET，但文件未变化</span><br><span class="line">305——请求的资源必须从服务器指定的地址得到</span><br><span class="line">306——前一版本HTTP中使用的代码，现行版本中不再使用</span><br><span class="line">307——申明请求的资源临时性删除</span><br><span class="line">400——错误请求，如语法错误</span><br><span class="line">401——请求授权失败</span><br><span class="line">402——保留有效ChargeTo头响应</span><br><span class="line">403——请求不允许</span><br><span class="line">404——没有发现文件、查询或URl</span><br><span class="line">405——用户在Request-Line字段定义的方法不允许</span><br><span class="line">406——根据用户发送的Accept拖，请求资源不可访问</span><br><span class="line">407——类似401，用户必须首先在代理服务器上得到授权</span><br><span class="line">408——客户端没有在用户指定的饿时间内完成请求</span><br><span class="line">409——对当前资源状态，请求不能完成</span><br><span class="line">410——服务器上不再有此资源且无进一步的参考地址</span><br><span class="line">411——服务器拒绝用户定义的Content-Length属性请求</span><br><span class="line">412——一个或多个请求头字段在当前请求中错误</span><br><span class="line">413——请求的资源大于服务器允许的大小</span><br><span class="line">414——请求的资源URL长于服务器允许的长度</span><br><span class="line">415——请求资源不支持请求项目格式</span><br><span class="line">416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</span><br><span class="line">417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求</span><br><span class="line">500——服务器产生内部错误</span><br><span class="line">501——服务器不支持请求的函数</span><br><span class="line">502——服务器暂时不可用，有时是为了防止发生系统过载</span><br><span class="line">503——服务器过载或暂停维修</span><br><span class="line">504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长</span><br><span class="line">505——服务器不支持或拒绝支请求头中指定的HTTP版本</span><br></pre></td></tr></table></figure><h4 id="ajax类库"><a href="#ajax类库" class="headerlink" title="ajax类库"></a>ajax类库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">function</span> ajax(value)&#123;</span><br><span class="line">        var url = value.url;</span><br><span class="line">        var <span class="built_in">type</span> = value.type || <span class="string">"get"</span>;</span><br><span class="line">        var data = value.data || <span class="string">""</span>;</span><br><span class="line">        var success = value.success;</span><br><span class="line">        var error = value.error || <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        //1、创建AJAX对象</span><br><span class="line">        var oAjax;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            //Firefox,Opera 8.0+, Safari</span><br><span class="line">            oAjax = new XMLHttpRequest();</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            //Internet Explorer</span><br><span class="line">            try&#123;</span><br><span class="line">                oAjax = new ActiveXObject(<span class="string">"Msxml2.XMLHTTP"</span>);</span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    oAjax = new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">                &#125;catch(e)&#123;</span><br><span class="line">                    alert(<span class="string">"浏览器不支持ajax"</span>);</span><br><span class="line">                    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //链接服务器</span><br><span class="line">        oAjax.open(<span class="built_in">type</span>, url, <span class="literal">true</span>);</span><br><span class="line">        //发送请求</span><br><span class="line">        oAjax.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded;charset=UTF-8"</span>);</span><br><span class="line">        oAjax.send(data);</span><br><span class="line">        //数据接收</span><br><span class="line">        oAjax.onreadystatechange = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            <span class="keyword">if</span>(oAjax.readyState == 4)&#123;</span><br><span class="line">                <span class="keyword">if</span>(oAjax.stack == 200)&#123;</span><br><span class="line">                    var data = oAjax.responseText;</span><br><span class="line">                    success(data);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(error)&#123;</span><br><span class="line">                        error();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>转载：<br>　　<a href="https://juejin.im/post/5a20b1f1f265da432529179c" target="_blank" rel="noopener">使用AJAX</a></p>]]></content>
      
      
      <categories>
          
          <category> AJAX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AJAX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据埋点</title>
      <link href="/2019/09/23/JavaScript/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9/"/>
      <url>/2019/09/23/JavaScript/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h2 id="数据埋点"><a href="#数据埋点" class="headerlink" title="数据埋点"></a>数据埋点</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>　　所谓埋点就是在应用中特定的流程收集一些信息，用来跟踪应用使用的状况，后续用来进一步优化产品或是提供运营的数据支撑，包括访问数（<code>Visits</code>），访客数（<code>Visitor</code>），停留时长（<code>Time On Site</code>），页面浏览数（<code>Page Views</code>）和跳出率（<code>Bounce Rate</code>）。这样的信息收集可以大致分为两种：页面统计（<code>track this virtual page view</code>），统计操作行为（<code>track this button by an event</code>）</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>现在埋点的主流有两种方式：<br>　　第一种：自己公司研发在产品中注入代码统计，并搭建起相应的后台查询。<br>　　第二种：第三方统计工具，如友盟、神策、<code>Talkingdata</code>、<code>GrowingIO</code>等。</p><h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标<a id="more"></a></h3><h4 id="访问与访客"><a href="#访问与访客" class="headerlink" title="访问与访客"></a>访问与访客</h4><p>　　访问次数（Visits）与访问人数（Vistors）是几乎所有应用都需要统计的指标，这也是最基础的指标。<br>　　对于应用的统计来说，经常看到的DAU，MAU，UV等指标都是指统计访客（Vistors）。访问（Visits）是指会话层，用户打开应用花一段时间浏览又离开，从指标定义（访问次数）来说这被称之为统计会话（Session）数。<br>　　一次会话（Session 或 Visit）是打开应用的第一个请求（打开应用）和最后一个请求决定的。如果用户打开应用然后放下手机或是离开电脑，并在接下来30分钟内没有任何动作，此次会话自动结束，通常也算作一次访问或会话期（30分钟是早起网页版应用约定俗成的会话数定义，目前用户停留在应用的时长变长，30分钟的限定也可能随之不同，总之是能代表一次用户访问的时长）。<br>　　在计算访问人数（Vistors）时，埋点上报的数据是尽可能接近真实访客的人数。对于有需要统计独立访客这个指标的场景，这里还是需要强调一下，访问人数（Vistors）并不是真实独立的人，因此收集数据时必须知道访问人数虽然能够很好的反映使用应用的真实访问者的数量，但不等于使用应用的真实人数。（原因是，重复安装的应用，或是手机参数被修改都会使得独立访客的指标收到影响。计算访问人数的埋点都是依赖Cookie，用户打开应用，应用都会在此人的终端创建一个独立Cookie, Cookie会被保留，但还是难免会被用户手动清理或是Cookie被禁用导致同一用户使用应用Cookie不一致，所以独立访客只能高度接近于使用应用的真实人数。）</p><h4 id="停留时长"><a href="#停留时长" class="headerlink" title="停留时长"></a>停留时长</h4><p>　　停留时长用来衡量用户在应用的某一个页面或是一次访问（会话）所停留的时间。<br>　　页面停留时长，表示在每个页面所花费的时间；例如：首页就是进入首页（10：00）到离开首页进入下一个页面(10:01)的时长，首页停留时长计算为1分钟。页面A是2分钟。停留时长的数据并不都是一定采集得到的，比如页面B进入时间（10：03），离开出现异常或是退出时间没有记录，这时候计算就是0 （所以指标计算时需要了解埋点的状况，剔除这样的无效数据）。<br>　　应用的停留时长，表示一次访问（会话）所停留的时间，计算起来就是所有页面的访问时长，同样是上一个流程，应用的停留时长就是4分钟。</p><h4 id="跳出率"><a href="#跳出率" class="headerlink" title="跳出率"></a>跳出率</h4><p>　　跳出率的计算方法现在在各个公司还是很多种，最经常被使用的是：用户只访问了一个页面所占的会话比例（原因是：假设这种场景，用户来了访问了一个页面就离开了，想想用户使用的心里画面应该是：打开应用，心想什么鬼，然后关闭应用甚至卸载了。这个场景多可怕，这也是为什么跳出率指标被如此关注）<br>　　跳出率可以分解到两个层次：<code>一是整个应用的跳出率</code>，<code>二是重点的着陆页的跳出率</code>，甚至是搜索关键词的跳出率。跳出率的指标可操作性非常强，通过统计跳出率可以直接发现页面的问题发现关键词的问题。</p><h4 id="退出率"><a href="#退出率" class="headerlink" title="退出率"></a>退出率</h4><p>　　退出率是针对页面的，这个指标的目标很简单，就是在针对某个页面有多少用户离开了应用，主要用户反映用户从应用离开的情况。哪些页面需要被改进最快的方式被发掘。（注意：退出率高不一定是坏事。例如：预测流程的最终节点的退出率就应该是高的）</p><h4 id="转化率"><a href="#转化率" class="headerlink" title="转化率"></a>转化率</h4><p>　　我们在产品上投入这么多，不就是为了衡量产出么？所以对于电商类应用，还有比转化率更值得关注的指标吗？转化率的计算方法是某种产出除以独立访客或是访问量，对于电商产品来说，就是提交订单用户数除以独立访客。<br>　　转化率的计算看起来想到那简单，但却是埋点中最贴近业务的数据收集。这也是最体现埋点技巧的指标，需要结合业务特点制定计算方法。提交订单量/访客数是最基本的转化率，转化率还可以分层次，指定用户路径的，如：完成某条路径的提交订单数/访客数。<br>　　试着找一条路径，想想转化率的数据怎么得来的吧，埋点都收集了什么样的数据吧？参与度参与度并不是一个指标，而是一系列的指标的统称，例如访问深度，访问频次，针对电商的下单次数，针对内容服务商的播放次数，及用户行为序列这些都可以是衡量参与度的指标。之所以把参与度列为一个指标，是希望大家明白把指标结合业务，产生化学反应，活学活用去发现事物的本质。</p><h4 id="埋点的内容"><a href="#埋点的内容" class="headerlink" title="埋点的内容"></a>埋点的内容</h4><p>　　看完关键的这些指标后，其实埋点大致分为两部分，一部分是统计应用页面访问情况，即页面统计，随页面访问动作发生时进行上报；另外一部分是统计应用内的操作行为，在页面中操作时进行上报（例如：组件曝光时，组件点击时，上滑，下滑时）。<br>　　为了统计到所需要的指标，应用中的所有页面，事件都被唯一标记，用户的信息，设备的信息，时间参数以及符合业务需要的参数具体内容被附加上报，就是埋点。</p><h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><h4 id="1、提高网站的转化率"><a href="#1、提高网站的转化率" class="headerlink" title="1、提高网站的转化率"></a>1、提高网站的转化率</h4><p>　　根据页面埋点可得到一些重要信息，它告诉你用户对网站的反应，以及如何<code>提高网站流量</code>、<code>改进网站性能</code>，<code>了解用户访问网站的行为</code>，<code>为更好地满足用户需求提供支持</code>。 </p><h4 id="2、反应用户黏度"><a href="#2、反应用户黏度" class="headerlink" title="2、反应用户黏度"></a>2、反应用户黏度</h4><p>　　即使网站吸引了很多用户访问，但是通过流量分析发现，用户停留的时间非常短，重复访问用户不多，用户平均浏览的页面也少，这样的网站用户黏度不够，有流量但是没有忠实的用户，一旦有其它可替代网站，用户随时可能流失。这样的网站，如果不采取有效的运营措施，很难有长期发展的后劲。</p><h4 id="3、为网站内容管理和网站的产品策划提供方向"><a href="#3、为网站内容管理和网站的产品策划提供方向" class="headerlink" title="3、为网站内容管理和网站的产品策划提供方向"></a>3、为网站内容管理和网站的产品策划提供方向</h4><p>　　通过流量分析，可以挖掘出整个网站哪个频道最有人气，频道之间的流量比例是多少，每个页面的流量是多少，哪个页面最受欢迎，每个页面中具体的哪个栏目点击 量最高，这样通过对频道、栏目、页面的具体流量分析和对比，可以挖掘出用户的需求，发现用户最关心什么内容，这对评估网站频道、内容、页面的价值有重要的 参考作用，也对网站内容下一步的优化有直接的参考意义。</p><blockquote><p>转载：<br><a href="https://zhuanlan.zhihu.com/p/25195217" target="_blank" rel="noopener">数据埋点是什么？设置埋点的意义是什么？</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/07/21/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/%E5%87%86%E5%A4%87/"/>
      <url>/2019/07/21/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">【百度-母婴业务部-前端】校招提前批内推</span><br><span class="line">lanjianguo@baidu.com</span><br><span class="line">1.姓名2.邮箱3.手机号4.简历5.推荐词（选填）</span><br><span class="line">坑位有限，先到先得，截止到8月14日。</span><br><span class="line">百度招聘官网：https://talent.baidu.com/external/baidu/campus.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">旷视科技</span><br><span class="line">sihaiyang@megvii.com</span><br><span class="line">发邮件时请注明岗位和工作地点，默认北京，正文请备注自己的姓名、邮箱、手机号。附件为简历，简历建议命名为：姓名-学校-手机号。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">陌陌</span><br><span class="line">https://uploadfiles.nowcoder.com/images/20190715/340047502_1563204023495_E4050D8294A27655000FDBF912B1FD08</span><br><span class="line">1.打开下方二维码（用微信扫描）</span><br><span class="line">2.选择自己对应的岗位</span><br><span class="line">3.扔简历</span><br><span class="line">4.内推完成</span><br><span class="line">https://app.mokahr.com/recommendation-apply/immomo/2050/?recommenderId=192152&amp;<span class="built_in">hash</span>=%23%2Fjobs%3Fkeyword%3D2020%26page%3D1%26isCampusJob%3D1%26_k%3D4v9ivu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">快手</span><br><span class="line">867326226@qq.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">贝壳找房</span><br><span class="line">23107689内推人:莫健锋</span><br><span class="line">http://campus.ke.com/Campus</span><br><span class="line">岗位 下划线 姓名 下划线 学校.pdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">拼多多</span><br><span class="line">xulongxiang@pinduoduo.com</span><br><span class="line">2020届学霸批+姓名+学校+岗位.pdf</span><br><span class="line">上海 web前端研发工程师</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">商汤研究院招前端-cv实习生</span><br><span class="line">sunjiaming@sensetime.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">阿里巴巴[秋招]</span><br><span class="line">qijin.hq@alibaba-inc.com</span><br><span class="line">【秋招内推】 姓名_学校_专业_L7GT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QQ音乐提前批来啦招聘web前端工程师</span><br><span class="line">坐标深圳，qqmusic_fe@outlook.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">星环科技</span><br><span class="line">前端开发工程师（实习生）</span><br><span class="line">扫描二维码，关注“星环科技招聘”，选择“星招聘”，进入校园招聘页面，</span><br><span class="line">选择你心仪的岗位进行投递</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>前端-面试题</title>
      <link href="/2019/07/21/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/vue%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/07/21/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单自我介绍, 做过哪些项目, 使用哪些技术栈 ?<br>如何看待前端框架选型 ?<br>vue的如何实现双向绑定的 ？<br>react 虚拟DOM 是什么? 如何实现? 说一下diff算法 ?<br>工作中最出色的点, 和你最头疼的问题 如何解决的 ?<br>平时如何学习, 最近接触了解了哪些新的知识 ?<br>技术一面<br>简单自我介绍, 介绍一下你的项目, 技术栈 ?<br>react和vue的比较 ?<br>React Diff 算法 ?<br>观察者模式实现 ?<br>http报文头部有哪些字段? 有什么意义 ?<br>移动端高清方案如何解决 ?<br>webpack的原理, loader 和 plugin 是干什么的? 有自己手写过么 ?<br>简述从网页输入url到网页展示的过程发生了哪些事情 ?<br>SSR 和 客户端渲染有什么区别 , vue是如何实现绑定事件的 ?<br>简述公司node架构中容灾的实现 ?<br>浏览器事件有哪些过程? 为什么一般在冒泡阶段, 而不是在捕获阶段注册监听? addEventListener 参数分别是什么 ?<br>面向对象如何实现? 需要复用的变量 怎么处理 ?<br>移动端300ms延时的原因? 如何处理?<br>主流框架的数据单向/双向绑定实现原理 ?<br>简述转行经历, 如何学习 ?<br>你觉得自己在前端工作的最大的优点是什么 拿实际工作的内容举例?<br>技术二面<br>和一面前3问基本一致,简述项目,React vue区别 virsualDOM实现<br>DIFF算法为什么是O(n)复杂度而不是O(n^3)<br>http code码?<br>移动端rem布局如何实现? 简述原理?<br>JSbridge原理, js和native是如何通信的?<br>Rollup和webpack区别, treeshaking是什么?<br>TCP三次握手的过程, get post请求的区别 ?<br>静态文件的浏览器缓存如何实现?<br>前端跨域方案<br>http 请求包含哪些字段 分别是什么意思<br>js 有哪些数据类型 如何判断? null 和 undefined区别 应用场景?<br>new String(‘a’) 和 ‘a’ 是一样的么?<br>移动端如何实现下拉到底部 跟随移动 结束后回弹的动画?<br>移动端如何优化首页白屏时间过长 ?<br>ES6 generator函数简述<br>数组去重实现?<br>js浮点数运算不精确 如何解决?<br>工作中最得意和出色的点, 头疼的点, 问题如何解决的<br>为何换工作?<br>聊了下阿里的压力,文化<br>技术三面<br>公司的前端工程化实践<br>转行之后是如何自学前端的, 学习途径 有没有一些自己的代码<br>DOM基础知识,添加元素,删除元素等等…<br>DOM节点类型<br>正则表达式如何匹配一段url ?在正则表达式中有哪几种作用?<br>移动端优化方式? 离线包是如何实现的?</p><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">https://ustbhuangyi.github.io/vue-analysis/</a></p><p>我的手机 2019/3/14 10:04:34<br><a href="https://www.jianshu.com/p/a804606ad8e9" target="_blank" rel="noopener">https://www.jianshu.com/p/a804606ad8e9</a></p><p>我的手机 2019/3/14 10:04:50<br><a href="https://www.cnblogs.com/chinabin1993/p/9115396.html" target="_blank" rel="noopener">https://www.cnblogs.com/chinabin1993/p/9115396.html</a></p><p>我的手机 2019/3/14 10:05:03<br><a href="https://segmentfault.com/a/1190000012996217" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012996217</a></p><p>我的手机 2019/3/14 10:05:20<br><a href="https://blog.csdn.net/qq_35430000/article/details/79291287" target="_blank" rel="noopener">https://blog.csdn.net/qq_35430000/article/details/79291287</a></p><p>我的手机 2019/3/14 10:05:37<br><a href="https://m.jb51.net/article/140581.htm" target="_blank" rel="noopener">https://m.jb51.net/article/140581.htm</a></p><p><a href="https://yukwan.cn/fronttech/front-end/" target="_blank" rel="noopener">https://yukwan.cn/fronttech/front-end/</a><br>2019/3/8 16:31:10<br>我的手机 2019/3/8 16:31:10<br><a href="https://mp.weixin.qq.com/s/L8P0RIXym4myfknzM5Nsog" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/L8P0RIXym4myfknzM5Nsog</a><br>2019/3/9 16:28:42<br>我的手机 2019/3/9 16:28:42<br><a href="https://campushr.hikvision.com/JobDetails.html?id=057c01652bb444b597345337c7b8c14f&amp;type=0" target="_blank" rel="noopener">https://campushr.hikvision.com/JobDetails.html?id=057c01652bb444b597345337c7b8c14f&amp;type=0</a></p><p><a href="https://wx2.sinaimg.cn/mw690/005NaMhPly1g0nayy8lbij30hs59p7wh.jpg?from=singlemessage" target="_blank" rel="noopener">https://wx2.sinaimg.cn/mw690/005NaMhPly1g0nayy8lbij30hs59p7wh.jpg?from=singlemessage</a></p><h3 id="2019-07-21"><a href="#2019-07-21" class="headerlink" title="2019-07-21"></a>2019-07-21</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">1. 说一下CSS盒模型</span><br><span class="line">标准盒模型和IE怪异盒模型，然后提到了设置 box-sizing 可以转换及一些常见应用场景（这题过）</span><br><span class="line">2. 怎样让一个元素水平垂直居中</span><br><span class="line">3. 知道什么是同源策略吗</span><br><span class="line">4. 那怎么解决跨域问题</span><br><span class="line">5. 知道 JSONP 原理吗</span><br><span class="line">6. 怎么检测浏览器中的内存泄漏</span><br><span class="line">7. 如果要让你给 chrome 写一个插件检测内存泄漏说一下你的思路</span><br><span class="line">8. 重绘和重排的区别</span><br><span class="line">9. 知道浏览器事件机制吗</span><br><span class="line">10. 从输入一个URL到页面加载完成发生了什么</span><br><span class="line">11. 计算机网络了解吗？OSI七层模型？选择一个比较熟悉的层，介绍一下有哪些协议</span><br><span class="line">12. DNS的运行过程，DNS性能优化有哪些方法</span><br><span class="line">13. 写代码：给一个淘宝的页面，写一下大概如何布局</span><br><span class="line">14. 写代码，DOM操作将所有页面元素存为一个&#123;key:count&#125;的结构，即统计在页面中每种元素的数量，将元素根据count进行排序。</span><br><span class="line">15. 垃圾回收机制</span><br><span class="line">16. https和http区别，对称加密和非对称加密区别</span><br><span class="line">17. http1.0和http1.1和http2.0</span><br><span class="line">18. CSS盒模型（box-sizing属性）</span><br><span class="line">19. 写代码：多维数组展为一维数组（如：[[1,2],3,[4,5,6],[7,8]]-&gt;[1,2,3,4,5,6,7,8]）</span><br><span class="line">20. 写代码：自己实现一个instanceof</span><br><span class="line">21. 对于原型链的理解，new的过程中发生了什么，写代码：自己实现一个new</span><br><span class="line">22. Vue双向绑定的原理</span><br><span class="line">23. Vue双向绑定的原理</span><br><span class="line">24. Vue组件间的通信</span><br><span class="line">25. CSS雪碧图是什么</span><br><span class="line">26. 重绘和重排，哪些属性会触发重绘，哪些属性会触发重排</span><br><span class="line">27. ES6中<span class="built_in">let</span>,const,var的区别</span><br><span class="line">28. map,forEach的区别</span><br><span class="line">29. 跨域有哪些方法</span><br><span class="line">30. 写代码：多维数组展开成一维数组，分析算法的时间复杂度，用es6的什么方法可以实现（flat）</span><br><span class="line">31. 写代码：数组去重有哪些方法</span><br><span class="line">32. 写代码：用闭包实现add()函数，第n次调用的时候输出n</span><br><span class="line">33. this的指向问题：</span><br><span class="line">var a=2; var obj=&#123; a:1, b:this.a, fun:<span class="function"><span class="title">function</span></span>()&#123; console.log(this.b); &#125; &#125;</span><br><span class="line">输出结果为2，分析原因</span><br><span class="line">34. 写代码：实现call函数</span><br><span class="line">35. TCP三次握手，为什么是三次</span><br><span class="line">36. http请求包括什么，http应答包括什么</span><br><span class="line">37. 了解哪些状态码</span><br><span class="line">38. 输入url到页面出现发生了什么</span><br><span class="line">39. 浏览器渲染机制</span><br><span class="line">40. 什么是同源策略（如何判断是否同源），CORS策略</span><br><span class="line">41. CSS实现三角形，箭头</span><br><span class="line">42. CSS垂直居中的方法</span><br><span class="line">43. CSRF和XSS是什么，如何预防</span><br><span class="line">44. localStorage和sessionStorage区别，localStorage最大存储量</span><br><span class="line">45. CORS机制</span><br><span class="line">46. Chrome调试断点如何设置</span><br><span class="line">47. TCP三次握手，为什么不是四次，为什么不是两次</span><br><span class="line">48. 浏览器渲染机制，js阻塞加载</span><br><span class="line">49. js动态加载，<span class="built_in">eval</span>()方法</span><br><span class="line">50. 写代码：请求一个require.js文件，并统计文件中<span class="string">'require'</span>的数量，分析时间复杂度，如何优化</span><br><span class="line">51. 为什么想做前端，平时如何学习前端，知不知道社区里有哪些大神，讲讲最近看的一些前端相关的知识</span><br><span class="line">52. 自己对前端未来发展方向是什么</span><br><span class="line">53. 如何实现一个轮播图效果</span><br><span class="line">54. CSS3新特性了解哪些</span><br><span class="line">55. js数组的方法、对象的方法</span><br><span class="line">56. Flex布局</span><br><span class="line">57. js闭包</span><br><span class="line">58. json是什么，为什么要用json</span><br><span class="line">59. ajax元素操作的步骤</span><br><span class="line">60. 数组排序的方法有哪些？说一下归并</span><br><span class="line">61. 数组深拷贝</span><br><span class="line">62. 从后端返回一个很大的数组，如何实现分页显示（通过数组下标进行对应）</span><br><span class="line">63. 如何实现一个下划线（和text-decoration里的underline不一样），答案：用box-shadow</span><br><span class="line">64. 单页应用有什么好处</span><br><span class="line">65. 如何判断一个链表是否有环</span><br><span class="line">66. 一个二叉树中找到两个节点的最小公共父节点</span><br><span class="line">67. js闭包是什么，什么是内存泄漏，如何解决内存泄漏问题</span><br><span class="line">68. js垃圾回收机制</span><br><span class="line">69. 原生ajax原理，ajax和fetch的区别，fetch支持http的哪些方法</span><br><span class="line">70. option方法可以发送那些内容</span><br><span class="line">71. CSS的display有哪些取值</span><br><span class="line">72. iso七层模型，每一层模型的经典协议</span><br><span class="line">73. es6新增的数组方法</span><br><span class="line">74. 数组的reduce方法</span><br><span class="line">75. js中找到一个数组最大值的方法，分析复杂度</span><br><span class="line">76. MVC和MVVM的区别，MVVM的优点</span><br><span class="line">77. flex布局用在哪些场景下</span><br><span class="line">78. 如何适配不同的屏幕</span><br><span class="line">79. HTTP状态码有哪些</span><br><span class="line">80. cookie,localStorage,sessionStorage的区别</span><br><span class="line">81. es6的<span class="built_in">let</span>,const和var区别，const绑定的对象能不能修改属性值</span><br><span class="line">82. Vue数组双向绑定的原理，数组中没有get和<span class="built_in">set</span>方法，应该如何实现数据劫持</span><br><span class="line">83. event-loop原理，宏任务，微任务有哪些</span><br><span class="line">84. 如何实现水平垂直居中（元素定长和不定长）</span><br><span class="line">85. position有哪些属性，有什么区别，除了定位上的不同还有什么区别</span><br><span class="line">86. Vue组件中的data为什么是函数</span><br><span class="line">87. Vue双向数据绑定的原理</span><br><span class="line">88. webpack怎么用，实现机制</span><br><span class="line">89. Vuex相关</span><br><span class="line">90. 一个网站图片很多，加载很慢，应该如何优化：DOMContentLoad,图片懒加载，CDN</span><br><span class="line">91. Vue的watch和computed区别</span><br><span class="line">92. CSS选择器优先级</span><br><span class="line">93. es5实现继承</span><br><span class="line">94. 一个页面加载不出来可能是那些方面的原因</span><br><span class="line">95. setTimeout和Promise的区别，如何实现Promise</span><br><span class="line">96. HTTP持续连接实现原理</span><br><span class="line">97. 了解哪些设计模式</span><br><span class="line">98. jQ选择器的实现原理</span><br><span class="line">99. Vue中虚拟DOM解决什么问题，原理？</span><br><span class="line">100. http协议是什么，请求和响应的构成，如何区分一个请求的头部和实体（中间有一个空行）</span><br><span class="line">101. http有哪些方法，为什么要有这些方法（语义化）</span><br><span class="line">102. 状态码3开头的有哪些，浏览器收到301和302怎么做，304用在哪些场景</span><br><span class="line">103. cookie相关，cookie用在什么场景，cookie有哪些性质</span><br><span class="line">104.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/07/10/%E5%89%8D%E7%AB%AF%E8%A7%84%E5%88%99/%E4%BB%A3%E7%A0%81%E8%A7%84%E5%88%99/"/>
      <url>/2019/07/10/%E5%89%8D%E7%AB%AF%E8%A7%84%E5%88%99/%E4%BB%A3%E7%A0%81%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前端代码命名规则"><a href="#前端代码命名规则" class="headerlink" title="前端代码命名规则"></a>前端代码命名规则</h3><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><ul><li>项目命名</li><li>目录/文件夹命名</li><li>JavaScript文件命名</li><li>css (scss、less、stylus)文件命名</li><li>html文件命名</li></ul><h4 id="HTML文件代码规范"><a href="#HTML文件代码规范" class="headerlink" title="HTML文件代码规范"></a>HTML文件代码规范</h4><ul><li>语法 （缩进，dom属性命名规范，单双引号的运用）</li><li>lang 属性</li><li>字符串编码</li><li>IE兼容模式</li><li>CSS 引入方式</li><li>JavaScript 文件引入顺序</li><li>避免 dom 标签嵌套的层级过多</li></ul><h4 id="CSS-文件代码规范"><a href="#CSS-文件代码规范" class="headerlink" title="CSS 文件代码规范"></a>CSS 文件代码规范</h4><ul><li>缩进</li><li>分号</li><li>空格</li><li>换行</li><li>注释方案</li><li>命名</li><li>媒体查询</li><li>….</li></ul><h4 id="JavaScript-文件代码规范"><a href="#JavaScript-文件代码规范" class="headerlink" title="JavaScript 文件代码规范"></a>JavaScript 文件代码规范</h4><ul><li>缩进、空格、换行、注释…</li><li>变量命名</li><li>函数引用</li><li>数组对象</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>事件循环与任务队列</title>
      <link href="/2019/04/22/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
      <url>/2019/04/22/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p><a href="https://juejin.im/post/5c8a024d51882546be0a3082" target="_blank" rel="noopener">从面试题看 JS 事件循环与 macro micro 任务队列</a></p><h3 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a>事件轮询</h3><p><strong>同步任务</strong> 指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<br><strong>异步任务</strong> 指的是，不进入主线程、而进入”任务队列”（<code>task queue</code>）的任务，等待同步任务执行完毕之后，轮询执行异步任务队列中的任务<br><strong>macrotask队列</strong> 等同于我们常说的任务队列，macrotask是由宿主环境分发的异步任务，事件轮询的时候总是一个一个任务队列去查看执行的，”任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。<br><strong>microtask</strong> 即<code>微任务</code>，是由js引擎分发的任务，总是添加到当前任务队列末尾执行。另外在处理<code>microtask</code>期间，如果有新添加的<code>microtasks</code>，也会被添加到队列的末尾并执行。注意与<code>setTimeout(fn,0)</code>的区别：<br>　　<code>setTimeOut(fn(),0)</code> 指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。<br><strong>所以我们可以得到js执行顺序是：</strong></p><blockquote><p>开始 -&gt; 取第一个task queue里的任务执行(可以认为同步任务队列是第一个task queue) -&gt; 取 microtask 全部任务依次执行 -&gt; 取下一个task queue里的任务执行 -&gt; 再次取出microtask全部任务执行 -&gt; … 这样循环往复</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CommonJS&amp;&amp;AMD&amp;&amp;CMD</title>
      <link href="/2019/04/21/JavaScript/CommonJS&amp;&amp;AMD&amp;&amp;CMD/"/>
      <url>/2019/04/21/JavaScript/CommonJS&amp;&amp;AMD&amp;&amp;CMD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p><a href="https://juejin.im/post/5aaa37c8f265da23945f365c" target="_blank" rel="noopener">前端模块化：CommonJS,AMD,CMD,ES6</a><br><a href="https://juejin.im/post/5c17ad756fb9a049ff4e0a62#heading-2" target="_blank" rel="noopener">前端模块化详解(完整版)</a></p><h2 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h2><h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h3><p>　　将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。<br>　　块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。</p><h3 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h3><p>　　避免命名冲突(减少命名空间污染)<br>　　更好的分离, 按需加载<br>　　更高复用性<br>　　高可维护性</p><h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>　　Node 应用由模块组成，采用 <code>CommonJS</code> 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>　　所有代码都运行在模块作用域，不会污染全局作用域。<br>　　模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。<br>　　模块加载的顺序，按照其在代码中出现的顺序。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>　　暴露模块：<code>module.exports = value</code>或<code>exports.xxx = value</code><br>　　引入模块：<code>require(xxx)</code>,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</p><p>　　此处我们有个疑问：<strong>CommonJS暴露的模块到底是什么?</strong> CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。<strong>加载某个模块，其实是加载该模块的module.exports属性。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var x = 5;</span><br><span class="line">var addX = <span class="keyword">function</span> (value) &#123;</span><br><span class="line">  <span class="built_in">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.x = x;</span><br><span class="line">module.exports.addX = addX;</span><br></pre></td></tr></table></figure></p><p>上面代码通过<code>module.exports</code>输出变量x和函数addX。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span><br><span class="line">var example = require(<span class="string">'./example.js'</span>);</span><br><span class="line">console.log(example.x); // 5</span><br><span class="line">console.log(example.addX(1)); // 6</span><br></pre></td></tr></table></figure></p><p>　　require命令用于加载模块文件。<strong>require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</strong></p><h4 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h4><p>　　<strong>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</strong>。这点与ES6模块化有重大差异（下文会介绍），请看下面这个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line">var counter = 3;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">incCounter</span></span>() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">var counter = require(<span class="string">'./lib'</span>).counter;</span><br><span class="line">var incCounter = require(<span class="string">'./lib'</span>).incCounter;</span><br><span class="line"></span><br><span class="line">console.log(counter);  // 3</span><br><span class="line">incCounter();</span><br><span class="line">console.log(counter); // 3</span><br></pre></td></tr></table></figure></p><p>　　上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。<strong>这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</strong></p><h3 id="AMD和require-js"><a href="#AMD和require-js" class="headerlink" title="AMD和require.js"></a>AMD和require.js</h3><p>　　AMD规范采用<code>异步方式加载模块</code>，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用<code>require.js</code>实现<code>AMD</code>规范的模块化：用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。<br>　　首先我们需要引入<code>require.js</code>文件和一个入口文件<code>main.js</code>。<code>main.js</code>中配置<code>require.config()</code>并规定项目中用到的基础模块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/** 网页中引入require.js及main.js **/</span><br><span class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/main"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">/** main.js 入口文件/主模块 **/</span><br><span class="line">// 首先用config()指定各模块路径和引用名</span><br><span class="line">require.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">"js/lib"</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,  //实际路径为js/lib/jquery.min.js</span><br><span class="line">    <span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 执行基本操作</span><br><span class="line">require([<span class="string">"jquery"</span>,<span class="string">"underscore"</span>],<span class="keyword">function</span>($,_)&#123;</span><br><span class="line">  // some code here</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>　　引用模块的时候，我们将模块名放在<code>[]</code>中作为<code>reqiure()</code>的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在<code>[]</code>中作为<code>define()</code>的第一参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 定义math.js模块</span><br><span class="line">define(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var basicNum = 0;</span><br><span class="line">    var add = <span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">        <span class="built_in">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        add: add,</span><br><span class="line">        basicNum :basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">// 定义一个依赖underscore.js的模块</span><br><span class="line">define([<span class="string">'underscore'</span>],<span class="keyword">function</span>(_)&#123;</span><br><span class="line">  var classify = <span class="keyword">function</span>(list)&#123;</span><br><span class="line">    _.countBy(list,<span class="keyword">function</span>(num)&#123;</span><br><span class="line">      <span class="built_in">return</span> num &gt; 30 ? <span class="string">'old'</span> : <span class="string">'young'</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    classify :classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 引用模块，将模块放在[]内</span><br><span class="line">require([<span class="string">'jquery'</span>, <span class="string">'math'</span>],<span class="keyword">function</span>($, math)&#123;</span><br><span class="line">  var sum = math.add(10,20);</span><br><span class="line">  $(<span class="string">"#sum"</span>).html(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>　　CMD规范专门用于浏览器端，<code>模块的加载是异步的</code>，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。</p><h4 id="CMD规范基本语法"><a href="#CMD规范基本语法" class="headerlink" title="CMD规范基本语法"></a>CMD规范基本语法</h4><p>定义暴露模块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义没有依赖的模块</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module)&#123;</span><br><span class="line">  exports.xxx = value</span><br><span class="line">  module.exports = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义有依赖的模块</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module)&#123;</span><br><span class="line">  //引入依赖模块(同步)</span><br><span class="line">  var module2 = require(<span class="string">'./module2'</span>)</span><br><span class="line">  //引入依赖模块(异步)</span><br><span class="line">    require.async(<span class="string">'./module3'</span>, <span class="keyword">function</span> (m3) &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  //暴露模块</span><br><span class="line">  exports.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>引入使用模块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span> (require) &#123;</span><br><span class="line">  var m1 = require(<span class="string">'./module1'</span>)</span><br><span class="line">  var m4 = require(<span class="string">'./module4'</span>)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="CMD和sea-js"><a href="#CMD和sea-js" class="headerlink" title="CMD和sea.js"></a>CMD和sea.js</h3><p>　　require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>], <span class="keyword">function</span>(a, b, c, d, e, f) &#123; </span><br><span class="line">    // 等于在最前面声明并初始化了要用到的所有模块</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">      // 即便没用到某个模块 b，但 b 还是提前执行了</span><br><span class="line">      b.foo()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>　　CMD是另一种js模块化方案，它与AMD很类似，不同点在于：<strong>AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/** AMD写法 **/</span><br><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>], <span class="keyword">function</span>(a, b, c, d, e, f) &#123; </span><br><span class="line">     // 等于在最前面声明并初始化了要用到的所有模块</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        // 即便没用到某个模块 b，但 b 还是提前执行了</span><br><span class="line">        b.doSomething()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/** CMD写法 **/</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var a = require(<span class="string">'./a'</span>); //在需要时申明</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        var b = require(<span class="string">'./b'</span>);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/** sea.js **/</span><br><span class="line">// 定义模块 math.js</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var $ = require(<span class="string">'jquery.js'</span>);</span><br><span class="line">    var add = <span class="keyword">function</span>(a,b)&#123;</span><br><span class="line">        <span class="built_in">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    exports.add = add;</span><br><span class="line">&#125;);</span><br><span class="line">// 加载模块</span><br><span class="line">seajs.use([<span class="string">'math.js'</span>], <span class="keyword">function</span>(math)&#123;</span><br><span class="line">    var sum = math.add(1+2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>　　ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/** 定义模块 math.js **/</span><br><span class="line">var basicNum = 0;</span><br><span class="line">var add = <span class="keyword">function</span> (a, b) &#123;</span><br><span class="line">    <span class="built_in">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">export</span> &#123; basicNum, add &#125;;</span><br><span class="line"></span><br><span class="line">/** 引用模块 **/</span><br><span class="line">import &#123; basicNum, add &#125; from <span class="string">'./math'</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(ele) &#123;</span><br><span class="line">    ele.textContent = add(99 + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　如上例所示，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名。其实<code>ES6</code>还提供了<code>exportdefault</code>命令，为模块指定默认输出，对应的<code>import</code>语句不需要使用大括号。这也更趋近于<code>ADM</code>的引用写法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** <span class="built_in">export</span> default **/</span><br><span class="line">//定义输出</span><br><span class="line"><span class="built_in">export</span> default &#123; basicNum, add &#125;;</span><br><span class="line">//引入</span><br><span class="line">import math from <span class="string">'./math'</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(ele) &#123;</span><br><span class="line">    ele.textContent = math.add(99 + math.basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p><h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><h4 id="CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h4><p>　　CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。<br>　　ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> counter = 3;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">incCounter</span></span>() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">// main.js</span><br><span class="line">import &#123; counter, incCounter &#125; from <span class="string">'./lib'</span>;</span><br><span class="line">console.log(counter); // 3</span><br><span class="line">incCounter();</span><br><span class="line">console.log(counter); // 4</span><br></pre></td></tr></table></figure></p><h4 id="CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h4><p>　　运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。<br>　　编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。<br>　　CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。<br>　　AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。<br>　　CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重<br>　　ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>项目的总结</title>
      <link href="/2019/04/21/Project/Backstage/"/>
      <url>/2019/04/21/Project/Backstage/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>项目名： 森尚宅配全屋定制流程控制系统<br>项目地址： <a href="https://github.com/aLittleLittleStar/Backstage" target="_blank" rel="noopener">https://github.com/aLittleLittleStar/Backstage</a><br>项目技术：<br>Asp.net<br>MySQL8.0.13<br>JQuery2.2.4<br>BootStarp3.3.7<br>负责功能：<br>前端页面的设计与编写<br>登录交互功能的编写<br>（如何根据不同的用户权限对内容页面的展示进行修改。解决方法使用localStrong把用户类别放到本地前端读取之后进行相对应页面的显示和隐藏），<br>时间组件bootstrap-datetimepicker的使用<br>页面的布局 flex布局<br>iframe 的使用： 点击侧边栏菜单内容页面进行相应的切换<br>项目的难点：<br>登录功能的实现</p><p>Travel去哪儿网<br>项目地址： <a href="https://github.com/aLittleLittleStar/Travel" target="_blank" rel="noopener">https://github.com/aLittleLittleStar/Travel</a><br>项目技术：<br>node10.5.0<br>npm 3.0.0<br>axios 0.18.0<br>better-scroll 6.26.0<br>faskclick 1.0.6<br>stylus 0.54.5<br>vue 2.5.2<br>vue-router 3.0.1<br>vuex 3.0.1<br>ESLint 4.15.0<br>webpack 3.6.0</p><p>负责功能：页面的设计，功能分析，编译打包<br>数据的传递共享（vuex）<br>项目的难点：<br>解决一像素边框问题 fastclick<br>使用ajax获取数据</p><p>刷新页面是轮播图无法显示第一页<br>解决方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;swiper :options=&quot;swiperOption&quot; v-if=&quot;showSwiper&quot;&gt;</span><br><span class="line">&lt;!-- 计算属性：计算list数组长度，刚开始没有加载数据所以数组长度为0，v-if为false页面不显示 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        showSwiper () &#123;</span><br><span class="line">            return this.list.length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编程风格</title>
      <link href="/2019/04/17/JavaScript/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
      <url>/2019/04/17/JavaScript/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>块级作用域<br>字符串<br>解构赋值<br>对象<br>数组<br>函数<br>Map函数<br>Class<br>模板<br>ESLint 使用</p><h3 id="正则："><a href="#正则：" class="headerlink" title="正则："></a>正则：</h3><h4 id="两种模糊匹配"><a href="#两种模糊匹配" class="headerlink" title="两种模糊匹配"></a>两种模糊匹配</h4><h5 id="横向模糊匹配"><a href="#横向模糊匹配" class="headerlink" title="横向模糊匹配"></a>横向模糊匹配</h5><p>横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。<br>{m,n}，表示连续出现最少m次，最多n次。<br>比如/ab{2,5}c/表示匹配这样一个字符串：第一个字符是“a”，接下来是2到5个字符“b”，最后是字符“c”。</p><h5 id="纵向模糊匹配"><a href="#纵向模糊匹配" class="headerlink" title="纵向模糊匹配"></a>纵向模糊匹配</h5><p>纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>蘑菇街面试准备</title>
      <link href="/2019/04/15/JavaScript/%E8%98%91%E8%8F%87%E8%A1%97%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/04/15/JavaScript/%E8%98%91%E8%8F%87%E8%A1%97%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>const<br>let  var 之间的区别<br>4、es6中的const解释解释<br>9.em和rem区别<br>3.js部分，const，let和 var 的区别。<br>4.js部分，数组遍历map和forEach的区别。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">能用forEach()做到的，map()同样可以。反过来也是如此。</span><br><span class="line">map()会分配内存空间存储新数组并返回，forEach()不会返回数据。</span><br><span class="line">forEach()允许callback更改原始数组的元素。map()返回新的数组。</span><br></pre></td></tr></table></figure></p><p>5.css部分，em和rem怎么做自适应。<br>8.函数提升和变量提升优先级<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">函数提升 优于变量</span><br><span class="line">解析器在向执行环境中加载数据时会率先读取函数声明，并使其在执行任何代码之前可用(可访问)，即函数声明提升、JavaScript上卷中第40页提到函数声明是优于变量提升的。可见代码</span><br><span class="line">console.log(getName)</span><br><span class="line">var getName = 1;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">// 输出为函数getName</span><br><span class="line">注意:不要学了一点就忘记别的了啊，如果两个函数名一样，后面的会覆盖前面的(认为是在函数解析的时候覆盖，即提升的时候就覆盖了)</span><br></pre></td></tr></table></figure></p><p>JS深拷贝的用处，哪里会用到？</p><blockquote><p>浅拷贝<br>深拷贝 </p></blockquote><p>7、闭包以及带来问题<br>闭包知道吗？它可能出现的问题呢<br>10、css有哪些布局（一开始理解错了说了一大堆，后来面试官带回来了，是关于position、float）<br>11、flex实现水平垂直居中<br>12、align-items:center是不是只针对垂直<br>css布局都用过啥，flex布局，想让我说flex布局的原理的。。。想想还是算了，感觉面试官对原理情有独钟<br>CSS布局技巧<br>跨域的几种方式，有答jsonp，然后又问了 jsonp 的原理是啥？<br>6.跨域问题<br>6.常用的跨域方式。<br>项目有没跨域问题<br>5.作用域链<br><a href="https://juejin.im/post/58ed9c0ea0bb9f006a4c28cd" target="_blank" rel="noopener">JavaScript深入之作用域链</a><br><a href="https://juejin.im/post/5c8290455188257e5d0ec64f" target="_blank" rel="noopener">深入理解JavaScript作用域和作用域链</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">作用域链，是由当前环境与上层环境的一系列变量对象组成，</span><br><span class="line">它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</span><br><span class="line"></span><br><span class="line">当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，</span><br><span class="line">就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到</span><br><span class="line">全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对</span><br><span class="line">象构成的链表就叫做作用域链。</span><br></pre></td></tr></table></figure></p><p>第一个问题是讲一下原型链，这个我先推了一下，讲了个小插曲，promise的状态和蘑菇街面试的状态吻合，只有pending、resolved、rejected三种状态，算是个破冰吧，今天看promise想到的。<br>然后继续回答原型链。</p><p>2、Promise了解多少<br><a href="https://juejin.im/post/5b32f552f265da59991155f0" target="_blank" rel="noopener"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Promise 是异步编程的一种解决方案：</span><br><span class="line">从语法上讲，promise是一个对象，从它可以获取异步操作的消息；</span><br><span class="line">从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</span><br><span class="line">promise有三种状态：pending(等待态)，fulfiled(成功态)，rejected(失败态)；</span><br><span class="line">状态一旦改变，就不会再变。创造promise实例后，它会立即执行。</span><br><span class="line"></span><br><span class="line">pending，异步任务正在进行。</span><br><span class="line">resolved (也可以叫fulfilled)，异步任务执行成功。</span><br><span class="line">rejected，异步任务执行失败。</span><br><span class="line"></span><br><span class="line">回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</span><br><span class="line">promise可以支持多个并发的请求，获取并发请求中的数据</span><br><span class="line">这个promise可以解决异步的问题，本身不能说promise是异步的</span><br><span class="line"></span><br><span class="line">Promise.resolve(value)</span><br><span class="line">类方法，该方法返回一个以 value 值解析后的 Promise 对象</span><br><span class="line">1、如果这个值是个 thenable（即带有 <span class="keyword">then</span> 方法），返回的 Promise </span><br><span class="line">对象会“跟随”这个 thenable 的对象，采用它的最终状态</span><br><span class="line">（指 resolved/rejected/pending/settled）</span><br><span class="line">2、如果传入的 value 本身就是 Promise 对象，</span><br><span class="line">  则该对象作为 Promise.resolve 方法的返回值返回。</span><br><span class="line">3、其他情况以该值为成功状态返回一个 Promise 对象。</span><br><span class="line"></span><br><span class="line">Promise.all的用法：谁跑的慢，以谁为准执行回调。</span><br><span class="line">  all接收一个数组参数，里面的值最终都算返回Promise对象</span><br><span class="line">  all方法可以说是Promise中很常用的方法了，它的作用就是将一个数组的Promise对象放在其中，当全部resolve的时候就会执行<span class="keyword">then</span>方法，当有一个reject的时候就会执行catch，并且他们的结果也是按着数组中的顺序来排放的，那么我们来实现一下。</span><br><span class="line">Promise.race的用法：谁跑的快，以谁为准执行回调</span><br><span class="line">它的作用是将一个Promise数组放入race中，哪个先执行完，race就直接执行完，并从<span class="keyword">then</span>中取值。</span><br><span class="line">Promise.prototype.catch</span><br><span class="line">  实例方法，捕获异常，函数形式：fn(err)&#123;&#125;, err 是 catch 注册 之前的回调抛出的异常信息。</span><br><span class="line">Promise.prototype.then</span><br><span class="line">  实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue)&#123;&#125;，value 是上一个任务的返回结果，<span class="keyword">then</span> 中的函数一定要 <span class="built_in">return</span> 一个结果或者一个新的 Promise 对象，才可以让之后的<span class="keyword">then</span> 回调接收。</span><br><span class="line">Promise.reject</span><br><span class="line">类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。</span><br><span class="line"></span><br><span class="line">Promise的立即执行性</span><br><span class="line">Promise 三种状态</span><br><span class="line">Promise 状态的不可逆性</span><br><span class="line"><span class="keyword">then</span>方法链式调用</span><br><span class="line"></span><br><span class="line">async/await</span><br></pre></td></tr></table></figure></p><p>promise有了解吗<br>Promise.all promise.race 有了解吗（当时一直听成Promise.out ，我就纳闷了说哪儿来的这个方法。。）</p><p>3.React 生命周期，如果要合并 props 和 state 在哪进行<br>4.React 组件想用函数调用的方式使用，怎么设计<br>react如果更新了父组件，子组件没有更新，会都重新渲染吗？<br>react的原理，他的内部是怎么构建DOM的，比如p标签的子元素放在哪个属性里。。。没看过源码着实不知道<br>react相关的redux的原理？<br>7.你印象比较深的项目或者代码<br>我觉得是像 antd 里面的 message 模块，使用 ReactDOM.render<br>挂载组件到指定节点，然后通过更新 props 使用<br>html css js擅长哪部分？<br>我回答擅长js，但他居然没有继续问下去了</p><p>3、es5和es6了解多少<br>es5,es6哪个用的多点？<br>3、es5和es6了解多少<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">变量声明：<span class="built_in">let</span> const</span><br><span class="line">字符串模板</span><br><span class="line">解构赋值 对象对对象 数组对数组</span><br><span class="line">扩展运算符</span><br><span class="line">箭头函数</span><br><span class="line">  不需要 <span class="keyword">function</span> 关键字来创建函数</span><br><span class="line">  省略 <span class="built_in">return</span> 关键字</span><br><span class="line">  继承当前上下文的 this 关键字</span><br><span class="line">import导入模块、<span class="built_in">export</span>导出模块</span><br><span class="line">Promise</span><br><span class="line">数组常用方法：</span><br><span class="line">Array.isArray</span><br><span class="line">map</span><br><span class="line">filter</span><br><span class="line">forEach</span><br><span class="line">every</span><br><span class="line">reduce</span><br><span class="line">splice</span><br><span class="line">indexOf</span><br><span class="line">slice</span><br><span class="line">concat</span><br><span class="line">reverse()</span><br><span class="line">join()</span><br><span class="line"></span><br><span class="line">Array.from()</span><br><span class="line">Array.of()</span><br><span class="line">copyWitch</span><br><span class="line">find</span><br><span class="line">findIndex</span><br><span class="line">keys()</span><br><span class="line">values()</span><br><span class="line">class 静态、私有、共有</span><br><span class="line"></span><br><span class="line">生成器（ generator）是能返回一个迭代器的函数。</span><br><span class="line">生成器函数也是一种函数，最直观的表现就是比普通的<span class="keyword">function</span>多了个星号*，</span><br><span class="line">在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。</span><br><span class="line"></span><br><span class="line">可以暂停并重新开始执行的函数</span><br><span class="line"></span><br><span class="line">generators 可以扮演三种角色</span><br><span class="line">  迭代器(数据生产者)</span><br><span class="line">  观察者(数据消费者)</span><br><span class="line">  协作程序(数据生产者和消费者)</span><br></pre></td></tr></table></figure></p><p><a href="https://segmentfault.com/a/1190000012358863" target="_blank" rel="noopener">es6 Generators详解</a></p><p>2.CSS sprite(雪碧图或者精灵图)<br><a href="https://www.cnblogs.com/evenyao/p/9262371.html" target="_blank" rel="noopener">CSS Sprite “精灵图”</a><br><a href="https://blog.csdn.net/CamilleZJ/article/details/80406645" target="_blank" rel="noopener">CSS Sprite雪碧图</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用CSS的<span class="string">"background-image"</span>，<span class="string">"background-repeat"</span>，<span class="string">"background-position"</span></span><br><span class="line">的组合进行背景定位，background-position可以用数字精确的定位出背景图片的位置。</span><br><span class="line">CSS Sprites 的优点：</span><br><span class="line">减少图片字节</span><br><span class="line">减少网页HTTP请求，提高网页性能</span><br><span class="line">减少命名难的问题</span><br><span class="line">缺点</span><br><span class="line">图片合并的时候要把图片合理的合并成一张图片，防止板块内出现不必要的背景</span><br><span class="line">在高分辨率下的自适应如果图片宽度不够，容易造成背景断裂</span><br><span class="line">维护的时候比较困难，如果背景图有少许改动，需要改动合并图片。</span><br></pre></td></tr></table></figure></p><p>事件节流？刚看过，没印象了，哭。<br>情景题，往下滚动，加载更多，有什么优化方案，图片懒加载？提示了可以滚轮事件是个比较频繁的操作，但是还是没想出来。防抖</p><p>vue和react差别，<br>8、问了vue有没有做过项目，然后就没有了<br>1.vue生命周期，没有问详细的，就是顺着生命周期说了一遍。英文捉急。<br>2.vue源码部分，几个重要的部分，compile，数据劫持，依赖收集，虚拟DOM。<br>问了一个异步加载组件，不用标签引入的方法。<br>让你实现vue你怎么实现……<br>说说vue的双向绑定（顺带把响应式说了）<br>说说Vue的diff过程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">如果不了解virtual dom，要理解diff的过程是比较困难的。虚拟dom对应的是真实dom， 使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点。</span><br><span class="line"></span><br><span class="line">我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。</span><br><span class="line">diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。</span><br><span class="line"></span><br><span class="line">在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。</span><br><span class="line">diff流程图</span><br><span class="line">当数据发生改变时，<span class="built_in">set</span>方法会让调用Dep.notify通知所有订阅者Watcher，</span><br><span class="line">订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。</span><br><span class="line"></span><br><span class="line">patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点</span><br><span class="line">判断两节点是否值得比较，值得比较则执行patchVnode</span><br><span class="line">不值得比较则用Vnode替换oldVnode</span><br><span class="line">如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。</span><br><span class="line"></span><br><span class="line">当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法</span><br><span class="line">这个函数做了以下事情：</span><br><span class="line">  找到对应的真实dom，称为el</span><br><span class="line">  判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接<span class="built_in">return</span></span><br><span class="line">  如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。</span><br><span class="line">  如果oldVnode有子节点而Vnode没有，则删除el的子节点</span><br><span class="line">  如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el</span><br><span class="line">  如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要</span><br><span class="line">updateChildren</span><br><span class="line">先说一下这个函数做了什么</span><br><span class="line">  将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来</span><br><span class="line">  oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。</span><br></pre></td></tr></table></figure></p><p>v-model，v-bind 和v-click<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">v-bind  动态地绑定一个或多个特性、或一个组件 prop 到表达式。</span><br><span class="line">1:v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，</span><br><span class="line">在为了能够动态的给这些属性添加值，可以使用v-bind:你要动态变化的值=<span class="string">"表达式"</span></span><br><span class="line"></span><br><span class="line">v-model 在表单控件或者组件上创建双向绑定。</span><br><span class="line">v-on 指令用于监听DOM事件 形式如：v-on:click  缩写为 @click;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[VUE中的v-if与v-show](http://www.cnblogs.com/wmhuang/p/5420344.html)</span><br><span class="line">手段：v-if是动态的向DOM树内添加或者删除DOM元素；</span><br><span class="line">v-show是通过设置DOM元素的display样式属性控制显隐；</span><br><span class="line">编译过程</span><br><span class="line">：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；</span><br><span class="line">v-show只是简单的基于css切换；</span><br><span class="line">编译条件：</span><br><span class="line">v-if是惰性的，如果初始条件为假，则什么也不做；</span><br><span class="line">只有在条件第一次变为真时才开始局部编译(编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载)</span><br><span class="line">v-if是动态的向DOM树内添加或者删除DOM元素；</span><br><span class="line">v-show是通过设置DOM元素的display样式属性控制显隐；</span><br><span class="line">v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；</span><br><span class="line">性能消耗：</span><br><span class="line">v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</span><br><span class="line">使用场景：</span><br><span class="line">v-if适合运营条件不大可能改变；v-show适合频繁切换。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</span><br><span class="line">v-if 也是惰性的：</span><br><span class="line">如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</span><br><span class="line">相比之下，v-show 就简单得多——不管初始条件是什么，</span><br><span class="line">元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</span><br><span class="line">一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；</span><br><span class="line">如果在运行时条件不太可能改变，则使用 v-if 较好。</span><br></pre></td></tr></table></figure></p><p>function a(){}，a的<strong>proto</strong> 指向哪，Function呢？Object呢？<br>js异步都有哪些？答了onclick之类的、setTimeout/setInterval/requestAnimation、Generator、promise、async/await，讲了promise和async/await的优缺点。</p><p>1.就我这次面试表现而言，有哪方面需要提升或者欠缺的<br>3.团队技术栈？<br>然后项目……照着你简历上的问，<br>技术选型，遇到的困难，解决思路，</p><p>面试中印象最深的问题<br>场面试官自己先介绍了三分钟..然后让我也介绍一下基本情况，项目经历难点之类的。<br>然后开始面试，很少技术问题<br>项目难点，如何解决的<br>有没有想过进入一个团队实习之后会有哪些压力大的事情？<br>有没有了解前端的新技术<br>有没有参加线下前端活动<br>会去看哪些博客或者社区<br>CSS动画和JS动画。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> (1)浏览器可以对动画进行优化。</span><br><span class="line">  1、 浏览器使用与 requestAnimationFrame 类似的机制，requestAnimationFrame比起setTimeout，setInterval设置动画的优势主要是:1)requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成,并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率,一般来说,这个频率为每秒60帧。2)在隐藏或不可见的元素中requestAnimationFrame不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。</span><br><span class="line">  2、强制使用硬件加速 （通过 GPU 来提高动画性能）</span><br><span class="line">  (2)代码相对简单,性能调优方向固定</span><br><span class="line">  (3)对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码</span><br><span class="line">缺点：</span><br><span class="line">　　1、 运行过程控制较弱,无法附加事件绑定回调函数。CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件,无进度报告</span><br><span class="line"> 　  2、  代码冗长。想用 CSS 实现稍微复杂一点动画,最后CSS代码都会变得非常笨重。</span><br><span class="line"></span><br><span class="line">JavaScript</span><br><span class="line">  (1)JavaScript动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。</span><br><span class="line">  (2)动画效果比css3动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成</span><br><span class="line">  (3)CSS3有兼容性问题，而JS大多时候没有兼容性问题</span><br><span class="line">缺点：</span><br><span class="line">　　　(1)JavaScript在浏览器的主线程中运行，而主线程中还有其它需要运行的JavaScript脚本、样式计算、布局、绘制任务等,对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。</span><br><span class="line">  (2)代码的复杂度高于CSS动画</span><br></pre></td></tr></table></figure></p><p>后来说问点有难度的问题的吧。直接怼了好多原理。。。卡了好几下<br>webpack的打包目录为啥是这样的，知道原理吗？<br>大概目前只能想到这些了，最后问了面试官几个问题，面试官说有结果，顿了一下，通过或者不通过hr都会通知你的emmm，感觉有点凉，主要是原理着实卡了好几个地方，不过自我感觉面试官人还是很nice的，没有太难为我，看面相是个忠厚老实的小哥哥emmm，求offer啊啊啊啊啊啊啊啊啊啊啊啊<br>7.项目印象深刻的部分和难点。<br>二面我就不写面经了，就是问了些项目上的问题，解决问题的思路，技术栈，基本情况<br>自我介绍<br>项目介绍<br>你说的你的项目里有个首屏加载特别慢的问题对吧？能说说怎么优化的吗？<br>一个骰子，5个面，你怎么实现它（一个面你怎么布局）<br>说说事件循环<br>假如有个项目加载最开始特别快，后面越来越慢你知道是为什么吗？以及如何第一时间定位（内存泄漏）<br>1、自我介绍 + 项目介绍（难点）<br>5、事件委托<br>6、任务队列<br>9、一个场景题（关于使用调试工具的）<br>13、bootstrap中的栅格式<br>一面我上来就说的微信小程序，然后后边面试官几乎都没问别的（倒是考我几个问题啊，js css啥都不问，得嘞，白准备了），然后说到Vue，说了个v-model感觉不是很满意，自己也觉得虽然自己懂原理，但是没讲清楚。。。整个流程10来分钟，估计gg了</p><p>重绘&amp;&amp;回流<br>vue differ<br>vue 生命周期<br>跨域<br>自我介绍</p><p>JavaScript 怎么实现 OOP<br>原型继承与类继承的区别<br>闭包的应用场景<br>关系完整性约束</p><p>Cookie &amp; Session 的区别<br>Session 的实现原理<br>HTTP 请求方法中哪些是幂等性的<br>跨域处理方案<br>JSONP 的缺点以及安全隐患<br>为什么要做单元测试<br>黑盒测试与白盒测试的区别<br>怎样实现测试覆盖率<br>Async &amp; Await 的使用</p><p>块级元素、行内元素、inline-block 的区别<br>水平居中的方法<br>String、Array 常用的方法<br>输入一个 URL 到呈现页面的过程<br>Vue.js 组件的生命周期<br>Git 怎么合并提交记录<br>Linux 常用的命令<br>HTTP2 新特性</p><p>常见的 Web 攻击手段以及防范措施<br>对 Ajax 的理解<br>对闭包的理解<br>对事件机制的理解<br>对 HTTP 的理解<br>GET &amp; POST 的区别<br>HTTP2 和 HTTP1 有什么不同<br>对 JavaScript 各大框架的理解<br>对 jQuery 的理解<br>页面性能优化<br>计算机网络分层<br>输入 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 到呈现页面的过程<br>事件机制（W3C 标准）<br>事件代理<br>XSS、CSRF 的防范<br>token 的实现原理<br>熟练使用JS实现Json、XML格式的数据发送与数据解析；<br>3、熟悉各种web标准，了解各主流浏览器特性，使页面兼容主浏览器；</p><p>自我介绍<br>事件流<br>vue nextTick原理<br>vue react区别<br>web优化<br>移动端的优化有特别了解过吗<br>css flex了解过吗<br>如何前端监控错误，<br>koa有学过吗<br>事件循环说一说<br>web新技术了解过哪些，最近有去学习哪些东西<br>PWA你能详细说说吗<br>service worker<br>h5 worker<br>非受控组件 与受控组件<br>const let var区别<br>三道题<br>有自己写过webpack插件吗<br>webpack loader 和plugin区别<br>实现promise<br>大数相加<br>纯js写一个动画，5s由快到慢，速度自定义<br>（这里特别感谢以前发过面筋的同学，前两道题因为碰到过，自己下去做了一下 10多分钟给做完了 然后又让我补了一道= =）<br>自我介绍，说一下怎么学习前端的，以及做的项目的亮点<br>web优化<br>缓存（协商，强制说一说）<br>CDN<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CDN的全称是Content Delivery Network，即内容分发网络。</span><br><span class="line">其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，</span><br><span class="line">使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联</span><br><span class="line">网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、</span><br><span class="line">负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近</span><br><span class="line">的服务节点上。</span><br><span class="line"></span><br><span class="line">其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，</span><br><span class="line">提高用户访问网站的响应速度。</span><br><span class="line">降低核心系统负载 加速用户访问</span><br><span class="line">CDN做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源</span><br></pre></td></tr></table></figure></p><p>DNS如何查询域名的<br>node中间件原理<br>跨域<br>作用域<br>一个页面白屏，分析原因<br>数据结构链表<br>怎么判断链表有环（当时还问我是不是刷了很多题，我们都笑了笑）<br>cookie了解吗<br>cookie的属性，怎么存储<br>web安全，xss csrf<br>css响应式布局<br>token生成过程<br>前端新技术<br>PWA讲一讲<br>serviceworker<br>h5 worker<br>智商题<br>3.45分夹角<br>两个火车相对而行，知道彼此的速度，中间有一个小鸟来回飞 知道小鸟的速度 求相撞的时候的 小鸟飞行的距离<br>10瓶药，每瓶药有10颗药片，每片10克，其中一瓶药里的所有药片是坏的 每片重量为11克，现在给你一个秤，如何一次性称出来</p><p>三面<br>自我介绍<br>web优化<br>css动画<br>csrf如何防御<br>如何生成token<br>Vue的diff能详细说一说吗<br>Vue子组件你的子组件方法是放在哪里的<br>Vue自定义指令<br>微信小程序接触过吗<br>微信小程序原理<br>TCP三次握手第三次失败了 客户端和服务端是如何处理的<br>301，302状态码区别，以及什么时候会返回这些状态。<br>node如何升级到webSoket<br>如何添加header头<br>DNS迭代和递归区别<br>前端怎么设置cookie过期<br>有看过源码吗<br>看过哪些书<br>能来实习的时间<br>智商题<br>一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球 求同时喜欢足球和篮球的<br>算法 最大的回文字符<br>北森<br>一面<br>面试官非常nice，善于引导<br>自我介绍<br>你的项目<br>能说下vue如何收集依赖双向绑定的吗<br>能说下vue如何更新节点的吗<br>node如何打印时间与错误<br>webpack构建流程<br>webpack如何找到依赖关系的<br>webpack如何配置<br>vue和react区别<br>react生命周期<br>函数式组件，如何给状态（hook）<br>原型链，原型知道多少<br>es6了解哪些<br>promise.resolve()<br>http状态码<br>post请求之前先发送Option条件<br>get,post,put,delete区别（冥等）<br>二面<br>面试官是个女架构师，感觉非常好，还因为迟到了几分钟说道歉之类的<br>vue,react，你更倾向于哪一个，为什么<br>es6模块cmd amd 区别<br>跨域<br>深拷贝，浅拷贝<br>post发送Option的条件<br>输入URL到浏览器会发生什么<br>TCP为什么三次握手<br>TCP为什么四次挥手<br>HTTP为什么基于TCP协议<br>vue diff过程<br>vue如果同一个数据，很短的时间内连续更新 会怎么样。<br>算法题<br>[0,0,1,1,1,2,3,4,5]，不借用辅助空间找到不重复项[2，3，4，5]</p><p>三面<br>面试官是技术总监，问的问题都是基于场景来说的，面试体验还可以<br>有这样一个数组，你如何扁平化<br>如果用字符串形式会出现什么问题<br>跨域你如何处理的<br>能说说同源策略吗，那如果是直接请求ip会有同源策略吗，如果一个域名对应多个ip的情况呢。<br>你以前做的项目，如果让你去完善你能说一说完善的细节吗，说三点 （我提到模块化，规范化，可扩展性）<br>能具体一点说说吗，说一点就可以<br>你觉得你相比其他实习生的优点和缺点在哪里</p><p>前天过了一面。问的有基础的知识和CSS、JS应用的知识，还问了OSI七层网络。其实自我感觉回答的不太好，面试官也说框架知识和项目经验不太足够，没想到过了。<br>了项目难点，然后还考了osi网络层级，怎么用css实现表格奇偶行不同颜色，怎么根据表格行的颜色拿到行数，还问了vue的生命周期钩子函数，vue-cli不过我没答上来</p><p>007bcc9b9629c19abe2d66d4ceb0c0006f9fd8e8</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue双向绑定原理及实现</title>
      <link href="/2019/04/15/Vue/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/04/15/Vue/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h4 id="双向绑定方法"><a href="#双向绑定方法" class="headerlink" title="双向绑定方法"></a>双向绑定方法</h4><p>发布者-订阅者模式（<code>backbone.js</code>）<br>脏值检查（<code>angular.js</code>）<br>数据劫持（<code>vue.js</code>）<br>发布者-订阅者模式: 一般通过<code>sub, pub</code>的方式实现数据和视图的绑定监听，更新数据方式通常做法是 <code>vm.set(&#39;property&#39;, value)</code><br>脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 <code>setInterval()</code> 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：<br>　　DOM事件，譬如用户输入文本，点击按钮等。( <code>ng-click</code> )<br>　　XHR响应事件 ( <code>$http</code> )<br>　　浏览器<code>Location</code>变更事件 ( <code>$location</code> )<br>　　Timer事件( <code>$timeout</code> , <code>$interval</code> )<br>　　执行 <code>$digest()</code> 或 <code>$apply()</code><br>数据劫持:<br>　　<code>vue.js</code> 则是采用<code>数据劫持结合发布者-订阅者模式</code>的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>　　<code>Vue</code> 响应系统，其核心有三点：<code>observe</code>、<code>watcher</code>、<code>dep</code>：<br>　　　　<code>observe</code>：遍历 <code>data</code> 中的属性，使用 <code>Object.defineProperty</code> 的 <code>get/set</code> 方法对其进行数据劫持；<br>　　　　<code>dep</code>：每个属性拥有自己的消息订阅器 <code>dep</code>，用于存放所有订阅了该属性的观察者对象；<br>　　　　<code>watcher</code>：观察者（对象），通过 <code>dep</code> 实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。<br>实现虚拟DOM包含以下三个步骤：<br>　　用JS对象模拟DOM树<br>　　比较两棵虚拟DOM树的差异, Diff算法<br>　　映射成真实DOM</p><h4 id="Vue-双向数据绑定的原理"><a href="#Vue-双向数据绑定的原理" class="headerlink" title="Vue 双向数据绑定的原理"></a>Vue 双向数据绑定的原理</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object​.define​Property()</a><br>属性描述符有两种主要形式：<code>数据描述符</code>和<code>存取描述符</code>。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。<br><code>Object.defineProperty</code>是<code>ES5</code>新增的一个<code>API</code>，其作用是给对象的属性增加更多的控制<br><code>Object.defineProperty(obj, prop, descriptor)</code><br>参数 :<br>　　<code>obj</code>: 需要定义属性的对象（目标对象）<br>　　<code>prop</code>: 需被定义或修改的属性名（对象上的属性或者方法）<br>对于<code>setter</code>和<code>getter</code>，我的理解是它们是一对勾子（<code>hook</code>）函数，当你对一个对象的某个属性赋值时，则会自动调用相应的<code>setter</code>函数；而当获取属性时，则调用<code>getter</code>函数。这也是实现双向数据绑定的关键。<br>　　<code>descriptor</code>: 将被定义或修改的属性描述符。<br>描述:<br>　　该方法允许精确添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，能够在属性枚举期间呈现出来（<code>for...in</code> 或 <code>Object.keys</code> 方法）， 这些属性的值可以被改变，也可以被删除。这个方法允许修改默认的额外选项（或配置）。<code>默认情况下</code>，使用 <code>Object.defineProperty()</code> 添加的属性值是<code>不可修改</code>的。</p><p>整理思路<br>实现mvvm的双向绑定，就必须要实现以下几点：<br>1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者<br>2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数<br>3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br>4、mvvm入口函数，整合以上三者<br>observer用来实现对每个vue中的data中定义的属性循环用<code>Object.defineProperty()</code>实现数据劫持，以便利用其中的setter和getter，然后通知订阅者，订阅者会触发它的update方法，对视图进行更新。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们介绍为什么要订阅者，在`vue`中`v-model`，`v-name`，`&#123;&#123;&#125;&#125;`等都可以</span><br><span class="line">对数据进行显示，也就是说假如一个属性都通过这三个指令了，那么每当这个属性</span><br><span class="line">改变的时候，相应的这个三个指令的html视图也必须改变，于是vue中就是每当有</span><br><span class="line">这样的可能用到双向绑定的指令，就在一个Dep中增加一个订阅者，其订阅者只是</span><br><span class="line">更新自己的指令对应的数据，也就是`v-model=<span class="string">'name'</span>`和`&#123;&#123;name&#125;&#125;`有两个对</span><br><span class="line">应的订阅者，各自管理自己的地方。每当属性的<span class="built_in">set</span>方法触发，就循环更新Dep中</span><br><span class="line">的订阅者。</span><br></pre></td></tr></table></figure></p><p><code>Object.defineProperty</code>缺陷：<br>只能对属性进行数据劫持，对于JS对象劫持需要深度遍历；<br>对于数组不能监听到数据的变化，而是通过一些hack办法来实现，如<code>push、pop、shift、unshift、splice、sort、reverse</code></p>]]></content>
      
      
      <categories>
          
          <category> 前端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>函数节流与防抖</title>
      <link href="/2019/04/15/JavaScript/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
      <url>/2019/04/15/JavaScript/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;防抖和节流&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        button &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 50px;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="built_in">log</span> &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 30px;</span><br><span class="line">            border: 1px solid <span class="comment">#ccc;</span></span><br><span class="line">            margin-top: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=<span class="string">"debounced"</span>&gt;Debounced&lt;/button&gt;</span><br><span class="line">    &lt;button id=<span class="string">"throttled"</span>&gt;Throttled&lt;/button&gt;</span><br><span class="line">    &lt;div id=<span class="string">"log1"</span> class=<span class="string">"log"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">"log2"</span> class=<span class="string">"log"</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        /*</span><br><span class="line">          节流说白了就是每ms执行一次函数，</span><br><span class="line">          防抖就是 我最后一次触发后ms后执行一次回调函数</span><br><span class="line">        */</span><br><span class="line">        /*debounced（防抖动）函数，该函数会从上一次被调用后，延迟 <span class="built_in">wait</span> 毫秒后调用 fn 方法。*/</span><br><span class="line">        <span class="keyword">function</span> debounce(fn, <span class="built_in">wait</span>, options) &#123;</span><br><span class="line">            // 等待时间</span><br><span class="line">            <span class="built_in">wait</span> = <span class="built_in">wait</span> || 0</span><br><span class="line">            // 点击次数</span><br><span class="line">            <span class="built_in">let</span> timerId;</span><br><span class="line">            console.log(<span class="string">"timerId:"</span>, timerId);</span><br><span class="line">            // 这个函数的功能是：</span><br><span class="line">            // </span><br><span class="line">            <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> (timerId) &#123;</span><br><span class="line">                    clearTimeout(timerId);</span><br><span class="line">                    timerId = null;</span><br><span class="line">                &#125;</span><br><span class="line">                timerId = setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                    fn();</span><br><span class="line">                &#125;, <span class="built_in">wait</span>);</span><br><span class="line">                console.log(<span class="string">"timerId:"</span>, timerId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 节流函数，在 <span class="built_in">wait</span> 秒内最多执行 fn 一次的函数。</span><br><span class="line">        <span class="keyword">function</span> throttle(fn, <span class="built_in">wait</span>, options) &#123;</span><br><span class="line">            <span class="built_in">wait</span> = <span class="built_in">wait</span> || 0;</span><br><span class="line">            <span class="built_in">let</span> timerId;</span><br><span class="line">            <span class="built_in">let</span> lastTime = 0;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                <span class="built_in">let</span> currentTime = new Date();</span><br><span class="line">                <span class="keyword">if</span> (currentTime &gt;= lastTime + <span class="built_in">wait</span>) &#123;</span><br><span class="line">                    fn();</span><br><span class="line">                    lastTime = currentTime;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (timerId) &#123;</span><br><span class="line">                        clearTimeout(timerId);</span><br><span class="line">                        timerId = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    timerId = setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                        fn();</span><br><span class="line">                    &#125;, <span class="built_in">wait</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">let</span> debouncedBtn = document.getElementById(<span class="string">'debounced'</span>);</span><br><span class="line">        <span class="built_in">let</span> throttledBtn = document.getElementById(<span class="string">'throttled'</span>);</span><br><span class="line">        <span class="built_in">let</span> log1 = document.getElementById(<span class="string">'log1'</span>);</span><br><span class="line">        <span class="built_in">let</span> log2 = document.getElementById(<span class="string">'log2'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">handleDebounce</span></span>() &#123;</span><br><span class="line">            log1.innerHTML += <span class="string">'debounced'</span>;</span><br><span class="line">            console.log(<span class="string">"debounced"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">handleThrottle</span></span>() &#123;</span><br><span class="line">            log2.innerHTML += <span class="string">'throttle'</span>;</span><br><span class="line">            console.log(<span class="string">"throttle"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        debouncedBtn.addEventListener(<span class="string">'click'</span>, debounce(handleDebounce, 2000));</span><br><span class="line">        throttledBtn.addEventListener(<span class="string">'click'</span>, throttle(handleThrottle, 2000));</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>跨域</title>
      <link href="/2019/04/11/Ajax/%E8%B7%A8%E5%9F%9F/"/>
      <url>/2019/04/11/Ajax/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p><a href="https://juejin.im/post/5a2f92c65188253e2470f16d" target="_blank" rel="noopener">正确面对跨域，别慌</a><br><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）</a></p>]]></content>
      
      
      <categories>
          
          <category> AJAX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AJAX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS3选择器</title>
      <link href="/2019/04/11/CSS3/CSS3%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2019/04/11/CSS3/CSS3%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br><a href="https://segmentfault.com/a/1190000003064142" target="_blank" rel="noopener">CSS &gt; 选择器优先级与效率优化</a></p><h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><p>　　important声明 1,0,0,0<br>　　ID选择器      0,1,0,0<br>　　类选择器      0,0,1,0<br>　　伪类选择器    0,0,1,0<br>　　属性选择器    0,0,1,0<br>　　标签选择器    0,0,0,1<br>　　伪元素选择器  0,0,0,1<br>　　通配符选择器  0,0,0,0<br>important &gt; 行内样式</p><h3 id="选择器效率"><a href="#选择器效率" class="headerlink" title="选择器效率"></a>选择器效率</h3><p>　　读取选择器的原则是<code>从右到左</code>。因此，我们书写的右边的最后一个选择器，被称作<code>关键选择器</code>，对于效率有决定性影响。<br>选择器效率：<br>　　ID选择器<br>　　类选择器<br>　　标签选择器<br>　　相邻选择器<br>　　子选择器<br>　　后代选择器<br>　　通配符选择器<br>　　属性选择器<br>　　伪类选择器<br><strong>优先级高的不一定效率高</strong><br>举个例子：<code>#id .class</code> 与 <code>div#id p.class</code><br>前者效率高于后者，而后者优先级高于前者。我们需要在效率与优先级之间平衡取舍。</p><h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><p>扼要摘其精要总结如下：<br>　　避免使用通配符<br>　　不使用标签名或类名修饰ID规则：如果规则使用ID选择器作为关键选择器，不要给规则添加标签名。因为ID本身就是唯一的，添加标签名会不必要地降低匹配效率。<br>　　不使用标签名修饰类：相较于标签，类更具独特性。<br>　　尽量选择最具体的方式：造成低效的最简单粗暴的原因就是在标签上使用太多规则。给元素添加类可以更快细分到类方式，可以减少规则去匹配标签的时间。<br>　　关于后代选择器和子选择器：避免使用后代选择器，非要用的话建议用子选择器代替，但子选择器也要慎用，标签规则永远不要包含子选择器。<br>　　利用可继承性：没必要在一般内容上声明样式。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数组操作</title>
      <link href="/2019/04/11/JavaScript/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/04/11/JavaScript/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><h4 id="改变原始数组的操作方法"><a href="#改变原始数组的操作方法" class="headerlink" title="改变原始数组的操作方法"></a>改变原始数组的操作方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向数组末尾添加元素，并返回新的长度</span></span><br><span class="line">push</span><br><span class="line"><span class="comment"># 删除最后一个并返回删除的元素</span></span><br><span class="line">pop</span><br><span class="line"><span class="comment"># 向数组开头添加元素，并返回新的长度</span></span><br><span class="line">unshift</span><br><span class="line"><span class="comment"># 将第一个元素删除并且返回删除元素，空即为undefined</span></span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="comment"># 颠倒数组顺序</span></span><br><span class="line">reverse</span><br><span class="line"><span class="comment"># 对数组排序</span></span><br><span class="line">sort</span><br><span class="line"><span class="comment"># 删，增，替换数组元素，返回被删除数组，无删除则不返回</span></span><br><span class="line">splice</span><br><span class="line"><span class="comment"># 用于从数组的指定位置拷贝元素到数组的另一个指定位置中。</span></span><br><span class="line">copyWithin</span><br><span class="line"><span class="comment"># 用于将一个固定值替换数组的元素。</span></span><br><span class="line">fill</span><br></pre></td></tr></table></figure><h5 id="splice-添加-删除数组元素"><a href="#splice-添加-删除数组元素" class="headerlink" title="splice() 添加/删除数组元素"></a>splice() 添加/删除数组元素</h5><p>定义： <code>splice()</code> 方法向/从数组中添加/删除项目，然后返回被删除的项目<br><code>array.splice(index,howmany,item1,.....,itemX)</code><br>参数:<br>　　<code>index</code>：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。<br>　　<code>howmany</code>：可选。要删除的项目数量。如果设置为 0，则不会删除项目。<br>　　<code>item1, ..., itemX</code>： 可选。向数组添加的新项目。<br><strong>删除元素</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line"><span class="built_in">let</span> item = a.splice(0, 3); // [1,2,3]</span><br><span class="line">console.log(a); // [4,5,6,7]</span><br><span class="line">// 从数组下标0开始，删除3个元素</span><br><span class="line"><span class="built_in">let</span> item = a.splice(-1, 3); // [7]</span><br><span class="line">// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span><br></pre></td></tr></table></figure></p><p><strong>删除并添加</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line"><span class="built_in">let</span> item = a.splice(0,3,<span class="string">'添加'</span>); // [1,2,3]</span><br><span class="line">console.log(a); // [<span class="string">'添加'</span>,4,5,6,7]</span><br><span class="line">// 从数组下标0开始，删除3个元素，并添加元素<span class="string">'添加'</span></span><br><span class="line"><span class="built_in">let</span> b = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line"><span class="built_in">let</span> item = b.splice(-2,3,<span class="string">'添加1'</span>,<span class="string">'添加2'</span>); // [6,7]</span><br><span class="line">console.log(b); // [1,2,3,4,5,<span class="string">'添加1'</span>,<span class="string">'添加2'</span>]</span><br><span class="line">// 从数组最后第二个元素开始，删除3个元素，并添加两个元素<span class="string">'添加1'</span>、<span class="string">'添加2'</span></span><br></pre></td></tr></table></figure></p><p><strong>添加元素</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">// [] 没有删除元素，返回空数组</span><br><span class="line"><span class="built_in">let</span> item = a.splice(0,0,<span class="string">'添加1'</span>,<span class="string">'添加2'</span>); </span><br><span class="line">console.log(a); // [<span class="string">'添加1'</span>,<span class="string">'添加2'</span>,1,2,3,4,5,6,7]</span><br><span class="line"><span class="built_in">let</span> b = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">// [] 没有删除元素，返回空数组</span><br><span class="line"><span class="built_in">let</span> item = b.splice(-1,0,<span class="string">'添加1'</span>,<span class="string">'添加2'</span>); </span><br><span class="line">// [1,2,3,4,5,6,<span class="string">'添加1'</span>,<span class="string">'添加2'</span>,7] 在最后一个元素的前面添加两个元素</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure></p><p>　　数组如果元素不够，会删除到最后一个元素为止<br>　　操作的元素，包括开始的那个元素<br>　　可以添加很多个元素<br>　　添加是在开始的元素前面添加的</p><h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h5><h5 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h5><h5 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h5><h5 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h5><h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h5><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h5><h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h5><h5 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h5><h4 id="不改变原始数组的操作方法"><a href="#不改变原始数组的操作方法" class="headerlink" title="不改变原始数组的操作方法"></a>不改变原始数组的操作方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接多个数组，返回新的数组</span></span><br><span class="line">concat</span><br><span class="line"><span class="comment"># 将数组中所有元素以参数作为分隔符放入一个字符</span></span><br><span class="line">join</span><br><span class="line"><span class="comment"># 返回选定元素</span></span><br><span class="line">slice</span><br><span class="line"><span class="comment"># 数组映射为新的数组</span></span><br><span class="line">map(es6)</span><br><span class="line"><span class="comment"># 数组过滤，返回所有通过方法判断后(判断为true时)生成的新数组</span></span><br><span class="line">filter(es6)</span><br><span class="line"><span class="comment"># 数组遍历，没有返回值</span></span><br><span class="line">forEach</span><br><span class="line"><span class="comment"># 对数组中的每一项运行给定函数，如每一项均为true时返回true，否则返回false</span></span><br><span class="line">every(es6)</span><br><span class="line"><span class="comment"># 数组中的的元素运行给定函数，如其中有一项为true时返回true，</span></span><br><span class="line"><span class="comment"># 此时剩余的元素不会再执行检测，如果所以都为false则返回false</span></span><br><span class="line">some(es6)</span><br><span class="line"><span class="comment"># 寻找数组中符合测试方法（函数）条件的第一个元素，并且返回该元素</span></span><br><span class="line">find(es6)</span><br><span class="line"><span class="comment"># 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</span></span><br><span class="line">reduce(es6)</span><br><span class="line"><span class="comment"># 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</span></span><br><span class="line">indexOf</span><br><span class="line"><span class="comment"># 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true，否则返回false。</span></span><br><span class="line">includes(es7)</span><br></pre></td></tr></table></figure><h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><h4 id="toLocaleString-数组转字符串"><a href="#toLocaleString-数组转字符串" class="headerlink" title="toLocaleString() 数组转字符串"></a>toLocaleString() 数组转字符串</h4><h4 id="toString-数组转字符串-不推荐"><a href="#toString-数组转字符串-不推荐" class="headerlink" title="toString() 数组转字符串 不推荐"></a>toString() 数组转字符串 不推荐</h4><h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><h4 id="ES6扩展运算符…合并数组"><a href="#ES6扩展运算符…合并数组" class="headerlink" title="ES6扩展运算符…合并数组"></a>ES6扩展运算符…合并数组</h4><h4 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h4><h4 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h4><h4 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7 includes() 查找数组是否包含某个元素 返回布尔"></a>ES7 includes() 查找数组是否包含某个元素 返回布尔</h4><h3 id="遍历方法-12个"><a href="#遍历方法-12个" class="headerlink" title="遍历方法(12个):"></a>遍历方法(12个):</h3><h4 id="关于forEach-你要知道："><a href="#关于forEach-你要知道：" class="headerlink" title="关于forEach()你要知道："></a>关于forEach()你要知道：</h4><h4 id="every-检测数组所有元素是否都符合判断条件"><a href="#every-检测数组所有元素是否都符合判断条件" class="headerlink" title="every 检测数组所有元素是否都符合判断条件"></a>every 检测数组所有元素是否都符合判断条件</h4><h4 id="some-数组中的是否有满足判断条件的元素"><a href="#some-数组中的是否有满足判断条件的元素" class="headerlink" title="some 数组中的是否有满足判断条件的元素"></a>some 数组中的是否有满足判断条件的元素</h4><h4 id="filter-过滤原始数组，返回新数组"><a href="#filter-过滤原始数组，返回新数组" class="headerlink" title="filter 过滤原始数组，返回新数组"></a>filter 过滤原始数组，返回新数组</h4><h4 id="map-对数组中的每个元素进行处理，返回新的数组"><a href="#map-对数组中的每个元素进行处理，返回新的数组" class="headerlink" title="map 对数组中的每个元素进行处理，返回新的数组"></a>map 对数组中的每个元素进行处理，返回新的数组</h4><h4 id="reduce-为数组提供累加器，合并为一个值"><a href="#reduce-为数组提供累加器，合并为一个值" class="headerlink" title="reduce 为数组提供累加器，合并为一个值"></a>reduce 为数组提供累加器，合并为一个值</h4><h4 id="reduceRight-从右至左累加"><a href="#reduceRight-从右至左累加" class="headerlink" title="reduceRight 从右至左累加"></a>reduceRight 从右至左累加</h4><h4 id="ES6-find-amp-findIndex-根据条件找到数组成员"><a href="#ES6-find-amp-findIndex-根据条件找到数组成员" class="headerlink" title="ES6 find()&amp; findIndex() 根据条件找到数组成员"></a>ES6 find()&amp; findIndex() 根据条件找到数组成员</h4><h4 id="ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值"><a href="#ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值" class="headerlink" title="ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值"></a>ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[【干货】js 数组详细操作方法及解析合集](https://juejin.im/post/5b0903b26fb9a07a9d70c7e0)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>原型&amp;&amp;原型链</title>
      <link href="/2019/04/10/JavaScript/%E5%8E%9F%E5%9E%8B&amp;&amp;%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2019/04/10/JavaScript/%E5%8E%9F%E5%9E%8B&amp;&amp;%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>摘自JavaScript高级程序设计:<br>　　继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: <code>接口继承</code> 和 <code>实现继承</code> .<code>接口继承只继承方法签名</code>,而<code>实现继承则继承实际的方法</code>.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 实现继承 主要是依靠<code>原型链</code>来实现的.<br>　　在 JavaScript 中，是一种面向对象的程序设计语言，但是 JS 本身是没有 “类” 的概念，JS 是靠原型和原型链实现对象属性的继承。<br>　　在理解原型前，需要先知道对象的构造函数是什么，构造函数都有什么特点？</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数 Person()</span><br><span class="line"><span class="keyword">function</span> Person(name, gender) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(<span class="string">"周杰伦"</span>, <span class="string">"男"</span>);</span><br><span class="line">// 最后创建出来的对象实例 person</span><br><span class="line">person</span><br><span class="line">&#123;</span><br><span class="line">  name: <span class="string">"周杰伦"</span>,</span><br><span class="line">  gender: <span class="string">"男"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，普通函数 <code>Person()</code>，加上 <code>new</code> 关键字后，就构造了一个对象 <code>person</code><br>所以构造函数的定义就是普通函数加上 <code>new</code> 关键字，并总会返回一个对象。</p><h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><p>　　同时，JS 中的对象分为一般对象和函数对象。那什么是一般对象，什么又是函数对象呢？<br>　　<code>JavaScript</code> 的类型分为<code>基本数据类型</code>和<code>引用数据类型</code>，基本数据类型目前有 6 种（<code>null</code>, <code>undefined</code>, <code>string</code>, <code>number</code>, <code>boolean</code>, <code>Symbol</code>）。 其余的数据类型都统称为 <code>object</code> 数据类型，其中，包括 <code>Array</code>, <code>Date</code>, <code>Function</code>等，所以函数可以称为函数对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> foo = <span class="function"><span class="title">function</span></span>()&#123;&#125;</span><br><span class="line">foo.name = <span class="string">"bar"</span>;</span><br><span class="line">foo.age = 24;</span><br><span class="line">console.log(foo instanceof Function)  //<span class="literal">true</span></span><br><span class="line">console.log(foo.age)  // 24</span><br></pre></td></tr></table></figure></p><p>以上代码就说明了<code>函数其实是一个对象，也可以具有属性</code>。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>　　<code>JavaScript</code> 中的对象，有一个特殊的 <code>[[prototype]]</code> 属性, 其实就是对于其他对象的引用（委托）。当我们在获取一个对象的属性时，如果这个对象上没有这个属性，那么 JS 会沿着对象的 <code>[[prototype]]</code>链 一层一层地去找，最后如果没找到就返回 <code>undefined</code>;<br>这条一层一层的查找属性的方式，就叫做原型链。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;</span><br><span class="line">  age: 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　那么，为什么一个对象要引用，或者说要委托另外一个对象来寻找属性呢？<br>　　本文开篇的第一句话，就指出来的，JavaScript 中，和一般的 OOP 语言不同，它没有 ‘类’的概念，也就没有 ‘模板’ 来创建对象，而是通过字面量或者构造函数的方式直接创建对象。那么也就不存在所谓的类的复制继承。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>　　那什么又是原型呢？<br>　　既然我们没有类，就用其他的方式实现类的行为吧，看下面这句话↓↓。</p><h4 id="每个函数都有一个原型属性-prototype-对象"><a href="#每个函数都有一个原型属性-prototype-对象" class="headerlink" title="每个函数都有一个原型属性 prototype 对象"></a>每个函数都有一个原型属性 prototype 对象</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'JayChou'</span>;</span><br><span class="line">// person1 和 person2 都是空对象</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person1.name) // JayChou</span><br><span class="line">console.log(person2.name) // JayChou</span><br></pre></td></tr></table></figure><p>　　通过构造函数创造的对象，对象在寻找 name 属性时，找到了 构造函数的 prototype 对象上。<br>　　这个构造函数的 prototype 对象，就是 <code>原型</code><br>用示意图来表示：<br><img src="/assets/images/原型.png" alt="原型"><br>　　查找对象实例属性时，会沿着原型链向上找，在现代浏览器中，标准让每个对象都有一个 <code>__proto__</code> 属性，指向原型对象。那么，我们可以知道对象实例和函数原型对象之间的关系。<br><img src="/assets/images/原型1.png" alt="原型"></p><h4 id="每个原型对象都有一个-constructor-属性指向关联的构造函数"><a href="#每个原型对象都有一个-constructor-属性指向关联的构造函数" class="headerlink" title="每个原型对象都有一个 constructor 属性指向关联的构造函数"></a>每个原型对象都有一个 constructor 属性指向关联的构造函数</h4><p>为了验证这一说话，举个例子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;&#125;</span><br><span class="line">Person === Person.prototype.constructor; // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>那么对象实例是构造函数构造而来，那么对象实例是不是也应该有一个 <code>constructor</code> 呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">const person = new Person();</span><br><span class="line">person.constructor === Person // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>但事实上，对象实例本身并没有 <code>constructor</code> 属性，对象实例的 <code>constructor</code> 属性来自于引用了原型对象的 <code>constructor</code> 属性<br><code>person.constructor === Person.prototype.constructor // true</code><br><img src="/assets/images/原型2.png" alt="原型"></p><h4 id="原型链顶层：Object-prototype-proto-null"><a href="#原型链顶层：Object-prototype-proto-null" class="headerlink" title="原型链顶层：Object.prototype.__proto__== null"></a>原型链顶层：<code>Object.prototype.__proto__== null</code></h4><p>　　既然 JS 通过原型链查找属性，那么链的顶层是什么呢，答案就是 <code>Object</code> 对象，<code>Object</code> 对象其实也有 <code>__proto__</code>属性，比较特殊的是 <code>Object.prototype.__proto__</code> 指向 <code>null</code>, 也就是空。<br><code>Object.prototype.__proto__ === null</code><br><img src="/assets/images/原型3.png" alt="原型"><br>我们回过头来看函数对象：</p><blockquote><p>所有函数对象的<code>proto</code>都指向<code>Function.prototype</code>，它是一个空函数（<code>Empty function</code>）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Number.__proto__ === Function.prototype  // <span class="literal">true</span></span><br><span class="line">Number.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Boolean.__proto__ === Function.prototype // <span class="literal">true</span></span><br><span class="line">Boolean.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">String.__proto__ === Function.prototype  // <span class="literal">true</span></span><br><span class="line">String.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 所有的构造器都来自于Function.prototype,</span><br><span class="line">// 甚至包括根构造器Object及Function自身</span><br><span class="line">Object.__proto__ === Function.prototype  // <span class="literal">true</span></span><br><span class="line">Object.constructor == Function // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 所有的构造器都来自于Function.prototype，</span><br><span class="line">// 甚至包括根构造器Object及Function自身</span><br><span class="line">Function.__proto__ === Function.prototype // <span class="literal">true</span></span><br><span class="line">Function.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Array.__proto__ === Function.prototype   // <span class="literal">true</span></span><br><span class="line">Array.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">RegExp.__proto__ === Function.prototype  // <span class="literal">true</span></span><br><span class="line">RegExp.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Error.__proto__ === Function.prototype   // <span class="literal">true</span></span><br><span class="line">Error.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Date.__proto__ === Function.prototype    // <span class="literal">true</span></span><br><span class="line">Date.constructor == Function //<span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>所有的构造器都来自于 <code>Function.prototype</code>，甚至包括根构造器<code>Object</code>及<code>Function</code>自身。所有构造器都继承了·<code>Function.prototype</code>·的属性及方法。如<code>length</code>、<code>call</code>、<code>apply</code>、<code>bind</code></p></blockquote><p>以图会友，这就是网上经常看到的 JS 原型和原型链关系图：<br><img src="/assets/images/原型4.png" alt="原型"></p><p>对于以上看似很复杂的关系图，只需要理解 5 点：<br>　　每个函数都有一个原型属性 <code>prototype</code> 对象<br>　　普通对象的构造函数是 <code>Object()</code>，所以 <code>Person.prototype.__proto__ === Object.prototype</code><br>　　函数对象都来自于 <code>Function.prototype</code><br>　　函数对象也是对象，所有 <code>Function.prototype.__proto__ === Object.prototype</code><br>　　记住，所有函数原型的都是 <code>Object()</code> 的实例<br>　　<code>Object.prototype.__proto__</code> 是 <code>null</code></p><p>转载：<br>　　<a href="https://juejin.im/post/5bc755b15188255c89015f39" target="_blank" rel="noopener">JavaScript原型与原型链</a><br>参考：<br>　　<a href="https://juejin.im/post/5c72a1766fb9a049ea3993e6#chapter-one" target="_blank" rel="noopener">2019 面试准备 - JS 原型与原型链</a><br>　　<a href="https://juejin.im/post/58f94c9bb123db411953691b#heading-2" target="_blank" rel="noopener">JS原型链与继承别再被问倒了</a><br>　　<a href="https://juejin.im/post/5835853f570c35005e413b19#heading-0" target="_blank" rel="noopener">三张图搞懂JavaScript的原型对象与原型链</a><br>　　<a href="https://hexianzhi.github.io/2017/04/27/JavaScript%E5%8E%9F%E5%9E%8B/" target="_blank" rel="noopener">JavaScript原型及原型链</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue知识点详解</title>
      <link href="/2019/04/09/Vue/Vue%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/04/09/Vue/Vue%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>Vue watch computed nexttick<br>双向绑定 虚拟dom<br>Vue双向绑定原理/组件通讯<br>Vue 单双向绑定（dep watcher observer）</p>]]></content>
      
      
      <categories>
          
          <category> 前端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>宏任务&amp;&amp;微任务</title>
      <link href="/2019/04/09/JavaScript/%E5%AE%8F%E4%BB%BB%E5%8A%A1&amp;&amp;%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
      <url>/2019/04/09/JavaScript/%E5%AE%8F%E4%BB%BB%E5%8A%A1&amp;&amp;%E5%BE%AE%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>JavaScript 是单线程、异步、非阻塞、解释型脚本语言。</code><br>　　微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。</p><h4 id="macrotask-宏任务"><a href="#macrotask-宏任务" class="headerlink" title="(macrotask)宏任务"></a>(macrotask)宏任务</h4><p>　　<code>macrotask</code>： 包括整体代码<code>script</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>requestAnimationFrame</code>、<code>I/O</code>、<code>UI rendering</code>等（可以看到，事件队列中的每一个事件都是一个 <code>macrotask</code>，现在称之为宏任务队列）</p><h4 id="microtask-微任务"><a href="#microtask-微任务" class="headerlink" title="(microtask)微任务"></a>(microtask)微任务</h4><p>　　<code>microtask</code>:<code>原生Promise</code>(有些实现的promise将then方法放到了宏任务中)、<code>process.nextTick</code>、<code>Promises</code>、Object.observe(已废弃)、 <code>MutationObserver</code> 记住就行了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'timer over'</span>)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line">// script start</span><br><span class="line">// script end</span><br><span class="line">// promise1</span><br><span class="line">// promise2</span><br><span class="line">// timer over</span><br></pre></td></tr></table></figure></p><p>JS引擎线程首先执行主代码块。<br>　　每次执行栈执行的代码就是一个宏任务，包括任务队列(宏任务队列)中的，因为执行栈中的宏任务执行完会去取任务队列（宏任务队列）中的任务加入执行栈中，即同样是事件循环的机制。<br>　　在执行宏任务时遇到<code>Promise</code>等，会<code>创建微任务</code>（.then()里面的回调），并加入到<code>微任务队列队尾</code>。<br>　　<code>microtask</code>必然是在某个宏任务执行的时候创建的，而在下一个宏任务开始之前，浏览器会对页面重新渲染(<code>task &gt;&gt; 渲染 &gt;&gt; 下一个task(从任务队列中取一个)</code>)。同时，<code>在上一个宏任务执行完成后，渲染页面之前，会执行当前微任务队列中的所有微任务</code>。<br>　　也就是说: <code>在某一个 macrotask 执行完后，在重新渲染与开始下一个宏任务之前，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）</code>。<br>　　这样就可以解释 “promise 1” “promise 2” 在 “timer over” 之前打印了。”promise 1” “promise 2” 做为微任务加入到微任务队列中，而 “timer over” 做为宏任务加入到宏任务队列中，它们同时在等待被执行，但是微任务队列中的所有微任务都会在开始下一个宏任务之前都被执行完。</p><blockquote><p>在node环境下，<code>process.nextTick</code>的优先级高于<code>Promise</code>，也就是说：<code>在宏任务结束后会先执行微任务队列中的nextTickQueue，然后才会执行微任务中的Promise</code>。</p></blockquote><p>执行机制：<br>　　执行一个宏任务（栈中没有就从事件队列中获取）<br>　　执行过程中如果遇到微任务，就将它添加到微任务的任务队列中<br>　　宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）<br>　　当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染<br>　　渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　<code>JavaScript</code> 是单线程语言，决定于它的设计最初是用来处理浏览器网页的交互。浏览器负责解释和执行 <code>JavaScript</code> 的线程只有一个（所有说是单线程），即<code>JS引擎线程</code>，但是浏览器同样提供其他线程，如：事件触发线程、定时器触发线程等。<br>异步一般是指：<br>　　<code>网络请求`</code><br>　　<code>计时器`</code><br>　　<code>DOM事件监听`</code><br>事件循环机制：<br>　　<code>JS引擎线程</code>会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。<br>　　<code>JS引擎线程</code>遇到异步函数，会将异步函数交给相应的Webapi，而继续执行后面的任务。<br>　　<code>Webapi</code>会在条件满足的时候，将异步对应的回调加入到消息队列中，等待执行。<br>　　<code>执行栈为空时</code>，JS引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。<br>　　<code>完成后出栈</code>，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。</p><p>原文：<br>　　<a href="https://juejin.im/post/5be5a0b96fb9a049d518febc" target="_blank" rel="noopener">总结：JavaScript异步、事件循环与消息队列、微任务与宏任务</a><br>　　<a href="https://juejin.im/post/5b498d245188251b193d4059" target="_blank" rel="noopener">JS事件循环机制（event loop）之宏任务/微任务</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP</title>
      <link href="/2019/04/08/HTTP/HTTP/"/>
      <url>/2019/04/08/HTTP/HTTP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载&amp;&amp;参考:<br>　　<a href="https://juejin.im/post/5a77fe396fb9a063317c2e71" target="_blank" rel="noopener">Pandaaa</a><br>　　<a href="https://juejin.im/post/5b5ef5a25188251af86bfebf#heading-5" target="_blank" rel="noopener">HTTP2和HTTPS来不来了解一下？</a><br>　　<a href="https://juejin.im/post/5ba65296f265da0ac8493503#heading-14" target="_blank" rel="noopener">深入理解 HTTP 协议</a><br>　　<a href="http://www.36nu.com/post/153.html" target="_blank" rel="noopener">HTTP协议Header详解</a><br>　　<a href="https://www.jianshu.com/p/6e9e4156ece3" target="_blank" rel="noopener">一篇文章带你详解 HTTP 协议（网络协议篇一）</a><br><a href="https://juejin.im/post/5ab308e9f265da238e0da39b" target="_blank" rel="noopener">天下无难试之HTTP协议面试刁难大全（上）</a><br><a href="https://juejin.im/post/5b7919345188254312414b9c#heading-1" target="_blank" rel="noopener">通过HTTP的HEADER完成各种骚操作</a><br><a href="https://www.jianshu.com/p/59d36b01608d" target="_blank" rel="noopener">Http–Header</a><br><a href="https://juejin.im/post/5c136bd16fb9a049d37efc47" target="_blank" rel="noopener">前端缓存最佳实践</a><br><a href="https://juejin.im/post/58eacff90ce4630058668257#heading-0" target="_blank" rel="noopener">浏览器缓存机制剖析</a><br><a href="https://juejin.im/post/5a6c87c46fb9a01ca560b4d7#heading-7" target="_blank" rel="noopener">缓存详解</a><br><a href="https://juejin.im/post/5b70edd4f265da27df0938bc#heading-3" target="_blank" rel="noopener">前端也要懂Http缓存机制</a></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>　　<code>超文本传输协议</code>（英文：<code>HyperText Transfer Protocol</code>，缩写：HTTP）是一种用于<code>分布式</code>、<code>协作式</code>和<code>超媒体信息系统</code>的<code>应用层协议</code>。HTTP是万维网的数据通信的基础。<br>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p><h4 id="HTTP-Header"><a href="#HTTP-Header" class="headerlink" title="HTTP Header"></a>HTTP Header</h4><p><a href="https://juejin.im/post/5b70edd4f265da27df0938bc#heading-0" target="_blank" rel="noopener">前端也要懂Http缓存机制</a><br><a href="https://juejin.im/post/58eacff90ce4630058668257#heading-10" target="_blank" rel="noopener">浏览器缓存机制剖析</a></p><h5 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h5><p>指请求报文和响应报文都可以使用的字段<br>　　<code>Cache-Control</code><br>　　　　<code>no-cache</code> 指客户端不缓存过期资源<br>　　　　<code>no-store</code> 指不进行缓存<br>　　　　<code>max-age</code> 指缓存资源的缓存时间比指定的值小，那么客户端就接受缓存资源，且缓存服务器不对资源有效性进行再次确认<br>　　<code>Connection</code> 指控制不再转发给代理的首部字段（<code>Hop-by-hop</code>），管理持久连接<br>　　　　<code>close</code> 指服务器像明确断开连接<br>　　　　<code>Keep-Alive</code> 指保存持久连接，<code>HTTP/1.1</code>前默认连接是非持久性的，如需要保存持久连接，需要增加此字段<br>　　<code>Upgrade</code>可以用来指定一个完全不同的通信协议，对于这个字段，服务器可以返回101状态码</p><h5 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h5><p>　　<code>Accept</code> 指用户代理能够处理的媒体类型及媒体类型的相对优先级<br>　　<code>Accept-Encoding</code> 指用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序<br>　　<code>Authorization</code> 指用来告知服务器，用户代理的认证信息<br>　　<code>Host</code> 当一个 <code>IP</code> 下存在多个域名时，帮助服务器知道要请求的具体主机<br>　　<code>User-Agent</code> 会讲创建请求的浏览器和用户代理名称等信息传达给服务器</p><h4 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h4><p><code>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术</code>。<br>缓存的好处：<br>　　<code>缓解服务器压力</code>(不用每次去请求资源)；<br>　　<code>提升性能</code>(打开本地资源速度当然比请求回来再打开要快得多)；<br>　　<code>减少带宽消耗</code>(我相信你可以理解)；<br>　　关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果<code>内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面</code>。这就可以比较合理的解释了为什么同一个资源有时是<code>from memory cache</code>有时是<code>from disk cache</code>的问题了。<br>　　浏览器对于请求资源, 拥有一系列成熟的缓存策略. 按照发生的时间顺序分别为<code>存储策略</code>, <code>过期策略</code>, <code>协商策略</code>, 其中存储策略在收到响应后应用, 过期策略, 协商策略在发送请求前应用. 流程图如下所示.<br><img src="/assets/images/http缓存.png" alt="http缓存"></p><p>1.http header中与缓存有关的key.</p><table><thead><tr><th>key</th><th>描述</th><th>储存策略</th><th>过期策略</th><th>协商策略</th></tr></thead><tbody><tr><td>Cache-Control</td><td>指定缓存机制,覆盖其它设置</td><td>✔️</td><td>✔️</td><td></td></tr><tr><td>Pragma</td><td>http1.0字段,指定缓存机制</td><td>✔️</td><td></td><td></td></tr><tr><td>Expires</td><td>http1.0字段,指定缓存的过期时间</td><td></td><td>✔️</td><td></td></tr><tr><td>Last-Modified</td><td>资源最后一次的修改时间</td><td></td><td></td><td>✔️</td></tr><tr><td>ETag</td><td>唯一标识请求资源的字符串</td><td></td><td></td><td>✔️</td></tr></tbody></table><p>2.缓存协商策略用于重新验证缓存资源是否有效, 有关的key如下.</p><table><thead><tr><th>key</th><th>描述</th></tr></thead><tbody><tr><td>If-Modified-Since</td><td>缓存校验字段, 值为资源最后一次的修改时间, 即上次收到的Last-Modified值</td></tr><tr><td>If-Unmodified-Since</td><td>同上, 处理方式与之相反</td></tr><tr><td>If-Match</td><td>缓存校验字段, 值为唯一标识请求资源的字符串, 即上次收到的ETag值</td></tr><tr><td>If-None-Match</td><td>同上, 处理方式与之相反</td></tr></tbody></table><p>　　Http缓存可以分为两大类，强制缓存（也称强缓存）和协商缓存。两类缓存规则不同，强制缓存在缓存数据未失效的情况下，不需要再和服务器发生交互；而协商缓存，顾名思义，需要进行比较判断是否可以使用缓存。<br>　　两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。</p><h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><p>　　强制缓存分为两种情况，<code>Expires</code> 和 <code>Cache-Control</code>。<br>一旦资源命中强缓存, 浏览器便不会向服务器发送请求, 而是直接读取缓存.<br>对于常规请求, 只要存在该资源的缓存, 且<code>Cache-Control:max-age</code> 或者<code>expires</code>没有过期, 那么就能命中强缓存.</p><h6 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h6><p>　　 针对浏览器和服务器时间不同步，加入了新的缓存方案；这次服务器不是直接告诉浏览器过期时间，而是告诉一个相对时间Cache-Control=10秒，意思是10秒内，直接使用浏览器缓存。<br>　　 <code>浏览器缓存里, Cache-Control是金字塔顶尖的规则, 它藐视一切其他设置, 只要其他设置与其抵触, 一律覆盖之.</code><br>　　 不仅如此, 它还是一个复合规则, 包含多种值, 横跨 存储策略, 过期策略 两种, 同时在请求头和响应头都可设置.</p><h6 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h6><p>　　Expires的值是服务器告诉浏览器的缓存过期时间（值为GMT时间，即格林尼治时间），即下一次请求时，如果浏览器端的当前时间还没有到达过期时间，则直接使用缓存数据。</p><h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>　　强制缓存的弊端很明显，即每次都是根据时间来判断缓存是否过期；但是当到达过期时间后，如果文件没有改动，再次去获取文件就有点浪费服务器的资源了。协商缓存有两组报文结合使用：<br>　　<code>Last-Modified</code> 和 <code>If-Modified-Since</code><br>　　<code>ETag</code> 和 <code>If-None-Match</code></p><h6 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h6><p>　　语法: Last-Modified: 星期,日期 月份 年份 时:分:秒 GMT</p><blockquote><p><code>Last-Modified: Tue, 04 Apr 2017 10:01:15 GMT</code></p></blockquote><p>　　用于标记请求资源的最后一次修改时间, 格式为GMT(格林尼治标准时间). 如可用 new Date().toGMTString()获取当前GMT时间. Last-Modified 是 ETag 的fallback机制, 优先级比 ETag 低, 且只能精确到秒, 因此不太适合短时间内频繁改动的资源. 不仅如此, 服务器端的静态资源, 通常需要编译打包, 可能出现资源内容没有改变, 而Last-Modified却改变的情况.</p><h6 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h6><p><code>If-Modified-Since: Tue, 04 Apr 2017 10:12:27 GMT</code><br>　　缓存校验字段, 其值为上次响应头的Last-Modified值, 若与请求资源当前的Last-Modified值相同, 那么将返回304状态码的响应, 反之, 将返回200状态码响应.</p><h6 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h6><p><code>ETag:&quot;fcb82312d92970bdf0d18a4eca08ebc7efede4fe&quot;</code><br>　　实体标签, 服务器资源的唯一标识符, 浏览器可以根据ETag值缓存数据, 节省带宽. 如果资源已经改变, etag可以帮助防止同步更新资源的相互覆盖. ETag 优先级比 Last-Modified 高.</p><h6 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h6><p>语法: <code>If-None-Match: ETag_value</code> 或者 <code>If-None-Match: ETag_value, ETag_value</code>,<br>　　缓存校验字段, 结合<code>ETag</code>字段, 常用于判断缓存资源是否有效, 优先级比<code>If-Modified-Since</code>高.<br>　　对于 <code>GET</code> 或 <code>HEAD</code> 请求, 如果其etags列表均不匹配, 服务器将返回200状态码的响应, 反之, 将返回304(Not Modified)状态码的响应. 无论是200还是304响应, 都至少返回<code></code> Cache-Control<code>,</code>Content-Location<code>,</code>Date<code>,</code>ETag<code>,</code>Expires<code>,</code>and Vary<code>中之一的字段.　　对于其他更新服务器资源的请求, 如果其etags列表匹配, 服务器将执行更新, 反之, 将返回412(</code>Precondition Failed`)状态码的响应.</p><h5 id="不缓存-Pragma"><a href="#不缓存-Pragma" class="headerlink" title="不缓存(Pragma)"></a>不缓存(Pragma)</h5><p>　　当该字段值为no-cache的时候，会告诉浏览器不要对该资源缓存，即每次都得向服务器发一次请求才行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//禁止缓存</span><br><span class="line">res.setHeader(<span class="string">'Pragma'</span>, <span class="string">'no-cache'</span>)</span><br><span class="line">//2分钟</span><br><span class="line">res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'public,max-age=120'</span>)</span><br></pre></td></tr></table></figure></p><p>　　通过<code>Pragma</code>来禁止缓存，通过<code>Cache-Control</code>设置两分钟缓存，但是重新访问我们会发现浏览器会再次发起一次请求，说明了<code>Pragma的优先级高于Cache-Control</code>。</p><h5 id="缓存优先级"><a href="#缓存优先级" class="headerlink" title="缓存优先级"></a>缓存优先级</h5><p><code>Pragma &gt; Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified</code></p><h4 id="HTTP的请求方法"><a href="#HTTP的请求方法" class="headerlink" title="HTTP的请求方法"></a>HTTP的请求方法</h4><blockquote><p>GET: 获取URL指定的资源；<br>POST：传输实体信息<br>PUT：上传文件<br>DELETE：删除文件<br>HEAD：获取报文首部，与GET相比，不返回报文主体部分<br>OPTIONS：询问支持的方法<br>TRACE：追踪请求的路径；<br>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信。主要使用SSL和TLS将数据加密后通过网络隧道进行传输。</p></blockquote><h3 id="HTTP1-1-新改动"><a href="#HTTP1-1-新改动" class="headerlink" title="HTTP1.1 新改动"></a>HTTP1.1 新改动</h3><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><h4 id="请求管道化"><a href="#请求管道化" class="headerlink" title="请求管道化"></a>请求管道化</h4><h4 id="增加缓存处理-新的字段如cache-control"><a href="#增加缓存处理-新的字段如cache-control" class="headerlink" title="增加缓存处理(新的字段如cache-control)"></a>增加缓存处理(新的字段如cache-control)</h4><h4 id="增加Host字段、支持断点传输"><a href="#增加Host字段、支持断点传输" class="headerlink" title="增加Host字段、支持断点传输"></a>增加Host字段、支持断点传输</h4><h3 id="HTTP2-0-新特性"><a href="#HTTP2-0-新特性" class="headerlink" title="HTTP2.0 新特性"></a>HTTP2.0 新特性</h3><p>　　<code>HTTP2.0</code>可以说是<code>SPDY</code>的升级版（其实原本也是基于<code>SPDY</code>设计的），但是，<code>HTTP2.0</code> 跟 <code>SPDY</code> 仍有不同的地方，主要是以下两点<br>　　<code>HTTP2.0</code> 支持<code>明文 HTTP 传输</code>，而 <code>SPDY</code> 强制使用 <code>HTTPS</code><br>　　<code>HTTP2.0</code> 消息头的压缩算法采用 <code>HPACK</code>，而非 <code>SPDY</code> 采用的 <code>DEFLATE</code></p><h4 id="新的二进制格式-二进制分帧-Binary-Format"><a href="#新的二进制格式-二进制分帧-Binary-Format" class="headerlink" title="新的二进制格式/ 二进制分帧(Binary Format)"></a>新的二进制格式/ 二进制分帧(Binary Format)</h4><p>　　HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p><h4 id="多路复用-MultiPlexing"><a href="#多路复用-MultiPlexing" class="headerlink" title="多路复用(MultiPlexing)"></a>多路复用(MultiPlexing)</h4><p>　　即连接共享，即每一个<code>request</code>都是用作连接共享机制的。一个<code>request</code>对应一个<code>id</code>，这样一个连接上可以有多个<code>request</code>，每个连接的<code>request</code>可以随机的混杂在一起，接收方可以根据<code>request</code>的 <code>id</code>将<code>request</code>再归属到各自不同的服务端请求里面。。</p><h4 id="header-压缩"><a href="#header-压缩" class="headerlink" title="header 压缩"></a>header 压缩</h4><p>　　如上文中所言，对前面提到过<code>HTTP1.x</code>的<code>header</code>带有大量信息，而且每次都要重复发送，<code>HTTP2.0</code>使用<code>encoder</code>来减少需要传输的<code>header</code>大小，通讯双方各自<code>cache</code>一份<code>header</code> <code>fields</code>表，既避免了重复<code>header</code>的传输，又减小了需要传输的大小。</p><h4 id="服务端推送-server-push"><a href="#服务端推送-server-push" class="headerlink" title="服务端推送(server push)"></a>服务端推送(server push)</h4><p>　　同SPDY一样，HTTP2.0也具有<code>server push</code>功能。目前，有大多数网站已经启用<code>HTTP2.0</code>。<code>例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</code>例如YouTuBe，淘宝网等网站，利用chrome控制台可以查看是否启用H2：<code>chrome=&gt;Network=&gt;Name栏右键=&gt;√Protocol</code></p><h3 id="HTTP1-0-和-HTPP1-1-区别"><a href="#HTTP1-0-和-HTPP1-1-区别" class="headerlink" title="HTTP1.0 和 HTPP1.1 区别"></a>HTTP1.0 和 HTPP1.1 区别</h3><h4 id="HTTP1-0和HTTP1-1最主要的区别就是："><a href="#HTTP1-0和HTTP1-1最主要的区别就是：" class="headerlink" title="HTTP1.0和HTTP1.1最主要的区别就是："></a>HTTP1.0和HTTP1.1最主要的区别就是：</h4><p>　　<code>HTTP1.1默认是持久化连接！</code><br>　　<code>在HTTP1.0默认是短连接</code><br>简单来说就是：<code>每次与服务器交互，都需要新开一个连接！</code><br>在<code>HTTP1.1</code>中默认就使用持久化连接来解决：<code>建立一次连接，多次请求均由这个连接完成</code>！(如果阻塞了，还是会开新的<code>TCP</code>连接的)</p><h4 id="HTTP1-0-和-HTTP1-1-比较重要的区别："><a href="#HTTP1-0-和-HTTP1-1-比较重要的区别：" class="headerlink" title="HTTP1.0 和 HTTP1.1 比较重要的区别："></a>HTTP1.0 和 HTTP1.1 比较重要的区别：</h4><p>相对于持久化连接还有另外比较重要的改动：<br>　　<code>HTTP 1.1增加host字段</code><br>　　<code>HTTP 1.1增加host字段</code><br>　　<code>HTTP 1.1</code>中引入了<code>Chunked</code> <code>transfer-coding</code>，范围请求，实现断点续传(实际上就是利用<code>HTTP</code>消息头使用分块传输编码，将实体主体分块传输)<br>　　<code>HTTP 1.1</code>管线化(<code>pipelining</code>)理论，客户端可以同时发出多个<code>HTTP</code>请求，而不用一个个等待响应之后再请求<br>　　注意：这个<code>pipelining</code>仅仅是限于理论场景下，大部分桌面浏览器仍然会选择默认关闭<code>HTTP pipelining</code>！<br>　　所以现在使用<code>HTTP1.1</code>协议的应用，都是有可能会开多个TCP连接的！</p><h4 id="管线化-pipelining-和非管线化的区别："><a href="#管线化-pipelining-和非管线化的区别：" class="headerlink" title="管线化(pipelining)和非管线化的区别："></a>管线化(pipelining)和非管线化的区别：</h4><p>　　在<code>HTTP1.0</code>中，发送一次请求时，需要等待服务端响应了才可以继续发送请求。<br>　　在<code>HTTP1.1</code>中，发送一次请求时，不需要等待服务端响应了就可以发送请求了，但是回送数据给客户端的时候，客户端还是需要按照响应的顺序来一一接收<br>　　所以说，无论是HTTP1.0还是HTTP1.1提出了Pipelining理论，还是会出现阻塞的情况。从专业的名词上说这种情况，叫做线头阻塞（Head of line blocking）简称：HOLB</p><h3 id="HTTP1-1-和-HTTP2-区别"><a href="#HTTP1-1-和-HTTP2-区别" class="headerlink" title="HTTP1.1 和 HTTP2 区别"></a>HTTP1.1 和 HTTP2 区别</h3><p>　　<code>HTTP2</code>与<code>HTTP1.1</code>最重要的区别就是解决了<code>线头阻塞</code>的问题！其中最重要的改动是：<code>多路复用 (Multiplexing)</code><br>　　多路复用意味着线头阻塞将不在是一个问题，允许同时通过单一的 <code>HTTP/2</code> 连接发起<code>多重的请求-响应消息</code>，合并多个请求为一个的优化将不再适用。<br>　　　　(我们知道：HTTP1.1中的Pipelining是没有付诸于实际的)，之前为了减少HTTP请求，有很多操作将多个请求合并，比如：Spriting(多个图片合成一个图片)，内联Inlining(将图片的原始数据嵌入在CSS文件里面的URL里)，拼接Concatenation(一个请求就将其下载完多个JS文件)，分片Sharding(将请求分配到各个主机上)……</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>事件代理(事件委托)</title>
      <link href="/2019/04/08/JavaScript/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/"/>
      <url>/2019/04/08/JavaScript/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://www.cnblogs.com/wp-js/p/7609539.html" target="_blank" rel="noopener">javascript事件代理（事件委托）原理是怎么实现的</a></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>　　那什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：<code>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件</code>。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象，我仔细揣摩了一下，这个例子还真是恰当，我就不去想别的例子来解释了，借花献佛，我摘过来，大家认真领会一下事件委托到底是一个什么原理：<br>　　有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。<br>这里其实还有2层意思的：<br>　　第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；<br>　　第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1、<code>可以大量节省内存的使用，减少注册事件</code>，例如给table中的td事件，就添加到table上<br>2、<code>实现新增子对象时无需再次对其绑定事件。对于动态部分尤为适合</code></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>仅是上述1中类似的需求才会使用，使用场景比较少。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>事件委托的原理：<br>　　<code>事件委托是利用事件的冒泡原理来实现的</code>，何为事件冒泡呢？就是<code>事件从最深的节点开始，然后逐步向上传播事件</code>，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="一般方法的例子："><a href="#一般方法的例子：" class="headerlink" title="一般方法的例子："></a>一般方法的例子：</h4><p>子节点实现相同的功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"ul1"</span>&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>实现功能是点击li，弹出123：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  var oUl = document.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">  var aLi = oUl.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line">  <span class="keyword">for</span>(var i=0;i&lt;aLi.length;i++)&#123;</span><br><span class="line">    aLi[i].onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">      alert(123);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="事件委托方式："><a href="#事件委托方式：" class="headerlink" title="事件委托方式："></a>事件委托方式：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var oUl = document.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">   oUl.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招：<br>　　<code>Event</code>对象提供了一个属性叫<code>target</code>，可以返回事件的目标节点，我们成为事件源，也就是说，<code>target</code>就可以表示为当前的事件操作的<code>dom</code>，但是不是真正操作<code>dom</code>，当然，这个是有兼容性的，标准浏览器用<code>ev.target</code>，IE浏览器用<code>event.srcElement</code>，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用<code>nodeName</code>来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　var oUl = document.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">　　oUl.onclick = <span class="keyword">function</span>(ev)&#123;</span><br><span class="line">　　　　var ev = ev || window.event;</span><br><span class="line">　　　　var target = ev.target || ev.srcElement;</span><br><span class="line">　　　　<span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;</span><br><span class="line">　 　　　　　　  alert(123);</span><br><span class="line">　　　　　　　  alert(target.innerHTML);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！</p><p>　　上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"add"</span> value=<span class="string">"添加"</span> /&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"remove"</span> value=<span class="string">"删除"</span> /&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"move"</span> value=<span class="string">"移动"</span> /&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"select"</span> value=<span class="string">"选择"</span> /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var Add = document.getElementById(<span class="string">"add"</span>);</span><br><span class="line">    var Remove = document.getElementById(<span class="string">"remove"</span>);</span><br><span class="line">    var Move = document.getElementById(<span class="string">"move"</span>);</span><br><span class="line">    var Select = document.getElementById(<span class="string">"select"</span>);</span><br><span class="line">    </span><br><span class="line">    Add.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">'添加'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Remove.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">'删除'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Move.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">'移动'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Select.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">'选择'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　上面实现的效果我就不多说了，很简单，4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  var oBox = document.getElementById(<span class="string">"box"</span>);</span><br><span class="line">  oBox.onclick = <span class="keyword">function</span> (ev) &#123;</span><br><span class="line">    var ev = ev || window.event;</span><br><span class="line">    var target = ev.target || ev.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName.toLocaleLowerCase() == <span class="string">'input'</span>)&#123;</span><br><span class="line">      switch(target.id)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'add'</span> :</span><br><span class="line">          alert(<span class="string">'添加'</span>);</span><br><span class="line">          <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'remove'</span> :</span><br><span class="line">          alert(<span class="string">'删除'</span>);</span><br><span class="line">          <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'move'</span> :</span><br><span class="line">          alert(<span class="string">'移动'</span>);</span><br><span class="line">          <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'select'</span> :</span><br><span class="line">          alert(<span class="string">'选择'</span>);</span><br><span class="line">          <span class="built_in">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> name=<span class="string">""</span> id=<span class="string">"btn"</span> value=<span class="string">"添加"</span> /&gt;</span><br><span class="line">&lt;ul id=<span class="string">"ul1"</span>&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  var oBtn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">  var oUl = document.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">  var aLi = oUl.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line">  var num = 4;</span><br><span class="line">  </span><br><span class="line">  //事件委托，添加的子元素也有事件</span><br><span class="line">  oUl.onmouseover = <span class="keyword">function</span>(ev)&#123;</span><br><span class="line">    var ev = ev || window.event;</span><br><span class="line">    var target = ev.target || ev.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;</span><br><span class="line">        target.style.background = <span class="string">"red"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  oUl.onmouseout = <span class="keyword">function</span>(ev)&#123;</span><br><span class="line">    var ev = ev || window.event;</span><br><span class="line">    var target = ev.target || ev.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;</span><br><span class="line">        target.style.background = <span class="string">"#fff"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  //添加新节点</span><br><span class="line">  oBtn.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    num++;</span><br><span class="line">    var oLi = document.createElement(<span class="string">'li'</span>);</span><br><span class="line">    oLi.innerHTML = 111*num;</span><br><span class="line">    oUl.appendChild(oLi);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试题详解</title>
      <link href="/2019/04/07/JavaScript/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/04/07/JavaScript/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>闭包<br><a href="https://alittlelittlestar.github.io/2019/04/02/JavaScript/作用域和闭包/" target="_blank" rel="noopener">闭包</a><br>作用域 this<br>声明提升(变量提升)<br><a href="https://alittlelittlestar.github.io/2019/03/27/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">声明提升</a><br>盒模型<br><a href="https://alittlelittlestar.github.io/2018/11/06/CSS3/盒子模型/" target="_blank" rel="noopener">盒模型</a><br>布局(all) flex 圣杯布局(JS实现左右高度为窗口高度)+ 双飞翼布局<br><a href="https://alittlelittlestar.github.io/2019/02/15/页面布局/CSS布局/" target="_blank" rel="noopener">布局</a></p><p>get post<br>JS 跨域<br>HTTP状态码<br><a href="https://alittlelittlestar.github.io/2018/10/10/HTTP/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81/" target="_blank" rel="noopener">HTTP状态码</a><br>position </p><p>垂直居中 定宽 不定宽<br>css布局 浮动<br>HTTP协议<br>absolute &amp;&amp; relative 区别</p><p>块级元素&amp;&amp;行内元素<br>代理事件的原理<br>JS promise原理及实现<br>float<br>手撕promise （解决回调地狱回调代码难以维护的问题）<br>js数组类型<br>instanceof<br><a href="https://juejin.im/post/5b0b9b9051882515773ae714" target="_blank" rel="noopener">浅谈 instanceof 和 typeof 的实现原理</a><br>settimeout 、 setinterval<br><a href="https://www.jianshu.com/p/3e482748369d" target="_blank" rel="noopener">彻底理解setTimeout()</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settimeout</span></span><br><span class="line">settimeout(callback, time)</span><br><span class="line"></span><br><span class="line"><span class="comment"># setinterval</span></span><br><span class="line">setinterval(callback, time)</span><br><span class="line"></span><br><span class="line">setTimeout含义是定时器，到达一定的时间触发一次，</span><br><span class="line">但是setInterval含义是计时器，到达一定时间触发一</span><br><span class="line">次，并且会持续触发</span><br></pre></td></tr></table></figure></p><p>伪元素/伪类的区别<br><a href="http://localhost:4000/2018/11/16/CSS3/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/" target="_blank" rel="noopener">伪元素/伪类的区别</a><br>form表单当前页面无刷新提交(target iframe)<br><a href="https://www.cnblogs.com/chongyao/p/7298986.html" target="_blank" rel="noopener">form表单提交方式</a><br>表单可实现无刷新页面提交，无需页面跳转，如下，通过一个隐藏的iframe实现，form表单的target设置为iframe的name名称，<br>form提交目标位当前页面iframe则不会刷新页面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"/url.do"</span> method=<span class="string">"post"</span> target=<span class="string">"targetIfr"</span>&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span>/&gt;</span><br><span class="line">&lt;/form&gt;   </span><br><span class="line">&lt;iframe name=<span class="string">"targetIfr"</span> style=<span class="string">"display:none"</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p><p>清除浮动 原理(使用clear:both 会把浮动元素的边界拉下来到标准流，从而把对应标准流的位置撑开)<br><a href="https://alittlelittlestar.github.io/2018/10/10/CSS3/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/" target="_blank" rel="noopener">清除浮动</a><br>deBounce 防抖 实现<br><a href="https://juejin.im/post/5a0b10726fb9a044fc444311" target="_blank" rel="noopener"></a><br><a href="https://juejin.im/post/5b5e724af265da0f4d0d88b2" target="_blank" rel="noopener"></a><br>http &amp;&amp; https  ssl 证书验证 加密算法<br>ES6、ES7 新特性<br>JS ES6<br>let const class声明类 promise 模板字符串 对象数组 解构赋值 箭头函数(this指向外层作用域)<br>队列里的优先级问题<br>（微任务(promise)宏任务(xhr请求、settimeout、setInterval)）当前同步操作完成后优先执行微任务队列任务<br>前端性能优化<br>xss<br>http 协议 header 缓存：（强缓存、协商缓存）<br>margin 坍塌， 水平方向会不会坍塌</p><hr><p>1、当两个对象为上下关系时，而且都具备margin属性时，上面的margin-bottom与下面的margin-top会发生塌陷<br>　　当margin-bottom和margin都为正数时，结果为两者之间的最大值<br>　　当margin-bottom和margin-top都为负时，结果为两者绝对最较大的那个值。<br>　　当margin-bottom和margin-top为一正一负时，结果为两者之和。<br>2、当两个对象为上下包含关系<br>　　父元素无填充内容，且没有设置border时，子元素的margin-top不会起作用<br>　　父元素设置border属性，子元素的margin-top起作用<br>　　父元素有填充内容，子元素的margin-top会起作用，当margin-top小于填充内容时，距离为填充内容的高度<br>　　<br>CSS及浏览器的设计者们希望我们在布局时，如果遇到上下两个并排内容块的安排，最好只设置其中每个块上或下margin的一处即可。</p><p>但对于父块DIV内含子块DIV的情况，就会按另一条CSS惯例来解释了，那就是：对于有块级子元素的元素计算高度的方式,如果元素没有垂直边框和填充,那其高度就是其子元素顶部和底部边框边缘之间的距离。<br>解决父元素塌陷的方法有，（应该给父类元素添加BFC）<br>1、为父元素添加overflow:hidden;<br>2、为父元素float非none属性，也可为子元素添加float非none属性<br>3、需要给父div设置：边框，当然可以设置边框为透明;<br>4、为父DIV添加padding，或者至少添加padding-top;<br>5，如果遇到上下两个并排内容块的安排，最好只设置其中每个块上或下margin的一处即可。</p><hr><p>如何判断一个数组/data<br><code>instanceof、typeof、 constructor、 Object.prototype.toSting.call()</code></p><p>三栏布局 float position flex<br>float 布局对后续元素的影响</p><p>数组去重<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">双重循环去重</span><br><span class="line">indexOf</span><br><span class="line">排序后去重(存疑)</span><br><span class="line">利用对象属性</span><br><span class="line">Set去重(<span class="built_in">return</span> [...new Set(arr)])</span><br><span class="line">Set和from(Array.from(new Set(arr)))</span><br></pre></td></tr></table></figure></p><p>链接<br><a href="https://juejin.im/post/5aed6110518825671b026bed#heading-3" target="_blank" rel="noopener">1</a><br><a href="https://juejin.im/post/5949d85f61ff4b006c0de98b#heading-8" target="_blank" rel="noopener">2</a><br><a href="https://juejin.im/post/5b0284ac51882542ad774c45" target="_blank" rel="noopener">3</a></p><p>原型链<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](https://juejin.im/post/5835853f570c35005e413b19<span class="comment">#heading-0)</span></span><br></pre></td></tr></table></figure></p><p>面向对象<br>哪些数组方法不能改变数组本身(concat、slice)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">改变原始数组的操作方法：</span><br><span class="line">不会改变原始数组的操作方法：</span><br></pre></td></tr></table></figure></p><p>选择器标签</p><p>判断一个变量是整数<br>数组去重 set for循环实现数组reduce<br>字符串数组操作方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[javascript 下常用的字符串操作](http://f10.moe/2014/10/15/javascript-%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/)</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">charAt()</span><br><span class="line">charCodeAt()</span><br><span class="line">fromCharCode()</span><br><span class="line">concat()</span><br><span class="line">indexOf()</span><br><span class="line">lastIndexOf()</span><br><span class="line">match()</span><br><span class="line">replace()</span><br><span class="line">search()</span><br><span class="line">slice()</span><br><span class="line">split()</span><br></pre></td></tr></table></figure><p>设计模式<br>MVC mvvm<br><a href="https://www.jianshu.com/p/fc1f75df5440" target="_blank" rel="noopener">简书</a><br><a href="https://juejin.im/post/593021272f301e0058273468" target="_blank" rel="noopener">掘金</a></p><p>原生js 封装 ajax 方法 get 、 post</p><p>Vue watch computed nexttick<br>双向绑定 虚拟dom<br>Vue双向绑定原理/组件通讯<br>Vue 单双向绑定（dep watcher observer）</p><p>数组和链表的数据结构的区别<br>underscore once 实现方法<br>框架选择<br>如何避免多重回调 promise，如何在外部进行resolve()<br>express 中间件<br>数据结构<br>算法<br>栈模拟队列<br>二分插入进数组<br>选择框实现原理<br>异步执行的原理<br>IE兼容<br>继承方法<br>原生 js实现jsonp跨域、深度克隆、模板引擎、正则表达式</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器兼容性</title>
      <link href="/2019/04/05/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
      <url>/2019/04/05/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://juejin.im/post/5b3da006e51d4518f140edb2#heading-5" target="_blank" rel="noopener">如何机智地回答浏览器兼容性问题</a></p><h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><p>　　浏览器的兼容性无非还是<code>样式兼容性（css）</code>，<code>交互兼容性（javascript）</code>，<code>浏览器 hack</code>三个方面。</p><h4 id="样式兼容-CSS-方面"><a href="#样式兼容-CSS-方面" class="headerlink" title="样式兼容(CSS)方面"></a>样式兼容(CSS)方面</h4><p>　　1、因为历史原因，不同的浏览器样式存在差异，可以通过 Normalize.css 抹平差异，也可以定制自己的 reset.css，例如通过通配符选择器，全局重置样式:<code>* { margin: 0; padding: 0; }</code><br>　　2、在CSS3还没有成为真正的标准时，浏览器厂商就开始支持这些属性的使用了。CSS3样式语法还存在波动时，浏览器厂商提供了针对浏览器的前缀，直到现在还是有部分的属性需要加上浏览器前缀。在开发过程中我们一般通过IDE开发插件、css 预处理器以及前端自动化构建工程帮我们处理。<br>浏览器内核与前缀的对应关系如下:</p><table><thead><tr><th>内核</th><th>主要代表的浏览器</th><th>前缀</th></tr></thead><tbody><tr><td>Trident</td><td>IE浏览器</td><td>-ms</td></tr><tr><td>Gecko</td><td>Firefox</td><td>-moz</td></tr><tr><td>Presto</td><td>Opera</td><td>-o</td></tr><tr><td>Webkit</td><td>Chrome(blink)、Safari</td><td>-webkit</td></tr></tbody></table><p>　　3、在还原设计稿的时候我们常常会需要用到透明属性，所以解决 IE9 以下浏览器不能使用 opacity。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opacity: 0.5;</span><br><span class="line">//IE6-IE8我们习惯使用filter滤镜属性来进行实现</span><br><span class="line">filter: alpha(opacity = 50); </span><br><span class="line">//IE4-IE9都支持滤镜写法progid:DXImageTransform.Microsoft.Alpha(Opacity=xx)</span><br><span class="line">filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50);</span><br></pre></td></tr></table></figure></p><h4 id="交互兼容-javascript"><a href="#交互兼容-javascript" class="headerlink" title="交互兼容(javascript)"></a>交互兼容(javascript)</h4><p>　　1、事件兼容的问题，我们通常需要会封装一个适配器的方法，过滤事件句柄绑定、移除、冒泡阻止以及默认事件行为处理<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var  helper = &#123;&#125;</span><br><span class="line">//绑定事件</span><br><span class="line">helper.on = <span class="keyword">function</span>(target, <span class="built_in">type</span>, handler) &#123;</span><br><span class="line"> <span class="keyword">if</span>(target.addEventListener) &#123;</span><br><span class="line">   target.addEventListener(<span class="built_in">type</span>, handler, <span class="literal">false</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   target.attachEvent(<span class="string">"on"</span> + <span class="built_in">type</span>,</span><br><span class="line">     <span class="keyword">function</span>(event) &#123;</span><br><span class="line">       <span class="built_in">return</span> handler.call(target, event);</span><br><span class="line">       &#125;, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//取消事件监听</span><br><span class="line">helper.remove = <span class="keyword">function</span>(target, <span class="built_in">type</span>, handler) &#123;</span><br><span class="line"> <span class="keyword">if</span>(target.removeEventListener) &#123;</span><br><span class="line">   target.removeEventListener(<span class="built_in">type</span>, handler);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   target.detachEvent(<span class="string">"on"</span> + <span class="built_in">type</span>,</span><br><span class="line">     <span class="keyword">function</span>(event) &#123;</span><br><span class="line">     <span class="built_in">return</span> handler.call(target, event);</span><br><span class="line">   &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>　　2、<code>new Date()</code>构造函数使用，’2018-07-05’是无法被各个浏览器中，使用<code>new Date(str)</code>来正确生成日期对象的。 正确的用法是’2018/07/05’.<br>　　3、获取 scrollTop 通过 <code>document.documentElement.scrollTop</code> 兼容非chrome浏览器<br><code>var scrollTop = document.documentElement.scrollTop||document.body.scrollTop;</code></p><h4 id="浏览器-hack-CSS-hack"><a href="#浏览器-hack-CSS-hack" class="headerlink" title="浏览器 hack(CSS hack)"></a>浏览器 hack(CSS hack)</h4><p>　　由于不同厂商的流览器或某浏览器的不同版本（如<code>IE6-IE11</code>,<code>Firefox/Safari/Opera/Chrome</code>等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack!<br>　　1、快速判断 IE 浏览器版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[<span class="keyword">if</span> IE 8]&gt; ie8 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[<span class="keyword">if</span> IE 9]&gt; 骚气的 ie9 浏览器 &lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></p><p>　　2、判断是否是 Safari 浏览器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Safari */</span><br><span class="line">var isSafari = /a/.__proto__==<span class="string">'//'</span>;</span><br></pre></td></tr></table></figure></p><p>　　3、判断是否是 Chrome 浏览器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Chrome */</span><br><span class="line">var isChrome = Boolean(window.chrome);</span><br></pre></td></tr></table></figure></p><p>关于 浏览器hack:<br>　　英文：<a href="http://browserhacks.com/" target="_blank" rel="noopener">BROWSERHACKS</a><br>　　中文：<a href="https://www.w3cplus.com/css/browser-hacks.html" target="_blank" rel="noopener">主流浏览器的Hack写法</a><br>　　<a href="https://blog.csdn.net/freshlover/article/details/12132801" target="_blank" rel="noopener">史上最全的CSS hack方式一览</a></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6新特性</title>
      <link href="/2019/04/05/JavaScript/ES6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/04/05/JavaScript/ES6%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://juejin.im/post/5b1fd28d6fb9a01e615ed6d1" target="_blank" rel="noopener">带你一起敲敲ES6的新特性</a><br>　　<a href="https://zhuanlan.zhihu.com/p/62515412" target="_blank" rel="noopener">ES6 新增的常用新特性</a><br>　　<a href="https://www.jianshu.com/p/ac1787f6c50f" target="_blank" rel="noopener">ES6中常用的10个新特性讲解</a></p><h3 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h3><h4 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1.变量声明"></a>1.变量声明</h4><p>1、常量(const， 不会变量提升，块级作用域，作用域内值不能改，const 对象仍然可以被改变的)<br>如果const的是一个对象，对象所包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址没有变就行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const student = &#123; name: <span class="string">'cc'</span> &#125;</span><br><span class="line"></span><br><span class="line">student.name = <span class="string">'yy'</span>;// 不报错</span><br><span class="line">student  = &#123; name: <span class="string">'yy'</span> &#125;;// 报错</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const aa = &#123;a: <span class="string">'12'</span>&#125;;</span><br><span class="line">aa.a // 12</span><br><span class="line">aa.a = <span class="string">"123456"</span>;</span><br><span class="line">console.log(aa); // a: <span class="string">'123456'</span></span><br></pre></td></tr></table></figure><p>2、块级作用域(let，不会变量提升)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i&lt;5; i++) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(i)    //0 1 2 3 4</span><br><span class="line">  &#125;,30)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i&lt;5; i++) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(i)   //5 5 5 5 5</span><br><span class="line">  &#125;,30)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> 关键词声明的变量不具备变量提升（hoisting）特性</span><br><span class="line"><span class="built_in">let</span> 和 const 声明只在最靠近的一个块中（花括号内）有效</span><br><span class="line">当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING</span><br><span class="line">const 在声明时必须被赋值</span><br><span class="line"><span class="built_in">let</span> const：</span><br><span class="line">块级作用域</span><br><span class="line">不可重复声明</span><br><span class="line">不存在变量提升</span><br></pre></td></tr></table></figure></p><p>　　特别要说明一点的是对于const和let都有<code>暂存死区</code>，所谓暂存死区就是:<code>如果作用域内有这样一个变量那么这个作用域内就会绑定这个变量,不会继续向上查找了,以下代码运行会报错</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const a = 1;</span><br><span class="line">&#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">  const a = 2;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure><h4 id="2-结构赋值"><a href="#2-结构赋值" class="headerlink" title="2.结构赋值"></a>2.结构赋值</h4><p>　　所谓解构赋值就是 声明和赋值都放到了一起<code>一般都是数组 对 数组, 对象 对 对象, 数组能够设置默认值，对象也能够设置默认值，默认值必须采用等号的方式</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [zhan, si, xl = 5] = [3, 4];</span><br><span class="line">console.log(zhan, si, xl) //3, 4, 5</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123;name, age = 23&#125; = &#123;name: <span class="string">'xl'</span>, bigAge: 24&#125;</span><br><span class="line">console.log(name, age) //xl, 23</span><br></pre></td></tr></table></figure></p><p>特别的，可能有时会有关键字的情况可以通过:的形式来更改名字，看下面代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; name, age: xl, default: d &#125; = &#123; name: <span class="string">'xlei'</span>, age: 9, default: <span class="string">'xxx'</span> &#125;;</span><br><span class="line">console.log(name, xl, d);</span><br></pre></td></tr></table></figure></p><p>来一个默认值的具体应用吧：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> ajax(&#123;</span><br><span class="line">    url = new Error(<span class="string">'url without'</span>),</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">'get'</span>,</span><br><span class="line">    data = xxx</span><br><span class="line">&#125;)&#123;</span><br><span class="line">  console.log(data, <span class="built_in">type</span>)   //&#123;a: 5&#125;, get</span><br><span class="line">&#125;</span><br><span class="line">ajax(&#123;</span><br><span class="line">    url: <span class="string">'/test'</span>,</span><br><span class="line">    data: &#123;a:5&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="3-模板字符串"><a href="#3-模板字符串" class="headerlink" title="3.模板字符串"></a>3.模板字符串</h4><p>1、模板字符串（拼接方便，可以换行）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本的字符串格式化。将表达式嵌入字符串中进行拼接。用<span class="variable">$&#123;&#125;</span>来界定；</span><br><span class="line">ES6反引号(``)直接搞定；</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> exe1 = <span class="string">'张三'</span></span><br><span class="line"><span class="built_in">let</span> exe2 = `我的名字是：<span class="variable">$&#123;exe1&#125;</span>`</span><br></pre></td></tr></table></figure><p>2、startWith, endWith 返回一个布尔值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> str1 = <span class="string">'www.bsym.online'</span></span><br><span class="line"><span class="built_in">let</span> str2 = <span class="string">'http://www.bsym.online'</span></span><br><span class="line">console.log(str1.startsWith(<span class="string">'http://'</span>))   //<span class="literal">false</span></span><br><span class="line">console.log(str2.startsWith(<span class="string">'http://'</span>))   //<span class="literal">true</span></span><br><span class="line">console.log(str2.endsWith(<span class="string">'online'</span>))     //<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>3、padStart, padEnd补全 – 不会删除原有内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// padStart padEnd 补全(记住只能增加，不能减少)</span><br><span class="line"><span class="built_in">let</span> str1 = <span class="string">'nihao'</span></span><br><span class="line"><span class="built_in">let</span> newStr = str1.padStart(8,<span class="string">'xl'</span>)</span><br><span class="line"><span class="built_in">let</span> newStr2 = str1.padEnd(8,<span class="string">'xl'</span>)</span><br><span class="line">console.log(newStr, newStr2)   //xlxnihao, nihaoxlx</span><br></pre></td></tr></table></figure></p><h5 id="3-1字符串新增的一些方法"><a href="#3-1字符串新增的一些方法" class="headerlink" title="3.1字符串新增的一些方法"></a>3.1字符串新增的一些方法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">let</span> str = <span class="string">'imshusheng.com'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  查看字符串中是否包含某些字符</span></span><br><span class="line">    console.log(str.includes(<span class="string">'.'</span>));</span><br><span class="line">    console.log(str.includes(<span class="string">'shu'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查看字符串是否以某个字符串开头</span></span><br><span class="line">    console.log(str.startsWith(<span class="string">'i'</span>));</span><br><span class="line">    console.log(str.startsWith(<span class="string">'im'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查看字符串是否以某个字符串结尾</span></span><br><span class="line">    console.log(str.endsWith(<span class="string">'com'</span>));</span><br><span class="line">    console.log(str.endsWith(<span class="string">'m'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 字符串重复3遍</span></span><br><span class="line">    console.log(str.repeat(3))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果字符串的长度不满20位，则在其后面补字符s</span></span><br><span class="line">    console.log(str.padEnd(20, <span class="string">'s'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果字符串的长度不满20位，则在其前面补字符s</span></span><br><span class="line">    console.log(str.padStart(20, <span class="string">'s'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-箭头函数-解决this问题，书写起来更简单"><a href="#4-箭头函数-解决this问题，书写起来更简单" class="headerlink" title="4.箭头函数(解决this问题，书写起来更简单)"></a>4.箭头函数(解决this问题，书写起来更简单)</h4><p>　　传统函数内的this是定义时所在的环境，而箭头函数内的this是使用时上下文的环境。<br>　　ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =&gt;，紧接着是函数体；</p><h5 id="箭头函数最直观的三个特点。"><a href="#箭头函数最直观的三个特点。" class="headerlink" title="箭头函数最直观的三个特点。"></a>箭头函数最直观的三个特点。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不需要 <span class="keyword">function</span> 关键字来创建函数</span><br><span class="line">省略 <span class="built_in">return</span> 关键字</span><br><span class="line">继承当前上下文的 this 关键字</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var add = (a, b) =&gt; a + b;</span><br><span class="line">[1,2,3].map(x =&gt; x + 1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> aa = (arg1, arg2) =&gt; &#123;</span><br><span class="line">  console.log(arg1, arg2)</span><br><span class="line">&#125;</span><br><span class="line">aa(1, 2)   //1, 2</span><br><span class="line">;((arg1, arg2) =&gt; &#123;</span><br><span class="line">  console.log(arg1, arg2)</span><br><span class="line">&#125;)(3, 4);</span><br></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>　　这里顺带提一下，像上面的<code>自执行匿名函数前后都要加分号</code>，这样既不会被坑，也不会坑别人。另外<code>不要使用箭头函数的argeuments</code></p><h5 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h5><p>　　当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略<code>{}</code> 和 <code>return</code></p><h4 id="5-函数"><a href="#5-函数" class="headerlink" title="5.函数"></a>5.函数</h4><p>　　在ES6之前，我们往往这样定义参数的默认值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ES6之前，当未传入参数时，text = 'default'；</span></span><br><span class="line"><span class="keyword">function</span> printText(text) &#123;</span><br><span class="line">    text = text || <span class="string">'default'</span>;</span><br><span class="line">    console.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ES6；</span></span><br><span class="line"><span class="keyword">function</span> printText(text = <span class="string">'default'</span>) &#123;</span><br><span class="line">    console.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printText(<span class="string">'hello'</span>); // hello</span><br><span class="line">printText();// default</span><br></pre></td></tr></table></figure></p><h4 id="6-Spread-Rest-操作符"><a href="#6-Spread-Rest-操作符" class="headerlink" title="6.Spread / Rest 操作符"></a>6.Spread / Rest 操作符</h4><p><code>Spread / Rest 操作符指的是 ...，具体是 Spread 还是 Rest 需要看上下文语境。</code><br>　　当被用于迭代器中时，它是一个 Spread 操作符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(x,y,z) &#123;</span><br><span class="line">  console.log(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> arr = [1,2,3];</span><br><span class="line">foo(...arr); // 1 2 3</span><br></pre></td></tr></table></figure></p><p>　　当被用于函数传参时，是一个 Rest 操作符：当被用于函数传参时，是一个 Rest 操作符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(...args) &#123;</span><br><span class="line">  console.log(args);</span><br><span class="line">&#125;</span><br><span class="line">foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></p><h4 id="7-二进制和八进制字面量"><a href="#7-二进制和八进制字面量" class="headerlink" title="7.二进制和八进制字面量"></a>7.二进制和八进制字面量</h4><p>　　ES6 支持二进制和八进制的字面量，通过在数字前面添加 0o 或者0O 即可将其转换为八进制值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> oValue = 0o10;</span><br><span class="line">console.log(oValue); // 8</span><br><span class="line"> </span><br><span class="line"><span class="built_in">let</span> bValue = 0b10; // 二进制使用 `0b` 或者 `0B`</span><br><span class="line">console.log(bValue); // 2</span><br></pre></td></tr></table></figure></p><h4 id="8-for…of-和-for…in"><a href="#8-for…of-和-for…in" class="headerlink" title="8.for…of 和 for…in"></a>8.for…of 和 for…in</h4><p>　　for…of 用于遍历一个迭代器，如数组：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">letter.size = 3;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> letter of letters) &#123;</span><br><span class="line">  console.log(letter);</span><br><span class="line">&#125;</span><br><span class="line">// 结果: a, b, c</span><br></pre></td></tr></table></figure></p><p>　　for…in 用来遍历对象中的属性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> stu = [<span class="string">'Sam'</span>, <span class="string">'22'</span>, <span class="string">'男'</span>];</span><br><span class="line">stu.size = 3;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> stu <span class="keyword">in</span> stus) &#123;</span><br><span class="line">  console.log(stu);</span><br><span class="line">&#125;</span><br><span class="line">// 结果: Sam, 22, 男</span><br></pre></td></tr></table></figure></p><h4 id="9-ES6中的类"><a href="#9-ES6中的类" class="headerlink" title="9.ES6中的类"></a>9.ES6中的类</h4><p>　　ES6 中支持 class 语法，不过，ES6的class不是新的对象继承模型，它只是原型链的语法糖表现形式。<br>　　函数中使用 static 关键词定义构造函数的的方法和属性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"I'm a student."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">study</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'study!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  static <span class="function"><span class="title">read</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"Reading Now."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">console.log(typeof Student); // <span class="keyword">function</span></span><br><span class="line"><span class="built_in">let</span> stu = new Student(); // <span class="string">"I'm a student."</span></span><br><span class="line">stu.study(); // <span class="string">"study!"</span></span><br><span class="line">stu.read(); // <span class="string">"Reading Now."</span></span><br></pre></td></tr></table></figure></p><p>　　类中的继承和超集：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Phone &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"I'm a phone."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class MI extends Phone &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(<span class="string">"I'm a phone designed by xiaomi"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> mi8 = new MI();</span><br></pre></td></tr></table></figure></p><p>　　<code>extends</code> 允许一个子类继承父类，需要注意的是，子类的<code>constructor</code> 函数中需要执行 <code>super()</code> 函数。<br>当然，你也可以在子类方法中调用父类的方法，如<code>super.parentMethodName()</code>。<br>在 这里 阅读更多关于类的介绍。</p><h5 id="有几点值得注意的是："><a href="#有几点值得注意的是：" class="headerlink" title="有几点值得注意的是："></a>有几点值得注意的是：</h5><p>　　类的声明不会提升（<code>hoisting</code>)，如果你要使用某个 <code>Class</code>，那你必须在使用之前定义它，否则会抛出一个 <code>ReferenceError</code> 的错误<br>　　在类中定义函数不需要使用 <code>function</code> 关键词</p><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><p>1、数组的扩展运算符：将一个数组转为用逗号分隔的参数序列<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [...[1, 2, 3], ...[4, 5, 6]]</span><br><span class="line">console.log(arr)   // 1, 2, 3, 4, 5, 6</span><br><span class="line">console.log(Math.min(...arr))  // 1</span><br></pre></td></tr></table></figure></p><p>2、对象的解构赋值<br>　　对象的 Rest 解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面,注意Rest 解构赋值必须是最后一个参数，否则会报错。Rest解构赋值所在的对象，拷贝了对象obj的属性，Rest解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么Rest解构赋值拷贝的是这个值的引用，而不是这个值的副本，解构赋值不会拷贝继承自原型对象的属性<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;name: <span class="string">'xl'</span>, age: 23, say:<span class="string">'ok'</span>, eat: &#123;xl: <span class="string">'okok'</span>&#125;&#125;</span><br><span class="line">//尚未被读取的属性，分配到指定的对象上面,浅拷贝了对象obj的属性</span><br><span class="line"><span class="built_in">let</span> &#123;name, age, ...z&#125; = obj</span><br><span class="line">obj.say = <span class="string">'oo'</span></span><br><span class="line">obj.eat.xl = <span class="string">'o?o?'</span></span><br><span class="line">console.log(name, age, z)  </span><br><span class="line">//xl 23 &#123; say: <span class="string">'ok'</span>, eat: &#123; xl: <span class="string">'o?o?'</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> z = &#123;a: 3, b: 4, c:&#123;</span><br><span class="line">    eat:<span class="string">'ok'</span></span><br><span class="line">&#125;&#125;</span><br><span class="line">// 注意这个地方和直接赋值的区别 <span class="built_in">let</span> n = z; </span><br><span class="line">// 一个是浅拷贝对象属性，一个是浅拷贝对象</span><br><span class="line"><span class="built_in">let</span> n = &#123;...z&#125;</span><br><span class="line">z.a = 5</span><br><span class="line">z.c.eat = <span class="string">'ok?'</span></span><br><span class="line">console.log(n)  //&#123; a: 3, b: 4, c: &#123; eat: <span class="string">'ok?'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>　　那么要是想实现一个深拷贝，怎么实现呢？其实就是遍历属性如果属性是一个普通值就赋值，不是普通值就递归知道是普通值为止，然后赋值，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 实现深拷贝 保留继承关系 可以实现各种类型的拷贝 实现递归拷贝</span><br><span class="line">    <span class="keyword">function</span> deepClone(obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof obj !== <span class="string">'object'</span>) <span class="built_in">return</span> obj;</span><br><span class="line">        <span class="keyword">if</span> (obj == null) <span class="built_in">return</span> null;</span><br><span class="line">        <span class="keyword">if</span> (obj instanceof Date) <span class="built_in">return</span> new Date(obj);</span><br><span class="line">        <span class="keyword">if</span> (obj instanceof RegExp) <span class="built_in">return</span> new RegExp(obj);</span><br><span class="line">        <span class="built_in">let</span> o = new obj.constructor(); // 保留类的继承关系</span><br><span class="line"></span><br><span class="line">        Object.keys(obj).forEach((key, index) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(typeof (obj[key]) == <span class="string">'object'</span>)&#123;</span><br><span class="line">                o[key] = deepClone(obj[key])</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                // console.log(obj[key])</span><br><span class="line">                o[key] = obj[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> o = &#123; a: &#123; a: 1 &#125;, b: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(this.a)</span><br><span class="line">    &#125; &#125;</span><br><span class="line">    <span class="built_in">let</span> newObj = deepClone(o);</span><br><span class="line">    o.a.a = 2;</span><br><span class="line">    console.log( newObj.b());</span><br></pre></td></tr></table></figure></p><h4 id="数组常用方式"><a href="#数组常用方式" class="headerlink" title="数组常用方式"></a>数组常用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// (1)map返回值 返回值是一个新数组</span><br><span class="line">    Array.prototype.map = <span class="keyword">function</span> (fn) &#123;</span><br><span class="line">        <span class="built_in">let</span> arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">            arr.push(fn(this[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> arr;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">let</span> arr = [1, 2, 3].map(item =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> item * 2;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(arr);</span><br><span class="line">    // (2)filter 过滤 如果返回<span class="literal">true</span>表示留下 返回<span class="literal">false</span>表示删除</span><br><span class="line">    <span class="built_in">let</span> arr = [1, 2, 3];</span><br><span class="line">    <span class="built_in">let</span> filterArr = arr.filter(item =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> item &gt; 2;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(filterArr);</span><br><span class="line">    // (3)some找到后返回<span class="literal">true</span>,找<span class="literal">false</span>可以用every </span><br><span class="line">    <span class="built_in">let</span> r = [2, 1, 3].some(item =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> item &gt; 2;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(r);  //<span class="literal">true</span></span><br><span class="line">    // (4)every 检测数组 ages 的所有元素是否都符合条件 :</span><br><span class="line"></span><br><span class="line">    var ages = [2, 1, 3];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> r = ages.every((item) =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> item &gt; 2</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(r)  //<span class="literal">false</span></span><br><span class="line">    // (5)Array.from();   将类数组转为数组</span><br></pre></td></tr></table></figure><h5 id="数组新增方法"><a href="#数组新增方法" class="headerlink" title="数组新增方法"></a>数组新增方法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 将几个值转成数组</span><br><span class="line">    <span class="built_in">let</span> a = Array.of(1, 3, 5, 7, 9);</span><br><span class="line">    console.log(a)</span><br><span class="line"></span><br><span class="line">    // 将集合等数据类型转成数组</span><br><span class="line">    <span class="built_in">let</span> b = new Set([1, 3, 5, 7, 9]);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(Array.from(b));</span><br><span class="line"></span><br><span class="line">    // 将数组中的值替换成我们设置的值</span><br><span class="line">    <span class="built_in">let</span> d = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line">    console.log(d.fill(100));</span><br><span class="line">    console.log(d.fill(101, 2));</span><br><span class="line">    console.log(d.fill(102, 2, 3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> e = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">//之前遍历数组</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i <span class="keyword">in</span> e)&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//es6 中新增的几种遍历数组方式</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of e)&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of e.keys())&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of e.values())&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [i, j] of e.entries())&#123;</span><br><span class="line">    console.log(i, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> f = [1, 3, 5, 7, 9];</span><br><span class="line">// find 会将数组的每一个元素放入到函数中进行迭代处理</span><br><span class="line">// 将第一个满足条件的值取出来</span><br><span class="line">console.log(f.find(<span class="keyword">function</span> (x) &#123;</span><br><span class="line">    <span class="built_in">return</span> x &gt; 5</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">// findIndex 会将数组的每一个元素放入到函数中进行迭代处理</span><br><span class="line">// 将第一个满足条件的值的键取出来</span><br><span class="line">console.log(f.findIndex(<span class="keyword">function</span> (x) &#123;</span><br><span class="line">    <span class="built_in">return</span> x &gt; 5</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">// 检验某个值是否在数组内</span><br><span class="line">console.log(f.includes(5))</span><br></pre></td></tr></table></figure><h4 id="ES6的Class"><a href="#ES6的Class" class="headerlink" title="ES6的Class"></a>ES6的Class</h4><p>先复习一下es5中的几个名词：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">成员属性（方法）| 实例属性（方法） ：在构造函数中通过this.属性声明的</span><br><span class="line">静态属性（方法）：通过类来声明的 类.xxx</span><br><span class="line">私有属性（方法）：只有在类的内部可以使用，其他任何地方都不可以使用的</span><br><span class="line">公有属性（方法）|原型属性（方法）：在原型上声明的属性或者方法 xx.prototype.xxx</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Parent(name) &#123;</span><br><span class="line">  this.name = name; //成员属性|实例属性</span><br><span class="line">  this.say = <span class="function"><span class="title">function</span></span>() &#123;   //成员方法</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//静态属性</span><br><span class="line">Parent.smoking = <span class="string">'no'</span></span><br><span class="line">//公有方法|原型方法</span><br><span class="line">Parent.prototype.up = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来说说es6中的class(es6中不考虑私有属性和方法):<br>ES6 中支持 class 语法，不过，ES6的class不是新的对象继承模型，它只是原型链的语法糖表现形式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    constructor(x, y)&#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        //成员属性|实例属性  可遍历 打印实例可直接打印出来, </span><br><span class="line">        // 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），</span><br><span class="line">        // 否则都是定义在原型上（即定义在class上）。</span><br><span class="line">        this.y = y;</span><br><span class="line">        //如果不返回 默认返回实例对象 this</span><br><span class="line">        <span class="built_in">return</span> this.x </span><br><span class="line">    &#125;</span><br><span class="line">    static <span class="function"><span class="title">b</span></span>()&#123; // 属于类上的方法 也称静态方法</span><br><span class="line">        <span class="built_in">return</span> 2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span></span>()&#123;</span><br><span class="line">      //原型上的方法 | 公有方法 并且都是不可枚举的 </span><br><span class="line">      // 打印实例不能显示的打印出来 </span><br><span class="line">      console.log(this.x);</span><br><span class="line">      <span class="built_in">return</span> this.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent&#123; // </span><br><span class="line">    constructor(x, y, z)&#123;</span><br><span class="line">        // Parent.call(this);返回的是子类的实例，</span><br><span class="line">        super(x, y); </span><br><span class="line">        this.age = z; // 成员属性|实例属性</span><br><span class="line">    &#125;</span><br><span class="line">    static <span class="function"><span class="title">a</span></span>()&#123; // 属于类上的方法</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">smoking</span></span>()&#123; // 原型上的方法</span><br><span class="line">        <span class="built_in">return</span> super.eat() + this.age</span><br><span class="line">        //需要说明的是 super不仅可以调用父类的原型方法</span><br><span class="line">        // 还可以调用父类的静态方法，方法内部的this指向当前的子类，</span><br><span class="line">        // 而不是子类的实例</span><br><span class="line">        // console.log(this.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> child = new Child(2, 3, 4);</span><br><span class="line">// console.log(child);</span><br><span class="line">console.log(child.smoking())</span><br><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    //constructor函数默认返回this,</span><br><span class="line">    //这里返回一个全新的对象，结果导致实例对象不是Foo类的实例</span><br><span class="line">    <span class="built_in">return</span> Object.create(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Foo() instanceof Foo</span><br><span class="line">// <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">//定义类</span><br><span class="line">class Point &#123;</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">        this.x = x;        </span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var point = new Point(2, 3);</span><br><span class="line">console.log(point)</span><br><span class="line">point.toString() // (2, 3)</span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(<span class="string">'x'</span>) // <span class="literal">true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'y'</span>) // <span class="literal">true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'toString'</span>) // <span class="literal">false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">'toString'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A // <span class="literal">true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h4 id="迭代器-Iterators"><a href="#迭代器-Iterators" class="headerlink" title="迭代器(Iterators)"></a>迭代器(Iterators)</h4><h4 id="生成器-Generators"><a href="#生成器-Generators" class="headerlink" title="生成器(Generators)"></a>生成器(Generators)</h4><h4 id="对象和数组解构"><a href="#对象和数组解构" class="headerlink" title="对象和数组解构"></a>对象和数组解构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 对象</span><br><span class="line">const student = &#123;</span><br><span class="line">    name: <span class="string">'Sam'</span>,</span><br><span class="line">    age: 22,</span><br><span class="line">    sex: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line">// 数组</span><br><span class="line">// const student = [<span class="string">'Sam'</span>, 22, <span class="string">'男'</span>];</span><br><span class="line"></span><br><span class="line">// ES5；</span><br><span class="line">const name = student.name;</span><br><span class="line">const age = student.age;</span><br><span class="line">const sex = student.sex;</span><br><span class="line">console.log(name + <span class="string">' --- '</span> + age + <span class="string">' --- '</span> + sex);</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">const &#123; name, age, sex &#125; = student;</span><br><span class="line">console.log(name + <span class="string">' --- '</span> + age + <span class="string">' --- '</span> + sex);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见的设计模式</title>
      <link href="/2019/04/05/JavaScript/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/05/JavaScript/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://www.cnblogs.com/smlp/p/9776789.html" target="_blank" rel="noopener">前端常用的设计模式</a><br>　　<a href="https://juejin.im/entry/5816e545570c3500607205f1" target="_blank" rel="noopener">常用的 JavaScript 设计模式</a></p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>　　设计模式（<code>Design pattern</code>）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。<br>　　使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p><h4 id="工程模式"><a href="#工程模式" class="headerlink" title="工程模式"></a>工程模式</h4><p>　　定义： 将其成员对象的实例化推迟到子类来实现的类<br>　　需求： 创建对象的流程赋值的时候，比如依赖很多设置文件等；处理大量具有相同属性的小对象，注：不能滥用<br>　　优点： 不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中<br>　　缺点： 当工厂增加到一定程度的时候，提升了代码的复杂度，可读性下降。而且没有解决对象的识别问题，即怎么知道一个对象的类型。</p><h5 id="简单工厂模式-创建单一对象，需要的类比较少"><a href="#简单工厂模式-创建单一对象，需要的类比较少" class="headerlink" title="简单工厂模式(创建单一对象，需要的类比较少)"></a>简单工厂模式(创建单一对象，需要的类比较少)</h5><p>　　使用一个类，通常为单体，来生成实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> UserFactory = <span class="keyword">function</span> (role) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">SuperAdmin</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"超级管理员"</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>, <span class="string">'应用数据'</span>, <span class="string">'权限管理'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">Admin</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"管理员"</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>, <span class="string">'应用数据'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">NormalUser</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">'普通用户'</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  switch (role) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'superAdmin'</span>:</span><br><span class="line">      <span class="built_in">return</span> new SuperAdmin();</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'admin'</span>:</span><br><span class="line">      <span class="built_in">return</span> new Admin();</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'user'</span>:</span><br><span class="line">      <span class="built_in">return</span> new NormalUser();</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    default:</span><br><span class="line">      throw new Error(<span class="string">'参数错误, 可选参数:superAdmin、admin、user'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="工厂方法模式-创建多类对象，需要的类比较多"><a href="#工厂方法模式-创建多类对象，需要的类比较多" class="headerlink" title="工厂方法模式(创建多类对象，需要的类比较多)"></a>工厂方法模式(创建多类对象，需要的类比较多)</h5><p>　　为方便后续新增类方便，只需改一处代码，封装了工厂方法而已。并且把类都放在工厂类原型中实现。<br>　　将其成员对象的实列化推到子类中，子类可以<code>重写</code>父类接口方法以便创建的时候指定自己的对象类型。<br>　　父类只对创建过程中的一般性问题进行处理，这些处理<code>会被子类继承，子类之间是相互独立的</code>，具体的业务逻辑会放在子类中进行编写。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//安全模式创建的工厂方法函数</span><br><span class="line"><span class="built_in">let</span> UserFactory = <span class="keyword">function</span>(role) &#123;</span><br><span class="line">  <span class="keyword">if</span>(this instanceof UserFactory) &#123;</span><br><span class="line">    var s = new this[role]();</span><br><span class="line">    <span class="built_in">return</span> s;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> new UserFactory(role);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂方法函数的原型中设置所有对象的构造函数</span><br><span class="line">UserFactory.prototype = &#123;</span><br><span class="line">  SuperAdmin: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"超级管理员"</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>, <span class="string">'应用数据'</span>, <span class="string">'权限管理'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  Admin: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"管理员"</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>, <span class="string">'应用数据'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  NormalUser: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">'普通用户'</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line"><span class="built_in">let</span> superAdmin = UserFactory(<span class="string">'SuperAdmin'</span>);</span><br><span class="line"><span class="built_in">let</span> admin = UserFactory(<span class="string">'Admin'</span>) </span><br><span class="line"><span class="built_in">let</span> normalUser = UserFactory(<span class="string">'NormalUser'</span>)</span><br></pre></td></tr></table></figure></p><h5 id="抽象工厂模式-创建父类，子类继承父类，具体实现在子类"><a href="#抽象工厂模式-创建父类，子类继承父类，具体实现在子类" class="headerlink" title="抽象工厂模式(创建父类，子类继承父类，具体实现在子类)"></a>抽象工厂模式(创建父类，子类继承父类，具体实现在子类)</h5><p>　　抽象工厂其实是实现子类继承父类的方法，只是一个方法。<br>　　抽象工厂模式一般用在多人协作的超大型项目中，并且严格的要求项目以面向对象的思想进行完成。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 抽象工厂方法</span><br><span class="line">var VehicleFatory = <span class="keyword">function</span>(subType, superType) &#123;</span><br><span class="line">    // 判断抽象工厂中是否有该抽象类</span><br><span class="line">    <span class="keyword">if</span>(typeof VehicleFactory[superType] === <span class="string">'function'</span>) &#123;</span><br><span class="line">        // 缓存类</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;&#125;;</span><br><span class="line">        // 继承父类属性和方法</span><br><span class="line">        F.prototype = new VehicleFactory[superType] ();</span><br><span class="line">        // 将子类constructor 指向子类</span><br><span class="line">        subType.constructor = subType;</span><br><span class="line">        // 子类原型继承<span class="string">'父类'</span></span><br><span class="line">        subType.prototype = new F();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // 不存在该抽象类抛出错误</span><br><span class="line">        throw new Error(<span class="string">'未创建该抽象类'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 小汽车抽象类</span><br><span class="line">VehicleFactory.Car = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.type = <span class="string">'car'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">VehicleFactory.Car.prototype = &#123;</span><br><span class="line">    getPrice: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;,</span><br><span class="line">    getSpeed: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 公交车抽象类</span><br><span class="line">VehicleFactory.Bus = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.type = <span class="string">'bus'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">VehicleFactory.Bus.prototype = &#123;</span><br><span class="line">    getPrice: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;,</span><br><span class="line">    getSpeed: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 货车抽象类</span><br><span class="line">VehicleFactory.Truck = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.type = <span class="string">'truck'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">VehicleFactory.Truck.prototype = &#123;</span><br><span class="line">    getPrice: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;,</span><br><span class="line">    getSpeed: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 创建产品子类继承相应的产品簇抽象类</span><br><span class="line">// 宝马汽车子类</span><br><span class="line">var BMW = <span class="keyword">function</span>(price, speed) &#123;</span><br><span class="line">    this.price = price;</span><br><span class="line">    this.speed = speed;</span><br><span class="line">&#125;</span><br><span class="line">//抽象工厂实现对Car抽象类的继承</span><br><span class="line">VehicleFactory(BMW, <span class="string">'Car'</span>);</span><br><span class="line">BMW.prototype.getPrice = <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> this.price &#125;;</span><br><span class="line">BMW.prototype.getSpeed = <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> this.speed &#125;;</span><br><span class="line"></span><br><span class="line">// 公交车...</span><br><span class="line">// 货车...</span><br></pre></td></tr></table></figure></p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>　　定义：是保证一个类只有一个实例，并且提供一个访问它的全局访问点。<br>　　需求：一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象、登录浮窗等。<br>　　实现：用一个变量标识当前是否已经为某个类创建过对象，如果是，则在下一次获取这个类的实例时，直接返回之前创建的对象。<br>　　优点：<br>　　　　<code>可以用来划分命名空间，减少全局变量的数量</code><br>　　　　<code>可以被实例化，且实例化一次，再次实例化生成的也是第一个实例</code></p><h5 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 单例模式</span><br><span class="line">var Singleton = <span class="keyword">function</span>(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.instance = null;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> this.name;</span><br><span class="line">&#125;;</span><br><span class="line">// 获取实例对象</span><br><span class="line">Singleton.getInstance = <span class="keyword">function</span>(name) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!this.instance) &#123;</span><br><span class="line">        this.instance = new Singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> this.instance;</span><br><span class="line">&#125;;</span><br><span class="line">// 测试单例模式的实例</span><br><span class="line">var a = Singleton.getInstance(<span class="string">"aa"</span>);</span><br><span class="line">var b = Singleton.getInstance(<span class="string">"bb"</span>);</span><br><span class="line"></span><br><span class="line">console.log(a===b)    // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="实践例子"><a href="#实践例子" class="headerlink" title="实践例子"></a>实践例子</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    //管理单例的逻辑代码，如果没有数据则创建，有数据则返回</span><br><span class="line">   var getSingle = <span class="keyword">function</span>(fn)&#123; //参数为创建对象的方法</span><br><span class="line">       var result;</span><br><span class="line">       <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123; //判断是Null或赋值</span><br><span class="line">           <span class="built_in">return</span> result || (result = fn.apply(this,arguments));</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;;</span><br><span class="line">    //创建登录窗口方法</span><br><span class="line">    var createLoginLayer = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var div = document.createElement(<span class="string">'div'</span>);</span><br><span class="line">        div.innerHTML = <span class="string">'我是登录浮窗'</span>;</span><br><span class="line">        div.style.display = <span class="string">'none'</span>;</span><br><span class="line">        document.body.appendChild(div);</span><br><span class="line">        <span class="built_in">return</span> div;</span><br><span class="line">    &#125;;</span><br><span class="line">    //单例方法</span><br><span class="line">    var createSingleLoginLayer = getSingle(createLoginLayer);</span><br><span class="line"></span><br><span class="line">    //使用惰性单例，进行创建</span><br><span class="line">    document.getElementById(<span class="string">'loginBtn'</span>).onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var loginLayer = createSingleLoginLayer();</span><br><span class="line">        loginLayer.style.display = <span class="string">'block'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h4 id="观察者模式-发布-订阅模式"><a href="#观察者模式-发布-订阅模式" class="headerlink" title="观察者模式(发布-订阅模式)"></a>观察者模式(发布-订阅模式)</h4><p>　　定义：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。<br>　　需求：当一个对象的状态发生变化时，所有依赖于他的对象都将得到通知。<br>　　优点：时间上的解耦，对象之间的解耦。当我们需要维护相关对象的一致性的时候，使用观察者模式，，就可以避免对象之间的紧密耦合。例如，一个对象可以通知另外一个对象，而不需要知道这个对象的信息。<br>　　缺点：在发布/订阅模式中，如果我们需要将发布者同订阅者上解耦，将会在一些情况下，导致很难确保我们应用中的特定部分按照我们预期的那样正常工作。也就是说它的优点也可能是它的缺点<br>　　实现：<br>　　　　<code>首先，指定好谁充当发布者</code>；<br>　　　　<code>然后，给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者</code>；<br>　　　　<code>最后，发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数</code>。<br>　　　　<code>退订（比如不想再接收到这些订阅的信息了，就可以取消掉）</code></p><h5 id="基础例子-1"><a href="#基础例子-1" class="headerlink" title="基础例子"></a>基础例子</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var salesOffices = &#123;&#125;;                           // 定义售楼处</span><br><span class="line">salesOffices.clientList = [];                    // 缓存列表，存放订阅者的回调函数</span><br><span class="line">salesOffices.listen = <span class="keyword">function</span>( fn )&#123;            // 增加订阅者</span><br><span class="line">    this.clientList.push( fn );                  // 订阅的消息添加进缓存列表</span><br><span class="line">&#125;;</span><br><span class="line">salesOffices.trigger = <span class="function"><span class="title">function</span></span>()&#123;               // 发布消息</span><br><span class="line">    <span class="keyword">for</span>( var i = 0, fn; fn = this.clientList[ i++ ]; )&#123;</span><br><span class="line">        fn.apply( this, arguments );             // arguments 是发布消息时带上的参数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//调用</span><br><span class="line">salesOffices.listen( <span class="keyword">function</span>( price, squareMeter )&#123;//订阅消息</span><br><span class="line">    console.log( <span class="string">'价格= '</span> + price );</span><br><span class="line">    console.log( <span class="string">'squareMeter= '</span> + squareMeter );</span><br><span class="line">&#125;);</span><br><span class="line">salesOffices.trigger( 2000000, 88 );                // 输出：200 万，88 平方米</span><br></pre></td></tr></table></figure><h5 id="实践例子-1"><a href="#实践例子-1" class="headerlink" title="实践例子"></a>实践例子</h5><p>　　登录页面登录后，会需要刷新各个模块的信息（头像、nav）这类。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">var ObserverEvent = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        var clientList = [], listen, trigger, remove;</span><br><span class="line">        listen = <span class="keyword">function</span> (key, fn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!clientList[key]) &#123;</span><br><span class="line">                clientList[key] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            clientList[key].push(fn);</span><br><span class="line">        &#125;;</span><br><span class="line">        trigger = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            var key = Array.prototype.shift.call(arguments), fns = clientList[key];</span><br><span class="line">            <span class="keyword">if</span> (!fns || fns.length === 0) &#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (var i = 0, fn; fn = fns[i++];) &#123;</span><br><span class="line">                fn.apply(this, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        remove = <span class="keyword">function</span> (key, fn) &#123;</span><br><span class="line">            var fns = clientList[key];</span><br><span class="line">            <span class="keyword">if</span> (!fns) &#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">                fns &amp;&amp; (fns.length = 0);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (var l = fns.length - 1; l &gt;= 0; l--) &#123;</span><br><span class="line">                    var _fn = fns[l];</span><br><span class="line">                    <span class="keyword">if</span> (_fn === fn) &#123;</span><br><span class="line">                        fns.splice(l, 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            listen:listen,</span><br><span class="line">            trigger:trigger,</span><br><span class="line">            remove:remove</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    ObserverEvent.listen(<span class="string">'squareMeter88'</span>, fn1 = <span class="keyword">function</span> (price) &#123;</span><br><span class="line">        console.log(<span class="string">'价格='</span> + price);</span><br><span class="line">    &#125;);</span><br><span class="line">    ObserverEvent.listen(<span class="string">'squareMeter100'</span>, <span class="keyword">function</span> (price) &#123;</span><br><span class="line">        console.log(<span class="string">'价格='</span> + price);</span><br><span class="line">    &#125;);</span><br><span class="line">    ObserverEvent.trigger(<span class="string">'squareMeter88'</span>, 200000);</span><br><span class="line"></span><br><span class="line">//刷新模块信息</span><br><span class="line">var header = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        ObserverEvent.listen(<span class="string">'loginSucc'</span>, <span class="keyword">function</span> (data) &#123;</span><br><span class="line">            header.setAvatar(data.avatar);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            setAvatar: <span class="keyword">function</span> (data) &#123;</span><br><span class="line">                console.log(data + <span class="string">"设置header成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    var nav = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        ObserverEvent.listen(<span class="string">'loginSucc'</span>, <span class="keyword">function</span> (data) &#123;</span><br><span class="line">            nav.setAvatar(data.avatar)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            setAvatar: <span class="keyword">function</span> (data) &#123;</span><br><span class="line">                console.log(data + <span class="string">'设置nav成功'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    var data = &#123;&#125;;</span><br><span class="line">    data.avatar = <span class="string">"参数"</span>;</span><br><span class="line">    ObserverEvent.trigger(<span class="string">'loginSucc'</span>, data);</span><br></pre></td></tr></table></figure></p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>　　策略模式指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>　　代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额。<br>　　没有使用策略模式的情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Price(personType, price) &#123;</span><br><span class="line">    //vip 5 折</span><br><span class="line">    <span class="keyword">if</span> (personType == <span class="string">'vip'</span>) &#123;</span><br><span class="line">        <span class="built_in">return</span> price * 0.5;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (personType == <span class="string">'old'</span>)&#123; //老客户 3 折</span><br><span class="line">        <span class="built_in">return</span> price * 0.3;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> price; //其他都全价</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　不足之处：不好的地方，当我有其他方面的折扣时，又或者我活动的折扣时经常变化的，这样就要不断的修改if..else里面的条件了。而且也违背了设计模式的一个原则：对修改关闭，对扩展开放的原则；<br>　　使用策略模式之后：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 对于vip客户</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">vipPrice</span></span>() &#123;</span><br><span class="line">    this.discount = 0.5;</span><br><span class="line">&#125;</span><br><span class="line">vipPrice.prototype.getPrice = <span class="keyword">function</span>(price) &#123;</span><br><span class="line">　　<span class="built_in">return</span> price * this.discount;</span><br><span class="line">&#125;</span><br><span class="line">// 对于老客户</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">oldPrice</span></span>() &#123;</span><br><span class="line">    this.discount = 0.3;</span><br><span class="line">&#125;</span><br><span class="line">oldPrice.prototype.getPrice = <span class="keyword">function</span>(price) &#123;</span><br><span class="line">    <span class="built_in">return</span> price * this.discount;</span><br><span class="line">&#125;</span><br><span class="line">// 对于普通客户</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Price</span></span>() &#123;</span><br><span class="line">    this.discount = 1;</span><br><span class="line">&#125;</span><br><span class="line">Price.prototype.getPrice = <span class="keyword">function</span>(price) &#123;</span><br><span class="line">    <span class="built_in">return</span> price ;</span><br><span class="line">&#125;</span><br><span class="line">// 上下文，对于客户端的使用</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Context</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">''</span>;</span><br><span class="line">    this.strategy = null;</span><br><span class="line">    this.price = 0;</span><br><span class="line">&#125;</span><br><span class="line">Context.prototype.set = <span class="keyword">function</span>(name, strategy, price) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.strategy = strategy;</span><br><span class="line">    this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">Context.prototype.getResult = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(this.name + <span class="string">' 的结账价为: '</span> + this.strategy.getPrice(this.price));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var context = new Context();</span><br><span class="line">var vip = new vipPrice();</span><br><span class="line">context.set (<span class="string">'vip客户'</span>, vip, 200);</span><br><span class="line">context.getResult();   // vip客户 的结账价为: 100</span><br><span class="line"></span><br><span class="line">var old = new oldPrice();</span><br><span class="line">context.set (<span class="string">'老客户'</span>, old, 200);</span><br><span class="line">context.getResult();  // 老客户 的结账价为: 60</span><br><span class="line"></span><br><span class="line">var Price = new Price();</span><br><span class="line">context.set (<span class="string">'普通客户'</span>, Price, 200);</span><br><span class="line">context.getResult();  // 普通客户 的结账价为: 200</span><br></pre></td></tr></table></figure></p><p>　　通过策略模式，使得客户的折扣与算法解藕，又使得修改跟扩展能独立的进行，不影到客户端或其他算法的使用；</p><h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p>　　定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 通俗的讲，就是将一些公共方法封装到父类，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。</p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>　　比如前端面试，基本包括笔试，技术面试，领导面试，HR面试等，但是每个公司的笔试题，技术面可能不一样，也可能一样，一样的就继承父类的方法，不一样的就重写父类的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">var Interview = <span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">// 笔试</span><br><span class="line">Interview.prototype.writtenTest = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"这里是前端笔试题"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">// 技术面试</span><br><span class="line">Interview.prototype.technicalInterview = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"这里是技术面试"</span>);</span><br><span class="line">&#125;; </span><br><span class="line">// 领导面试</span><br><span class="line">Interview.prototype.leader = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"领导面试"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">// 领导面试</span><br><span class="line">Interview.prototype.HR = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"HR面试"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">// 等通知</span><br><span class="line">Interview.prototype.waitNotice = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"等通知啊，不知道过了没有哦"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">// 代码初始化</span><br><span class="line">Interview.prototype.init = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    this.writtenTest();</span><br><span class="line">    this.technicalInterview();</span><br><span class="line">    this.leader();</span><br><span class="line">    this.HR();</span><br><span class="line">    this.waitNotice();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 阿里巴巴的笔试和技术面不同，重写父类方法，其他继承父类方法。</span><br><span class="line">var AliInterview = <span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">AliInterview.prototype = new Interview();</span><br><span class="line"></span><br><span class="line">// 子类重写方法 实现自己的业务逻辑</span><br><span class="line">AliInterview.prototype.writtenTest = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"阿里的技术题就是难啊"</span>);</span><br><span class="line">&#125;</span><br><span class="line">AliInterview.prototype.technicalInterview = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"阿里的技术面就是叼啊"</span>);</span><br><span class="line">&#125;</span><br><span class="line">var AliInterview = new AliInterview();</span><br><span class="line">AliInterview.init();</span><br><span class="line"></span><br><span class="line">// 阿里的技术题就是难啊</span><br><span class="line">// 阿里的技术面就是叼啊</span><br><span class="line">// 领导面试</span><br><span class="line">// HR面试</span><br><span class="line">// 等通知啊，不知道过了没有哦</span><br></pre></td></tr></table></figure></p><p><strong>应用场景：</strong><br>　　模板模式主要应用在一些代码刚开要一次性实现不变的部分。但是将来页面有修改，需要更改业务逻辑的部分或者重新添加新业务的情况。主要是通过子类来改写父类的情况，其他不需要改变的部分继承父类。　　</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>概念：<br>　　代理模式的中文含义就是帮别人做事，<code>javascript</code>的解释为：把对一个对象的访问, 交给另一个代理对象来操作.<br>代码实现：<br>　　比如我们公司的补打卡是最后是要交给大boss来审批的，但是公司那么多人，每天都那么多补打卡，那大boss岂不是被这些琐事累死。所以大boss下会有一个助理，来帮忙做这个审批，最后再将每个月的补打卡统一交给大boss看看就行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 补打卡事件</span><br><span class="line">var fillOut = <span class="keyword">function</span> (lateDate) &#123;</span><br><span class="line"></span><br><span class="line">    this.lateDate = lateDate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 这是bigBoss</span><br><span class="line">var bigBoss = <span class="keyword">function</span> (fillOut) &#123;</span><br><span class="line"></span><br><span class="line">    this.state = <span class="keyword">function</span> (isSuccess) &#123;</span><br><span class="line">        console.log(<span class="string">"忘记打卡的日期为："</span> + fillOut.lateDate + <span class="string">", 补打卡状态："</span> + isSuccess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 助理代理大boss 完成补打卡审批</span><br><span class="line">var proxyAssis = <span class="keyword">function</span> (fillOut) &#123;</span><br><span class="line">    </span><br><span class="line">    this.state = <span class="keyword">function</span> (isSuccess) &#123;</span><br><span class="line">        (new bigBoss(fillOut)).state(isSuccess); // 替bigBoss审批</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 调用方法：</span><br><span class="line">var proxyAssis = new proxyAssis(new fillOut(<span class="string">"2016-9-11"</span>));</span><br><span class="line">proxyAssis.state(<span class="string">"补打卡成功"</span>);</span><br><span class="line">// 忘记打卡的日期为：2016-9-11, 补打卡状态：补打卡成功</span><br></pre></td></tr></table></figure></p><p>应用场景：<br>　　比如图片的懒加载，我们就可以运用这种技术。在图片未加载完成之前，给个loading图片，加载完成后再替换成实体路径。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var myImage = (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var imgNode = document.createElement(<span class="string">"img"</span>);</span><br><span class="line">    document.body.appendChild(imgNode);</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(src)&#123;</span><br><span class="line">        imgNode.src = src; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">// 代理模式</span><br><span class="line">var ProxyImage = (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        myImage(this.src);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(src) &#123;</span><br><span class="line">      // 占位图片loading</span><br><span class="line">      myImage(<span class="string">"http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif"</span>);</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">// 调用方式</span><br><span class="line"></span><br><span class="line">ProxyImage(<span class="string">"https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png"</span>); // 真实要展示的图片</span><br></pre></td></tr></table></figure></p><p>　　当然，这种懒加载方法不用代理模式也是可以实现的，只是用代理模式。我们可以让 myImage 只做一件事，只负责将实际图片加入到页面中，而loading图片交给ProxyImage去做。从而降低代码的耦合度。因为当我不想用loading的时候，可以直接调用myImage 方法。也即是说假如我门不需要代理对象的话，直接可以换成本体对象调用该方法即可。</p><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>　　概念：<br>　　外观模式是很常见。其实它就是通过编写一个单独的函数，来简化对一个或多个更大型的，可能更为复杂的函数的访问。也就是说可以视外观模式为一种简化某些内容的手段。<br>　　说白了，外观模式就是一个函数，封装了复杂的操作。<br>代码实现：<br>　　比如一个跨浏览器的ajax调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> ajaxCall(<span class="built_in">type</span>,url,callback,data)&#123;</span><br><span class="line">    // 根据当前浏览器获取对ajax连接对象的引用</span><br><span class="line">    var xhr=(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 所有现代浏览器所使用的标准方法</span><br><span class="line">            <span class="built_in">return</span> new XMLHttpRequest();</span><br><span class="line">        &#125;catch(e)&#123;&#125;</span><br><span class="line">        // 较老版本的internet Explorer兼容</span><br><span class="line">        try&#123;</span><br><span class="line">            <span class="built_in">return</span> new ActiveXObject(<span class="string">"Msxml2.XMLHTTP.6.0"</span>);</span><br><span class="line">        &#125;catch(e)&#123;&#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            <span class="built_in">return</span> new ActiveXObject(<span class="string">"Msxml2.XMLHTTP.3.0"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;catch(e)&#123;&#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            <span class="built_in">return</span> new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">        &#125;catch(e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        // 如果没能找到相关的ajax连接对象，则跑出一个错误。</span><br><span class="line">        throw new Error(<span class="string">"Ajax not support in this browser."</span>)</span><br><span class="line"></span><br><span class="line">    &#125;()),</span><br><span class="line">    STATE_LOADED=4,</span><br><span class="line">    STATUS_OK=200;</span><br><span class="line"></span><br><span class="line">    // 一但从服务器收到表示成功的相应消息，则执行所给定的回调方法</span><br><span class="line">    xhr.onreadystatechange=<span class="keyword">function</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState !==STATE_LOADED)&#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xhr.state==STATUS_OK)&#123;</span><br><span class="line">            callback(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用浏览器的ajax连接对象来向所给定的URL发出相关的调用</span><br><span class="line">    xhr.open(type.toUpperCase(),url);</span><br><span class="line">    xhr.send(data);</span><br><span class="line">&#125;</span><br><span class="line">// 使用方法</span><br><span class="line">ajaxCall(<span class="string">"get"</span>,<span class="string">"/user/12345"</span>,<span class="keyword">function</span>(rs)&#123;</span><br><span class="line">    alert(<span class="string">'收到的数据为：'</span>+rs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>应用场景：<br>　　当需要通过一个单独的函数或方法来访问一系列的函数或方法调用，以简化代码库的其余内容，使得代码更容易跟踪管理或者更好的维护时，可以使用外观模式。其实我们平时代码中这种模式应该是用的比较多的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP和UDP的区别</title>
      <link href="/2019/04/05/HTTP/TCP&amp;&amp;UDP/"/>
      <url>/2019/04/05/HTTP/TCP&amp;&amp;UDP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://segmentfault.com/a/1190000018582150" target="_blank" rel="noopener">TCP和UDP比较</a></p><h3 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP/IP网络模型"></a>TCP/IP网络模型</h3><p>　　计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（<code>protocol</code>）。<br>　　<code>TCP/IP</code> 是互联网相关的各类协议族的总称，比如：<code>TCP</code>，<code>UDP</code>，<code>IP</code>，<code>FTP</code>，<code>HTTP</code>，<code>ICMP</code>，<code>SMTP</code> 等都属于 <code>TCP/IP</code> 族内的协议。<br>　　<code>TCP/IP</code>模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为<code>链路层</code>、<code>网络层</code>、<code>传输层</code>和<code>应用层</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</span><br><span class="line">网络层：负责路由以及把分组报文发送给目标网络或主机。</span><br><span class="line">传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</span><br><span class="line">应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</span><br></pre></td></tr></table></figure></p><p>详情图片:<br><img src="/assets/images/httposi.png" alt="HTPPOSI七层模型"><br>　　在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>　　当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。<br>　　TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p><h4 id="TCP连接过程"><a href="#TCP连接过程" class="headerlink" title="TCP连接过程"></a>TCP连接过程</h4><p>三次握手:<br><strong>第一次握手</strong><br>　　客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。<br><strong>第二次握手</strong><br>　　服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。<br><strong>第三次握手</strong><br>　　当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。<br>　　这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</p><h4 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h4><p>　　TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。<br><strong>第一次挥手</strong><br>　　若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。<br><strong>第二次挥手</strong><br>　　B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。<br><strong>第三次挥手</strong><br>　　B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。<br><strong>第四次挥手</strong><br>　　A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p><h4 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h4><h5 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h5><p>　　面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p><h5 id="仅支持单播传输"><a href="#仅支持单播传输" class="headerlink" title="仅支持单播传输"></a>仅支持单播传输</h5><p>　　每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><h5 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h5><p>　　TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><h5 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h5><p>　　对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p><blockquote><p>TCP 内部的很多算法机制让他保持连接的过程中是很可靠的。比如：TCP 的超时重传、错误重传、TCP 的流量控制、阻塞控制、慢热启动算法、拥塞避免算法、快速恢复算法 等等。</p></blockquote><h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><h6 id="其基本原理：在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。"><a href="#其基本原理：在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。" class="headerlink" title="其基本原理：在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。"></a>其基本原理：在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</h6><p>　　这里比较重要的是重传超时时间，怎样设置这个定时器的时间（RTO），从而保证对网络资源最小的浪费。因为若RTO太小，可能有些报文只是遇到拥堵或网络不好延迟较大而已，这样就会造成不必要的重传。太大的话，使发送端需要等待过长的时间才能发现数据丢失，影响网络传输效率。<br>　　由于不同的网络情况不一样，不可能设置一样的RTO，实际中RTO是根据网络中的RTT（传输往返时间）来自适应调整的。具体关系参考相关算法。<br><a href="https://www.cnblogs.com/duan2/p/9180861.html" target="_blank" rel="noopener">TCP超时与重传机制</a></p><h5 id="提供拥塞控制"><a href="#提供拥塞控制" class="headerlink" title="提供拥塞控制"></a>提供拥塞控制</h5><p>　　当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p><h5 id="TCP提供双工通信"><a href="#TCP提供双工通信" class="headerlink" title="TCP提供双工通信"></a>TCP提供双工通信</h5><p>　　TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>　　UDP协议全称是<code>用户数据报协议</code>，在网络中它与<code>TCP</code>协议一样用于处理数据包，是一种<code>无连接的协议</code>。在OSI模型中，在<code>第四层——传输层</code>，处于IP协议的上一层。<code>UDP</code>有<code>不提供数据包分组</code>、<code>组装</code>和<code>不能对数据包进行排序</code>的缺点，也就是说，<code>当报文发送之后，是无法得知其是否安全完整到达的</code>。</p><h4 id="UDP的特点"><a href="#UDP的特点" class="headerlink" title="UDP的特点"></a>UDP的特点</h4><h5 id="面向无连接"><a href="#面向无连接" class="headerlink" title="面向无连接"></a>面向无连接</h5><p>　　首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。<br>具体来说就是：<br>　　在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了<br>　　在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</p><h5 id="有单播、多播、广播的功能"><a href="#有单播、多播、广播的功能" class="headerlink" title="有单播、多播、广播的功能"></a>有单播、多播、广播的功能</h5><p>　　UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><h5 id="UDP是面向报文的"><a href="#UDP是面向报文的" class="headerlink" title="UDP是面向报文的"></a>UDP是面向报文的</h5><p>　　发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><h5 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h5><p>　　首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。<br>　　并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。<br>　　再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p><blockquote><p>UDP 是一个面向非连接的协议，UDP 发送的每个数据报带有自己的 IP 地址和接收方的 IP 地址，它本身对这个数据报是否出错，是否到达不关心，只要发出去了就好了。所以来研究下，什么情况会导致 UDP 丢包：<br>数据报分片重组丢失：<br>在文章之前我们就说过，UDP 的每个数据报大小多少最合适，事实上 UDP 协议本身规定的大小是 64kb，但是在数据链路层有 MTU 的限制，大小大概在 5kb，所以当你发送一个很大的 UDP 包的时候，这个包会在 IP 层进行分片，然后重组。这个过程就有可能导致分片的包丢失。UDP 本身有 CRC 检测机制，会抛弃掉丢失的 UDP 包。<br>UDP 缓冲区填满<br>当 UDP 的缓冲区已经被填满的时候，接收方还没有处理这部分的 UDP 数据报，这个时候再过来的数据报就没有地方可以存了，自然就都被丢弃了。</p></blockquote><h5 id="头部开销小，传输数据报文时是很高效的。"><a href="#头部开销小，传输数据报文时是很高效的。" class="headerlink" title="头部开销小，传输数据报文时是很高效的。"></a>头部开销小，传输数据报文时是很高效的。</h5><p>UDP 头部包含了以下几个数据：<br>　　两个十六位的端口号，分别为源端口（可选字段）和目标端口<br>　　整个数据报文的长度<br>　　整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误<br>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p><h3 id="TCP和UDP的比较"><a href="#TCP和UDP的比较" class="headerlink" title="TCP和UDP的比较"></a>TCP和UDP的比较</h3><table><thead><tr><th>对比项</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>无连接</td></tr><tr><td>是否可靠</td><td>可靠传输，使用流量控制和拥塞控制</td><td>不可靠传输，不使用流量控制和拥塞控制</td></tr><tr><td>连接对象个数</td><td>只能是一对一通信</td><td>支持一对一，一对多，多对一和多对多交互通信</td></tr><tr><td>传输方式</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>首部开销</td><td>首部最小20字节，最大60字节</td><td>首部开销小，仅8字节</td></tr><tr><td>使用场景</td><td>适用于要求可靠传输的应用，例如文件传输</td><td>适用于实时应用（IP电话、视频会议、直播等）</td></tr></tbody></table><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>　　TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。<br>　　虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为<br>　　对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DOM操作和BOM操作</title>
      <link href="/2019/04/02/JavaScript/DOM%E6%93%8D%E4%BD%9C%E5%92%8CBOM%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/04/02/JavaScript/DOM%E6%93%8D%E4%BD%9C%E5%92%8CBOM%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><p>　　当网页被加载时，浏览器会创建页面的文档对象模型(DOM),我们可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。接下来我们介绍常见DOM操作：<a href="https://alittlelittlestar.github.io/2019/03/31/JavaScript/DOM基本操作/" target="_blank" rel="noopener">DOM基本操作</a></p><h3 id="DOM事件模型和事件流"><a href="#DOM事件模型和事件流" class="headerlink" title="DOM事件模型和事件流"></a>DOM事件模型和事件流</h3><p>　　<code>DOM事件模型分为捕获和冒泡</code>。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。<br>　　（1）捕获阶段：事件从window对象自上而下向目标节点传播的阶段,捕获阶段不会响应任何事件；<br>　　（2）目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；<br>　　（3）冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；<br>详情：<br>　　<a href="https://alittlelittlestar.github.io/2018/10/10/JavaScript/冒泡和捕获/" target="_blank" rel="noopener">冒泡和捕获</a></p><h3 id="事件代理-事件委托"><a href="#事件代理-事件委托" class="headerlink" title="事件代理(事件委托)"></a>事件代理(事件委托)</h3><p>　　由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。<br>　　我们设定一种场景，如下代码，一个<code>&lt;div&gt;</code>中包含了若干个<code>&lt;a&gt;</code>，而且还能继续增加。那如何快捷方便地为所有<code>&lt;a&gt;</code>绑定事件呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"div1"</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span>&gt;a1&lt;/a&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span>&gt;a2&lt;/a&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span>&gt;a3&lt;/a&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span>&gt;a4&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;button&gt;点击增加一个 a 标签&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><p>　　如果给每个<code>&lt;a&gt;</code>标签一一都绑定一个事件，那对于内存消耗是非常大的。借助事件代理，我们只需要给父容器<code>div</code>绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把父容器的<code>click</code>行为触发，然后把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而完成不同的事。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var div1 = document.getElementById(<span class="string">'div1'</span>)</span><br><span class="line">div1.addEventListener(<span class="string">'click'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    // e.target 可以监听到触发点击事件的元素是哪一个</span><br><span class="line">    var target = e.target</span><br><span class="line">    <span class="keyword">if</span> (e.nodeName === <span class="string">'A'</span>) &#123;</span><br><span class="line">        // 点击的是 &lt;a&gt; 元素</span><br><span class="line">        alert(target.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>最后，使用代理的优点如下：<br>　　使代码简洁<br>　　减少浏览器的内存占用<br>　　动态昂定事件</p><h3 id="BOM操作"><a href="#BOM操作" class="headerlink" title="BOM操作"></a>BOM操作</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>　　BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含有关用户屏幕的信息</span></span><br><span class="line">window.screen对象</span><br><span class="line"><span class="comment"># 用于获得当前页面的地址(URL)，并把浏览器重定向到新的页面</span></span><br><span class="line">window.location对象</span><br><span class="line"><span class="comment"># 浏览历史的前进后退等</span></span><br><span class="line">window.history对象</span><br><span class="line"><span class="comment"># 常常用来获取浏览器信息、是否移动端访问等等</span></span><br><span class="line">window.navigator对象</span><br></pre></td></tr></table></figure></p><p>获取屏幕的宽度和高度<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(screen.width)</span><br><span class="line">console.log(screen.height)</span><br></pre></td></tr></table></figure></p><p>获取网址、协议、path、参数、hash 等<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如当前网址是 </span></span><br><span class="line">https://juejin.im/timeline/frontend?a=10&amp;b=10<span class="comment">#some</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回（当前页面的）整个 URL</span></span><br><span class="line"><span class="comment"># https://juejin.im/timeline/frontend?a=10&amp;b=10#some</span></span><br><span class="line">console.log(location.href)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回所使用的 web 协议（http:// 或 https://）</span></span><br><span class="line"><span class="comment"># https:</span></span><br><span class="line">console.log(location.protocol) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性返回 URL 的路径名</span></span><br><span class="line"><span class="comment"># /timeline/frontend</span></span><br><span class="line">console.log(location.pathname) </span><br><span class="line"></span><br><span class="line"><span class="comment"># ?a=10&amp;b=10</span></span><br><span class="line">console.log(location.search) </span><br><span class="line"></span><br><span class="line"><span class="comment"># #some</span></span><br><span class="line">console.log(location.hash)</span><br></pre></td></tr></table></figure></p><p>另外，还有调用浏览器的前进、后退功能等<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history.back()</span><br><span class="line">history.forward()</span><br></pre></td></tr></table></figure></p><p>获取浏览器特性（即俗称的UA）然后识别客户端，例如判断是不是 Chrome 浏览器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ua = navigator.userAgent</span><br><span class="line">var isChrome = ua.indexOf(<span class="string">'Chrome'</span>)</span><br><span class="line">console.log(isChrome)</span><br></pre></td></tr></table></figure></p><p>转载：<br>　　<a href="https://segmentfault.com/a/1190000018696018#articleHeader18" target="_blank" rel="noopener">思否</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>作用域和闭包</title>
      <link href="/2019/04/02/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/"/>
      <url>/2019/04/02/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="执行上下文和执行栈"><a href="#执行上下文和执行栈" class="headerlink" title="执行上下文和执行栈"></a>执行上下文和执行栈</h3><p>　　执行上下文就是当前 <code>JavaScript</code>代码被解析和执行时所在环境的抽象概念， <code>JavaScript</code> 中运行任何的代码都是在执行上下文中运行。</p><h4 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h4><p>执行上下文总共有三种类型：<br>　　<code>全局执行上下文</code>： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：<br>　　　　1、 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。<br>　　　　2、 将this指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。<br>　　<code>函数执行上下文</code>： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。<br>　　<code>Eval 函数执行上下文</code>： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。</p><h4 id="执行上下文：创建阶段"><a href="#执行上下文：创建阶段" class="headerlink" title="执行上下文：创建阶段"></a>执行上下文：创建阶段</h4><p>　　执行上下文的生命周期包括三个阶段：<code>创建阶段</code>→<code>执行阶段</code>→<code>回收阶段</code>，我们重点介绍创建阶段。<br>创建阶段（当函数被调用，但未执行任何其内部代码之前）会做以下三件事：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。</span><br><span class="line">创建作用域链：下文会介绍</span><br><span class="line">确定this指向：下文会介绍</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(arg)&#123;</span><br><span class="line">    // 1. 形参 arg 是 <span class="string">"hi"</span></span><br><span class="line">    // 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 <span class="keyword">function</span></span><br><span class="line">    console.log(arg);  </span><br><span class="line">    var arg = <span class="string">'hello'</span>; // 3.var arg 变量声明被忽略， arg = <span class="string">'hello'</span>被执行</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">arg</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'hello world'</span>) </span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arg);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>(<span class="string">'hi'</span>);</span><br><span class="line">/* 输出：</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">arg</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'hello world'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">hello </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>这是因为当函数执行的时候,首先会形成一个新的私有的作用域，然后依次按照如下的步骤执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果有形参，先给形参赋值</span><br><span class="line">进行私有作用域中的预解释，函数声明优先级比变量声明高，最后后者会被前者所覆盖，但是可以重新赋值</span><br><span class="line">私有作用域中的代码从上到下执行</span><br></pre></td></tr></table></figure></p><h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>　　函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？<br>　　<code>JavaScript</code> 引擎创建了执行栈来管理执行上下文。<code>可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</code>。<br>　　执行栈，在其他编程语言中也被叫做调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。<br>　　当 JavaScript 引擎首次读取你的脚本时，它会创建一个全局执行上下文并将其推入当前的执行栈。每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈的顶端。</p><p>　　引擎会运行执行上下文在执行栈顶端的函数，当此函数运行完成后，其对应的执行上下文将会从执行栈中弹出，上下文控制权将移到当前执行栈的下一个执行上下文。<br><img src="/assets/images/执行栈.gif" alt="执行栈"><br>从上面的流程图，我们需要记住几个关键点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaScript执行在单线程上，所有的代码都是排队执行。</span><br><span class="line">一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</span><br><span class="line">每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。</span><br><span class="line">当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。</span><br><span class="line">浏览器的JS执行引擎总是访问栈顶的执行上下文。</span><br><span class="line">全局上下文只有唯一的一个，它在浏览器关闭时出栈。</span><br></pre></td></tr></table></figure></p><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>　　ES6 到来JavaScript 有全局作用域、函数作用域和块级作用域（ES6新增）。我们可以这样理解：<code>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</code>。<br>　　在介绍作用域链之前，先要了解下自由变量，如下代码中，console.log(a)要得到a变量，但是在当前的作用域中没有定义a（可对比一下b）。当前作用域没有定义的变量，这成为 自由变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 100</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">    var b = 200</span><br><span class="line">    console.log(a) // 这里的a在这里就是一个自由变量</span><br><span class="line">    console.log(b)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure></p><p><code>自由变量的值如何得到 —— 向父级作用域(创建该函数的那个父级作用域)</code>寻找。如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">F1</span></span>() &#123;</span><br><span class="line">    var a = 100</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> F2(f1) &#123;</span><br><span class="line">    var a = 200</span><br><span class="line">    console.log(f1())</span><br><span class="line">&#125;</span><br><span class="line">var f1 = F1()</span><br><span class="line">F2(f1) // 100</span><br></pre></td></tr></table></figure></p><p>　　上述代码中，自由变量a的值，从函数F1中查找而不是F2,这是因为当自由变量从作用域链中去寻找，依据的是函数定义时的作用域链，而不是函数执行时。</p><h3 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h3><p>　　闭包这个概念也是JavaScript中比较抽象的概念，我个人理解，闭包是就是函数中的函数(其他语言不能这样),<code>里面的函数可以访问外面函数的变量</code>，<code>外面的变量的是这个内部函数的一部分</code>。<br><code>闭包让我们能够从一个函数内部访问其外部函数的作用域</code>。<br>闭包的优点：<br>　　（1）<code>逻辑连续，当闭包作为另一个函数调用参数时，避免脱离当前逻辑而单独编写额外逻辑</code><br>　　（2）<code>方便调用上下文的局部变量</code>。<br>　　（3）<code>加强封装性</code>，是第2点的延伸，可以达到对变量的保护作用。<br>使用闭包的注意点（缺点）：<br>　　（1）由于闭包会使得函数中的变量都被保存在内存中，<code>内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题</code>，在IE中可能导致内存泄露。<code>解决方法是，在退出函数之前，将不使用的局部变量全部删除</code>。<br>　　（2）<code>闭包会在父函数外部，改变父函数内部变量的值</code>。所以，如果你把父函数当作对象（<code>object</code>）使用，把闭包当作它的公用方法（<code>Public Method</code>），把内部变量当作它的私有属性（<code>private value</code><br>），这时一定要小心，不要随便改变父函数内部变量的值。<br>闭包的特性:<br>　　（1）作为函数变量的一个引用。当函数返回时，其处于激活状态。<br>　　（2）闭包就是当一个函数返回时，并没有释放资源的栈区。<br>闭包的作用：<br>　　<code>使用闭包可以访问函数中的变量</code>。<br>　　<code>可以使变量长期保存在内存中，生命周期比较长</code>。<br>闭包主要有两个应用场景：<br>　　闭包的应用比较典型是定义模块，我们将操作函数暴露给外部，而细节隐藏在模块内部<br>　　<code>函数作为参数传递</code>（见作用域部分例子）<br>　　<code>函数作为返回值</code>（如下例）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">outer</span></span>() &#123;</span><br><span class="line">  var num = 0 //内部变量</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">    //通过<span class="built_in">return</span>返回add函数，就可以在outer函数外访问了。</span><br><span class="line">    num++ //内部函数有引用，作为add函数的一部分了</span><br><span class="line">    console.log(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var func1 = outer() //</span><br><span class="line">func1() //实际上是调用add函数， 输出1</span><br><span class="line">func1() //输出2</span><br><span class="line">var func2 = outer()</span><br><span class="line">func2() // 输出1</span><br><span class="line">func2() // 输出2</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        var j = i;</span><br><span class="line">        setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(j);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i =0; i&lt;= 10; i++) &#123; </span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">timeId</span></span> () &#123; </span><br><span class="line">        var j = i; </span><br><span class="line">        setTimeout(<span class="function"><span class="title">function</span></span>() &#123; </span><br><span class="line">            console.log(<span class="string">'j:'</span>, j); </span><br><span class="line">        &#125;, 1000); </span><br><span class="line">    &#125; </span><br><span class="line">    timeId(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h3><p>先搞明白一个很重要的概念 —— <code>this的值是在执行的时候才能确认，定义的时候不能确认！</code> 为什么呢 —— 因为this是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 情况1</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  console.log(this.a) //1</span><br><span class="line">&#125;</span><br><span class="line">var a = 1</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 情况2</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>()&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var obj=&#123;fn:fn&#125;;</span><br><span class="line">obj.fn(); //this-&gt;obj</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 情况3</span><br><span class="line"><span class="keyword">function</span> CreateJsPerson(name,age)&#123;</span><br><span class="line">//this是当前类的一个实例p1</span><br><span class="line">this.name=name; //=&gt;p1.name=name</span><br><span class="line">this.age=age; //=&gt;p1.age=age</span><br><span class="line">&#125;</span><br><span class="line">var p1=new CreateJsPerson(<span class="string">"尹华芝"</span>,48);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 情况4</span><br><span class="line"><span class="keyword">function</span> add(c, d)&#123;</span><br><span class="line">  <span class="built_in">return</span> this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line">var o = &#123;a:1, b:3&#125;;</span><br><span class="line">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</span><br><span class="line">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 情况5</span><br><span class="line">&lt;button id=<span class="string">"btn1"</span>&gt;箭头函数this&lt;/button&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;   </span><br><span class="line">    <span class="built_in">let</span> btn1 = document.getElementById(<span class="string">'btn1'</span>);</span><br><span class="line">    <span class="built_in">let</span> obj = &#123;</span><br><span class="line">        name: <span class="string">'kobe'</span>,</span><br><span class="line">        age: 39,</span><br><span class="line">        getName: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            btn1.onclick = () =&gt; &#123;</span><br><span class="line">                console.log(this);//obj</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.getName();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>接下来我们逐一解释上面几种情况:<br>　　对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window<br>　　对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象<br>　　在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例<br>　　call、apply和bind：this 是第一个参数<br>　　箭头函数this指向:箭头函数没有自己的this，看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vuex</title>
      <link href="/2019/04/01/Vue/Vuex/"/>
      <url>/2019/04/01/Vue/Vuex/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>　　Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>　　每一个 Vuex 应用的核心就是<code>store</code>（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (<code>state</code>)。<code>Vuex</code> 和单纯的全局对象有以下两点不同：<br>　　1、<code>Vuex</code> 的状态存储是响应式的。当 <code>Vue</code> 组件从 <code>store</code> 中读取状态的时候，若 <code>store</code> 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>　　2、你不能直接改变 <code>store</code> 中的状态。改变 <code>store</code> 中的状态的唯一途径就是显式地提交 <code>(commit) mutation</code>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>下载: <code>&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;</code><br><code>&lt;script src=&quot;/path/to/vuex.js&quot;&gt;&lt;/script&gt;</code><br>CND: <code>https://unpkg.com/vuex</code><br>也可以通过 <code>https://unpkg.com/vuex@2.0.0</code> 这样的方式指定特定的版本。<br>npm: <code>npm install vuex --save</code><br>在一个模块化的打包系统中，您必须显式地通过 Vue.use() 来安装 Vuex：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import Vuex from <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure></p><p>当使用全局 script 标签引用 Vuex 时，不需要以上安装过程。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue生命周期和钩子函数</title>
      <link href="/2019/04/01/Vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
      <url>/2019/04/01/Vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p><img src="/assets/images/vue.png" alt="vue生命周期"></p><h3 id="Vue生命周期和钩子函数"><a href="#Vue生命周期和钩子函数" class="headerlink" title="Vue生命周期和钩子函数"></a>Vue生命周期和钩子函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate</span><br><span class="line">created</span><br><span class="line">beforeMount</span><br><span class="line">mounted</span><br><span class="line">beforeUpdate</span><br><span class="line">updated</span><br><span class="line">beforeDestroy</span><br><span class="line">destroyed</span><br></pre></td></tr></table></figure><p>创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。<br>　　载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。<br>　　更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。<br>　　销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在</p><h4 id="生命周期探究"><a href="#生命周期探究" class="headerlink" title="生命周期探究"></a>生命周期探究</h4><p>　　对于执行顺序和什么时候执行，看上面两个图基本有个了解了。下面我们将结合代码去看看钩子函数的执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;title&gt;<span class="built_in">test</span>&lt;/title&gt;</span><br><span class="line">  &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> </span><br><span class="line">    src=<span class="string">"https://cdn.jsdelivr.net/vue/2.1.3/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message : <span class="string">"xuxiao is boy"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeCreate: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.group(<span class="string">'beforeCreate 创建前状态===============》'</span>);</span><br><span class="line">    //undefined</span><br><span class="line">    console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">    //undefined </span><br><span class="line">    console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>);</span><br><span class="line">    console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message)</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.group(<span class="string">'created 创建完毕状态===============》'</span>);</span><br><span class="line">    //undefined</span><br><span class="line">    console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">    //已被初始化 </span><br><span class="line">    console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>);</span><br><span class="line">    //已被初始化</span><br><span class="line">    console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message);</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.group(<span class="string">'beforeMount 挂载前状态===============》'</span>);</span><br><span class="line">      //已被初始化</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + (this.<span class="variable">$el</span>));</span><br><span class="line">      console.log(this.<span class="variable">$el</span>);</span><br><span class="line">      //已被初始化  </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>);</span><br><span class="line">      //已被初始化  </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message);</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.group(<span class="string">'mounted 挂载结束状态===============》'</span>);</span><br><span class="line">      //已被初始化</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(this.<span class="variable">$el</span>);    </span><br><span class="line">      //已被初始化</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>);</span><br><span class="line">      //已被初始化 </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message);</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeUpdate: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.group(<span class="string">'beforeUpdate 更新前状态===============》'</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>); </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message); </span><br><span class="line">    &#125;,</span><br><span class="line">    updated: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.group(<span class="string">'updated 更新完成状态===============》'</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>); </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message); </span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.group(<span class="string">'beforeDestroy 销毁前状态===============》'</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>); </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message); </span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.group(<span class="string">'destroyed 销毁完成状态===============》'</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>); </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h5 id="beforeCreate-和-created-钩子函数"><a href="#beforeCreate-和-created-钩子函数" class="headerlink" title="beforeCreate 和 created 钩子函数"></a>beforeCreate 和 created 钩子函数</h5><p>　　在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定（放在data中的属性当值发生改变的同时，视图也会改变）。</p><h5 id="create-和-mounted-相关"><a href="#create-和-mounted-相关" class="headerlink" title="create 和 mounted 相关"></a>create 和 mounted 相关</h5><p>咱们在chrome浏览器里打开，F12看console就能发现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">beforecreated：el 和 data 并未初始化 </span><br><span class="line">created:完成了 data 数据的初始化，el没有</span><br><span class="line">beforeMount：完成了 el 和 data 初始化 </span><br><span class="line">mounted ：完成挂载</span><br><span class="line">另外在标红处，我们能发现el还是 &#123;&#123;message&#125;&#125;，</span><br><span class="line">这里就是应用的 Virtual DOM（虚拟Dom）技术，先把坑占住了。</span><br><span class="line">到后面mounted挂载的时候再把值渲染进去。</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/vue03.png" alt="vue生命周期"></p><h5 id="update-相关"><a href="#update-相关" class="headerlink" title="update 相关"></a>update 相关</h5><p>这里我们在 chrome console里执行以下命令<code>app.message= &#39;yes !! I do&#39;</code>;<br>下面就能看到data里的值被修改后，将会触发update的操作。<br><img src="/assets/images/vue02.png" alt="vue生命周期"></p><h5 id="destroy-相关"><a href="#destroy-相关" class="headerlink" title="destroy 相关"></a>destroy 相关</h5><p>有关于销毁，暂时还不是很清楚。我们在console里执行下命令对 vue实例进行销毁。销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。<br><code>app.$destroy()</code>;<br><img src="/assets/images/vue01.png" alt="vue生命周期"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforecreate : 举个栗子：可以在这加个loading事件 </span><br><span class="line">created ：在这结束loading，还做一些初始化，实现函数自执行 </span><br><span class="line">mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情</span><br><span class="line">beforeDestroy： 你确认删除XX吗？ destroyed ：当前组件已被删除，清空相关内容</span><br></pre></td></tr></table></figure><p>转载：<br>　　<a href="https://segmentfault.com/a/1190000008010666?utm_source=tag-newest" target="_blank" rel="noopener">Vue2.0 探索之路——生命周期和钩子函数的一些理解</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue知识点</title>
      <link href="/2019/04/01/Vue/Vue%E6%80%BB%E7%BB%93/"/>
      <url>/2019/04/01/Vue/Vue%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="Vue的优点是什么"><a href="#Vue的优点是什么" class="headerlink" title="Vue的优点是什么"></a>Vue的优点是什么</h3><p>　　低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。<br>　　可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。<br>　　独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。<br>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</p><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><p>beforeCreate<br>created<br>在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定（放在data中的属性当值发生改变的同时，视图也会改变）<br>beforeMount<br>mounted<br>beforeUpdate<br>updated<br>beforeDestroy钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。<br>destroyed钩子函数在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p><p>答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。<br>　　创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。<br>　　载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。<br>　　更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。<br>　　销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在</p><h3 id="路由之间跳转？"><a href="#路由之间跳转？" class="headerlink" title="路由之间跳转？"></a>路由之间跳转？</h3><p>声明式（标签跳转）<br>编程式（ js 跳转） router.push(‘index’)</p><h3 id="懒加载（按需加载路由）（常考）"><a href="#懒加载（按需加载路由）（常考）" class="headerlink" title="懒加载（按需加载路由）（常考）"></a>懒加载（按需加载路由）（常考）</h3><p>webpack 中提供了 require.ensure()来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。</p><p>不进行页面按需加载引入方式：<br><code>import  home   from &#39;../../common/home.vue&#39;</code><br>进行页面按需加载的引入方式：<br><code>const  home = r =&gt; require.ensure( [], () =&gt; r (require(&#39;../../common/home.vue&#39;)))</code></p><h3 id="vue-router-有哪几种导航钩子"><a href="#vue-router-有哪几种导航钩子" class="headerlink" title="vue-router 有哪几种导航钩子?"></a>vue-router 有哪几种导航钩子?</h3><p>三种<br>全局导航钩子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(to, from, next),</span><br><span class="line">router.beforeResolve(to, from, next),</span><br><span class="line">router.afterEach(to, from ,next)</span><br></pre></td></tr></table></figure></p><p>组件内钩子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter,</span><br><span class="line">beforeRouteUpdate,</span><br><span class="line">beforeRouteLeave</span><br></pre></td></tr></table></figure></p><p>单独路由独享组件<br>beforeEnte</p><h3 id="说出至少-4-种-vue-当中的指令和它的用法"><a href="#说出至少-4-种-vue-当中的指令和它的用法" class="headerlink" title="说出至少 4 种 vue 当中的指令和它的用法"></a>说出至少 4 种 vue 当中的指令和它的用法</h3><p>v-if(判断是否隐藏)、v-for(把数据遍历出来)、v-bind(绑定属性)、v-model(实现双向绑定)</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><h4 id="vuex-是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex-是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex 是什么？怎么使用？哪种功能场景使用它？"></a>vuex 是什么？怎么使用？哪种功能场景使用它？</h4><p>vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p><h4 id="vuex-有哪几种属性"><a href="#vuex-有哪几种属性" class="headerlink" title="vuex 有哪几种属性"></a>vuex 有哪几种属性</h4><p>有 5 种，分别是 state、getter、mutation、action、module</p><h4 id="vuex-的-store-特性是什么"><a href="#vuex-的-store-特性是什么" class="headerlink" title="vuex 的 store 特性是什么"></a>vuex 的 store 特性是什么</h4><p>vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data<br>state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新<br>它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</p><h4 id="vuex-的-getter-特性是什么"><a href="#vuex-的-getter-特性是什么" class="headerlink" title="vuex 的 getter 特性是什么"></a>vuex 的 getter 特性是什么</h4><p>getter 可以对 state 进行计算操作，它就是 store 的计算属性<br>虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用<br>如果一个状态只在一个组件内使用，是可以不用 getters</p><h4 id="vuex-的-mutation-特性是什么"><a href="#vuex-的-mutation-特性是什么" class="headerlink" title="vuex 的 mutation 特性是什么"></a>vuex 的 mutation 特性是什么</h4><p>action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态<br>action 可以包含任意异步操作</p><h4 id="vue-中-ajax-请求代码应该写在组件的-methods-中还是-vuex-的-action-中"><a href="#vue-中-ajax-请求代码应该写在组件的-methods-中还是-vuex-的-action-中" class="headerlink" title="vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中"></a>vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中</h4><p>如果请求来的数据不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 vuex 的 state 里<br>如果被其他地方复用，请将请求放入 action 里，方便复用，并包装成 promise 返回</p><h4 id="不用-vuex-会带来什么问题"><a href="#不用-vuex-会带来什么问题" class="headerlink" title="不用 vuex 会带来什么问题"></a>不用 vuex 会带来什么问题</h4><p>可维护性会下降，你要修改数据，你得维护 3 个地方<br>可读性下降，因为一个组件里的数据，你根本就看不出来是从哪里来的<br>增加耦合，大量的上传派发，会让耦合性大大的增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背</p><h4 id="vuex-原理"><a href="#vuex-原理" class="headerlink" title="vuex 原理"></a>vuex 原理</h4><h4 id="使用-Vuex-只需执行-Vue-use-Vuex-，并在-Vue-的配置中传入一个-store-对象的示例，store-是如何实现注入的？"><a href="#使用-Vuex-只需执行-Vue-use-Vuex-，并在-Vue-的配置中传入一个-store-对象的示例，store-是如何实现注入的？" class="headerlink" title="使用 Vuex 只需执行 Vue.use(Vuex)，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？"></a>使用 Vuex 只需执行 Vue.use(Vuex)，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？</h4><p>Vue.use(Vuex) 方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的store中。因此在VueComponent任意地方都能够通过this.store 访问到该 store</p><h4 id="state-内部支持模块配置和模块嵌套，如何实现的？"><a href="#state-内部支持模块配置和模块嵌套，如何实现的？" class="headerlink" title="state 内部支持模块配置和模块嵌套，如何实现的？"></a>state 内部支持模块配置和模块嵌套，如何实现的？</h4><p>在 store 构造方法中有 makeLocalContext 方法，所有 module 都会有一个 local context，根据配置时的 path 进行匹配。所以执行如 dispatch(‘submitOrder’, payload)这类 action 时，默认的拿到都是 module 的 local state，如果要访问最外层或者是其他 module 的 state，只能从 rootState 按照 path 路径逐步进行访问。</p><h4 id="在执行-dispatch-触发-action-commit-同理-的时候，只需传入-type-payload-，action-执行函数中第一个参数-store-从哪里获取的？"><a href="#在执行-dispatch-触发-action-commit-同理-的时候，只需传入-type-payload-，action-执行函数中第一个参数-store-从哪里获取的？" class="headerlink" title="在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？"></a>在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？</h4><p>store 初始化时，所有配置的 action 和 mutation 以及 getters 均被封装过。在执行如 dispatch(‘submitOrder’, payload)的时候，actions 中 type 为 submitOrder 的所有处理方法都是被封装后的，其第一个参数为当前的 store 对象，所以能够获取到 { dispatch, commit, state, rootState } 等数据。</p><h4 id="Vuex-如何区分-state-是外部直接修改，还是通过-mutation-方法修改的？"><a href="#Vuex-如何区分-state-是外部直接修改，还是通过-mutation-方法修改的？" class="headerlink" title="Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？"></a>Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？</h4><p>Vuex 中修改 state 的唯一渠道就是执行 commit(‘xx’, payload) 方法，其底层通过执行 this._withCommit(fn) 设置_committing 标志变量为 true，然后才能修改 state，修改完毕还需要还原_committing 变量。外部修改虽然能够直接修改 state，但是并没有修改_committing 标志位，所以只要 watch 一下 state，state change 时判断是否_committing 值为 true，即可判断修改的合法性。</p><p>#### </p><p>#### </p><h4 id="vue基础"><a href="#vue基础" class="headerlink" title="vue基础"></a>vue基础</h4><p>计算属性，方法与侦听器<br>计算属性的setter和getter<br>样式绑定，条件与列表渲染<br>Vue中的set方法<br>事件与表单绑定</p><h4 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h4><p>组件使用的细节点<br>父子组件传值与组件参数校验<br>原生事件绑定与非Props特性<br>使用bus进行非父子组件间传值<br>插槽的使用<br>动态组件</p><p>多组件状态管理与数据传递技巧<br>组件混入机制大幅精简组件代码<br>组件插槽提升组件复用度<br>动态组件提升组件灵活性<br>异步组件+组件缓存提升访问性能<br>组件API化简化组件调用过程</p><h4 id="vue动画"><a href="#vue动画" class="headerlink" title="vue动画"></a>vue动画</h4><p>Vue transition过渡<br>Vue transition-group过渡<br>Vue交互touch+mouse事件<br>CSS3过渡和帧动画<br>css 预处理</p><p> event、v-model、slot、keep-alive、transition、transition-group</p><h4 id="说一下Vue的双向绑定数据的原理"><a href="#说一下Vue的双向绑定数据的原理" class="headerlink" title="说一下Vue的双向绑定数据的原理"></a>说一下Vue的双向绑定数据的原理</h4><p>vue 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调</p><h4 id="解释单向数据流和双向数据绑定"><a href="#解释单向数据流和双向数据绑定" class="headerlink" title="解释单向数据流和双向数据绑定"></a>解释单向数据流和双向数据绑定</h4><p>单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 action 来维护对应的 state<br>双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 debug 的难度</p><h4 id="Vue-如何去除url中的"><a href="#Vue-如何去除url中的" class="headerlink" title="Vue 如何去除url中的"></a>Vue 如何去除url中的</h4><p>vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 url 会自带 #。如果不想使用 #， 可以使用 vue-router 的另一种模式 history<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: [ ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 404 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面</p><h4 id="介绍虚拟DOM"><a href="#介绍虚拟DOM" class="headerlink" title="介绍虚拟DOM"></a>介绍虚拟DOM</h4><p><a href="https://www.jianshu.com/p/616999666920" target="_blank" rel="noopener">https://www.jianshu.com/p/616999666920</a></p><h4 id="http-www-ruanyifeng-com-blog-2015-02-mvcmvp-mvvm-html"><a href="#http-www-ruanyifeng-com-blog-2015-02-mvcmvp-mvvm-html" class="headerlink" title="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html"></a><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a></h4><p>#### </p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>优化DOM</title>
      <link href="/2019/03/31/JavaScript/%E4%BC%98%E5%8C%96DOM/"/>
      <url>/2019/03/31/JavaScript/%E4%BC%98%E5%8C%96DOM/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DOM基本操作</title>
      <link href="/2019/03/31/JavaScript/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/03/31/JavaScript/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><ul><li>document<ul><li>getElementById<ul><li>语法： document.getElementById(元素ID)</li><li>功能： 通过元素ID获取节点</li></ul></li><li>getElementsByName<ul><li>语法： document.getElementsByName(元素name属性)</li><li>功能： 通过元素name属性获取节点</li></ul></li><li>getElementsByTagName<ul><li>语法： document.getElementsByTagName(元素标签)</li><li>功能： 通过元素标签获取节点</li></ul></li><li>getElementsByClassName<ul><li>语法： document.getElementsByClassName(“classname”)</li><li>功能： 根据class获取元素节点</li></ul></li></ul></li><li>CSS选择器<ul><li>querySelector()<ul><li>语法： document.querySelector()</li><li>功能： 根据CSS选择器的规则，返回第一个匹配到的元素</li></ul></li><li>querySelectorAll()<ul><li>语法： document.querySelectorAll()</li><li>功能： 根据CSS选择器的规则，返回所有匹配到的元素</li></ul></li></ul></li><li>节点指针<ul><li>firstChild<ul><li>语法： 父节点.firstChild</li><li>功能： 获取元素首个节点</li></ul></li><li>lastChild<ul><li>语法： 父节点.lastChild</li><li>功能： 获取元素最后一个节点</li></ul></li><li>childNodes<ul><li>语法： 父节点.childNodes</li><li>功能： 获取元素子节点列表</li></ul></li><li>previousSibling<ul><li>语法： 兄弟节点.previousSibling</li><li>功能： 获取已知节点前一个节点</li></ul></li><li>nextSibling<ul><li>语法： 兄弟节点.nextSibling</li><li>功能： 获取已知节点后一个节点</li></ul></li><li>parentNode<ul><li>语法： 子节点.parentNode</li><li>功能： 获取已知节点的父节点</li></ul></li></ul></li></ul><h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><ul><li>创建节点<ul><li>createElement<ul><li>语法： document.createElement(元素标签)</li><li>功能： 创造元素节点</li></ul></li><li>createAttribute<ul><li>语法： document.createAttribute(元素属性)</li><li>功能： 创建属性节点</li></ul></li><li>createTextNode<ul><li>语法： document.createTextNode(文本内容)</li><li>功能： 创建文本节点</li></ul></li></ul></li><li>插入节点<ul><li>appendChild<ul><li>语法： appendChild(所添加的新节点)</li><li>功能： 向节点的子节点列表的末尾添加新的子节点</li></ul></li><li>insertBefore<ul><li>语法： insertBefore(所要添加的新节点, 已知子节点)</li><li>功能： 向已知的子节点前插入一个新的子节点</li></ul></li></ul></li><li>替换节点<ul><li>replaceChild<ul><li>语法： replaceChild(要插入的新元素， 将被替换的老元素)</li><li>功能： 将子节点替换成另一个</li></ul></li></ul></li><li>复制节点<ul><li>cloneNode<ul><li>语法： 需要被复制的节点.cloneNode(true/false)</li><li>功能： 创建指定节点的副本</li><li>参数： <ul><li>true 复制当前节点以及其他所有子节点</li><li>false 仅复制当前节点</li></ul></li></ul></li></ul></li><li>删除节点<ul><li>removeChild<ul><li>语法： removeChild(要删除的节点)</li><li>功能： 删除指定的节点</li></ul></li></ul></li></ul><h4 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h4><ul><li>获取属性<ul><li>getAttribute<ul><li>语法： 元素节点.getAttribute(元素属性名)</li><li>功能： 获取元素节点中指定属性的属性值</li></ul></li></ul></li><li>设置属性<ul><li>setAttribute<ul><li>语法： 元素节点.setAttribute(属性名， 属性值)</li><li>功能： 创建或者改变元素的属性</li></ul></li></ul></li><li>删除属性<ul><li>removeAttribute<ul><li>语法： 元素节点.removeAttribute(属性名)</li><li>功能： 删除元素中的指定属性</li></ul></li></ul></li></ul><h4 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h4><ul><li>文本操作<ul><li>insterData(offset, string)<ul><li>从offset指定的位置插入string</li></ul></li><li>appendData(string)<ul><li>将string插入到文本节点的末尾处</li></ul></li><li>deleteData(offset, count)<ul><li>从offset起删除count个字符</li></ul></li><li>replaceData(off, count, string)<ul><li>从off将count个字符用string</li></ul></li><li>splitData(offset)<ul><li>从offset起将文本节点分成两个节点</li></ul></li><li>substring(offset, count)<ul><li>返回由offset起的count个节点</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue中使用Axios</title>
      <link href="/2019/03/30/Ajax/Axios/"/>
      <url>/2019/03/30/Ajax/Axios/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://www.jianshu.com/p/df464b26ae58" target="_blank" rel="noopener">axios</a><br>参考：<br>　　<a href="https://github.com/axios/axios/blob/master/README.md" target="_blank" rel="noopener">axio github</a><br>　　<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">Axios中文</a></p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>安装: <code>npm install axios --save</code><br>设置全局都可以使用axios<br>设置在 main.js 中引入 axios:<br>　　<code>import axios from &#39;axios&#39;</code><br>axios 改写为 Vue 的原型属性（不推荐这样用）<br>　　<code>Vue.prototype.$http= axios</code><br>在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $http命令<br>例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">    this.<span class="variable">$http</span>(&#123;</span><br><span class="line">      method: <span class="string">'get'</span>,</span><br><span class="line">      url: <span class="string">'/user'</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        name: <span class="string">'virus'</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><h5 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过给定的ID来发送请求</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(response)&#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="keyword">function</span>(err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment"># 以上请求也可以通过这种方式来发送</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>,&#123;</span><br><span class="line">  params:&#123;</span><br><span class="line">    ID:12345</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="keyword">function</span>(response)&#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="keyword">function</span>(err)&#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>,&#123;</span><br><span class="line">  firstName:<span class="string">'Fred'</span>,</span><br><span class="line">  lastName:<span class="string">'Flintstone'</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="keyword">function</span>(res)&#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="keyword">function</span>(err)&#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="一次性并发多个请求"><a href="#一次性并发多个请求" class="headerlink" title="一次性并发多个请求"></a>一次性并发多个请求</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getUserAccount</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getUserPermissions</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line">axios.all([getUserAccount(),getUserPermissions()])</span><br><span class="line">  .<span class="keyword">then</span>(axios.spread(<span class="keyword">function</span>(acct,perms)&#123;</span><br><span class="line">    <span class="comment"># 当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果</span></span><br><span class="line">  &#125;))</span><br></pre></td></tr></table></figure><h4 id="axios的API"><a href="#axios的API" class="headerlink" title="axios的API"></a>axios的API</h4><h5 id="axios可以通过配置（config）来发送请求"><a href="#axios可以通过配置（config）来发送请求" class="headerlink" title="axios可以通过配置（config）来发送请求"></a>axios可以通过配置（config）来发送请求</h5><h6 id="axios-config"><a href="#axios-config" class="headerlink" title="axios(config)"></a>axios(config)</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送一个`POST`请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">    method:<span class="string">"POST"</span>,</span><br><span class="line">    url:<span class="string">'/user/12345'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        firstName:<span class="string">"Fred"</span>,</span><br><span class="line">        lastName:<span class="string">"Flintstone"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="axios-url-config"><a href="#axios-url-config" class="headerlink" title="axios(url[,config])"></a>axios(url[,config])</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送一个`GET`请求（默认的请求方式）</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>);</span><br></pre></td></tr></table></figure><h5 id="请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名"><a href="#请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名" class="headerlink" title="请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名"></a>请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.request(config);</span><br><span class="line">axios.get(url[,config]);</span><br><span class="line">axios.delete(url[,config]);</span><br><span class="line">axios.head(url[,config]);</span><br><span class="line">axios.post(url[,data[,config]]);</span><br><span class="line">axios.put(url[,data[,config]])</span><br><span class="line">axios.patch(url[,data[,config]])</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明</p><h5 id="并发请求（concurrency）-即是帮助处理并发请求的辅助函数"><a href="#并发请求（concurrency）-即是帮助处理并发请求的辅助函数" class="headerlink" title="并发请求（concurrency）,即是帮助处理并发请求的辅助函数"></a>并发请求（concurrency）,即是帮助处理并发请求的辅助函数</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iterable是一个可以迭代的参数如数组等</span></span><br><span class="line">axios.all(iterable)</span><br><span class="line"><span class="comment"># callback要等到所有请求都完成才会执行</span></span><br><span class="line">axios.spread(callback)</span><br></pre></td></tr></table></figure><h5 id="创建一个axios实例，并且可以自定义其配置"><a href="#创建一个axios实例，并且可以自定义其配置" class="headerlink" title="创建一个axios实例，并且可以自定义其配置"></a>创建一个axios实例，并且可以自定义其配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># axios.create([config])</span></span><br><span class="line">var instance = axios.create(&#123;</span><br><span class="line">  baseURL:<span class="string">"https://some-domain.com/api/"</span>,</span><br><span class="line">  timeout:1000,</span><br><span class="line">  headers: &#123;<span class="string">'X-Custom-Header'</span>:<span class="string">'foobar'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例的方法</span></span><br><span class="line"><span class="comment"># 一下是实例方法，注意已经定义的配置将和利用create创建的实例的配置合并</span></span><br><span class="line">axios<span class="comment">#request(config)</span></span><br><span class="line">axios<span class="comment">#get(url[,config])</span></span><br><span class="line">axios<span class="comment">#delete(url[,config])</span></span><br><span class="line">axios<span class="comment">#head(url[,config])</span></span><br><span class="line">axios<span class="comment">#post(url[,data[,config]])</span></span><br><span class="line">axios<span class="comment">#put(url[,data[,config]])</span></span><br><span class="line">axios<span class="comment">#patch(url[,data[,config]])</span></span><br></pre></td></tr></table></figure><h4 id="请求的配置（request-config）"><a href="#请求的配置（request-config）" class="headerlink" title="请求的配置（request config）"></a>请求的配置（request config）</h4><p>　　以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment"># `url`是请求的服务器地址</span></span><br><span class="line">  url:<span class="string">'/user'</span>,</span><br><span class="line">  <span class="comment"># `method`是请求资源的方式</span></span><br><span class="line">  method:<span class="string">'get'</span><span class="comment"># default</span></span><br><span class="line">  <span class="comment"># 如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面</span></span><br><span class="line">  <span class="comment"># 当`url`是相对地址的时候，设置`baseURL`会非常的方便</span></span><br><span class="line">  baseURL:<span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line">  <span class="comment"># `transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动</span></span><br><span class="line">  <span class="comment"># 该选项只适用于以下请求方式：`put/post/patch`</span></span><br><span class="line">  <span class="comment"># 数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream`</span></span><br><span class="line">  transformRequest:[<span class="keyword">function</span>(data)&#123;</span><br><span class="line">    <span class="comment"># 在这里根据自己的需求改变数据</span></span><br><span class="line">    <span class="built_in">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="comment"># `transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动</span></span><br><span class="line">  transformResponse:[<span class="keyword">function</span>(data)&#123;</span><br><span class="line">    <span class="comment"># 在这里根据自己的需求改变数据</span></span><br><span class="line">    <span class="built_in">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="comment"># `headers`选项是需要被发送的自定义请求头信息</span></span><br><span class="line">  headers: &#123;<span class="string">'X-Requested-With'</span>:<span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line">  <span class="comment"># `params`选项是要随请求一起发送的请求参数----一般链接在URL后面</span></span><br><span class="line">  <span class="comment"># 他的类型必须是一个纯对象或者是URLSearchParams对象</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID:12345</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化</span></span><br><span class="line">  <span class="comment"># 例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param)</span></span><br><span class="line">  paramsSerializer: <span class="keyword">function</span>(params)&#123;</span><br><span class="line">    <span class="built_in">return</span> Qs.stringify(params,&#123;arrayFormat:<span class="string">'brackets'</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `data`选项是作为一个请求体而需要被发送的数据</span></span><br><span class="line">  <span class="comment"># 该选项只适用于方法：`put/post/patch`</span></span><br><span class="line">  <span class="comment"># 当没有设置`transformRequest`选项时dada必须是以下几种类型之一</span></span><br><span class="line">  <span class="comment"># string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams</span></span><br><span class="line">  <span class="comment"># 仅仅浏览器：FormData/File/Bold</span></span><br><span class="line">  <span class="comment"># 仅node:Stream</span></span><br><span class="line">  data &#123;</span><br><span class="line">    firstName:<span class="string">"Fred"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `timeout`选项定义了请求发出的延迟毫秒数</span></span><br><span class="line">  <span class="comment"># 如果请求花费的时间超过延迟的时间，那么请求会被终止</span></span><br><span class="line"></span><br><span class="line">  timeout:1000,</span><br><span class="line">  <span class="comment"># `withCredentails`选项表明了是否是跨域请求</span></span><br><span class="line">  </span><br><span class="line">  withCredentials:<span class="literal">false</span>,<span class="comment"># default</span></span><br><span class="line">  <span class="comment"># `adapter`适配器选项允许自定义处理请求，这会使得测试变得方便</span></span><br><span class="line">  <span class="comment"># 返回一个promise,并提供验证返回</span></span><br><span class="line">  adapter: <span class="keyword">function</span>(config)&#123;</span><br><span class="line">    /*..........*/</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `auth`表明HTTP基础的认证应该被使用，并提供证书</span></span><br><span class="line">  <span class="comment"># 这会设置一个authorization头（header）,并覆盖你在header</span></span><br><span class="line">  <span class="comment"># 设置的Authorization头信息</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username:<span class="string">"zhangsan"</span>,</span><br><span class="line">    password: <span class="string">"s00sdkf"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># 返回数据的格式</span></span><br><span class="line">  <span class="comment"># 其可选项是arraybuffer,blob,document,json,text,stream</span></span><br><span class="line">  responseType:<span class="string">'json'</span>,<span class="comment"># default</span></span><br><span class="line">  <span class="comment"># </span></span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>,<span class="comment"># default</span></span><br><span class="line">  xsrfHeaderName:<span class="string">'X-XSRF-TOKEN'</span>,<span class="comment"># default</span></span><br><span class="line">  <span class="comment"># `onUploadProgress`上传进度事件</span></span><br><span class="line">  onUploadProgress:<span class="keyword">function</span>(progressEvent)&#123;</span><br><span class="line">    <span class="comment"># 下载进度的事件</span></span><br><span class="line">onDownloadProgress:<span class="keyword">function</span>(progressEvent)&#123;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># 相应内容的最大值</span></span><br><span class="line">  maxContentLength:2000,</span><br><span class="line">  <span class="comment"># `validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise</span></span><br><span class="line">  <span class="comment"># 如果`validateStatus`返回true(或者设置为`null`或者`undefined`),</span></span><br><span class="line">  <span class="comment"># 那么promise的状态将会是resolved,否则其状态就是rejected</span></span><br><span class="line">  validateStatus:<span class="keyword">function</span>(status)&#123;</span><br><span class="line">    <span class="built_in">return</span> status &gt;= 200 &amp;&amp; status &lt;300;<span class="comment"># default</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `maxRedirects`定义了在nodejs中重定向的最大数量</span></span><br><span class="line">  maxRedirects: 5,<span class="comment"># default</span></span><br><span class="line">  <span class="comment"># `httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理</span></span><br><span class="line">  <span class="comment"># keeyAlive在选项中没有被默认激活</span></span><br><span class="line">  httpAgent: new http.Agent(&#123;keeyAlive:<span class="literal">true</span>&#125;),</span><br><span class="line">  httpsAgent: new https.Agent(&#123;keeyAlive:<span class="literal">true</span>&#125;),</span><br><span class="line">  <span class="comment"># proxy定义了主机名字和端口号，</span></span><br><span class="line">  <span class="comment"># `auth`表明http基本认证应该与proxy代理链接，并提供证书</span></span><br><span class="line">  <span class="comment"># 这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的</span></span><br><span class="line">  <span class="comment"># Proxy-Authorization  header</span></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host:<span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: 9000,</span><br><span class="line">    auth: &#123;</span><br><span class="line">      username:<span class="string">'skda'</span>,</span><br><span class="line">      password:<span class="string">'radsd'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `cancelToken`定义了一个用于取消请求的cancel token</span></span><br><span class="line">  <span class="comment"># 详见cancelation部分</span></span><br><span class="line">  cancelToken: new cancelToken(<span class="keyword">function</span>(cancel)&#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="请求返回的内容"><a href="#请求返回的内容" class="headerlink" title="请求返回的内容"></a>请求返回的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  data:&#123;&#125;,</span><br><span class="line">  status:200,</span><br><span class="line">  <span class="comment"># 从服务器返回的http状态文本</span></span><br><span class="line">  statusText:<span class="string">'OK'</span>,</span><br><span class="line">  <span class="comment"># 响应头信息</span></span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line">  <span class="comment"># `config`是在请求的时候的一些配置信息</span></span><br><span class="line">  config: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你可以这样来获取响应信息</span></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(res)&#123;</span><br><span class="line">    console.log(res.data);</span><br><span class="line">    console.log(res.status);</span><br><span class="line">    console.log(res.statusText);</span><br><span class="line">    console.log(res.headers);</span><br><span class="line">    console.log(res.config);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><p>你可以设置默认配置，对所有请求都有效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、 全局默认配置</span><br><span class="line">axios.defaults.baseURL = <span class="string">'http://api.exmple.com'</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'content-Type'</span>] = <span class="string">'appliction/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure></p><p>2、 自定义的实例默认设置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当创建实例的时候配置默认配置</span></span><br><span class="line">var instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'https://api.example.com'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当实例创建时候修改配置</span></span><br><span class="line">instance.defaults.headers.common[<span class="string">"Authorization"</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure></p><p>3、 配置中的有优先级<br>　　config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个实例的时候会使用libray目录中的默认配置</span></span><br><span class="line"><span class="comment"># 在这里timeout配置的值为0，来自于libray的默认值</span></span><br><span class="line">var instance = axios.create();</span><br><span class="line"><span class="comment"># 回覆盖掉library的默认值</span></span><br><span class="line"><span class="comment"># 现在所有的请求都要等2.5S之后才会发出</span></span><br><span class="line">instance.defaults.timeout = 2500;</span><br><span class="line"><span class="comment"># 这里的timeout回覆盖之前的2.5S变成5s</span></span><br><span class="line">instance.get(<span class="string">'/longRequest'</span>,&#123;</span><br><span class="line">  timeout: 5000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>你可以在请求、响应在到达then/catch之前拦截他们<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加一个请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="keyword">function</span>(config)&#123;</span><br><span class="line">  <span class="comment"># 在请求发出之前进行一些操作</span></span><br><span class="line">  <span class="built_in">return</span> config;</span><br><span class="line">&#125;,<span class="keyword">function</span>(err)&#123;</span><br><span class="line">  <span class="comment"># Do something with request error</span></span><br><span class="line">  <span class="built_in">return</span> Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment"># 添加一个响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="keyword">function</span>(res)&#123;</span><br><span class="line">  <span class="comment"># 在这里对返回的数据进行处理</span></span><br><span class="line">  <span class="built_in">return</span> res;</span><br><span class="line">&#125;,<span class="keyword">function</span>(err)&#123;</span><br><span class="line">  <span class="comment"># Do something with response error</span></span><br><span class="line">  <span class="built_in">return</span> Promise.reject(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>2、取消拦截器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myInterceptor = axios.interceptor.request.use(<span class="function"><span class="title">function</span></span>()&#123;/*....*/&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure></p><p>3、 给自定义的axios实例添加拦截器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="title">function</span></span>()&#123;&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .catch(<span class="keyword">function</span>(error)&#123;</span><br><span class="line">    <span class="keyword">if</span>(error.response)&#123;</span><br><span class="line">      <span class="comment"># 请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内</span></span><br><span class="line">      console.log(error.response.data);</span><br><span class="line">      console.log(error.response.status);</span><br><span class="line">      console.log(error.response.header);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment"># 一些错误是在设置请求的时候触发</span></span><br><span class="line">      console.log(<span class="string">'Error'</span>,error.message);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(error.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h4><p>1、你可以通过一个cancel token来取消一个请求<br>你可以通过CancelToken.source工厂函数来创建一个cancel token<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var CancelToken = axios.CancelToken;</span><br><span class="line">var <span class="built_in">source</span> = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>,&#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(thrown)&#123;</span><br><span class="line">  <span class="keyword">if</span>(axios.isCancel(thrown))&#123;</span><br><span class="line">    console.log(<span class="string">'Request canceled'</span>,thrown.message);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment"># handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消请求（信息的参数可以设置的）</span></span><br><span class="line">source.cance(<span class="string">"操作被用户取消"</span>);</span><br></pre></td></tr></table></figure></p><p>2、你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var cancelToken = axios.CancelToken;</span><br><span class="line">var cance;</span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>,&#123;</span><br><span class="line">  cancelToken: new CancelToken(<span class="keyword">function</span>(c)&#123;</span><br><span class="line">    <span class="comment"># 这个executor函数接受一个cancel function作为参数</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment"># 取消请求</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure></p><h4 id="创建axios实例"><a href="#创建axios实例" class="headerlink" title="创建axios实例"></a>创建axios实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># helpers.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"># 定义常量ERR_OK</span><br><span class="line"><span class="keyword">const</span> ERR_OK = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 导出一个getDate方法</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getDate(url) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(url, &#123;</span><br><span class="line">      params</span><br><span class="line">      # 成功之后的.then方法</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      # 通过结构赋值的方法难道error和data的数值</span><br><span class="line">      <span class="keyword">const</span> &#123; error, data&#125; = res.data</span><br><span class="line">      # 如果成功的话，返回data数据</span><br><span class="line">      <span class="keyword">if</span>(error === ERR_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">      &#125;</span><br><span class="line">      # 如果失败的话打印失败的原因</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) =&gt; </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"error:"</span>, error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 出口文件</span><br><span class="line"># index.js</span><br><span class="line"><span class="keyword">import</span> &#123; getDate &#125; <span class="keyword">from</span> <span class="string">'./helpers'</span></span><br><span class="line"></span><br><span class="line"># 定义getSeller方法</span><br><span class="line"><span class="keyword">const</span> getSeller = getDate(<span class="string">'./api/seller'</span>)</span><br><span class="line"></span><br><span class="line"># 导出getSeller方法</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  getSeller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AJAX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AJAX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器渲染流程</title>
      <link href="/2019/03/30/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/03/30/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://blog.csdn.net/xiaozhuxmen/article/details/52014901" target="_blank" rel="noopener">浏览器加载、解析、渲染的过程</a><br>　　<a href="https://juejin.im/post/5a8e242c5188257a6b060000" target="_blank" rel="noopener">【干货】十分钟读懂浏览器渲染流程</a></p><h4 id="为什么要了解浏览器加载、解析、渲染这个过程"><a href="#为什么要了解浏览器加载、解析、渲染这个过程" class="headerlink" title="为什么要了解浏览器加载、解析、渲染这个过程"></a>为什么要了解浏览器加载、解析、渲染这个过程</h4><p>　　了解浏览器如何进行加载，可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。<br>　　了解浏览器如何进行解析，可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。<br>　　了解浏览器如何进行渲染，明白渲染的过程，在设置元素属性，编写js文件时，可以减少”reflow“”repaint“的消耗。</p><h4 id="浏览器的主要功能"><a href="#浏览器的主要功能" class="headerlink" title="浏览器的主要功能"></a>浏览器的主要功能</h4><p>　　浏览器的主要功能是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式。用户用URI（Uniform Resource Identifier统一资源标识符）来指定所请求资源的位置，通过DNS查询，将网址转换为IP地址。整个浏览器工作的流程为：<br>　　1、 输入网址。<br>　　2、 浏览器查找域名的IP地址。<br>　　3、 浏览器给web服务器发送一个HTTP请求<br>　　4、 网站服务的永久重定向响应<br>　　5、 浏览器跟踪重定向地址。现在，浏览器知道了要访问的正确地址，所以它会发送另一个获取请求。<br>　　6、 服务器“处理”请求，服务器接收到获取请求，然后处理并返回一个响应。<br>　　7、 服务器发回一个HTML响应<br>　　8、 浏览器开始显示HTML<br>　　9、 浏览器发送请求，以获取嵌入在HTML中的对象。在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。这些文件就包括CSS/JS/图片等资源，这些资源的地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…</p><p>　　那么，一个页面，究竟是如何从我们输入一个网址到最后完整的呈现在我们面前的呢？还需要了解一下浏览器是如何渲染的：</p><h4 id="浏览器的渲染"><a href="#浏览器的渲染" class="headerlink" title="浏览器的渲染"></a>浏览器的渲染</h4><p>渲染引擎在取得内容之后的基本流程：<br><code>解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</code><br>所以，浏览器会解析三个东西：<br>（1） HTML/SVG/XHTML，解析这三种文件会产生一个 DOM Tree。<br>（2） CSS，解析 CSS 会产生 CSS 规则树。<br>（3） Javascript脚本，主要是通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree.</p><h5 id="关键渲染路径"><a href="#关键渲染路径" class="headerlink" title="关键渲染路径"></a>关键渲染路径</h5><p>　　关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。</p><p>当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。<br>解析：<br>　　1、 <code>DOM Tree</code>: 浏览器会将HTML解析成一个DOM树。DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。<br>　　2、 <code>CSS Rule Tree</code>: 将CSS解析成 CSS Rule Tree 。<br>　　3、 <code>Render Tree</code>: 根据DOM树和CSSOM来构造 Rendering Tree。<br>　　注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header<br>　　或 display:none 的东西就没必要放在渲染树中了。<br>　　4、 <code>layout</code>: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。 （<code>遍历渲染树开始布局，计算每个节点的位置大小信息</code>）<br>　　5、 <code>painting</code>: 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。<br>　　(<code>将渲染树每个节点绘制到屏幕</code>。)</p><h6 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h6><p>　　当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。<br>需要注意的是，DOM树的生成过程中可能会被CSS和JS的加载执行阻塞。渲染阻塞问题下文会讲。</p><h6 id="构建CSSOM规则树"><a href="#构建CSSOM规则树" class="headerlink" title="构建CSSOM规则树"></a>构建CSSOM规则树</h6><p>　　浏览器解析CSS文件并生成CSS规则树，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。</p><h6 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h6><p>　　当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建DOM。每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。<br>　　所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：<br><code>CSS 优先</code>：引入顺序上，CSS 资源先于 JavaScript资源。<br><code>JS置后</code>：我们通常把JS代码放到<code>页面底部</code>，且JavaScript 应尽量少影响 DOM 的构建。当解析html的时候，会把新来的元素插入dom树里面，同时去查找css，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。例如： div p {font-size: 16px}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染）。所以，我们平时写CSS时，尽量用id和class，千万不要过渡层叠。</p><h6 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h6><p>　　通过DOM树和CSS规则树我们便可以构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的CSS样式规则并应用。渲染树构建完成后，每个节点都是可见节点并且都含有其内容和对应规则的样式。这也是渲染树与DOM树的最大区别所在。渲染树是用于显示，那些不可见的元素当然就不会在这棵树中出现了，譬如。除此之外，display等于none的也不会被显示在这棵树里头，但是visibility等于hidden的元素是会显示在这棵树里头的。</p><h6 id="渲染树布局"><a href="#渲染树布局" class="headerlink" title="渲染树布局"></a>渲染树布局</h6><p>　　布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。</p><h6 id="渲染树绘制"><a href="#渲染树绘制" class="headerlink" title="渲染树绘制"></a>渲染树绘制</h6><p>　　在绘制阶段，遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。</p><h5 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h5><p>　　上述这个过程是<code>逐步完成</code>的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。<br><strong>几个概念： </strong><br>　　（1）Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。<br>　　（2）Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。<br>Reflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。</p><h6 id="reflow"><a href="#reflow" class="headerlink" title="reflow"></a>reflow</h6><p>　　（1）页面初始化的时候；<br>　　（2）操作DOM时；<br>　　（3）某些元素的尺寸变了；<br>　　（4）如果 CSS 的属性发生变化了。</p><h6 id="减少reflow-repaint"><a href="#减少reflow-repaint" class="headerlink" title="减少reflow/repaint"></a>减少reflow/repaint</h6><p>　　（1）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。<br>　　（2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。<br>　　（3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。<br>　　（4）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p>注意：<br>　　　(1)<code>display:none</code> 的节点不会被加入<code>Render Tree</code>，而<code>visibility: hidden</code> 则会，所以，如果某个节点最开始是不显示的，设为<code>display:none</code>是更优的。<br>　　　(2)<code>display:none</code> 会触发 <code>reflow</code>，而 <code>visibility:hidden</code> 只会触发 <code>repaint</code>，因为没有发现位置变化。<br>　　　(3)有些情况下，比如修改了元素的样式，浏览器并不会立刻<code>reflow</code> 或 <code>repaint</code> 一次，而是会把这样的操作积攒一批，然后做一次 <code>reflow</code>，这又叫异步<code>reflow</code> 或增量异步 <code>reflow</code>。但是在有些情况下，比如<code>resize</code> 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 <code>reflow</code>。</p><h6 id="HTML页面加载和解析流程"><a href="#HTML页面加载和解析流程" class="headerlink" title="HTML页面加载和解析流程"></a>HTML页面加载和解析流程</h6><ol><li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件； </li><li>浏览器开始载入<code>html</code>代码，发现<code>＜head＞</code>标签内有一个<code>＜link＞</code>标签引用外部<code>CSS</code>文件； </li><li>浏览器又发出<code>CSS</code>文件的请求，服务器返回这个<code>CSS</code>文件； </li><li>浏览器继续载入<code>html</code>中<code>＜body＞</code>部分的代码，并且<code>CSS</code>文件已经拿到手了，可以开始渲染页面了； </li><li>浏览器在代码中发现一个<code>＜img＞</code>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； </li><li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； </li><li>浏览器发现了一个包含一行<code>Javascript</code>代码的<code>＜script＞</code>标签，赶快运行它； </li><li><code>Javascript</code>脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （<code>style.display=”none”</code>）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码； </li><li>终于等到了<code>＜/html＞</code>的到来，浏览器泪流满面…… </li><li>等等，还没完，用户点了一下界面中的“换肤”按钮，<code>Javascript</code>让浏览器换了一下<code>＜link＞</code>标签的CSS路径； </li><li>浏览器召集了在座的各位<code>＜div＞＜span＞＜ul＞＜li＞</code>们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</li></ol><h6 id="编写CSS时应该注意"><a href="#编写CSS时应该注意" class="headerlink" title="编写CSS时应该注意"></a>编写CSS时应该注意</h6><p>　　CSS选择符是从右到左进行匹配的。从右到左！所以，#nav li 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的li，然后再去确定它的父元素是不是#nav。，因此，写css的时候需要注意：<br>　　1、dom深度尽量浅。<br>　　2、减少<code>inline javascript、css</code>的数量。<br>　　3、使用现代合法的css属性。<br>　　4、不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。<br>　　5、避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;<code>#tp p{}</code>子选择符：<code>#tp&gt;p{}`</code><br>　　6、避免使用通配符，举一个例子，<code>.mod .hd *{font-size:14px;}</code>根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配<code>.hd</code>（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知.</p><h6 id="关于Script标签位置"><a href="#关于Script标签位置" class="headerlink" title="关于Script标签位置"></a>关于Script标签位置</h6><p><strong>Javascript的加载和执行的特点： </strong><br>　　（1）载入后马上执行；<br>　　（2）执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）。原因：因为浏览器需要一个稳定的DOM树结构，而JS中很有可能有 代码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修 改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现。</p><h6 id="减少JavaScript对性能的影响"><a href="#减少JavaScript对性能的影响" class="headerlink" title="减少JavaScript对性能的影响"></a>减少JavaScript对性能的影响</h6><p>　　（1）将所有的script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染。<br>　　（2）尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。<br>　　（3）采用无阻塞下载 JavaScript 脚本的方法：<br>　　　　（1）使用script标签的 defer 属性（仅适用于 IE 和 Firefox 3.5 以上版本）；<br>　　　　（2）使用动态创建的script元素来下载并执行代码；</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器渲染流程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DOM结构</title>
      <link href="/2019/03/30/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/DOM%E7%BB%93%E6%9E%84/"/>
      <url>/2019/03/30/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/DOM%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>DOM是个缩写，全称是<code>Document Object Model</code>。<br>D表示Document，就是DOM将HTML页面解析为一个文档，同时提供了document对象。<br>O表示Object，就是DOM将HTML页面中每一个元素解析为一个对象。<br>M表示Model，就是DOM中表示各个对象之间的关系。<a id="more"></a></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于解析HTML页面文档，方便JavaScript语言通过DOM访问和操作HTML页面中的内容。</p><h4 id="DOM结构"><a href="#DOM结构" class="headerlink" title="DOM结构"></a>DOM结构</h4><h5 id="DOM树结构"><a href="#DOM树结构" class="headerlink" title="DOM树结构"></a>DOM树结构</h5><p>DOM可以访问和更新HTML中的内容、结构和样式，是因为DOM将HTML解析为一个树状结构。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">'en'</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">      &lt;meta charset=<span class="string">'UTF-8'</span>&gt;</span><br><span class="line">      &lt;title&gt;示例页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">       &lt;h2&gt;这是一个示例页面&lt;/h2&gt;</span><br><span class="line">       &lt;p id=<span class="string">"p"</span> title=<span class="string">"this is p."</span>&gt;这是一个段落内容。&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>将上面的 HTML 页面绘制成 DOM 树结构，如下效果:<br><img src="/assets/images/dom2.png" alt="DOM"><br>　　通过上面的 DOM 树结构，我们可以看到，Document 对象是作为 DOM树结构的入口。再根据 DOM 树结构的特点，我们就可以定位到 HTML 页面中任意一个元素、属性或文本内容。</p><p>　　浏览器加载并运行 HTML 页面时，会创建 DOM 树结构这个模型。并且 DOM 树结构模型会被存储在浏览器的内存中。<br><code>当 HTML 页面内容过于庞大和复杂时，生成的 DOM 树结构就越复杂。进而，浏览器加载 HTML 页面的耗时就越长。</code><br><img src="/assets/images/dom.png" alt="DOM"></p><h5 id="DOM树中的节点"><a href="#DOM树中的节点" class="headerlink" title="DOM树中的节点"></a>DOM树中的节点</h5><p>在 DOM 树结构中，主要由以下 4 种节点组成:</p><table><thead><tr><th>节点名称</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>文档节点</td><td>表示整个HTML页面(相当于document对象)</td><td>当需要访问任何标签、属性或文本时，都可以通过文档节点进行导航</td></tr><tr><td>元素节点</td><td>表示HTML页面中的标签(即HTML页面结构)</td><td>访问DOM树时，需要从查找元素节点开始</td></tr><tr><td>属性节点</td><td>表示HTML页面中的开始标签包含的属性</td><td></td></tr><tr><td>文本节点</td><td>表示整个HTML页面中的标签所包含的文本内容</td></tr></tbody></table><p>节点（Node）作为DOM树结构中的连接点，最终构成了完整的DOM树结构<br><img src="/assets/images/dom1.png" alt="DOM"></p><h5 id="节点树结构"><a href="#节点树结构" class="headerlink" title="节点树结构"></a>节点树结构</h5><p>通过节点概念，我们可以将原本的 DOM 树结构改成 DOM 节点树结构进行表示。<br><img src="/assets/images/dom3.jpg" alt="DOM"></p><h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><p>1、获取节点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、标准DOM API</span></span><br><span class="line">document.getElementById</span><br><span class="line">document.getElementsByTagName</span><br><span class="line">document.getElementsByName</span><br><span class="line">document.getElemensByClassName</span><br><span class="line"><span class="comment"># 功能强大，但是也许会有浏览器不兼容的情况存在</span></span><br><span class="line">document.querySelectorAll </span><br><span class="line"></span><br><span class="line">2、 亲属访问</span><br><span class="line"></span><br><span class="line">3、 属性获取</span><br><span class="line">getAttribute</span><br><span class="line">getAttributeNode</span><br></pre></td></tr></table></figure></p><p>2、 创建<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建元素</span></span><br><span class="line">document.createElement </span><br><span class="line"><span class="comment"># 创建文本节点</span></span><br><span class="line">document.createTesxtNode </span><br><span class="line"><span class="comment"># 属性节点</span></span><br><span class="line">document.createAttribute </span><br><span class="line">innerHTML</span><br><span class="line">innerText</span><br><span class="line">node.cloneNode()</span><br></pre></td></tr></table></figure></p><p>3、 加入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 追加到结尾处</span></span><br><span class="line">appendChild </span><br><span class="line">innerHTML</span><br><span class="line"><span class="comment"># 用法：将元素插入到某一个元素的前面 父元素.insertBefore(新元素, 旧元素);</span></span><br><span class="line">insertBefore</span><br></pre></td></tr></table></figure></p><p>4、 其他<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">style 的操作</span><br><span class="line">setAttribute(属性名， 属性值)</span><br></pre></td></tr></table></figure></p><p>5、 删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用法：父元素.removeChild()</span></span><br><span class="line">removeChild </span><br><span class="line">removeAttributeNode</span><br></pre></td></tr></table></figure></p><p>6、 修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.修改节点</span><br><span class="line">删除节点再加入</span><br><span class="line"></span><br><span class="line">2.修改样式</span><br><span class="line">style.xxx = vvv;</span><br><span class="line">setAttribute</span><br><span class="line"></span><br><span class="line">3.修改文本</span><br><span class="line">innerHTML</span><br><span class="line">innerText</span><br><span class="line">节点操作</span><br><span class="line">nodeValue</span><br><span class="line"></span><br><span class="line">4.修改属性</span><br><span class="line">.xxx = vvv</span><br><span class="line">setAttribute</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器渲染流程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BFC&amp;IFC&amp;GFC&amp;FFC</title>
      <link href="/2019/03/29/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/BFC&amp;IFC/"/>
      <url>/2019/03/29/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/BFC&amp;IFC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>　　对CSS有了解的道友们肯定都知道盒式模型这个概念，对一个元素设置CSS，首先需要知道这个元素是block还是inline类型。而BFC就是用来格式化块级盒子，同样管理inline类型的盒子还有IFC，以及其他的FC。那首先我们就来看一下FC的概念。<br>　　<code>Formatting Context</code>：指页面中的一个渲染区域，并且拥有一套渲染规则，他<code>决定了其子元素如何定位</code>，以及<code>与其他元素的相互关系和作用</code>。<br>　　BFC：<code>块级格式化上下文</code>，它是指一个独立的块级渲染区域，只有Block-level BOX参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。</p><h4 id="BFC生成"><a href="#BFC生成" class="headerlink" title="BFC生成"></a>BFC生成</h4><p>BFC(Block Formatting Context)是Web页面中盒模型布局的CSS渲染模式。它属于常规文档流。<br>CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC:<br>（1）float的值不为none<br>（2）position的值为<code>absolute</code>或者<code>fixed</code><br>（3）display的值为<code>table-cell</code>、<code>table-caption</code>、<code>inline-block</code>、<code>flex</code>或者<code>inline-flex</code>的其中一个<br>（4）overflow的值不为<code>visible</code></p><h4 id="BFC的约束规则"><a href="#BFC的约束规则" class="headerlink" title="BFC的约束规则"></a>BFC的约束规则</h4><p>浏览器对于BFC这块区域的约束规则如下：<br>　　生成BFC元素的子元素会一个接一个的放置。垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的margin特性。在BFC中相邻的块级元素外边距会折叠。<br>　　生成BFC元素的子元素中，每一个子元素做外边距与包含块的左边界相接触，（对于从右到左的格式化，右外边距接触右边界），即使浮动元素也是如此（尽管子元素的内容区域会由于浮动而压缩），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。<br>有道友对它做了分解，我们直接拿来：<br>　　（1）内部的Box会在<code>垂直方向</code>上一个接一个的放置<br>　　（2）垂直方向上的距离由<code>margin</code>决定。（完整的说法是：<code>属于同一个BFC的两个相邻Box的margin会发生重叠</code>，<code>与方向无关</code>。）<br>　　（3）每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）<br>　　（4）BFC的区域不会与<code>float box</code>的元素区域重叠<br>　　（5）计算BFC的高度时，浮动子元素也参与计算<br>　　（6）BFC就是页面上的一个<code>隔离的独立容器</code>，容器里面的子元素<code>不会影响</code>到外面元素，反之亦然</p><h4 id="BFC的用处"><a href="#BFC的用处" class="headerlink" title="BFC的用处"></a>BFC的用处</h4><h5 id="防止发生因浮动导致的高度塌陷"><a href="#防止发生因浮动导致的高度塌陷" class="headerlink" title="防止发生因浮动导致的高度塌陷"></a>防止发生因浮动导致的高度塌陷</h5><h6 id="防止margin重叠"><a href="#防止margin重叠" class="headerlink" title="防止margin重叠"></a>防止margin重叠</h6><p>　　同一个BFC中的两个相邻Box才会发生重叠与方向无关，不过由于上文提到的第一条限制，我们甚少看到水平方向的margin重叠。这在IE中是个例外，IE可以设置write-mode<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">"first-block"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"second-block"</span>&gt;</span><br><span class="line">    &lt;h2&gt;DDFE&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># css</span></span><br><span class="line">.first-block &#123;</span><br><span class="line">    background: <span class="comment">#F44336;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.second-block &#123;</span><br><span class="line">    background: <span class="comment">#00BCD4;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    overflow: hidden;   //添加溢出隐藏</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>first-block和second-block之间存在间距，这个间距是 h2 的上外边距引起的<br>通过把 overflow 把 second-block 元素形成一个 BFC，完美解决！</p><p><strong>CSS 里面关于折叠的条件：</strong><br>两个块元素要产生折叠现象，必须满足一个必备条件：这两个元素的 margin 必须是 相邻 的；那么如果定义相邻呢，w3c 规范，两个 margin 是邻接的必须满足以下条件：<br>必须是处于常规文档流（非float和绝对定位）的块级盒子,并且处于同一个 BFC 当中。<br>没有inline盒子，没有空隙，没有 padding 和 border 将他们分隔开。<br><strong>折叠的结果按照如下规则计算：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</span><br><span class="line">两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</span><br><span class="line">两个外边距一正一负时，折叠结果是两者的相加的和。</span><br></pre></td></tr></table></figure></p><h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><p>　　在一个IFC中，从父级元素的顶部开始，盒子一个接一个横向排列。此时，横向的margin、borders、padding在这些盒子中都是有效的。这些盒子有可能通过不同的方式垂直对齐：1、他们底部或者顶部可以对齐，2、或者可以他们内部的文字基线可以对齐。如果一个矩形区域，包含着一些排成一条线的盒子，称为line box。</p><h4 id="什么是IFC"><a href="#什么是IFC" class="headerlink" title="什么是IFC"></a>什么是IFC</h4><p>　　IFC(Inline Formatting Contexts)直译为”<code>行内格式化上下文</code>“，IFC的line box（线框）<code>高度由其包含行内元素中最高的实际高度计算而来</code>(不受到竖直方向的 padding/margin 影响)</p><h4 id="IFC特性"><a href="#IFC特性" class="headerlink" title="IFC特性"></a>IFC特性</h4><p>　　IFC中的linebox一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。<br>　　IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。</p><h4 id="IFC的应用"><a href="#IFC的应用" class="headerlink" title="IFC的应用"></a>IFC的应用</h4><p>　　水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。<br>　　垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</p><p>参考文章：<br>　　<a href="https://www.cnblogs.com/dojo-lzz/p/3999013.html" target="_blank" rel="noopener">我对BFC的理解</a><br>　　<a href="https://juejin.im/post/583bb606a22b9d006c141286" target="_blank" rel="noopener">细说CSS中的BFC</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 页面布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/29/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
      <url>/2019/03/29/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>前端知识点</title>
      <link href="/2019/03/27/JavaScript/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/03/27/JavaScript/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><ul><li>HTML+CSS布局<ul><li>内容+样式 基础<ul><li>重点了解布局、流</li><li>less、sass、stylus</li></ul></li></ul></li><li>CSS<ul><li>px、em、rem、vw、vh</li><li>设置html的font-size大小，统一标准</li><li>小程序单位rpx</li></ul></li><li>布局<ul><li>相对、绝对</li><li>流式、响应式布局</li><li>flex布局</li></ul></li><li>CSS3<ul><li>透明度、文字阴影、圆角、渐变色</li><li>盒阴影、边框图片、媒体查询</li><li>transition过渡、transform变形、animation动画</li></ul></li><li>CSS优化<ul><li>选择器原理: 从右向左</li><li>避免后台、链式、重复</li><li>避免!important</li></ul></li><li>BFC &amp; IFC<ul><li>float不是none，绝对定位，表格，overflow不是visable，flex盒子</li><li>创建BFC后，元素会一个个的摆放</li><li>外边距折叠<ul><li>最常见的：<code>overflow:hidden</code>、 <code>float:left/right</code>、 <code>position: absolut、</code></li></ul></li></ul></li><li>ES6 &amp; ES7<ul><li>let、const、解构(结构)、</li><li>箭头函数、SymboL、Set</li><li>Proxy、Class、generator、模块化</li></ul></li><li>函数<ul><li>默认参数、返回值、原型链</li><li>箭头函数、this、作用域、闭包、bind、apply</li><li>高阶函数、递归、Decorator、Compose、Currying…</li></ul></li><li>面向对象<ul><li>class、实例方法、静态属性和方法</li><li>构造函数、super</li><li>继承</li></ul></li><li>JS异步<ul><li>解决回调<ul><li>Promise</li><li>Generator</li><li>Async + await</li></ul></li></ul></li><li>模块化<ul><li>最早期AMD、CMD、commonjs</li><li>import export</li><li>ES6加载原理和node加载原理</li></ul></li><li>面试题<ul><li>Promise相当于一个状态机<ul><li>pending、rejected、fulfilled状态</li><li>维护callback队列</li><li><a href="https://juejin.im/post/5c41297cf265da613356d4ec" target="_blank" rel="noopener">掘金</a></li></ul></li></ul></li><li>Vue<ul><li>Vue-cli3.0+</li><li>组件化通讯<ul><li>父子组件 props $emit 兄弟组件可以让父母代理中转</li><li>祖先后代关系eventbus 或者自己实现dispath&amp;boardcast</li><li>没关系eventbus或者Vuex</li></ul></li><li>生命周期</li><li>组件化设计</li><li>源码</li><li>全家桶、服务端渲染</li><li>复用.Vue组件<ul><li>props、event、slot</li><li>手动挂载的组件$emit</li><li>递归组件和动态组件</li></ul></li><li>双向绑定<ul><li>Object.defineProperty</li><li>依赖机制</li><li>异步更新队列</li></ul></li><li>Vuex + vue-router<ul><li>单页应用 依赖加载模块</li><li>vue单行数据流</li><li>数据交给专门的store管理，全局数据中心、</li></ul></li><li>服务端渲染<ul><li>服务端解析vue组件成html渲染首屏<ul><li>速度</li><li>SEO</li><li>nuxt.js</li></ul></li></ul></li></ul></li><li>Typescript<br>+ </li><li>Webpack<ul><li>基础配置</li><li>性能优化，缩小搜索范围，DllPlugin，多进程、tree-shaking，代码抽取，按需加载</li><li>定制loader和plugin<ul><li>loader定义自己的转换规则</li><li>plugin 整个webpack工作流程定义，有一个apply方法获取compiler对象</li><li>loader单一职责，链式组合，模块化，无状态</li></ul></li><li>plugin<ul><li>修改输出资源</li><li>读取模块和依赖</li><li>监听文件变化</li></ul></li></ul></li><li>异步</li><li>浏览器</li><li>性能优化<ul><li>抛开场景谈优化，就是耍流氓</li><li>常见性能优化策略,文件少加载，代码少执行，多用缓存，少计算，</li><li>性能如何分析 devtools代码打包压缩，图片压缩，gzip，缓存，<br>cdn，SSR，框架对应的优化策略，lazy-load,节流防抖</li></ul></li></ul><p>服务端渲染</p><ul><li>安全<ul><li>常见漏洞，如何防御</li><li>XSS、CSRF、Cookie劫持、点击劫持</li><li>传输安全、接入层</li><li>Oauth</li></ul></li><li>多端（Node，小程序，App）<ul><li>微信小程序</li><li>测试</li><li>微服务</li><li>Node.js </li><li>监控</li><li>部署</li><li>自动化</li><li>云开发</li><li>RN flutter</li><li>小程序生态</li></ul></li><li>nodejs<ul><li>Node核心概念<ul><li>events，fs，stream，buffer</li><li>IO，event-loop，线程池</li><li>libuv，V8</li></ul></li><li>Node应用场景<ul><li>Express、Koa等web开方</li><li>自动化，微服务</li><li>express/koa网站</li><li>前端工具 </li><li>webpack/ gulp</li><li>API/hapi</li><li>跨平台/ electron</li><li>区块链/ ipfs</li><li>命令行工具/ </li><li>shell.js</li><li>Express/koa代理</li><li>硬件/ ruff</li><li>微服务 </li><li>企业级框架eggj</li><li>实时/socket.io</li></ul></li></ul></li><li>Event-loop<ul><li>代码到底咋执行的<ul><li>执行微任务 比如promise</li><li>同步代码，完事之后查询是否有异步</li><li>执行宏任务，setTimeout,SetImmediate,等</li></ul></li></ul></li><li>自动化测试</li><li>代码的健壮性，改代码不再胆战心惊<ul><li>E2E测试Puppeteer，代码覆盖率istanbul</li><li>单元测试，mocha，jest ，jasmine </li><li>测试驱动开发TDD，先写测试，再写代码</li></ul></li><li>前端监控<ul><li>对运行状况了然于胸<ul><li>前端错误监控 onerror Sentry</li><li>前端性能监控 性能参数 berserkJS 屏幕补货，网络监控</li><li>上报 img 的src</li></ul></li></ul></li><li>浏览器<ul><li>最重要的一端<ul><li>缓存机制<ul><li>性能优化重要策略</li><li>memory cache，disk cache</li><li>网络请求，强缓存弱缓存</li></ul></li><li>如何渲染的<ul><li>收到html=》解析dom树</li><li>css =&gt; css 树 和dom结合 形成render tree 开始渲染</li><li>少操作dom，重绘回流</li></ul></li><li>输入url发生了啥</li></ul></li></ul></li><li>部署<ul><li>项目总要上线<ul><li>Nginx</li><li>Pm2</li><li>Docker + 自动化</li></ul></li></ul></li><li>特殊场景<ul><li>不算通用能力，但是特殊业务需求<ul><li>可视化 echarts (canvas)，d3(svg)，three.js(webgl)</li><li>小游戏</li><li>PS切图</li></ul></li></ul></li><li>软件工程师<ul><li>算法<ul><li>排序 搜索 遍历</li><li>贪婪</li><li>动态规划</li></ul></li><li>编译原理</li><li>设计模式</li><li>网络协议</li><li>数据库</li><li>数据结构<ul><li>数组、字符串、队列、堆、链表</li><li>二叉树</li><li>图</li></ul></li><li>软件工程</li><li>数学基础</li><li>编码</li></ul></li><li>网络协议<ul><li>IP</li><li>TCP/UDP</li><li>HTTP / HTTPS / SSH / FTP </li></ul></li><li>设计模式<ul><li>常见设计模式，单例，装饰器，代理，观察者，发布订阅</li><li>前端常用的设计模式</li><li>如何使用、不要滥用</li></ul></li><li>数据库<ul><li>Mysql 关系型数据库，多表join</li><li>Mongodb json数据库</li><li>Redis 内存数据库 速度快</li></ul></li><li><p>面试题</p><ul><li>跨域方案</li><li>强缓存弱缓存</li><li>输入url发生啥<ul><li>DNS解析 ， 三次握手，建立链接</li><li>接受相应，查库查文件，等待数据返回，拼接响应报文</li><li>浏览器接受报文，解析html 渲染页面</li></ul></li><li>渲染原理</li><li>业余干啥</li><li>可访问性</li><li>箭头函数优点</li><li>前后端分离JWT</li><li>垃圾回收</li></ul></li><li><p>基础vuejs</p><ul><li>组件通讯<ul><li>prop<ul><li>父组件通过 Prop 往子组件传递数据</li><li>Prop 让组件更加灵活</li><li>不要直接修改 Prop</li></ul></li><li>event<ul><li>子组件往当前实例上派发事件</li><li>子组件在父组件中使用，可以监听到该事件，并做出响应</li></ul></li><li>golbal event bus<ul><li>非父子组件通讯</li><li>可以基于新的 Vue 实例实现</li></ul></li><li>Vuex<ul><li>非父子组件通讯（数据共享）</li><li>数据状态管理</li></ul></li></ul></li><li>插槽<ul><li>普通插槽<ul><li>组件的实现更加灵活</li><li>内容分发</li><li>插槽访问的数据作用域是父组件</li></ul></li><li>作用域插槽<ul><li>插槽可以访问到子组件中的数据</li></ul></li></ul></li><li>过度动画<ul><li>触发条件<ul><li>Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡：<ul><li>条件渲染 (使用 v-if)</li><li>动态组件</li><li>条件展示 (使用 v-show)</li><li>组件根节点</li></ul></li></ul></li><li>过渡类名<ul><li>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <code>&lt;transition&gt;</code>，则 v- 是这些类名的默认前缀。如果你使用了 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code>，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code></li><li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除</li><li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li><li><code>v-enter-to</code>：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时<code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li><li><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li><li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li><li><code>v-leave-to</code>：定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除</li></ul></li><li>JavaScript 钩子<ul><li>可以在属性中声明J<code>avaScript</code> </li><li>当只用 <code>JavaScript</code> 过渡的时候，在 <code>enter</code> 和 <code>leave</code> 中必须使用<code>done</code> 进行回调。否则，它们将被同步调用，过渡会立即完成。</li><li>推荐对于仅使用 <code>JavaScript</code> 过渡的元素添加 <code>v-bind:css=&quot;false&quot;</code>，<code>Vue</code> 会跳过 <code>CSS</code> 的检测。这也可以避免过渡过程中 <code>CSS</code> 的影响。</li></ul></li></ul></li><li>DOM操作<ul><li>操作CSS<ul><li>某些交互可以通过手动操作CSS 做精细的控制</li></ul></li><li>配合原生JS库使用<ul><li>与原生 JS 库配合使用，再做一层 Vue 化的封装</li><li>cube-ui 对 better-scroll 的封装</li><li>element-ui 对 popper.js 的封装</li></ul></li></ul></li><li>组件封装<ul><li>就近管理<ul><li>单文件开发</li><li>依赖的静态资源放在同级目录</li><li>相关联组件也放在同级目录</li></ul></li><li>分层设计<ul><li>通过分层设计的思想设计复杂组件</li></ul></li><li>高度复用<ul><li>页面级别的复用（基础组件）</li><li>项目级别的复用 —私有组件库（业务组件）</li><li>公司级别的复用 —开源组件库（element-ui、cube-ui）</li></ul></li><li>灵活扩展<ul><li>组件设计要尽量灵活可扩展，除了提供丰富的 Props，还可以利用 slot插槽完成用户个性化定制需求）</li></ul></li></ul></li><li>Keep-alive<ul><li>使用场景<ul><li>保留组件状态或避免重新渲染</li><li>可以配合路由组件使用</li></ul></li><li>生命周期<ul><li>activated：组件激活时触发</li><li>deactivate：组件失活时触发</li></ul></li></ul></li><li>内存泄漏<ul><li>产生的原因<ul><li>未清理的定时器</li><li>未清理的全局注册的自定义事件</li><li>未清理的全局注册的 DOM 事件</li></ul></li><li>如何避免<ul><li>编写组件要有相关意识</li><li>检查是否有上述造成内存泄漏的可能</li><li>利用 beforeDestroy 生命周期函数，做对应的内存清理工作</li></ul></li></ul></li><li>错误回调<ul><li>常见的错误<ul><li>深层对象数据访问问题</li><li>对计算属性赋值</li><li>对 Prop 直接修改</li><li>使用了未注册的组件</li></ul></li><li>调试工具<ul><li>Chrome 开发者工具，学会查找错误堆栈</li><li>vue-devtools <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener">https://github.com/vuejs/vue-devtools</a></li><li>vConsole <a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">https://github.com/Tencent/vConsole</a></li></ul></li></ul></li><li>性能优化<ul><li>数据定义<ul><li>不需要把所有的数据都定义在 data 上，可以直接挂载到实例上</li></ul></li><li>按需加载<ul><li>对于首次渲染，我们只需要加载首屏渲染所需的资源，其他资源可以异步按需加载。这样可以减少首屏加载的资源包大小，加速渲染</li><li>异步组件<ul><li>异步组件——比如我们使用一些图标库，如 echart，我们可以考虑做成异步组件，单独打包</li></ul></li><li>异步路由<ul><li>异步路由——比如单页应用，我们的导航切换是基于路由切换，那么其他页面可以考虑做成异步路由</li></ul></li></ul></li><li>预渲染<ul><li>由于基于 Vue.js 的单页应用是由 Vue.js 渲染页面，所以页面下载后到渲染会有一定白屏时间</li><li>我们可以不依赖 JS，在页面下载后先渲染一张 Loading图片或者是骨架屏结构</li><li>当主页面渲染时，把这张占位图片或者结构隐藏</li><li>用户看到的不是白屏，有等待预期</li></ul></li><li>后编译<ul><li>编译代码冗余？</li><li>依赖包本身不编译，它的编译交给应用来做。通过修改 webpack 配置 rules 中的 include</li><li>后编译依赖嵌套？<ul><li>webpack-post-compile-plugin需要后编译的依赖包在 package.json 中声明<code>&quot;postCompile&quot;: true</code></li></ul></li><li>性能优化<ul><li>一份编译代码</li><li>主题定制</li><li>一份 ployfill</li><li>rem布局</li><li>NPM包无需编译发布</li></ul></li></ul></li></ul></li></ul></li><li>深入理解Vue.js<ul><li>Vue.js渲染原理</li><li>响应式实现原理</li><li>组件化实现原理</li></ul></li><li>前端工程<ul><li>脚手架<ul><li>Vue-cli 3.0<ul><li>是一个基于 Vue.js 进行快速开发的完整系统</li><li>通过 @vue/cli 搭建交互式的项目脚手架</li><li>通过 @vue/cli + @vue/cli-service-global 快速开始零配置原型开发</li><li>一个运行时依赖 (@vue/cli-service)</li><li>一个丰富的官方插件集合，集成了前端生态中最好的工具。</li><li>一套完全图形化的创建和管理 Vue.js 项目的用户界面</li></ul></li><li>插件化机制<ul><li>Vue CLI 使用了一套基于插件的架构。在项目创建的过程中，绝大部分列出的特性都是通过插件来实现的</li><li>插件可以帮助我们生成初始化代码， 安装指定的依赖包</li></ul></li><li>webpack 配置<ul><li>调整 webpack 配置最简单的方式就是在 vue.config.js中的 configureWebpack 选项提供一个对象</li><li>因为 @vue/cli-service 对 webpack 配置进行了抽象，所以理解配置中包含的东西会比较困难，可以通过下面命令查看 webpack 配置<code>vue inspect &gt; output.js</code></li></ul></li></ul></li><li>webpack<ul><li>现代 JavaScript 应用程序的静态模块打包器<ul><li>module<ul><li>开发者将程序分解成离散功能块（discrete chunks offunctionality），并称之为模块</li><li>每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。</li><li>精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的</li><li>前端模块化面对的挑战 —处理JS之外的静态资源、资源的依赖关系加载顺序、资源的请求和加载是异步的</li><li>ES2015 import 语句</li><li>CommonJS require() 语句</li><li>AMD define 和 require 语句</li><li>css/sass/less 文件中的 @import 语句</li><li>样式<code>(url(...))</code>或 HTML 文件<code>(&lt;img src=...&gt;)</code>中的图片链接<code>(image url)</code></li></ul></li><li>entry<ul><li>入口起点(entry point)指示 webpack应该使用哪个模块，来作为构建其内部依赖图的开始，webpack会找出有哪些模块和 library是入口起点（直接和间接）依赖的</li><li>多入口：数组结构</li><li>多入口：对象结构</li><li>多页面应用程序</li></ul></li><li>output<ul><li>配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。即使可以存在多个入口起点，也只指定一个输出配置</li><li>如果配置创建了多个单独的 “chunk”，则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。</li><li>线上运行时需要通过设置 public path 指向 CDN 地址</li></ul></li><li>loader<ul><li>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件</li><li><code>Typescript -&gt; JavaScript</code></li><li><code>Image -&gt; data URL</code></li><li><code>JavaScript import CSS</code></li><li>loader 支持链式传递</li><li>loader 可以是同步的，也可以是异步的</li><li>loader 运行在 Node.js 中，并且能够执行任何可能的操作</li><li>loader 能够使用options 对象进行配置</li><li>babel-loader 加载ES2015+ 代码，然后使用 Babel 转译为 ES5</li><li>style-loader 将模块的导出作为样式添加到 DOM 中</li><li>css-loader 解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码</li><li>less-loader 加载和转译 LESS 文件</li><li>file-loader 将文件发送到输出文件夹，并返回（相对）URL</li><li>url-loader 像 file loader 一样工作，但如果文件小于限制，可以返回 data URL</li><li>vue-loader 加载和转译 Vue 组件</li></ul></li><li>plugins<ul><li>插件比 loader 更加强大，可以帮助用户直接触及到编译过程。 插件可以将处理函数注册到编译过程中的不同时间点上运行的生命周期钩子函数上。</li><li>打包优化</li><li>资源管理</li><li>注入环境变量</li><li>CommonsChunkPlugin 提取 chunks 之间共享的通用模块</li><li>DefinePlugin 允许在编译时(compile time)配置的全局常量</li><li>ExtractTextWebpackPlugin 从 bundle 中提取文本（CSS）到单独的文件</li><li>UglifyjsWebpackPlugin 使用 UglifyJS 压缩 JS</li><li>HtmlWebpackPlugin 创建HTML文件来服务打包文件</li></ul></li></ul></li></ul></li><li>开发&amp;部署</li><li>开发阶段<ul><li>需求阶段<ul><li>前后端共同参与产品需求评审，并做一轮技术评审</li><li>技术评审过程中，梳理所有交互通讯的接口</li><li>把接口落地成文档，并约定好所有字段</li></ul></li><li>开发阶段<ul><li>前后端独立开发</li><li>前端伪造 mock 数据</li><li>可以使用 mock webpack 插件</li></ul></li><li>联调阶段<ul><li>预留联调的时间</li><li>前后端开发完成后开始联调</li><li>前端把接口请求指向后端的联调地址（可自动完成）</li></ul></li><li>上线阶段<ul><li>前端把接口请求指向后端的线上地址（可自动完成）</li><li>一定要后端先上线</li></ul></li></ul></li><li>部署流程<ul><li>预留联调的时间后端先上线 API 接口（若需要）</li><li>前端项目最终编译生成静态资源文件（HTML、JS、CSS 等）</li><li>增量发布，前端先全量上线 JS、CSS 等静态资源</li><li>前端接着上线模板 HTML，先发布到一台 pre 机器，QA 回归</li><li>回归通过后，逐步放量模板直至全量</li></ul></li></ul></li><li>知识点<ul><li>HTPP相关<ul><li>常见 HTTP 状态码</li><li>浏览器缓存原理</li><li>抓包工具（fiddler、charles）</li></ul></li><li>跨域<ul><li>CORS</li><li>JSONP</li></ul></li><li>性能优化<ul><li>性能监测：<a href="https://github.com/GoogleChrome/lighthouse" target="_blank" rel="noopener">https://github.com/GoogleChrome/lighthouse</a></li><li>数据埋点</li><li>雅虎军规：<a href="https://developer.yahoo.com/performance/rules.html、https://juejin.im/post/5b73ef38f265da281e048e51" target="_blank" rel="noopener">https://developer.yahoo.com/performance/rules.html、https://juejin.im/post/5b73ef38f265da281e048e51</a></li></ul></li><li>Web安全<ul><li>XSS</li><li>CSRF</li><li>HTTPS </li><li><a href="https://zhuanlan.zhihu.com/p/561228" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/561228</a></li></ul></li><li>数据结构&amp;算法<ul><li>栈/队列/树/ 图</li><li>排序/递归</li><li>算法设计技巧</li></ul></li><li>浏览器渲染原理<ul><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></li></ul></li><li>正则表达式<ul><li>匹配原理</li><li>基本语法</li><li>实用技巧</li></ul></li><li>设计模式<ul><li>订阅发布模式</li><li>工厂模式</li><li>适配器模式</li></ul></li><li>后端语言<ul><li>PHP</li><li>JAVA</li><li>Node.js</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端知识点 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据类型</title>
      <link href="/2019/03/27/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/03/27/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>参考：<br>　　<a href="https://www.yuque.com/hoxz/frontend-map/vbfeaf" target="_blank" rel="noopener">类型检测</a><br>　　<a href="https://juejin.im/post/5b0b9b9051882515773ae714" target="_blank" rel="noopener">浅谈 instanceof 和 typeof 的实现原理</a><br>　　<a href="https://segmentfault.com/a/1190000006150186" target="_blank" rel="noopener">在JavaScript中，如何判断数组是数组？</a></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p><code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Undefined</code>、<code>Null</code><br><strong>Number</strong><br>　　Number类型包含整数和浮点数（浮点数数值必须包含一个小数点，且小数点后面至少有一位数字）两种值。<a id="more"></a><br>NaN: 非数字类型。特点：① 涉及到的任何关于NaN的操作，都会返回NaN ②NaN不等于自身。<br>isNaN() 函数用于检查其参数是否是非数字值。<br><code>isNaN(123)  //false   isNaN(&quot;hello&quot;)  //true</code><br><strong>String</strong><br>　　字符串有length属性。<br>字符串转换：转型函数String(),适用于任何数据类型（null,undefined 转换后为null和undefined）；toString()方法（null,defined没有toString()方法）。<br><strong>Boolean</strong><br>　　该类型只有两个值，true和false<br><strong>Undefined</strong><br>　　只有一个值，即undefined值。使用var声明了变量，但未给变量初始化值，那么这个变量的值就是undefined。<br><strong>Null</strong><br>　　null类型被看做空对象指针，前文说到null类型也是空的对象引用。</p><h5 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h5><p><code>Object</code><br>　　Object本质上是由一组无序的名值对组成的。<br>　　js中对象是一组属性与方法的集合。这里就要说到引用类型了，引用类型是一种数据结构，用于将数据和功能组织在一起。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p><code>Object</code>、<code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>等</p><h5 id="基本类型与引用类型"><a href="#基本类型与引用类型" class="headerlink" title="基本类型与引用类型"></a>基本类型与引用类型</h5><p>基本类型又叫原始类型（primitive type）<br>栈：原始数据类型（Undefined，Null，Boolean，Number、String）<br>堆：引用数据类型（Object、Array、Function）<br>两种类型的区别是 <code>存储位置不同</code>：<br>　　<code>原始数据类型</code>直接存储在<code>栈(stack)</code>中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br>　　<code>引用数据类型</code>存储在<code>堆(heap)</code>中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>　　ECMAScript中用var关键字来定义变量，因为js是弱类型的，所以无法确定变量一定会存储什么值，也就不知道变量到底会是什么类型，而且变量的类型可以随时改变。<br>这就是ECMAScript是松散类型的来由，所谓松散类型就是可以用来保存任何类型的数据。<br>ps:<br>es6中新增了let命令来声明变量、const命令声明一个只读的常量。<br>let的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。<br>const一旦声明，常量的值就不能改变。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const是用来定义常量的，而且定义的时候必须初始化，且定义后不可以修改。</span><br><span class="line">对于基本类型的数据来说，自然很好理解了，例如 const PI = 3.14。</span><br><span class="line">如果定义的时候不初始化值的话就会报错,错误内容就是没有初始化。</span><br><span class="line"></span><br><span class="line">const p = &#123;name: <span class="string">'www'</span>, age: <span class="string">'22'</span>&#125;</span><br><span class="line"></span><br><span class="line">p.name = <span class="string">'dfsfs'</span></span><br><span class="line"></span><br><span class="line">p: // &#123;name: <span class="string">'dfsfs'</span>, age: <span class="string">'22'</span> &#125;</span><br><span class="line"></span><br><span class="line">因为对象是引用类型的，P中保存的仅是对象的指针，这就意味着，const仅保证指针不发生改变，</span><br><span class="line">修改对象的属性不会改变对象的指针，所以是被允许的。也就是说const定义的引用类型只要指针不发生改变，</span><br><span class="line">其他的不论如何改变都是允许的。</span><br><span class="line">即使对象的内容没发生改变，指针改变也是不允许的。</span><br></pre></td></tr></table></figure></p><h4 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h4><p><code>typeof</code>、<code>Object.prototype.toString()</code></p><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><p>　　typeof返回一个表示数据类型的字符串，返回结果包括：<code>number</code>、<code>boolean</code>、<code>string</code>、<code>symbol</code>、<code>object</code>、<code>undefined</code>、<code>function</code>等7种数据类型，但不能判断<code>null</code>、<code>array</code>等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typeof Symbol();    // symbol 有效</span><br><span class="line">typeof <span class="string">''</span>;          // string 有效</span><br><span class="line">typeof 1;          // number 有效</span><br><span class="line">typeof <span class="literal">true</span>;       //boolean 有效</span><br><span class="line">typeof undefined;  //undefined 有效</span><br><span class="line">typeof new Function(); // <span class="keyword">function</span> 有效</span><br><span class="line">typeof null;           //object 无效</span><br><span class="line">typeof [] ;           //object 无效</span><br><span class="line">typeof new Date();    //object 无效</span><br><span class="line">typeof new RegExp();  //object 无效</span><br></pre></td></tr></table></figure></p><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><p>　　<code>instanceof</code> <code>主要的作用就是判断一个实例是否属于某种类型</code>。是用来判断A是否为B的实例，表达式为：<code>A instanceof B</code>，如果A是B的实例，则返回true,否则返回false。<code>instanceof</code> 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性，但它不能检测<code>null</code> 和 <code>undefined</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Array; //<span class="literal">true</span></span><br><span class="line"><span class="comment"># 在数组的原型链上也能找到Object构造函数</span></span><br><span class="line">[] instanceof Object;//<span class="literal">true</span></span><br><span class="line">&#123;&#125; instanceof Object;//<span class="literal">true</span></span><br><span class="line">new Date() instanceof Date;//<span class="literal">true</span></span><br><span class="line">new RegExp() instanceof RegExp//<span class="literal">true</span></span><br><span class="line">null instanceof Null//报错</span><br><span class="line">undefined instanceof undefined//报错</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> person = <span class="function"><span class="title">function</span></span> () &#123;&#125;</span><br><span class="line"><span class="built_in">let</span> nicole = new person()</span><br><span class="line">nicole instanceof person // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h6 id="instanceof-实现原理"><a href="#instanceof-实现原理" class="headerlink" title="instanceof 实现原理"></a>instanceof 实现原理</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> new_instance_of(leftVaule, rightVaule) &#123; </span><br><span class="line">  // 取右表达式的 prototype 值</span><br><span class="line">  <span class="built_in">let</span> rightProto = rightVaule.prototype; </span><br><span class="line">  // 取左表达式的__proto__值</span><br><span class="line">  leftVaule = leftVaule.__proto__;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftVaule === null) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftVaule === rightProto) &#123;</span><br><span class="line">      <span class="built_in">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    leftVaule = leftVaule.__proto__ </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　其实 instanceof 主要的实现原理就是只要右边变量的<code>prototype</code>在左边变量的原型链上即可。因此，<code>instanceof</code> 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 <code>prototype</code>，如果查找失败，则会返回 <code>false</code>，告诉我们左边变量并非是右边变量的实例。</p><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><p>　　<code>constructor</code>作用和<code>instanceof</code>非常相似。但<code>constructor</code>检测 <code>Object</code>与<code>instanceof</code>不一样，<code>还可以处理基本数据类型的检测</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = []</span><br><span class="line">console.log(a.constructor);</span><br><span class="line">// ƒ <span class="function"><span class="title">Array</span></span>() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure></p><p>　　不过函数的 <code>constructor</code> 是不稳定的，这个主要体现在把类的原型进行重写，在重写的过程中很有可能出现把之前的<code>constructor</code>给覆盖了，这样检测出来的结果就是不准确的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义一个数组</span><br><span class="line">const a = [];</span><br><span class="line">//作死将constructor属性改成了别的</span><br><span class="line">a.contrtuctor = Object;</span><br><span class="line">console.log(a.constructor == Array);</span><br><span class="line">//<span class="literal">false</span> (哭脸)</span><br><span class="line">console.log(a.constructor == Object);</span><br><span class="line">//<span class="literal">true</span> (哭脸)</span><br><span class="line">console.log(a instanceof Array);</span><br><span class="line">//<span class="literal">true</span> (instanceof火眼金睛)</span><br></pre></td></tr></table></figure></p><p>　　可以看出，<code>constructor</code>属性被修改之后，就无法用这个方法判断数组是数组了，除非你能保证不会发生<code>constructor</code>属性被改写的情况，否则用这种方法来判断数组也是不靠谱的。</p><h5 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h5><p>　　toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]]。<br>这是一个内部属性，其格式为 [object xxx] ，其中 xxx 就是对象的类型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var gettype=Object.prototype.toString;</span><br><span class="line"></span><br><span class="line">gettype.call(<span class="string">'aaaa'</span>)      输出     [object String]</span><br><span class="line">gettype.call(2222)        输出     [object Number]</span><br><span class="line">gettype.call(<span class="literal">true</span>)        输出     [object Boolean]</span><br><span class="line">gettype.call(undefined)   输出     [object Undefined]</span><br><span class="line">gettype.call(null)        输出     [object Null]</span><br><span class="line">gettype.call(&#123;&#125;)          输出     [object Object]</span><br><span class="line">gettype.call([])          输出     [object Array]</span><br><span class="line">gettype.call(<span class="function"><span class="title">function</span></span>()&#123;&#125;)     输出   [object Function]</span><br></pre></td></tr></table></figure></p><h5 id="用Array对象的isArray方法判断"><a href="#用Array对象的isArray方法判断" class="headerlink" title="用Array对象的isArray方法判断"></a>用Array对象的isArray方法判断</h5><p>　　当参数为数组的时候，isArray方法返回true，当参数不为数组的时候，isArray方法返回false。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [];</span><br><span class="line">const b = &#123;&#125;;</span><br><span class="line">Array.isArray(a);//<span class="literal">true</span></span><br><span class="line">Array.isArray(b);//<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>我试着在调用这个方法之前重写了Object.prototype.toString方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString = ()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">'Hello Howard'</span>);</span><br><span class="line">&#125;</span><br><span class="line">const a = [];</span><br><span class="line">Array.isArray(a);//<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>并不影响判断的结果。<br>我又试着修改了constructor对象：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [];</span><br><span class="line">const b = &#123;&#125;;</span><br><span class="line">a.constructor = b.constructor;</span><br><span class="line">Array.isArray(a);//<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>OK，还是不影响判断的结果。<br>　　可见，它与instance运算符判断的方法以及<code>Object.prototype.toString</code>法并不相同，一些列的修改并没有影响到判断的结果。<br>　　<code>Array.isArray</code>是ES5标准中增加的方法，部分比较老的浏览器可能会有兼容问题，所以为了增强健壮性，建议还是给Array.isArray方法进行判断，增强兼容性，重新封装的方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Array.isArray) &#123;</span><br><span class="line">  Array.isArray = <span class="keyword">function</span>(arg) &#123;</span><br><span class="line">    <span class="built_in">return</span> Object.prototype.toString.call(arg) === <span class="string">'[object Array]'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="封装可以分辨所有数据类型的方法"><a href="#封装可以分辨所有数据类型的方法" class="headerlink" title="封装可以分辨所有数据类型的方法"></a>封装可以分辨所有数据类型的方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> typeName = &#123;</span><br><span class="line">  <span class="string">'[object Function]'</span>: <span class="string">'function'</span>,</span><br><span class="line">  <span class="string">'[object Boolean]'</span>: <span class="string">'boolean - object'</span>,</span><br><span class="line">  <span class="string">'[object Number]'</span>: <span class="string">'number - object'</span>,</span><br><span class="line">  <span class="string">'[object String]'</span>: <span class="string">'string - object'</span>,</span><br><span class="line">  <span class="string">'[object Object]'</span>: <span class="string">'object'</span>,</span><br><span class="line">  <span class="string">'[object RegExp]'</span>: <span class="string">'regExp'</span>,</span><br><span class="line">  <span class="string">'[object Array]'</span>: <span class="string">'array'</span>,</span><br><span class="line">  <span class="string">'[object Error]'</span>: <span class="string">'error'</span>,</span><br><span class="line">  <span class="string">'[object Date]'</span> : <span class="string">'date'</span>  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Object的toString方法，通过call调用</span></span><br><span class="line"><span class="keyword">var</span> toStringFn = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkType</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( obj == <span class="literal">null</span> )&#123;</span><br><span class="line">    <span class="comment">//js自带的的String方法，用于检测null和undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>( obj );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//safari5及之前版本，Chrome7, typeof RegExp返回的是function</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> || </span><br><span class="line">         <span class="keyword">typeof</span> obj === <span class="string">'function'</span> ? </span><br><span class="line">         typeName[toStringFn.call(obj)]:<span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">checkType(<span class="string">"123"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>媒体查询</title>
      <link href="/2019/03/26/CSS3/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/03/26/CSS3/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>css的媒体查询允许通过@media标签为特定媒体的浏览器设定样式，其中包含众多筛选，功能强大。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>　　HTML4和CSS2支持为不同的媒体类型指定专用的样式表，<code>screen</code>和<code>print</code>, <code>projection</code>是已定义的媒体类型<br>媒体查询由 媒体类型 和 一个或多个检测媒体特性的的条件表达式组成。<a id="more"></a><br>相对于CSS2只支持对媒体类型进行判断，<code>媒体查询</code>增加了<code>媒体特性</code>的判断，能够更准确地根据设备特性指定专用的样式。</p><h4 id="语法逻辑"><a href="#语法逻辑" class="headerlink" title="语法逻辑"></a>语法逻辑</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和</span></span><br><span class="line">and</span><br><span class="line"><span class="comment"># 也就是 or 的逻辑</span></span><br><span class="line">,</span><br><span class="line"><span class="comment"># 对查询结果取反</span></span><br><span class="line">not</span><br><span class="line"><span class="comment"># only操作符仅在媒体查询匹配成功的情况下被用于应用一个样式，</span></span><br><span class="line"><span class="comment"># 这对于防止让选中的样式在老式浏览器中被应用到。</span></span><br><span class="line">only</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>　　媒体查询包含一个可选的媒体类型和媒体特性表达式(0或多个)最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示文档所使用的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># link元素中的CSS媒体查询</span></span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> media=<span class="string">"(max-width: 800px)"</span> href=<span class="string">"example.css"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 样式表中的CSS媒体查询</span></span><br><span class="line">&lt;style&gt;</span><br><span class="line">@media (max-width: 600px) &#123;</span><br><span class="line">  .facet_sidebar &#123;</span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h5 id="使用媒体类型"><a href="#使用媒体类型" class="headerlink" title="使用媒体类型"></a>使用媒体类型</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> href=<span class="string">"site.css"</span> media=<span class="string">"screen"</span> /&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> href=<span class="string">"print.css"</span> media=<span class="string">"print"</span> /&gt;</span><br></pre></td></tr></table></figure><p><strong>media 属性定义了应该用于指定每种媒体类型的样式表：</strong><br>　　<code>screen</code> 适用于计算机彩色屏幕。<br>　　<code>print</code> 适用于打印预览模式下查看的内容或者打印机打印的内容。<br>　　作为 CSS v3 规范的一部分，可以扩展媒体类型函数，并允许在样式表中使用更精确的显示规则。媒体查询 是评估 True 或 False 的一种表达。如果为 True，则继续使用样式表。如果为 False，则不能使用样式表。这种简单逻辑通过表达式变得更加强大，使您能够更灵活地对特定的设计场景使用自定义的显示规则。</p><h5 id="媒体查询规则"><a href="#媒体查询规则" class="headerlink" title="媒体查询规则"></a>媒体查询规则</h5><p><code>@media all and (min-width: 800px) { ... }</code><br><code>@media all</code> 是媒体类型，也就是说，将此 <code>CSS</code> 应用于所有媒体类型<br><code>(min-width:800px)</code> 是包含媒体查询的表达式，如果浏览器的最小宽度为 800 像素，则会告诉浏览器只运用下列 <code>CSS</code>。<br><strong>请注意</strong>:可以省略关键词 <code>all</code> 和 <code>and</code>。在将某个媒体查询应用于所有媒体类型时，会省略<code>all</code>。后面的 <code>and</code> 也是可选的。使用简写语法重新编写媒体查询</p><h5 id="简写语法"><a href="#简写语法" class="headerlink" title="简写语法"></a>简写语法</h5><p><code>@media (min-width:800px) { ... }</code></p><h5 id="复杂表达式"><a href="#复杂表达式" class="headerlink" title="复杂表达式"></a>复杂表达式</h5><p>创建一个仅在最小宽度为 800 像素且最大宽度为 1200 像素时应用的样式<br><code>@media (min-width:800px) and (max-width:1200px) { ... }</code></p><h5 id="and-条件"><a href="#and-条件" class="headerlink" title="and 条件"></a>and 条件</h5><p>在您的表达式中，您可以根据自己的喜好使用任意数量的 and 条件。如果您想要增加其他条件来检查特定的屏幕方向，只需添加另一个 and 关键词，后跟 orientation 媒体查询.<br><code>@media (min-width:800px) and (max-width:1200px) and (orientation:portrait) { ... }</code><br>仅在宽度为 800 到 1200 像素且方向是纵向时才能激活.</p><h5 id="or-关键词"><a href="#or-关键词" class="headerlink" title="or 关键词"></a>or 关键词</h5><p>and 关键词的反义词是 or 关键词。和 and 一样，这些条件组合在一起会构成复杂表达式。如果其中有一个条件为 True，那么整个表达式或分离的两个条件都会为 True，如清单 6 所示。<br><code>@media (min-width:800px) or (orientation:portrait) { ... }</code><br>如果宽度至少是 800 像素或方向是纵向的，则会应用该规则。</p><h5 id="使用-not"><a href="#使用-not" class="headerlink" title="使用 not"></a>使用 not</h5><p><code>@media not all and (min-width: 800px) { ... }</code><br><code>@media not (all and (min-width: 800px)) { ... }</code><br>当最小宽度不是 800 像素时，会应用下列 CSS 规则。这些示例只是将像素作为媒体查询中的测量单位，但是测量单位并不仅限于像素。您可以使用任何有效的 CSS 测量单位，比如厘米 (cm)、英寸 (in)、毫米 (mm) 等。</p><h5 id="only"><a href="#only" class="headerlink" title="only"></a>only</h5><p><code>@media only (min-width: 300px) { ... }</code></p><h4 id="有用的媒体特性"><a href="#有用的媒体特性" class="headerlink" title="有用的媒体特性"></a>有用的媒体特性</h4><h5 id="orientation-媒体查询"><a href="#orientation-媒体查询" class="headerlink" title="orientation 媒体查询"></a>orientation 媒体查询</h5><p>方向： <code>orientation</code><br>值为：横排方向（ <code>landscape</code>）竖排方向（<code>portrait</code>）<br><code>@media (orientation: portrait) { ... }</code><br>高度和宽度行为十分相似，都支持以 min- 和 max- 为前缀</p><h5 id="高度和宽度媒体查询"><a href="#高度和宽度媒体查询" class="headerlink" title="高度和宽度媒体查询"></a>高度和宽度媒体查询</h5><p><code>@media (min-width:800px) and (min-height:400px) { ... }</code></p><h5 id="不带-min-和-max-前缀"><a href="#不带-min-和-max-前缀" class="headerlink" title="不带 min- 和 max- 前缀"></a>不带 min- 和 max- 前缀</h5><p><code>@media (width:800px) and (height:400px) { ... }</code></p><h4 id="媒体属性特征"><a href="#媒体属性特征" class="headerlink" title="媒体属性特征"></a>媒体属性特征</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前缀`min-`表示“至少”，即“大于等于”的意思。</span><br><span class="line">前缀`max-`表示“至多”，即“小于等于”的意思。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">width: 视口宽度</span><br><span class="line">height: 视口高度</span><br><span class="line">device-width: 渲染表面的高度(设备高度)</span><br><span class="line">device-height: 渲染表面的宽度(设备宽度)</span><br><span class="line">orientation: 检测设备是处于横向(landscape)还是纵向(portrait)</span><br><span class="line">aspect-ratio: 基于视口宽度和高度的宽高比</span><br><span class="line">device-aspect-ratio: 基于设备渲染表面的宽度和高度的宽高比</span><br><span class="line">color: 每种颜色的位数</span><br><span class="line">color-index: 设备的颜色索引表中的颜色数</span><br><span class="line">monochrome: 检测单色帧缓冲区中每像素所使用的位数</span><br><span class="line">resoluion: 用来检测屏幕和打印机的分辨率,dpi/dpcm</span><br><span class="line">scan: 电视机的扫描方式,逐行扫描(progressive)或隔行扫描(interlace)</span><br><span class="line">grid: 用来检测输出设备是网格设备还是位图设备</span><br></pre></td></tr></table></figure><p>参考：<br>　　<a href="https://www.ibm.com/developerworks/cn/web/wa-cssqueries/" target="_blank" rel="noopener">使用 CSS 媒体查询创建响应式网站</a><br>　　<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#-moz-device-pixel-ratio" target="_blank" rel="noopener">CSS媒体查询</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mate标签</title>
      <link href="/2019/03/26/H5/mate%E6%A0%87%E7%AD%BE/"/>
      <url>/2019/03/26/H5/mate%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载:<br>　　<a href="https://juejin.im/post/5b94d8965188255c5a0cdc02#heading-4" target="_blank" rel="noopener">2018前端面试总结，看完弄懂，工资少说加3K | 掘金技术征文</a><br>参考:<br>　　<a href="https://www.cnblogs.com/2050/p/3877280.html" target="_blank" rel="noopener">移动前端开发之viewport的深入理解</a><br><code>&lt;mate&gt;</code>标签: 提供页面的元信息但和内容无关，元数据可以被浏览器、搜索引擎和其他web服务器使用。<a id="more"></a></p><p>mate两种属性：http-equiv和name<br>　　<code>http-equiv</code> 相当于HTTP头<br>　　<code>content-type</code> 定义文档的字符集<br>　　<code>&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</code><br>　　<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code><br>　　<code>expires</code>网页到期时间<br>　　<code>&lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri, 12 Jan 2001 18:18:18 GMT&quot;&gt;</code><br>　　<code>X-UA-Compatible</code> 浏览器采取何种版本渲染当前页面<br>　　<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;</code><br>　　指定IE和Chrome使用最新版本渲染当前页面<br>　　<code>cache-control</code> 指定请求和响应遵循的缓存机制<br>　　<code>refresh</code> 自动刷新，病指向某个页面<br>　　<code>&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2; URL=http://www.root.net&quot;&gt;</code><br>　　<code>set-cookie</code> 设置cookie<br>　　<code>&lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx; expires=Friday, 12-Jan-2001 18:18:18 GMT; path=/&quot;&gt;</code><br>　　<code>cleartype</code>只对IE有用，用于平滑字体,不推荐使用<br>　　<code>&lt;!--[if IEMobile]&gt;&lt;meta http-equiv=&quot;cleartype&quot; content=&quot;on&quot;&gt;&lt;![endif]--&gt;`</code><br><code>name</code> 描述网页<br>　　<code>author</code> 作者<br>　　<code>&lt;meta name=&quot;author&quot; content=&quot;xx@xx&quot;&gt;</code><br>　　<code>description</code> 描述，网站主要内容<br>　　<code>&lt;meta name=&quot;description&quot; content=&quot;This page is about&quot;&gt;</code><br>　　<code>keywords</code> 关键字，搜索引擎会使用这些关键字分类<br>　　<code>&lt;meta name =&quot;keywords&quot; content=&quot;science, education&quot;&gt;</code><br>　　<code>renderer</code> 双核浏览器渲染方式，指定以哪种渲染方式<br>　　<code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</code><br>　　<code>viewport</code>视口，定义设备的大小<br>　　<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</code><br>　　<code>HandheldFriendly</code>针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓<br>　　<code>&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;True&quot;&gt;</code><br>　　<code>MobileOptimized</code> 微软为IE Mobile版设置的定义宽度标记<br>　　<code>&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;</code><br>　　<code>apple-mobile-web-app-capable</code> 是否启动webapp功能（全屏），会删除默认的苹果工具栏和菜单栏。<br>　　<code>apple-mobile-web-app-capable</code><br>　　<code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</code><br>　　<code>apple-mobile-web-app-status-bar-style</code> 当启动webapp功能时，手机顶部导航栏的颜色<br>　　<code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;</code><br>　　<code>apple-mobile-web-app-title</code> 添加到主屏后的标题<br>　　<code>&lt;meta name=&quot;apple-mobile-we-app-title&quot; content=&quot;&quot;&gt;</code><br>　　<code>format-detection</code> 格式检测，识别页面中的电话号码<br>　　<code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</code><br>　　<code>format-detection</code> 格式检测，识别页面中的email<br>　　<code>&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;&gt;</code></p><p><strong>viewPort</strong><br>|属性|作用|<br>|—-|—–|<br>|width| 设置layout viewport  的宽度，为一个正整数，或字符串”width-device”|<br>|initial-scale| 设置页面的初始缩放值，为一个数字，可以带小数|<br>|minimum-scale| 允许用户的最小缩放值，为一个数字，可以带小数|<br>|maximum-scale| 允许用户的最大缩放值，为一个数字，可以带小数|<br>|height | 设置layout viewport  的高度，这个属性对我们并不重要，很少使用|<br>|user-scalable | 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许|</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># H5标准声明，使用 HTML5 doctype，不区分大小写</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="comment"># 标准的 lang 属性写法</span></span><br><span class="line">&lt;head lang=”en”&gt;</span><br><span class="line"><span class="comment"># 声明文档使用的字符编码</span></span><br><span class="line">&lt;meta charset=’utf-8′&gt;</span><br><span class="line"><span class="comment"># 优先使用 IE 最新版本和 Chrome</span></span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt;   </span><br><span class="line"><span class="comment"># 页面描述</span></span><br><span class="line">&lt;meta name=”description” content=”不超过150个字符”/&gt;</span><br><span class="line"><span class="comment"># 页面关键词</span></span><br><span class="line">&lt;meta name=”keywords” content=””/&gt;</span><br><span class="line"><span class="comment"># 网页作者</span></span><br><span class="line">&lt;meta name=”author” content=”name, email@gmail.com”/&gt;</span><br><span class="line"><span class="comment"># 搜索引擎抓取</span></span><br><span class="line">&lt;meta name=”robots” content=”index,follow”/&gt;</span><br><span class="line"><span class="comment"># 为移动设备添加 viewport</span></span><br><span class="line">&lt;meta name=”viewport” content=”initial-scale=1,</span><br><span class="line">maximum-scale=3, minimum-scale=1, user-scalable=no”&gt;</span><br><span class="line"><span class="comment"># iOS 设备 begin</span></span><br><span class="line">&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt;</span><br><span class="line"><span class="comment"># 添加到主屏后的标题（iOS 6 新增）</span></span><br><span class="line">&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt;</span><br><span class="line"><span class="comment"># 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏</span></span><br><span class="line">&lt;meta name=”apple-itunes-app” </span><br><span class="line">content=”app-id=myAppStoreID,</span><br><span class="line"> 1affiliate-data=myAffiliateData, app-argument=myURL”&gt;</span><br><span class="line"><span class="comment"># 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）</span></span><br><span class="line">&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;</span><br><span class="line"><span class="comment"># 设置苹果工具栏颜色</span></span><br><span class="line">&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt;  </span><br><span class="line"><span class="comment"># 启用360浏览器的极速模式(webkit)</span></span><br><span class="line">&lt;meta name=”renderer” content=”webkit”&gt; </span><br><span class="line"><span class="comment"># 避免IE使用兼容模式</span></span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt;</span><br><span class="line"><span class="comment"># 不让百度转码</span></span><br><span class="line">&lt;meta name=”HandheldFriendly” content=”<span class="literal">true</span>”&gt;</span><br><span class="line"><span class="comment"># 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓</span></span><br><span class="line">&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt;</span><br><span class="line"><span class="comment"># 微软的老式浏览器</span></span><br><span class="line">&lt;meta name=”MobileOptimized” content=”320″&gt;</span><br><span class="line"><span class="comment"># uc强制竖屏</span></span><br><span class="line">&lt;meta name=”screen-orientation” content=”portrait”&gt;</span><br><span class="line"><span class="comment"># QQ强制竖屏</span></span><br><span class="line">&lt;meta name=”x5-orientation” content=”portrait”&gt;</span><br><span class="line"><span class="comment"># UC强制全屏</span></span><br><span class="line">&lt;meta name=”full-screen” content=”yes”&gt;</span><br><span class="line"><span class="comment"># QQ强制全屏</span></span><br><span class="line">&lt;meta name=”x5-fullscreen” content=”<span class="literal">true</span>”&gt;</span><br><span class="line"><span class="comment"># UC应用模式</span></span><br><span class="line">&lt;meta name=”browsermode” content=”application”&gt;</span><br><span class="line"><span class="comment"># QQ应用模式</span></span><br><span class="line">&lt;meta name=”x5-page-mode” content=”app”&gt;</span><br><span class="line"><span class="comment"># windows phone 点击无高光</span></span><br><span class="line">&lt;meta name=”msapplication-tap-highlight” content=”no”&gt;</span><br><span class="line">设置页面不缓存</span><br><span class="line">&lt;meta http-equiv=”pragma” content=”no-cache”&gt;</span><br><span class="line">&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;</span><br><span class="line">&lt;meta http-equiv=”expires” content=”0″&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> H5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/25/HTTP/TCP%E3%80%81UDP%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E3%80%81DNS/"/>
      <url>/2019/03/25/HTTP/TCP%E3%80%81UDP%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E3%80%81DNS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载：<br>　　<a href="https://juejin.im/post/5bbaa549e51d450e827b6b13#heading-0" target="_blank" rel="noopener">一篇文章搞定前端面试</a></p><p>TCP<br>UDP<br>套接字socket<br>HTTP协议<br>DNS解<br>HTTP请求发起和响应<br>页面渲染的过程<br>页面的性能优化</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/25/JavaScript/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/03/25/JavaScript/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一行代码实现数组去重？<br><code>[...new Set([1,2,3,1,&#39;a&#39;,1,&#39;a&#39;])]</code><br>怎么判断两个对象相等？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">obj=&#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:2</span><br><span class="line">&#125;</span><br><span class="line">obj2=&#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:2</span><br><span class="line">&#125;</span><br><span class="line">obj3=&#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:&apos;2&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JSON.stringify(obj)==JSON.stringify(obj2);//true</span><br><span class="line">JSON.stringify(obj)==JSON.stringify(obj3);//false</span><br></pre></td></tr></table></figure></p><p>CommonJS 中的 require/exports 和 ES6 中的 import/export 区别？</p><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。<br>ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。<br>import/export 最终都是编译为 require/exports 来执行的。<br>CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。<br>export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><p>浏览器缓存<br>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：</p><p>先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；<br>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；<br>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；<br>区别是，强缓存不对发送请求到服务器，但协商缓存会。<br>当协商缓存也没命中时，服务器就会将资源发送回客户端。<br>当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；<br>当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；</p><p>强缓存</p><p>Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）<br>Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）</p><p>协商缓存</p><p>Last-Modified（值为资源最后更新时间，随服务器response返回）<br>If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）<br>ETag（表示资源内容的唯一标识，随服务器response返回）<br>If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</p><p>页面渲染的完整流程是怎样的？</p><h3 id="图片里的-alt-属性是做什么的？"><a href="#图片里的-alt-属性是做什么的？" class="headerlink" title="图片里的 alt 属性是做什么的？"></a>图片里的 alt 属性是做什么的？</h3><p>查看答案<br>如果用户看不到图像，alt 属性可以提供替代信息。alt 属性应该用于描述，而那些仅仅是装饰目的图像，可以为空</p><p>小贴士<br>装饰性的图像应该有一个空的 alt 属性<br>web 爬虫可以通过 alt 属性理解图像的信息，因此认为它对于搜索引擎优化（SEO）非常重要<br>在 alt 末尾加 . 可以提高访问性</p><h3 id="不采用缓存的目的是什么，你如何实现它？"><a href="#不采用缓存的目的是什么，你如何实现它？" class="headerlink" title="不采用缓存的目的是什么，你如何实现它？"></a>不采用缓存的目的是什么，你如何实现它？</h3><p>查看答案<br>浏览器有一个临时的存储网站文件的缓存，所以他们不需要在切换或重新加载同一个页面时再次重新下载。服务器设置发送头信息告诉浏览器在给定的一段时间内使用存储文件。这极大加快了网站的速度和节省了带宽</p><p>然而，当开发人员网站更新时，因为用户的缓存依然指向旧的文件，这会造成问题。如果缓存的 CSS 和 JavaScript 文件引用的元素不再存在，已移除或已重命名时，它会保留原有功能或破坏网站</p><p>禁用缓存是一个强制浏览器下载新文件的过程。通过命名来区分于旧文件</p><p>一个常用的强制浏览器重新下载文件的技术是在文件的结尾处增加一个查询字符串</p><p>src=”js/script.js” =&gt; src=”js/script.js?v=2”<br>浏览器认为这是一个不同的文件但是避免了修改文件名的必要</p><h3 id="一个页面里是否可以包含多个-元素，-元素呢？"><a href="#一个页面里是否可以包含多个-元素，-元素呢？" class="headerlink" title="一个页面里是否可以包含多个  元素，  元素呢？"></a>一个页面里是否可以包含多个 <header> 元素， <footer> 元素呢？</footer></header></h3><p>查看答案<br>都可以。W3C 文档声明这些标签代表离它们最近祖先区域的页眉（<header>）和页脚（<footer>）。因此，不只是可以在页面的 <body> 里包含页眉和页脚，而且每一个 <article> 和 <section> 元素都可以包含</section></article></body></footer></header></p><p>小贴士<br>W3C 推荐你想用多少就用多少，但是每一个页面的区域只能有一个，即，body，section 等等</p><h3 id="lt-script-gt-标签的-defer-和-async-是什么？"><a href="#lt-script-gt-标签的-defer-和-async-是什么？" class="headerlink" title="&lt;script&gt; 标签的 defer 和 async 是什么？"></a><code>&lt;script&gt;</code> 标签的 defer 和 async 是什么？</h3><p>查看答案<br>如果两个属性都没有的话，脚本将同步下载和执行，并且会阻塞 document 解析，直到脚本执行完成（默认行为）。脚本下载和执行按它们书写的顺序进行</p><p>defer 属性在 document 解析的过程中下载脚本，但是在 document 解析完成之前执行，等价于执行了一个内置的事件监听器 DOMContentLoaded。defer 脚本顺序执行</p><p>async 属性在 document 解析过程中下载脚本，但是会暂停解析器，直到脚本解析执行完成。async 不一定按顺序执行</p><p>注意：两个属性必须在脚本拥有 src 属性时才起作用（即，在内联脚本不起作用）</p><p><script src="myscript.js"></script></p><p><script src="myscript.js" defer></script></p><p><script src="myscript.js" async></script><br>小贴士<br>请用 <head> 中放置一个 defer，允许浏览器在页面还在解析过程中下载脚本，因此把脚本放到 body 之前是更好的选择<br>如果脚本之间相互依赖，请用 defer.<br>如果脚本是独立的，请用 async.<br>如果 DOM 必须加载完并且内容还未放置到 DOMContentLoaded 监听器中时，请用 defer</head></p><h3 id="相比-HTML，XHTML-有哪些不同？"><a href="#相比-HTML，XHTML-有哪些不同？" class="headerlink" title="相比 HTML，XHTML 有哪些不同？"></a>相比 HTML，XHTML 有哪些不同？</h3><p>查看答案<br>有一些关键区别：</p><p>一个 XHTML 元素必须要有一个 XHTML <doctype><br>属性值必须用引号包裹<br>禁止属性简写（例如，checked=”checked” 不能简写为 checked）<br>元素必须正确的被嵌套<br>元素必须闭合<br>特殊字符必须被转义<br>小贴士<br>任何被标签都是自闭合<br>标签和属性区分大小写，通常小写</doctype></p><h3 id="你能说出-media-属性的四种类型吗？"><a href="#你能说出-media-属性的四种类型吗？" class="headerlink" title="你能说出 @media 属性的四种类型吗？"></a>你能说出 @media 属性的四种类型吗？</h3><p>查看答案<br>all，适用于所有媒体设备<br>print，仅适用于打印机<br>screen，仅适用于屏幕设备（台式电脑、平板电脑、移动设备等）<br>speech，仅适用于屏幕阅读器</p><p>如何统计网页里出现多少种html标签<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有标签</span></span><br><span class="line">var doms = document.getElementsByTagName(<span class="string">"*"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#去重</span></span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">var ret = []</span><br><span class="line"><span class="keyword">for</span> (var j = 0; j &lt; doms.length; i++) &#123;</span><br><span class="line">  var name = doms[j].nodeName</span><br><span class="line">  <span class="keyword">if</span>(!obj[name]) &#123;</span><br><span class="line">    ret.push(name)</span><br><span class="line">    obj[name] = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(ret.length);</span><br><span class="line"></span><br><span class="line"><span class="comment"># ES6方法</span></span><br><span class="line">const names = [...document.getElementsByTagName(<span class="string">"*"</span>)].map(v=&gt;v.nodeName)</span><br><span class="line"></span><br><span class="line">console.log(new Set(names).size);</span><br></pre></td></tr></table></figure></p><p>手写bind call<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call = <span class="keyword">function</span>(context) &#123;</span><br><span class="line">  context = context || window</span><br><span class="line">  context.fn = this</span><br><span class="line">  const args = [...arguments].slice(1)</span><br><span class="line">  const result = context.fn(...args)</span><br><span class="line">  delete context.fn</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function.prototype.bind = <span class="keyword">function</span>(context) &#123;</span><br><span class="line">  const _this = this</span><br><span class="line">  const args = [...arguments].slice(1)</span><br><span class="line">  // 返回一个高阶函数</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(this instanceof F) &#123;</span><br><span class="line">      <span class="built_in">return</span> new _this(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如何提升渲染性能<br>服务端渲染<br>为什么要进行服务端渲染</p><p>JS<br>回收机制<br>String、Array类型的方法使用<br>原型与原型链<br>构造函数模型/原型模型<br>闭包/递归<br>BOM<br>操作BOM结构<br>事件冒泡/捕获<br>AJAX请求</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>定位</title>
      <link href="/2019/03/22/CSS3/%E5%AE%9A%E4%BD%8D/"/>
      <url>/2019/03/22/CSS3/%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>position<br>static<br>表示没有定位，元素出现在正常的文档流中。<br>为静态定位的元素设置 top|bottom|left|right 不起作用。<a id="more"></a><br>fixed<br>元素的位置相对于浏览器窗口是固定位置。<br>即使浏览器的窗口是滚动的它也不会移动。<br>fixed定位使得元素脱离了文档流，因而不占据空间。<br>设置了固定定位的元素宽高由其内部元素撑起。<br>relative<br>相对定位的元素是相对其正常位置。<br>1.使用了相对定位元素的元素，其参照物是其本身，其偏移量由TRBL(top，right,bottom,left)的值确定。<br>2.使用了相对定位的元素，仍然会在标准流中占据原来的位置，它对父元素和兄弟元素没有影响。<br>3.相对定位的使用场景往往是作为绝对定位元素的参照物。<br>absolute<br>绝对定位的元素的位置是相对其最近的已定位父元素（也就是除static之外），如果找不到已定位的父元素，那么就相对于<code>&lt;html&gt;</code>元素。<br>absolute定位使得元素脱离了文档流，因而不占据空间。<br>设置了绝对定位的元素宽高由其内部元素撑起。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/22/Vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/03/22/Vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.cnblogs.com/happ0/p/8075562.html" target="_blank" rel="noopener">vue 生命周期 详解</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>网络安全(SQL、XSS、CSRF)</title>
      <link href="/2019/03/21/JavaScript/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
      <url>/2019/03/21/JavaScript/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载：<br>　　<a href="http://netsecurity.51cto.com/art/201901/590563.htm" target="_blank" rel="noopener">3大Web安全漏洞防御详解：XSS、CSRF、以及SQL注入解决方案</a><br>参考：<br>　　<a href="https://www.cnblogs.com/443855539-wind/p/6055816.html" target="_blank" rel="noopener">前端安全（XSS、CSRF防御）</a><br>　　<a href="https://segmentfault.com/a/1190000007059639" target="_blank" rel="noopener">用大白话谈谈XSS与CSRF</a><br>常见的Web安全分为两种前端安全(XSS攻击、CSRF攻击)和后端安全(SQL注入)</p><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>　　XSS：中译是<code>跨站脚本攻击</code>（<code>Cross-site scripting</code>，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。<code>这类攻击通常包含了HTML以及用户端脚本语言</code>。<a id="more"></a><br>　　XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码。</p><h4 id="XSS攻击的危害"><a href="#XSS攻击的危害" class="headerlink" title="XSS攻击的危害"></a>XSS攻击的危害</h4><p>　　1. 盗取用户资料，比如：登录帐号、网银帐号等<br>　　2. 利用用户身份，读取、篡改、添加、删除数据等<br>　　3. 盗窃重要的具有商业价值的资料<br>　　4. 非法转账<br>　　5. 强制发送电子邮件<br>　　6. 网站挂马<br>　　7. 控制受害者机器向其它网站发起攻击</p><h4 id="防止XSS的解决方法"><a href="#防止XSS的解决方法" class="headerlink" title="防止XSS的解决方法"></a>防止XSS的解决方法</h4><p><code>XSS</code>的根源主要是没完全过滤客户端提交的数据 ，所以重点是要过滤用户提交的信息。<br>　　1. 将重要的cookie标记为<code>http only</code>, 这样的话js 中的<code>document.cookie</code>语句就不能获取到<code>cookie</code>了.<br>　　2. 只允许用户输入我们期望的数据。 例如：<code>age</code>用户年龄只允许用户输入数字，而数字之外的字符都过滤掉。<br>　　3. 对数据进行<code>Html Encode</code>处理：用户将数据提交上来的时候进行<code>HTML</code>编码，将相应的符号转换为实体名称再进行下一步的处理。<br>　　4. 过滤或移除特殊的<code>Html</code>标签。<br>　　5. 过滤<code>js</code>事件的标签。例如 <code>&quot;onclick=&quot;</code>, <code>&quot;onfocus&quot;</code>等等。</p><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>　　CSRF:跨站请求伪造（英语：<code>Cross-site request forgery</code>），也被称为 <code>one-click attack</code> 或者 <code>session riding</code>，通常缩写为 <code>CSRF</code> 或者 <code>XSRF</code>，是一种挟制用户在当前已登录的Web应用程序上<code>执行非本意的操作的攻击方法</code>。<br>　　XSS主要是利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求，来利用受信任的网站。与XSS攻击相比，CSRF更具危险性。</p><h4 id="CSRF攻击危害"><a href="#CSRF攻击危害" class="headerlink" title="CSRF攻击危害"></a>CSRF攻击危害</h4><p>　　主要的危害来自于，攻击者盗用用户身份，发送恶意请求。比如：模拟用户发送邮件，发消息，以及支付、转账等。</p><h4 id="防止CSRF的解决方法"><a href="#防止CSRF的解决方法" class="headerlink" title="防止CSRF的解决方法"></a>防止CSRF的解决方法</h4><p>　　1. 重要数据交互采用POST进行接收，当然是用POST也不是万能的，伪造一个form表单即可破解。<br>　　2. 使用验证码，只要是涉及到数据交互就先进行验证码验证，这个方法可以完全解决CSRF。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。<br>　　3. 验证HTTP Referer字段，该字段记录了此次HTTP请求的来源地址，最常见的应用是图片防盗链。<br>　　4. 为每个表单添加令牌token并验证。</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>　　SQL注入是比较常见的网络攻击方式之一，主要是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，实现无帐号登录，甚至篡改数据库。</p><h4 id="SQL注入的危害"><a href="#SQL注入的危害" class="headerlink" title="SQL注入的危害"></a>SQL注入的危害</h4><p>　　1. 数据库信息泄漏：数据库中存放的用户的隐私信息的泄露<br>　　2. 网页篡改：通过操作数据库对特定网页进行篡改<br>　　3. 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改<br>　　4. 服务器被远程控制，被安装后门<br>　　5. 删除和修改数据库表信息</p><h4 id="SQL注入的方式"><a href="#SQL注入的方式" class="headerlink" title="SQL注入的方式"></a>SQL注入的方式</h4><p>通常情况下，SQL注入的位置包括：<br>　　1. 表单提交，主要是POST请求，也包括GET请求;<br>　　2. URL参数提交，主要为GET请求参数;<br>　　3. Cookie参数提交;<br>　　4. HTTP请求头部的一些可修改的值，比如Referer、User_Agent等;</p><h4 id="防止SQL注入的解决方法"><a href="#防止SQL注入的解决方法" class="headerlink" title="防止SQL注入的解决方法"></a>防止SQL注入的解决方法</h4><p>　　1. 对用户的输入进行校验，使用正则表达式过滤传入的参数<br>　　2. 使用参数化语句，不要拼接sql，也可以使用安全的存储过程<br>　　3. 不要使用管理员权限的数据库连接，为每个应用使用权限有限的数据库连接<br>　　4. 检查数据存储类型<br>　　5. 重要的信息一定要加密</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/21/JavaScript/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2019/03/21/JavaScript/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Mvvm响应式原理？"><a href="#Mvvm响应式原理？" class="headerlink" title="Mvvm响应式原理？"></a>Mvvm响应式原理？</h3><p>原型链？<br>闭包？应用场景？<br>Es6的新特性？<br>Html大纲？<br>Js数据类型，堆和栈的区别？<br>Vue的diff算法？怎么样才算samenode（源码相关）？比较子节点的时候顺序比较行不行？<br>用defineProperty进行数据劫持的缺点？怎么办（考察vue3.0数据劫持的方式proxy）？<br>手写二分查找<br>Css盒子模型？<br>Express中间件？<br>Symbol？作用？<br>三面约的19：10，结果前面面试的同学太多了，到19：45才面上<br>腾讯三面（电话，20min左右）：</p><ol><li>从输入url到显示页面的过程？<br>dns域名解析<br>建立连接 三次握手<br>发送 http请求<br>服务器处理请求<br>返回相应结果<br>页面渲染</li><li>这个过程中有哪些会影响性能？</li><li>Es6有哪些了解？<br>2.做过什么项目？<br>3.了解es6吗<br>4.promise原理<br>5.了解什么算法？<br>6.堆排序过程，时间复杂度（nlogn,他还让我再想一下？？），应用场景（没答出来，哭）。<br>7.用过的技术栈<br>8.怎么学习前端<br>9.问题：公司主要用react，vue哪个，为什么用它呢？</li></ol><p>什么时候开始学习的前端？<br>==和===的区别<br>JS 继承（ES6 extends、ES5 各种继承）<br>怎么判断参数是数组还是对象？（Array.isArray、toString、instanceOf）<br>问项目，技术方案，话题转 Vue<br>Vue 生命周期有哪些？（Create、Mount、Active、Update、Deactive、Destory）<br>DOM 结点在什么时候挂载？<br>Vue 能不能挂载到body或html标签上，为什么？<br>项目开发联调方式？</p><p>写一个两边定宽，中间自适应的布局（dispaly: flex、双飞翼/圣杯、position: absolute）<br>垂直居中方案（line-height、transform）<br>JS 怎么对象的属性是数组还是对象（参考一面第 8 问），<br>解释下每个方法怎么判断（数组 Object.prototype.toString.call之后是[object, Array]，对象toString之后是[object, object]，instanceOf就是返回true还是false）<br>JS 继承（ES6 extends、原型链、构造），<br>解释下原型链和构造哪个好，好在哪里，原型链继承的时候，可不可以直接A.prototype = B()，而不是A.prototype = new B()，为什么<br>构造继承为什么用call，而不是apply？（参数不同，一个数组，一个不定参数），追问哪个参数是数组？（apply）<br>实现一个数组去重（Array.from(new Set(arr))），不用 ES6 实现一个对所有数组有可以调用的去重（forindexOf，添加到Array.prototype），面试官说i</p><p>跨域的方式<br>websocket和Http的区别<br>长轮询<br>cookie和session，没有cookie的话session能不能使用<br>浏览器缓存机制，304是协商缓存还是强缓存<br>类数组变成数组<br>let和var的区别<br>CSRF以及Token验证的Token放在哪里<br>TCP三次握手，如果没有三次握手会怎样<br>Vue用watch实现数据双向绑定<br>重绘和重排，什么操作会造成重排<br>LESS怎么遍历一个列表<br>await语法<br>JS继承有哪几种，具体的实现及原理<br>常见的HTTP状态码各个是什么意思<br>介绍浏览器缓存？各个响应头优先级？以及之间的区别，可以取的值，分别是什么意思<br>介绍浏览器时间<br>介绍一下跨域，各个跨域的具体实现方法？以及JSONP实现方式中服务器是怎样交互的<br>介绍一下网络安全（xss以及csrf具体防范方法）</p><p>行内元素和块级元素二者区别<br>css选择器有哪些，怎么样计算<br>JS面向对象的理解<br>盒子模型，box-sizing<br>常用的设计模式，<br>封装一个函数判断数据类型，数组还是对象<br>状态码404 400 502 304<br>http底层协议<br>http协议用在tcp还是udp<br>三次握手，四次握手，两次握手，<br>time wait 2ml 的原因<br>浏览器缓存，硬盘（持久化）<br>数据结构，快速排序，稳定的还是不稳定的。最差的时间复杂度<br>内存存不下，很多个数据，找出最大的10个或者100个<br>哈希<br>操作系统 nio, i/o操作<br>计算机组成原理，数据用什么码储存的，正负数的储存，负数的源码补码<br>基址寻址和变址寻址<br>get，post请求最本质的区别<br>多路复用<br>事件代理。常规做法的优势体现在哪里<br>session。分布式集群，如何保障session可以保持相同<br>浏览器cookie禁掉session是哪一端session特别多怎么办</p><p>进程和线层的区别<br>内存分配<br>闭包、作用域链<br>vue生命周期<br>css3动画，怎么做<br>单行文本溢出，多行文本溢出代码实现<br>bfc布局<br>js类型，封装一个类型鉴定函数<br>闭包，哪里用到立即执行函数解决闭包中访问变量的问题<br>时间轮询机制<br>原生js实现bind函数<br>一个函数，然后让你说他们的值是多少，为什么<br>预编译、严格模式、作用域链<br>算法 快排 选择排序<br>浏览器渲染原理</p><p>实现一个构造函数new的时候每次加一<br>css性能优化</p><p>js作用域链怎么来的<br>this<br>cdn有存在的必要吗</p><h4 id="2019-5-16"><a href="#2019-5-16" class="headerlink" title="2019/5/16"></a>2019/5/16</h4><p>1、不定高盒子水平垂直居中<br>2、跨域<br>3、meta标签<br>4、jsonp<br>5、同源<br>6、闭包<br>7、深浅拷贝<br>8、HTTP状态码401<br>9、cookie、session、本地缓存<br>10、stylus</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>主流浏览器内核</title>
      <link href="/2019/03/19/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/"/>
      <url>/2019/03/19/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p>　　浏览器内核可以分为两部分：<strong>渲染引擎</strong>(<code>layout engineer</code> 或者 <code>Rendering Engine</code>)和<strong>JS引擎</strong><a id="more"></a><br>　　浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p><h5 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h5><p>　　渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等）、以及计算网页的显示方式，然后会输出至显示器或打印机。</p><h5 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h5><p>　　JS 引擎则是解析<code>Javascript</code>语言，执行<code>javascript</code>语言来实现网页的动态效果。<br>　　最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 <code>JS引擎越来越独立，内核就倾向于只指渲染引擎</code>。</p><h4 id="主流浏览器内核"><a href="#主流浏览器内核" class="headerlink" title="主流浏览器内核"></a>主流浏览器内核</h4><p><code>Trident</code>内核：IE<br><code>Gecko</code>内核：NETSCAPE6及以上版本，火狐(Mozilla FireFox)<br><code>Presto</code>内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink;]<br><code>Webkit</code>内核：Safari，Chrome等。<br>Chrome的：<code>Blink</code>（WebKit的分支）</p><h4 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h4><p>移动端的浏览器内核主要说的是<code>系统内置浏览器的内核</code>。<br>目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 。<br>1、iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit。<br>2、Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink。<br>3、Windows Phone 8 系统浏览器内核是 Trident。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS3新特性</title>
      <link href="/2019/03/18/CSS3/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/03/18/CSS3/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>实现圆角<code>border-radius</code>，<br>阴影<code>box-shadow</code>，<br>边框图片<code>border-image</code><br>对文字加特效<code>text-shadow</code>，<br>强制文本换行<code>word-wrap</code>，<br>线性渐变<code>linear-gradient</code><a id="more"></a><br>实现旋转<code>transform:rotate(90deg)</code>,<br>缩放<code>scale(0.85,0.90)</code>,<br>定位<code>translate(0px,-30px)</code>,<br>倾斜<code>skew(-9deg,0deg)</code>;<br>增加了更多的<code>CSS</code>选择器、多背景、<code>rgba()</code><br>唯一引入的伪元素是<code>::selection</code>；<br>实现媒体查询<code>@media</code>，多栏布局<code>flex</code><br>过渡<code>transition</code><br>动画<code>animation</code><br><code>text-overflow</code>(文本溢出隐藏)<br><code>CSS3</code>中，<code>text-shadow</code>可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。<br><code>CSS3</code>新增了几个关于背景的属性，分别是<code>background-clip</code>、<code>background-origin</code>、<code>background-size</code>和<code>background-break</code>。<br><code>text-decoration</code>:CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：<br>　　<code>text-fill-color</code>: 设置文字内部填充颜色<br>　　<code>text-stroke-color</code>: 设置文字边界填充颜色<br>　　<code>text-stroke-width</code>: 设置文字边界宽度</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Url、Href、Src、Link详解</title>
      <link href="/2019/03/18/CSS3/Url%E3%80%81Href%E3%80%81Src%E3%80%81Link/"/>
      <url>/2019/03/18/CSS3/Url%E3%80%81Href%E3%80%81Src%E3%80%81Link/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载：<br>　　<a href="https://segmentfault.com/a/1190000002877022" target="_blank" rel="noopener">url、href、src 详解</a><br><a id="more"></a></p><h4 id="Url"><a href="#Url" class="headerlink" title="Url"></a>Url</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>　　<code>URL</code>(<code>Uniform Resource Locator</code>)统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的<code>URL</code>，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><h5 id="Url格式"><a href="#Url格式" class="headerlink" title="Url格式"></a>Url格式</h5><p><strong>标准格式</strong><br>　　协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名?查询<br><strong>完整格式</strong><br>　　协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名?查询</p><h6 id="Url语法规则"><a href="#Url语法规则" class="headerlink" title="Url语法规则"></a>Url语法规则</h6><p>　　比如网址<code>http://segmentfault.com/html/index.asp</code>必须遵守以下的语法规则:<br><code>scheme://host.domain:port/path/filename</code><br><strong>说明</strong><br>　　<code>scheme</code> - 定义因特网服务的类型。最常见的类型是 http<br>　　<code>host</code> - 定义域主机（http 的默认主机是 www）<br>　　<code>domain</code> - 定义因特网域名，比如 w3school.com.cn<br>　　<code>:port</code> - 定义主机上的端口号（http 的默认端口号是 80）<br>　　<code>path</code> - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。<br>　　<code>filename</code> - 定义文档/资源的名称</p><h6 id="URL-Schemes"><a href="#URL-Schemes" class="headerlink" title="URL Schemes"></a>URL Schemes</h6><table><thead><tr><th style="text-align:left">Scheme</th><th style="text-align:left">访问</th><th style="text-align:center">用于</th></tr></thead><tbody><tr><td style="text-align:left">http</td><td style="text-align:left">超文本传输协议</td><td style="text-align:center">以 http:// 开头的普通网页。不加密。</td></tr><tr><td style="text-align:left">https</td><td style="text-align:left">安全超文本传输协议</td><td style="text-align:center">安全网页。加密所有信息交换。</td></tr><tr><td style="text-align:left">ftp</td><td style="text-align:left">文件传输协议</td><td style="text-align:center">用于将文件下载或上传至网站。</td></tr><tr><td style="text-align:left">file</td><td style="text-align:left"></td><td style="text-align:center">您计算机上的文件。</td></tr></tbody></table><h6 id="URL的类型"><a href="#URL的类型" class="headerlink" title="URL的类型"></a>URL的类型</h6><p><strong>绝对URL</strong><br>　　绝对<code>URL</code>（<code>absolute URL</code>）显示文件的完整路径，这意味着绝对<code>URL</code>本身所在的位置与被引用的实际文件的位置无关。<br><strong>相对URL</strong><br>　　相对<code>URL</code>（<code>relative URL</code>）以包含<code>URL</code>本身的文件夹的位置为参考点，描述目标文件夹的位置。<br>　　一般来说，对于同一服务器上的文件，应该总是使用相对<code>URL</code>，它们更容易输入，而且在将页面从本地系统转移到服务器上时更方便，只要每个文件的相对位置保持不变，链接就仍然是有效地。<br><code>.</code>：代表目前所在的目录，相对路径。<br>例： <code>&lt;a href=&quot;./abc&quot;&gt;文本&lt;/a&gt;</code> 或 <code>&lt;img src=&quot;./abc&quot; /&gt;</code><br><code>..</code>：代表上一层目录，相对路径。<br>例： <code>&lt;a href=&quot;../abc&quot;&gt;文本&lt;/a&gt;</code>或 <code>&lt;img src=&quot;../abc&quot; /&gt;</code><br><code>../../</code>：代表的是上一层目录的上一层目录，相对路径。<br>例： <code>&lt;img src=&quot;../../abc&quot; /&gt;</code><br><code>/</code>：代表根目录，绝对路径。<br>例： <code>&lt;a href=&quot;/abc&quot;&gt;文本&lt;/a&gt;</code> 或 <code>&lt;img src=&quot;/abc&quot; /&gt;</code></p><h4 id="Href"><a href="#Href" class="headerlink" title="Href"></a>Href</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>　　<code>href</code> (<code>Hypertext Reference</code>)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。</p><h5 id="通俗理解"><a href="#通俗理解" class="headerlink" title="通俗理解"></a>通俗理解</h5><p>　　<code>href</code>: 目的不是为了引用资源，而是为了建立这个标签与外部资源之间的关系，让当前标签能够链接到目标地址。<br><code>&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;</code>浏览器加载到这里的时候，html的渲染和解析不会暂停，css文件的加载是同时进行的</p><h4 id="Src"><a href="#Src" class="headerlink" title="Src"></a>Src</h4><p>　　<code>src</code>用于替代这个元素: <code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code>当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个js文件</p><h4 id="Href和Src的区别"><a href="#Href和Src的区别" class="headerlink" title="Href和Src的区别"></a>Href和Src的区别</h4><p><strong>请求资源类型不同</strong><br>　　href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。<br>　　在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；<br><strong>作用结果不同</strong><br>　　href 用于在当前文档和引用资源之间确立联系；<br>　　src 用于替换当前内容；<br><strong>浏览器解析方式不同</strong><br>　　若在文档中添加 <code>&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;/&gt;</code>，浏览器会识别该文档为 <code>CSS</code> 文件，就会并行下载资源并且<code>不会停止</code>对当前文档的处理。这也是为什么建议使用 <code>link</code> 方式加载 <code>CSS</code>，而不是使用<code>@import</code> 方式。<br>　　当浏览器解析到 <code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code>，会<code>暂停</code>其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 <code>js</code> 脚本放在底部而不是头部的原因。</p><h4 id="Link和-import的区别"><a href="#Link和-import的区别" class="headerlink" title="Link和@import的区别"></a>Link和@import的区别</h4><p>两者都是外部引用 <code>CSS</code> 的方式，但是存在一定的区别：<br>（1）<code>link</code>是<code>XHTML</code>标签，除了能够加载<code>CSS</code>，还可以定义<code>RSS</code>等其他事务；而<code>@import</code>属于<code>CSS</code>范畴，只可以加载<code>CSS</code>。<br>（2）<code>link</code>引用<code>CSS</code>时，在页面载入时同时加载；<code>@import</code>需要页面完全载入以后再加载。<br>（3）<code>link</code>是<code>XHTML</code>标签，无兼容问题；<code>@import</code>则是在<code>CSS2.1</code>提出的，低版本的浏览器不支持。<br>（4）<code>link</code>支持使用<code>Javascript</code>控制<code>DOM</code>改变样式；而<code>@import</code>不支持。</p><h4 id="为什么尽量不要使用-import加载css"><a href="#为什么尽量不要使用-import加载css" class="headerlink" title="为什么尽量不要使用@import加载css"></a>为什么尽量不要使用@import加载css</h4><p>使用<code>@import</code>会导致和预期不一致的下载顺 序。<br>我们确实要避免使用<code>css @import，</code>但原因却不是什么相当于放在了页面底部，而是这样做会导致<code>css</code>无法并行下载，因为使用<code>@import</code>引用的文件只有在引用它的那个<code>css</code>文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建<code>render tree</code>等一系列操作。 浏览器在页面所有<code>css</code>下载并解析完成后才会开始渲染页面（<code>Before a browser can begin to render a web page, it mustdownload and parse any stylesheets that are required to lay out thepage. Even if a stylesheet is in an external file that is cached,rendering is blocked until the browser loads the stylesheet from disk.</code>），因此<code>css @import</code>引起的<code>css</code>解析延迟会加长页面留白期。 所以，要尽量避免使用<code>css @import</code>而尽量采用<code>link</code>标签的方式引入。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>同源策略和跨域</title>
      <link href="/2019/03/17/Ajax/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F/"/>
      <url>/2019/03/17/Ajax/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载:<br>　　<a href="https://segmentfault.com/a/1190000012469713" target="_blank" rel="noopener">ajax跨域，这应该是最全的解决方案了</a><br>参考:<br>　　<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法</a><br>　　<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>同源即指：协议相同、域名相同、端口号相同。<br><a id="more"></a><br>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/dir2/other.html：同源</span><br><span class="line">http://example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://v2.www.example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://www.example.com:81/dir/other.html：不同源（端口不同）</span><br></pre></td></tr></table></figure></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>　　同源政策的目的，是为了<strong>为了保证使用者信息的安全，防止恶意网站篡改用户数据</strong>。<br>　　设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的<code>Cookie</code>，会发生什么？<br>　　很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，<code>Cookie</code> 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。<br>　　由此可见，”同源政策”是必需的，否则 <code>Cookie</code> 可以共享，互联网就毫无安全可言了。</p><h3 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h3><p>　　随着互联网的发展，”同源政策”越来越严格。目前，非同源的网站之间，共有四种行为受到限制。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1） Cookie、LocalStorage 和 IndexDB 无法读取。</span><br><span class="line">（2） DOM 无法获得。</span><br><span class="line">（3） AJAX 请求不能发送。</span><br><span class="line">（4）无法通过 flash 发送 http 请求</span><br></pre></td></tr></table></figure></p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>　　同源策略做了很严格的限制，但是在实际的场景中，又确实有很多地方需要突破同源策略的限制，也就是我们常说的跨域。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>　　同源策略最早被提出的时候，为的就是防止不同域名的网页之间共享 <code>cookie</code>。<code>Cookie</code>是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享<code>Cookie</code>。<br>举个例子，<br><code>https://market.douban.com</code>和<code>https://book.douban.com</code>，这两个网页的一级域名都是 <code>douban.com</code>，如果我在 <code>market.douban.com</code>中执行了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#A、B页面设置相同的document.domain</span></span><br><span class="line">document.domain = <span class="string">'douban.com'</span></span><br><span class="line"><span class="comment"># A页面通过脚本设置一个Cookie</span></span><br><span class="line">document.cookie = <span class="string">'cross=yes'</span></span><br><span class="line">或</span><br><span class="line">document.cookie = <span class="string">'cross=yes;path=/;domain=douban.com'</span></span><br><span class="line"><span class="comment"># B页面就可以读取到Cookie</span></span><br><span class="line">var allCookie = document.cookie</span><br></pre></td></tr></table></figure></p><p>这样设置了 <code>cookie</code>之后，在<code>book.douban.com</code>中是可以取到这个<code>cookie</code>的。<br>除了在前端设置之外，也可以直接在<code>response</code>里将<code>cookie</code>的<code>domain</code>设置成 <code>.douban.com</code>。</p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="什么是Ajax跨域"><a href="#什么是Ajax跨域" class="headerlink" title="什么是Ajax跨域"></a>什么是Ajax跨域</h4><h5 id="ajax跨域的原理"><a href="#ajax跨域的原理" class="headerlink" title="ajax跨域的原理"></a>ajax跨域的原理</h5><p>　　<code>ajax</code>出现请求跨域错误问题,主要原因就是因为浏览器的“同源策略”,可以参考</p><h5 id="ajax跨域的表现"><a href="#ajax跨域的表现" class="headerlink" title="ajax跨域的表现"></a>ajax跨域的表现</h5><p>　　<code>ajax</code>请求时,如果存在跨域现象,并且没有进行解决,会有如下表现:(注意，是<code>ajax</code>请求，请不要说为什么<code>http</code>请求可以，而<code>ajax</code>不行，因为<code>ajax</code>是伴随着跨域的，所以仅仅是<code>http</code>请求<code>ok</code>是不行的)<br><strong>第一种现象</strong>:<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>,并且<code>The response had HTTP status code 404</code><br><img src="/assets/images/ajax001.png" alt="ajax001"><br>出现这种情况的原因如下：<br>　　本次ajax请求是“非简单请求”,所以请求前会发送一次预检请求(<code>OPTIONS</code>)<br>　　服务器端后台接口没有允许<code>OPTIONS</code>请求,导致无法找到对应接口地址<br>解决方案: 后端允许options请求<br><strong>第二种现象</strong>:<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>,并且<code>The response had HTTP status code 405</code><br><img src="/assets/images/ajax002.png" alt="ajax001"><br>这种现象和第一种有区别,这种情况下，后台方法允许<code>OPTIONS</code>请求,但是一些配置文件中(如安全配置),阻止了<code>OPTIONS</code>请求,才会导致这个现象<br>解决方案: 后端关闭对应的安全配置<br><strong>第三种现象</strong>:<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>,并且<code>status 200</code><br><img src="/assets/images/ajax003.png" alt="ajax001"><br>这种现象和第一种和第二种有区别,这种情况下，服务器端后台允许<code>OPTIONS</code>请求,并且接口也允许<code>OPTIONS</code>请求,但是头部匹配时出现不匹配现象<br>比如<code>origin</code>头部检查不匹配,比如少了一些头部的支持(如常见的<code>X-Requested-With</code>头部),然后服务端就会将<code>response</code>返回给前端,前端检测到这个后就触发<code>XHR.onerror</code>,导致前端控制台报错<br>解决方案: 后端增加对应的头部支持<br><strong>第四种现象</strong>:<code>heade contains multiple values &#39;*,*&#39;</code><br><img src="/assets/images/ajax004.jpg" alt="ajax001"><br>表现现象是，后台响应的http头部信息有两个<code>Access-Control-Allow-Origin:*</code><br>说实话，这种问题出现的主要原因就是进行跨域配置的人不了解原理，导致了重复配置，如:<br>常见于<code>.net</code>后台(一般在<code>web.config</code>中配置了一次<code>origin</code>,然后代码中又手动添加了一次<code>origin</code>(比如代码手动设置了返回<code>*</code>))<br>常见于<code>.net</code>后台(在<code>IIS</code>和项目的<code>webconfig</code>中同时设置<code>Origin:*</code>)<br>解决方案(一一对应):<br>　　建议删除代码中手动添加的<code>*</code>，只用项目配置中的即可<br>　　建议删除IIS下的配置<code>*</code>，只用项目配置中的即可</p><h4 id="如何解决ajax跨域"><a href="#如何解决ajax跨域" class="headerlink" title="如何解决ajax跨域"></a>如何解决ajax跨域</h4><p>　　一般ajax跨域解决就是通过<code>JSONP</code>解决或者<code>CORS</code>解决,如以下:(注意，现在已经几乎不会再使用<code>JSONP</code>了，所以<code>JSONP</code>了解下即可)</p><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p>jsonp 其实算是一种 hack 形式的请求。<br>jsonp 的本质其实是请求一段 js 代码，<code>是对静态文件资源的请求</code>，所以并<code>不遵循同源策略</code>。但是因为是对静态文件资源的请求，所以只能支持 GET 请求，对于其他方法没有办法支持。</p><h5 id="设置CORS"><a href="#设置CORS" class="headerlink" title="设置CORS"></a>设置CORS</h5><p>　　<code>CORS</code>是一个<code>W3C</code>标准，全称是”跨域资源共享”（<code>Cross-origin resource sharing</code>）。<br>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了<code>AJAX</code>只能同源使用的限制。<br>本文详细介绍CORS的内部机制。</p><h6 id="CORS简介"><a href="#CORS简介" class="headerlink" title="CORS简介"></a>CORS简介</h6><p>　　<code>CORS</code>需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于<code>IE10</code>。<br>　　整个<code>CORS</code>通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现<code>AJAX</code>请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><h6 id="CORS两种请求"><a href="#CORS两种请求" class="headerlink" title="CORS两种请求"></a>CORS两种请求</h6><p>浏览器将CORS请求分成两类：简单请求（<code>simple request</code>）和非简单请求（<code>not-so-simple request</code>）。<br>只要同时满足以下两大条件，就属于简单请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">（1）请求方法是以下三种方法之一：</span><br><span class="line">  HEAD</span><br><span class="line">  GET</span><br><span class="line">  POST</span><br><span class="line">（2）HTTP的头信息不超出以下几种字段：</span><br><span class="line">  Accept</span><br><span class="line">  Accept-Language</span><br><span class="line">  Content-Language</span><br><span class="line">  Last-Event-ID</span><br><span class="line">  Content-Type：只限于三个值</span><br><span class="line">                application/x-www-form-urlencoded、</span><br><span class="line">                multipart/form-data、</span><br><span class="line">                text/plain</span><br></pre></td></tr></table></figure></p><p>凡是不同时满足上面两个条件，就属于<code>非简单请求</code>。<br>浏览器对这两种请求的处理，是不一样的。</p><h6 id="CORS简单请求"><a href="#CORS简单请求" class="headerlink" title="CORS简单请求"></a>CORS简单请求</h6><p>对于简单请求，浏览器直接发出<code>CORS</code>请求。具体来说，就是在头信息之中，增加一个<code>Origin(protocal + host + path + port)</code>字段,来标明这个请求是来自哪里。<br>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>　　如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest的onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。<br>　　如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。<br>（1）Access-Control-Allow-Origin<br>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。<br>（2）Access-Control-Allow-Credentials<br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。<br>（3）Access-Control-Expose-Headers<br>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。<br>withCredentials 属性<br>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。<br><code>Access-Control-Allow-Credentials: true</code><br>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>否则，即使服务器同意发送<code>Cookie</code>，浏览器也不会发送。或者，服务器要求设置<code>Cookie</code>，浏览器也不会处理。<br>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送<code>Cookie</code>。这时，可以显式关闭<code>withCredentials</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p><p>　　需要注意的是，如果要发送<code>Cookie</code>，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，<code>Cookie</code>依然遵循同源政策，只有用服务器域名设置的<code>Cookie</code>才会上传，其他域名的<code>Cookie</code>并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的<code>Cookie</code>。</p><h6 id="CORS非简单请求"><a href="#CORS非简单请求" class="headerlink" title="CORS非简单请求"></a>CORS非简单请求</h6><p>与<code>简单请求</code>最大的不同在于，<code>非简单请求</code>实际上是发送了两个请求。<br><strong>预请求</strong><br>首先，在正式请求之前，会先发送一个预请求(preflight-request)，这个请求的作用是尽可能少的携带信息，供服务端判断是否响应该请求。<br><strong>浏览器</strong><br>浏览器发送预请求，请求的 Request Method 会设置为 options。<br>另外，还会带上这几个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin: 同简单请求的origin</span><br><span class="line">Access-Control-Request-Method: 请求将要使用的方法</span><br><span class="line">Access-Control-Request-Headers: 浏览器会额外发送哪些头信息</span><br></pre></td></tr></table></figure></p><p><strong>服务端</strong><br>服务端收到预请求之后会根据request中的origin,Access-Control-Request-Method和Access-Control-Request-Headers判断是否响应该请求。<br>如果判断响应这个请求，返回的response中将会携带：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: origin</span><br><span class="line">Access-Control-Allow-Methods: like request</span><br><span class="line">Access-Control-Allow-Headers: like request</span><br></pre></td></tr></table></figure></p><p>如果否定这个请求，直接返回不带这三个字段的response就可以，浏览器将会把这种返回判断为失败的返回，触发onerror方法<br><strong>正式响应</strong><br>如果预请求被正确响应，接下来就会发送正式请求，正式请求的request和正常的 ajax 请求基本没有区别，只是会携带 origin 字段；response和简单请求一样，会携带上Access-Control-*这些字段</p><h5 id="WebScoket"><a href="#WebScoket" class="headerlink" title="WebScoket"></a>WebScoket</h5><p>websocket 不遵循同源策略。</p><p>但是在 websocket 请求头中会带上 origin 这个字段，服务端可以通过这个字段来判断是否需要响应，在浏览器端并没有做任何限制。</p><h5 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h5><h5 id="代理请求方式"><a href="#代理请求方式" class="headerlink" title="代理请求方式"></a>代理请求方式</h5>]]></content>
      
      
      <categories>
          
          <category> AJAX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AJAX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/15/JavaScript/index/"/>
      <url>/2019/03/15/JavaScript/index/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>test</title><script type="text/javascript" src="https://cdn.jsdelivr.net/vue/2.1.3/vue.js"></script><style>#app {/*background: orange;width: 100%;height: 400px;display: flex;align-items: center;*//*position: relative;*//*text-align: center;*//*margin: auto;*/}.box {background: yellow;width: 100px;height: 100px;/*position: absolute;top: 50%;left: 50%;*//*margin-top: -50px;margin-left: -50px;*//*transform: translate(-50px, -50px);*/}.layout{/*   width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/  max-width: 960px;  margin: 0 auto;}</style></head><body><div id="app"><!-- <p></p> --><!-- <p></p> --><!-- <div class="box">1231</div> --><div id="header"><div class="layout">头部</div></div><div id="content" class="layout">内容</div><div id="footer"><div class="layout">尾部</div></div><input type="text" v-model="text"></div><script>var app = new Vue({el: '#app',data: {message : "xuxiao is boy",text: 'hello word'},beforeCreate: function () {console.group('beforeCreate 创建前状态===============》');//undefinedconsole.log("%c%s", "color:red" , "el     : " + this.$el);//undefined console.log("%c%s", "color:red","data   : " + this.$data);console.log("%c%s", "color:red","message: " + this.message)},created: function () {console.group('created 创建完毕状态===============》');//undefinedconsole.log("%c%s", "color:red","el     : " + this.$el);//已被初始化 console.log("%c%s", "color:red","data   : " + this.$data);//已被初始化console.log("%c%s", "color:red","message: " + this.message);},beforeMount: function () {console.group('beforeMount 挂载前状态===============》');//已被初始化console.log("%c%s", "color:red","el     : " + (this.$el));console.log(this.$el);//已被初始化  console.log("%c%s", "color:red","data   : " + this.$data);//已被初始化  console.log("%c%s", "color:red","message: " + this.message);},mounted: function () {console.group('mounted 挂载结束状态===============》');//已被初始化console.log("%c%s", "color:red","el     : " + this.$el);console.log(this.$el);    //已被初始化console.log("%c%s", "color:red","data   : " + this.$data);//已被初始化 console.log("%c%s", "color:red","message: " + this.message);},beforeUpdate: function () {console.group('beforeUpdate 更新前状态===============》');console.log("%c%s", "color:red","el     : " + this.$el);console.log(this.$el);console.log("%c%s", "color:red","data   : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); },updated: function () {console.group('updated 更新完成状态===============》');console.log("%c%s", "color:red","el     : " + this.$el);console.log(this.$el);console.log("%c%s", "color:red","data   : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); },beforeDestroy: function () {console.group('beforeDestroy 销毁前状态===============》');console.log("%c%s", "color:red","el     : " + this.$el);console.log(this.$el);console.log("%c%s", "color:red","data   : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); },destroyed: function () {console.group('destroyed 销毁完成状态===============》');console.log("%c%s", "color:red","el     : " + this.$el);console.log(this.$el);console.log("%c%s", "color:red","data   : " + this.$data); console.log("%c%s", "color:red","message: " + this.message)}})/*for(var i =0; i< 5; i++) {setTimeout(function() {console.log("new Date", new Date, i);}, 1000)}console.log(new Date, i);*/function outer() {var num = 0;return function add() {num++;console.log("num:", num);}}var func1 = outer()func1()func1()var func2 = outer()func2()func2()</script></body></html>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/15/JavaScript/%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/03/15/JavaScript/%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h3><h3 id="在HTML中使用JavaScript"><a href="#在HTML中使用JavaScript" class="headerlink" title="在HTML中使用JavaScript"></a>在HTML中使用JavaScript</h3><h4 id="混杂模式与标准模式"><a href="#混杂模式与标准模式" class="headerlink" title="混杂模式与标准模式"></a>混杂模式与标准模式</h4><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>变量、函数名和操作符都区分大小写</p><p>标识符，就是指变量、函数、属性的名字，或者函数的参数。ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的<br>首字母大写</p><p>严格模式： “use strict”; </p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><blockquote><p>简单数据类型(基本数据类型)：Undefined、Null、Boolean、Number、String  <br><br>复杂数据类型：Object      <br><br>typeof 操作符来区分函数和其他对象是有必要的  <br></p></blockquote><h5 id="Undefind"><a href="#Undefind" class="headerlink" title="Undefind"></a>Undefind</h5><p>　　即便未初始化的变量会自动被赋予 undefined 值，但显式地初始化变量依然是<br>明智的选择。如果能够做到这一点，那么当 typeof 操作符返回”undefined”值时，<br>我们就知道被检测的变量还没有被声明，而不是尚未初始化。</p><h5 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h5><h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h5><h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><h6 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h6><h6 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h6><h6 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h6><p>即非数值（Not a Number）<br>ECMAScript 定义了 isNaN()函数。这个函数接受一个参数，该参数可以<br>是任何类型，而函数会帮我们确定这个参数是否“不是数值”。</p><h6 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h6><p>把非数值转换为数值：Number()、parseInt()和 parseFloat()。</p><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><h4 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h4><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h3 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h3><h4 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h4><p>基本类型值指的是<br>简单的数据段，而引用类型值指那些可能由多个值构成的对象</p><h5 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h5><p>如果从一个变量向另一个变量复制<strong>基本类型</strong>的值，会在变量对象上创建一个新值，然后把该值复制<br>到为新变量分配的位置上.<br><br>当从一个变量向另一个变量复制<strong>引用类型</strong>的值时，同样也会将存储在变量对象中的值复制一份放到<br>为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一<br>个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另<br>一个变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = new Object(); </span><br><span class="line">var obj2 = obj1; </span><br><span class="line">obj1.name = <span class="string">"Nicholas"</span>; </span><br><span class="line">alert(obj2.name); //<span class="string">"Nicholas"</span></span><br></pre></td></tr></table></figure></p><h5 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h5><p>typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具 <br></p><p>虽然在检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的<br>用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript<br>提供了 instanceof 操作符，其语法如下所示：<br><code>result = variable instanceof constructor</code></p><h4 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h4><h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><h5 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h5><h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；</li><li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；</li><li>引用类型的值是对象，保存在堆内存中；</li><li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；</li><li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同<br>一个对象；</li><li>确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用<br>instanceof 操作符。</li><li>所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执<br>行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。</li></ol><h5 id="以下是关于执行环境的几点总结："><a href="#以下是关于执行环境的几点总结：" class="headerlink" title="以下是关于执行环境的几点总结："></a>以下是关于执行环境的几点总结：</h5><ul><li>执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；</li><li>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；<br>函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全<br>局环境；</li><li>全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；</li><li>变量的执行环境有助于确定应该何时释放内存。</li><li>JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。</li></ul><h5 id="可以对-JavaScript-的垃圾收集例程作如下总结："><a href="#可以对-JavaScript-的垃圾收集例程作如下总结：" class="headerlink" title="可以对 JavaScript 的垃圾收集例程作如下总结："></a>可以对 JavaScript 的垃圾收集例程作如下总结：</h5><ul><li>离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。<br>“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然<br>后再回收其内存。</li><li>另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript<br>引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种<br>算法仍然可能会导致问题。</li><li>当代码中存在循环引用现象时，“引用计数”算法就会导致问题。</li><li>解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回<br>收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h4><h5 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h5><ul><li>Array类型<ul><li>检测数组  value instanceof Array、 Array.isArray()方</li><li>转换方法 toLocaleString()、toString()和 valueOf()</li><li>栈方法 后进先出 push()、pop()</li><li>队列方法 后进先出 shift()、unshift()</li><li>重排序方法 reverse()、sort()</li><li>操作方法 concat() 连接数组、splice()</li><li>位置方法 indexOf()、lastIndexOf()</li><li>迭代方法<ul><li>every()  全部</li><li>filter() 筛选</li><li>forEach()</li><li>map() </li><li>some() 存在</li></ul></li><li>归并方法<ul><li>reduce()</li><li>reduceRight()</li></ul></li></ul></li><li>Date类型<ul><li>new Date()、Date.parse() 、Date.UTC()</li><li>继承的方法</li><li>日期格式化方法<ul><li>toDateString()——以特定于实现的格式显示星期几、月、日和年</li><li>toTimeString()——以特定于实现的格式显示时、分、秒和时区；</li><li>toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年</li><li>toLocaleTimeString()——以特定于实现的格式显示时、分、秒</li><li>toUTCString()——以特定于实现的格式完整的 UTC 日期</li></ul></li><li>日期/时间组件<ul><li>getTime() 返回表示日期的毫秒数；与valueOf()方法返回的值相同</li><li>setTime(毫秒) 以毫秒数设置日期，会改变整个日期</li><li>getFullYear() 取得4位数的年份（如2007而非仅07）</li><li>getUTCFullYear() 返回UTC日期的4位数年份</li></ul></li></ul></li><li>RegExp()类型</li><li>Function类型<ul><li>没有重载</li><li>函数声明与函数表达式<ul><li>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）</li><li>至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真<br>正被解释执行。</li></ul></li><li>作为值的函数</li><li>函数内部属性<ul><li>arguments</li><li>this</li><li>callee</li></ul></li><li>函数属性和方法<ul><li>length</li><li>prototype</li><li>apply()</li><li>call()</li></ul></li><li>基本包装类型<ul><li>Boolean类型</li><li>Number<ul><li>toFixed()方法会按照指定的小数位返回数值的字符串表示</li><li>toExponential()</li></ul></li><li>String<ul><li>trim()方法： 这个方法会创建一个字符串的副本，删除前置及<br>后缀的所有空格，然后返回结果</li><li>字符串大小写转换方法<ul><li>toLowerCase()</li><li>toLocaleLowerCase()</li><li>toUpperCase()</li><li>toLocaleUpperCase()。</li></ul></li></ul></li><li>字符串的模式匹配方法</li><li>localeCompare()</li><li>localeCompare()</li><li>fromCharCode()</li></ul></li><li>单体内置对象<ul><li>Global对象</li><li>Math对象<ul><li>Math对象的属性</li><li>min()、max()</li><li>舍入方法<ul><li>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数</li><li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数</li><li>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</li></ul></li><li>random() Math.radom()</li></ul></li></ul></li></ul></li></ul><p>160</p><h4 id="创建并操作数组"><a href="#创建并操作数组" class="headerlink" title="创建并操作数组"></a>创建并操作数组</h4><h4 id="基本的JavaScript类型"><a href="#基本的JavaScript类型" class="headerlink" title="基本的JavaScript类型"></a>基本的JavaScript类型</h4><h4 id="基本类型和基本包装类型"><a href="#基本类型和基本包装类型" class="headerlink" title="基本类型和基本包装类型"></a>基本类型和基本包装类型</h4><h3 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h3><h4 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h4><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><h3 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a>客户端检测</h3><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><h3 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h3><h3 id="DOM2和DOM3"><a href="#DOM2和DOM3" class="headerlink" title="DOM2和DOM3"></a>DOM2和DOM3</h3><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h3 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h3><h3 id="使用Canvas绘图"><a href="#使用Canvas绘图" class="headerlink" title="使用Canvas绘图"></a>使用Canvas绘图</h3><h3 id="HTML5脚本编程"><a href="#HTML5脚本编程" class="headerlink" title="HTML5脚本编程"></a>HTML5脚本编程</h3><h3 id="错误处理与调试"><a href="#错误处理与调试" class="headerlink" title="错误处理与调试"></a>错误处理与调试</h3><h3 id="JavaScript与XML"><a href="#JavaScript与XML" class="headerlink" title="JavaScript与XML"></a>JavaScript与XML</h3><h3 id="E4X"><a href="#E4X" class="headerlink" title="E4X"></a>E4X</h3><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><h3 id="Ajax与Comet"><a href="#Ajax与Comet" class="headerlink" title="Ajax与Comet"></a>Ajax与Comet</h3><h3 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h3><h3 id="离线应用和客户端储存"><a href="#离线应用和客户端储存" class="headerlink" title="离线应用和客户端储存"></a>离线应用和客户端储存</h3><h3 id="最佳实战"><a href="#最佳实战" class="headerlink" title="最佳实战"></a>最佳实战</h3><h3 id="新兴的API"><a href="#新兴的API" class="headerlink" title="新兴的API"></a>新兴的API</h3>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>客户端渲染和服务端渲染详细执行流程</title>
      <link href="/2019/03/14/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/SSR%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
      <url>/2019/03/14/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/SSR%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>客户端渲染：CSR (client side render)<br>在服务端放了一个html 页面，里面有<script>//发请求，拿数据，模版引擎渲染等，$.ajax  ,</script><br>客户端发起请求，服务端把页面（响应的是字符串）发送过去，客户端从上到下依次解析，如果在解析的过程中，发现ajax<br>请求，再次像服务器发送新的请求，客户端拿到ajax 响应结果，模板引擎渲染。<br>过程至少和服务端发起两次请求</p></li><li><p>服务端渲染：SSR (server side render)<br>sever 端页面+数据，服务端过程：<br>1.读取index.html<br>2.模版进行渲染，在发送给客户端之前，在服务端已经把index.html 渲染处理了。var 渲染结果 = tempeter.render(模板字符串，｛解析替换对象｝)   response.end(渲染结果)，服务端响应的就是最总的结果<br>服务端只请求一次<br>多数网站既有服务端渲染又有客户端渲染</p></li><li><p>服务端渲染和客户端渲染的区别</p><ul><li>客户端渲染不利于 SEO 搜索引擎优化</li><li>服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的</li><li>所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的</li><li>而是两者结合来做的</li><li>例如京东的商品列表就采用的是服务端渲染，目的了为了 SEO 搜索引擎优化</li><li>而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue组件间通信&amp;传值</title>
      <link href="/2019/03/14/Vue/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1&amp;%E4%BC%A0%E5%80%BC/"/>
      <url>/2019/03/14/Vue/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1&amp;%E4%BC%A0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- 目录 --><!-- toc --><p>转载：<br>　　<a href="https://blog.csdn.net/qq_35430000/article/details/79291287" target="_blank" rel="noopener">vue通信、传值的多种方式（详细）</a><br>　　<a href="https://www.jianshu.com/p/a804606ad8e9" target="_blank" rel="noopener">Vue.js——十分钟入门Vuex</a></p><h4 id="通过路由带参数进行传值"><a href="#通过路由带参数进行传值" class="headerlink" title="通过路由带参数进行传值"></a>通过路由带参数进行传值</h4><ol><li>两个组件 A和B,A组件通过query把orderId传递给B组件（触发事件可以是点击事件、钩子函数等）<br><code>this.$router.push({ path: &#39;/conponentsB&#39;, query: { orderId: 123 } }) // 跳转到B</code></li><li>在B组件中获取A组件传递过来的参数<br><code>this.$route.query.orderId</code><a id="more"></a></li></ol><h4 id="通过设置-Session-Storage缓存的形式进行传递"><a href="#通过设置-Session-Storage缓存的形式进行传递" class="headerlink" title="通过设置 Session Storage缓存的形式进行传递"></a>通过设置 Session Storage缓存的形式进行传递</h4><ol><li><p>两个组件A和B，在A组件中设置缓存orderData</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const orderData = &#123; <span class="string">'orderId'</span>: 123, <span class="string">'price'</span>: 88 &#125;</span><br><span class="line"> </span><br><span class="line">sessionStorage.setItem(<span class="string">'缓存名称'</span>, JSON.stringify(orderData))</span><br></pre></td></tr></table></figure></li><li><p>B组件就可以获取在A中设置的缓存了<br><code>const dataB = JSON.parse(sessionStorage.getItem(&#39;缓存名称&#39;))</code><br>此时 dataB 就是数据 orderData</p><h4 id="父子组件之间的传值"><a href="#父子组件之间的传值" class="headerlink" title="父子组件之间的传值"></a>父子组件之间的传值</h4><h5 id="父组件往子组件传值props"><a href="#父组件往子组件传值props" class="headerlink" title="父组件往子组件传值props"></a>父组件往子组件传值props</h5><p>①定义父组件，父组件传递 number这个数值给子组件，如果传递的参数很多，推荐使用json数组{}的形式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"parent"</span>&gt;  <span class="comment"># 例如：传递数组88给子组件</span></span><br><span class="line">    &lt;children number=888&gt;&lt;/children&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">import Children from <span class="string">'components/children'</span>  <span class="comment"># 引入子组件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>②定义子组件，子组件通过 props方法获取父组件传递过来的值。props中可以定义能接收的数据类型，如果不符合会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># children.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"children"</span>&gt;</span><br><span class="line">    &#123;&#123;number&#125;&#125;  <span class="comment"># 显示父组件传递过来的值，显示88</span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  props: &#123;  <span class="comment"># 限制父组件传递过来的数据类型，如果不符合就报错</span></span><br><span class="line">    <span class="string">'number'</span>: [Number, String, Object],</span><br><span class="line">    <span class="string">'string'</span>: [String] <span class="comment">#可以传递多个值，逗号隔开</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然也可以简单一点，如果不考虑数据类型，直接 <code>props:[&quot;number&quot;,&quot;string&quot;]</code>就可以了,中括号包裹，多个值使用，分隔。<br>③假如接收的参数 是动态的，比如 input输入的内容 v-model的形式<br><strong>注意</strong>：传递的参数名称 支持驼峰命名，下面示例描述不正确（1.0是不支持的）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"parent"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"inputText"</span>&gt;</span><br><span class="line">    &lt;children :input-val = <span class="string">'inputText'</span>&gt;&lt;/children&gt; </span><br><span class="line">    <span class="comment"># 注意 :input-val 不支持驼峰命名，建议 - 分割 </span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import Children from <span class="string">'components/children'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"children"</span>&gt;</span><br><span class="line">    &#123;&#123;inputVal&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="string">'input-val'</span>: [String]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④父子组件传值，数据是异步请求，有可能数据渲染时报错<br>原因：异步请求时，数据还没有获取到但是此时已经渲染节点了<br>解决方案：可以在 父组件需要传递数据的节点加上<code>v-if = false</code>,异步请求获取数据后,<code>v-if = true</code></p><h5 id="子组件往父组件传值，通过emit事件"><a href="#子组件往父组件传值，通过emit事件" class="headerlink" title="子组件往父组件传值，通过emit事件"></a>子组件往父组件传值，通过emit事件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># children.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=<span class="string">"children"</span>&gt;</span><br><span class="line">      &lt;button @click=<span class="string">"emitToParent"</span>&gt;按钮点击传值给父组件&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">emitToParent</span></span>() &#123;</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">'child-event'</span>, <span class="string">'我是子组件往父组件传递的内容'</span>)</span><br><span class="line">      <span class="comment"># child-event 不支持驼峰命名</span></span><br><span class="line">      <span class="comment"># 子组件通过emit事件给父组件传递内容</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"parent"</span>&gt; <span class="comment"># 触发父组件的一个方法，然后进行相应的操作</span></span><br><span class="line">    &lt;children @child-event=<span class="string">"parentEvent"</span>&gt;&lt;/children&gt;</span><br><span class="line">    <span class="comment"># @child-event 这是子组件自定义的方法</span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import Children from <span class="string">'components/children'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    parentEvent(data) &#123; </span><br><span class="line">      <span class="comment"># data 就是子组件传递过来的数据</span></span><br><span class="line">      console.log(data)</span><br><span class="line">      <span class="comment"># 我是子组件往父组件传递的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用-vuex）"><a href="#不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用-vuex）" class="headerlink" title="不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用 vuex）"></a>不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用 vuex）</h4><p>①定义一个新的vue实例专门用于传递数据，并导出<br><br>就是定义一个公共的传值用的组件进行数据的交互<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建文佳eventBus.js</span></span><br><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line"><span class="built_in">export</span> default new Vue()</span><br></pre></td></tr></table></figure></p><p>②定义传递的方法名和传输内容，点击事件或钩子函数触发eventBus.emit事件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># componentA.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"componentsA"</span>&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"emitToB"</span>&gt;按钮点击传递数据给兄弟组件B&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import eventBus from <span class="string">'common/js/eventBus.js'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">emitToB</span></span>() &#123;</span><br><span class="line">      eventBus.<span class="variable">$emit</span>(<span class="string">'eventFromA'</span>, <span class="string">'我是组件A传递给组件B的数据'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>③接收传递过来的数据<br>注意：enentBus是一个另一个新的Vue实例，区分两个this所代表得vue实例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">componentB.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"componentsB"</span>&gt;</span><br><span class="line">    &#123;&#123;title&#125;&#125; <span class="comment"># 显示传递过来的值</span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import eventBus from <span class="string">'common/js/eventBus.js'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      title: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">    this.getEventData()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">getEventData</span></span>() &#123;</span><br><span class="line">      const that = this </span><br><span class="line">      <span class="comment">#this是项目vue的实例，用that接收，与eventBus的vue区分</span></span><br><span class="line">      eventBus.<span class="variable">$on</span>(<span class="string">'eventFormA'</span>, <span class="keyword">function</span>(val) &#123;</span><br><span class="line">        that.title = val</span><br><span class="line">        <span class="comment"># this.title = val </span></span><br><span class="line">        <span class="comment"># 这个this指的是eventBus的vue实例</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h4 id="Vuex进行传值"><a href="#Vuex进行传值" class="headerlink" title="Vuex进行传值"></a>Vuex进行传值</h4><h5 id="什么是Vuex"><a href="#什么是Vuex" class="headerlink" title="什么是Vuex"></a>什么是Vuex</h5><p>　　Vuex是一个专门为Vue.js应用程序开发的状态管理模式, 它采用集中式存储管理所有组件的公共状态, 并以相应的规则保证状态以一种可预测的方式发生变化.<br><img src="/assets/images/vuex.png" alt="vuex"><br>　　上图中绿色虚线包裹起来的部分就是Vuex的核心, <code>state</code>中保存的就是公共状态, 改变<code>state</code>的唯一方式就是通过<code>mutations</code>进行更改. 可能你现在看这张图有点不明白, 等经过本文的解释和案例演示, 再回来看这张图, 相信你会有更好的理解.</p><h5 id="为什么要使用Vuex"><a href="#为什么要使用Vuex" class="headerlink" title="为什么要使用Vuex"></a>为什么要使用Vuex</h5><p>　　试想这样的场景, 比如一个Vue的根实例下面有一个根组件名为App.vue, 它下面有两个子组件A.vue和B.vue, App.vue想要与A.vue或者B.vue通讯可以通过props传值的方式, 但是如果A.vue和B.vue之间的通讯就很麻烦了, 他们需要共有的父组件通过自定义事件进行实现, A组件想要和B组件通讯往往是这样的:<br><img src="/assets/images/vuex1.png" alt="vuex"></p><ul><li>A组件说: “报告老大, 能否帮我托个信给小弟B” =&gt; dispatch一个事件给App</li><li>App老大说: “包在我身上, 它需要监听A组件的dispatch的时间, 同时需要broadcast一个事件给B组件”</li><li>B小弟说: “信息已收到”, 它需要on监听App组件分发的事件</li></ul><p>　　这只是一条通讯路径, 如果父组件下有多个子组件, 子组件之间通讯的路径就会变的很繁琐, 父组件需要监听大量的事件, 还需要负责分发给不同的子组件, 很显然这并不是我们想要的组件化的开发体验.<br><strong>Vuex就是为了解决这一问题出现的</strong></p><h5 id="如何引入Vuex"><a href="#如何引入Vuex" class="headerlink" title="如何引入Vuex"></a>如何引入Vuex</h5><p>下载vuex: <code>npm install vuex --save</code> <br><br>在<code>main.js</code>添加:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import Vuex from <span class="string">'vuex'</span></span><br><span class="line"><span class="comment"># 使用vuex</span></span><br><span class="line">Vue.use( Vuex );</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    //待添加</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    store,</span><br><span class="line">    render: h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="Vuex的核心概念"><a href="#Vuex的核心概念" class="headerlink" title="Vuex的核心概念"></a>Vuex的核心概念</h5><p>　　在介绍Vuex的核心概念之前, 我使用<code>vue-cli</code>初始化了一个demo, 准备以代码的形式来说明Vuex的核心概念,这个demo分别有两个组件<code>ProductListOne.vue</code>和<code>ProductListTwo.vue</code>, 在<code>App.vue</code>的d<code>atat</code>中保存着共有的商品列表, 代码和初始化的效果如下图所示:<br><img src="/assets/images/vuex2.png" alt="vuex"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//App.vue中的初始化代码</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;product-list-one v-bind:products=<span class="string">"products"</span>&gt;&lt;/product-list-one&gt;</span><br><span class="line">    &lt;product-list-two v-bind:products=<span class="string">"products"</span>&gt;&lt;/product-list-two&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ProductListOne from <span class="string">'./components/ProductListOne.vue'</span></span><br><span class="line">import ProductListTwo from <span class="string">'./components/ProductListTwo.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    name: <span class="string">'app'</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">'product-list-one'</span>: ProductListOne,</span><br><span class="line">        <span class="string">'product-list-two'</span>: ProductListTwo</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products: [</span><br><span class="line">                &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">                &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">                &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">                &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">body&#123;</span><br><span class="line">  font-family: Ubuntu;</span><br><span class="line">  color: <span class="comment">#555;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//ProductListOne.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"product-list-one"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Product List One&lt;/h2&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=<span class="string">"product in products"</span>&gt;</span><br><span class="line">                &lt;span class=<span class="string">"name"</span>&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span class=<span class="string">"price"</span>&gt;<span class="variable">$&#123;&#123; product.price &#125;</span>&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    props: [<span class="string">'products'</span>],</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="comment">#product-list-one&#123;</span></span><br><span class="line">    background: <span class="comment">#FFF8B1;</span></span><br><span class="line">    box-shadow: 1px 2px 3px rgba(0,0,0,0.2);</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">    padding: 10px 20px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#product-list-one ul&#123;</span></span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#product-list-one li&#123;</span></span><br><span class="line">    display: inline-block;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    background: rgba(255,255,255,0.7);</span><br><span class="line">&#125;</span><br><span class="line">.price&#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    color: <span class="comment">#E8800C;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//ProductListTwo.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"product-list-two"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Product List Two&lt;/h2&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=<span class="string">"product in products"</span>&gt;</span><br><span class="line">                &lt;span class=<span class="string">"name"</span>&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span class=<span class="string">"price"</span>&gt;<span class="variable">$&#123;&#123; product.price &#125;</span>&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    props: [<span class="string">'products'</span>],</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="comment">#product-list-two&#123;</span></span><br><span class="line">    background: <span class="comment">#D1E4FF;</span></span><br><span class="line">    box-shadow: 1px 2px 3px rgba(0,0,0,0.2);</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">    padding: 10px 20px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#product-list-two ul&#123;</span></span><br><span class="line">    padding: 0;</span><br><span class="line">    list-style-type: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#product-list-two li&#123;</span></span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    background: rgba(255,255,255,0.7);</span><br><span class="line">&#125;</span><br><span class="line">.price&#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    color: <span class="comment">#860CE8;</span></span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h6 id="State"><a href="#State" class="headerlink" title="State"></a>State</h6><p>　　<code>state</code>就是Vuex中的公共的状态, 我是将<code>state</code>看作是所有组件的data, 用于保存所有组件的公共数据.</p><ol><li>此时我们就可以把App.vue中的两个组件共同使用的data抽离出来, 放到<code>state</code>中,代码如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.js</span></span><br><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import App from <span class="string">'./App.vue'</span></span><br><span class="line">import Vuex from <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use( Vuex )</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state:&#123; </span><br><span class="line">    products: [</span><br><span class="line">      &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">      &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">      &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">      &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>此时,<code>ProductListOne.vue</code>和<code>ProductListTwo.vue</code>也需要做相应的更改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ProductListOne.vue</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products : this.<span class="variable">$store</span>.state.products //获取store中state的数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ProductListTwo.vue</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products: this.<span class="variable">$store</span>.state.products //获取store中state的数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的页面如下图所示, 可以看到, 将公共数据抽离出来后, 页面没有发生变化.<br><img src="/assets/images/vuex3.png" alt="vuex"></p><h6 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h6><p>　　我将getters属性理解为所有组件的<code>computed</code>属性, 也就是计算属性. <code>vuex</code>的官方文档也是说到可以将<code>getter</code>理解为<code>store</code>的计算属性, <code>getters</code>的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>　　此时,我们可以在main.js中添加一个<code>getters</code>属性, 其中的<code>saleProducts</code>对象将state中的价格减少一半(除以2)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.js</span></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    products: [</span><br><span class="line">      &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">      &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">      &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">      &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters:&#123; //添加getters</span><br><span class="line">    saleProducts: (state) =&gt; &#123;</span><br><span class="line">      <span class="built_in">let</span> saleProducts = state.products.map( product =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">          name: product.name,</span><br><span class="line">          price: product.price / 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">return</span> saleProducts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>将<code>productListOne.vue</code>中的<code>products</code>的值更换为<code>this.$store.getters.saleProducts</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products : this.<span class="variable">$store</span>.getters.saleProducts </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在的页面中,Product List One中的每项商品的价格都减少了一半<br><img src="/assets/images/vuex4.png" alt="vuex"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">###### Mutations</span></span><br><span class="line">　　我将mutaions理解为store中的methods, mutations对象中保存着更改数据的回调函数,该函数名官方规定叫<span class="built_in">type</span>, 第一个参数是state, 第二参数是payload, 也就是自定义的参数.</span><br><span class="line"></span><br><span class="line">下面,我们在main.js中添加mutations属性,其中minusPrice这个回调函数用于将商品的价格减少payload这么多, 代码如下:</span><br><span class="line">```bash</span><br><span class="line">//main.js</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    products: [</span><br><span class="line">      &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">      &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">      &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">      &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters:&#123;</span><br><span class="line">    saleProducts: (state) =&gt; &#123;</span><br><span class="line">      <span class="built_in">let</span> saleProducts = state.products.map( product =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">          name: product.name,</span><br><span class="line">          price: product.price / 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">return</span> saleProducts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123; //添加mutations</span><br><span class="line">    minusPrice (state, payload ) &#123;</span><br><span class="line">      <span class="built_in">let</span> newPrice = state.products.forEach( product =&gt; &#123;</span><br><span class="line">        product.price -= payload</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在<code>ProductListTwo.vue</code>中添加一个按钮,为其添加一个点击事件, 给点击事件触发<code>minusPrice</code>方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ProductListTwo.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"product-list-two"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Product List Two&lt;/h2&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=<span class="string">"product in products"</span>&gt;</span><br><span class="line">                &lt;span class=<span class="string">"name"</span>&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span class=<span class="string">"price"</span>&gt;<span class="variable">$&#123;&#123; product.price &#125;</span>&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;button @click=<span class="string">"minusPrice"</span>&gt;减少价格&lt;/button&gt; //添加按钮</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>在<code>ProductListTwo.vue</code>中注册<code>minusPrice</code>方法, 在该方法中<code>commitmutations</code>中的<code>minusPrice</code>这个回调函数<br><strong>注意:调用<code>mutaions</code>中回调函数, 只能使用<code>store.commit(type, payload)</code></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ProductListTwo.vue</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products: this.<span class="variable">$store</span>.state.products</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">minusPrice</span></span>() &#123;</span><br><span class="line">            this.<span class="variable">$store</span>.commit(<span class="string">'minusPrice'</span>, 2); //提交`minusPrice,payload为2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加按钮, 可以发现,<code>Product List Two</code>中的价格减少了2, 当然你可以自定义<code>payload</code>,以此自定义减少对应的价格.<br><img src="/assets/images/vuex5.png" alt="vuex"></p><h6 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h6><p><code>actions</code> 类似于 <code>mutations</code>，不同在于：<br><code>actions</code>提交的是<code>mutations</code>而不是直接变更状态<br><code>actions</code>中可以包含异步操作, <code>mutations</code>中绝对不允许出现异步<br><code>actions</code>中的回调函数的第一个参数是<code>context</code>, 是一个与<code>store</code>实例具有相同属性和方法的对象<br>　　此时,我们在<code>store</code>中添加<code>actions</code>属性, 其中<code>minusPriceAsync</code>采用<code>setTimeout</code>来模拟异步操作,延迟2s执行 该方法用于异步改变我们刚才在<code>mutaions</code>中定义的<code>minusPrice</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    products: [</span><br><span class="line">      &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">      &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">      &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">      &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters:&#123;</span><br><span class="line">    saleProducts: (state) =&gt; &#123;</span><br><span class="line">      <span class="built_in">let</span> saleProducts = state.products.map( product =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">          name: product.name,</span><br><span class="line">          price: product.price / 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">return</span> saleProducts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123;</span><br><span class="line">    minusPrice (state, payload ) &#123;</span><br><span class="line">      <span class="built_in">let</span> newPrice = state.products.forEach( product =&gt; &#123;</span><br><span class="line">        product.price -= payload</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions:&#123; //添加actions</span><br><span class="line">    minusPriceAsync( context, payload ) &#123;</span><br><span class="line">      setTimeout( () =&gt; &#123;</span><br><span class="line">        context.commit( <span class="string">'minusPrice'</span>, payload ); //context提交</span><br><span class="line">      &#125;, 2000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在<code>ProductListTwo.vue</code>中添加一个按钮,为其添加一个点击事件, 给点击事件触发<code>minusPriceAsync</code>方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"product-list-two"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Product List Two&lt;/h2&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=<span class="string">"product in products"</span>&gt;</span><br><span class="line">                &lt;span class=<span class="string">"name"</span>&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span class=<span class="string">"price"</span>&gt;<span class="variable">$&#123;&#123; product.price &#125;</span>&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;button @click=<span class="string">"minusPrice"</span>&gt;减少价格&lt;/button&gt;</span><br><span class="line">            &lt;button @click=<span class="string">"minusPriceAsync"</span>&gt;异步减少价格&lt;/button&gt; //添加按钮</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>在<code>ProductListTwo.vue</code>中注册<code>minusPriceAsync</code>方法, 在该方法中<code>dispatchactions</code>中的<code>minusPriceAsync</code>这个回调函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products: this.<span class="variable">$store</span>.state.products</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">minusPrice</span></span>() &#123;</span><br><span class="line">            this.<span class="variable">$store</span>.commit(<span class="string">'minusPrice'</span>, 2);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">minusPriceAsync</span></span>() &#123;</span><br><span class="line">            this.<span class="variable">$store</span>.dispatch(<span class="string">'minusPriceAsync'</span>, 5); //分发actions中的minusPriceAsync这个异步函数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加按钮, 可以发现, <code>Product List Two</code>中的价格延迟2s后减少了5<br><img src="/assets/images/vuex6.png" alt="vuex"></p><h6 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h6><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，<code>store</code> 对象就有可能变得相当臃肿。为了解决以上问题，<code>Vuex</code>允许我们将 <code>store</code> 分割成模块<code>（module）</code>。每个模块拥有自己的 <code>state</code>、<code>mutation</code>、<code>action</code>、<code>getter</code>、甚至是嵌套子模块——从上至下进行同样方式的分割</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure><h5 id="mapactions-amp-amp-…mapgetters"><a href="#mapactions-amp-amp-…mapgetters" class="headerlink" title="..mapactions&amp;&amp; …mapgetters"></a>..mapactions&amp;&amp; …mapgetters</h5>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flex布局</title>
      <link href="/2019/03/08/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/flex%E5%B8%83%E5%B1%80/"/>
      <url>/2019/03/08/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载：<br>　　阮一峰：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a><br><img src="/assets/images/flex.jpg" alt="flex布局"><br>　　2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。<br><a id="more"></a><br><img src="/assets/images/flexSupport.jpg" alt="flex"></p><h4 id="Flex布局是什么？"><a href="#Flex布局是什么？" class="headerlink" title="Flex布局是什么？"></a>Flex布局是什么？</h4><p>　　Flex 是 <code>Flexible Box</code> 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: felx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>行内元素也可以使用 <code>Flex</code> 布局。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: -webkit-flex; /* Safari */</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="注意，设为-Flex-布局以后，子元素的float、clear和vertical-align属性将失效。"><a href="#注意，设为-Flex-布局以后，子元素的float、clear和vertical-align属性将失效。" class="headerlink" title="注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。"></a>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</h5><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>　　采用 <code>Flex</code> 布局的元素，称为 <code>Flex</code> 容器（<code>flex container</code>），简称”容器”。它的所有子元素自动成为容器成员，称为 <code>Flex</code> 项目（<code>flex item</code>），简称”项目”。<br><img src="/assets/images/flex01.png" alt="flex01"><br>容器默认存在两根轴：水平的主轴（<code>main axis</code>）和垂直的交叉轴（<code>cross axis</code>）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h4 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h4><p>　　以下6个属性设置在容器上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-direction</span><br><span class="line">flex-wrap</span><br><span class="line">flex-flow</span><br><span class="line">justify-content</span><br><span class="line">align-items</span><br><span class="line">align-content</span><br></pre></td></tr></table></figure></p><h5 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h5><p>　　<code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex02.png" alt="flex02"><br>　　它可能有4个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row（默认值）：主轴为水平方向，起点在左端。</span><br><span class="line">row-reverse：主轴为水平方向，起点在右端。</span><br><span class="line">column：主轴为垂直方向，起点在上沿。</span><br><span class="line">column-reverse：主轴为垂直方向，起点在下沿。</span><br></pre></td></tr></table></figure></p><h5 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h5><p>　　默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。<br><img src="/assets/images/flex03.png" alt="flex03"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　它可能取三个值。<br>（1）<code>nowrap</code>（默认）：不换行。<br><img src="/assets/images/flex04.png" alt="flex04"><br>（2）<code>wrap</code>：换行，第一行在上方。<br><img src="/assets/images/flex05.jpg" alt="flex05"><br>（3）<code>wrap-reverse</code>：换行，第一行在下方。<br><img src="/assets/images/flex06.jpg" alt="flex06"></p><h5 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h5><p>　　<code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h5><p>　　<code>justify-content</code>属性定义了项目在主轴上的对齐方式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex07.png" alt="flex07"><br>　　它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex-start（默认值）：左对齐</span><br><span class="line">flex-end：右对齐</span><br><span class="line">center： 居中</span><br><span class="line">space-between：两端对齐，项目之间的间隔都相等。</span><br><span class="line">space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br></pre></td></tr></table></figure></p><h5 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h5><p>　　<code>align-items</code>属性定义项目在交叉轴上如何对齐。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>建立在主轴为水平方向时测试，即 <code>flex-direction: row</code></strong><br>默认值为 <code>stretch</code> 即如果项目未设置高度或者设为 <code>auto</code>，将占满整个容器的高度。<br><img src="/assets/images/flex08.jpg" alt="flex08"><br>假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。<br><img src="/assets/images/flex08.png" alt="flex08"><br>　　它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex-start：交叉轴的起点对齐。</span><br><span class="line">flex-end：交叉轴的终点对齐。</span><br><span class="line">center：交叉轴的中点对齐。</span><br><span class="line">baseline: 项目的第一行文字的基线对齐。</span><br><span class="line">stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span><br></pre></td></tr></table></figure></p><h5 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h5><p>　　<code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex09.png" alt="flex09"><br>　　该属性可能取6个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-start：与交叉轴的起点对齐。</span><br><span class="line">flex-end：与交叉轴的终点对齐。</span><br><span class="line">center：与交叉轴的中点对齐。</span><br><span class="line">space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</span><br><span class="line">space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</span><br><span class="line">stretch（默认值）：轴线占满整个交叉轴。</span><br></pre></td></tr></table></figure></p><h4 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h4><p>以下6个属性设置在项目上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">order</span><br><span class="line">flex-grow</span><br><span class="line">flex-shrink</span><br><span class="line">flex-basis</span><br><span class="line">flex</span><br><span class="line">align-self</span><br></pre></td></tr></table></figure></p><h5 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h5><p>　　<code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  order: &lt;<span class="built_in">integer</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex10.png" alt="flex10"></p><h5 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h5><p>　　<code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-grow: &lt;number&gt;; /* default 0 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex11.png" alt="flex11"><br>　　如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h5 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h5><p>　　<code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-shrink: &lt;number&gt;; /* default 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex12.jpg" alt="flex12"></p><p>　　如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h5 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h5><p>　　flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><p>.item {<br>  flex-basis: <length> | auto; /<em> default auto </em>/<br>}<br>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</length></p><h5 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h5><p>　　<code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该属性有两个快捷值：<code>auto (1 1 auto)`</code> 和 <code>none (0 0 auto)</code>。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h5 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h5><p>　　<code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex13.png" alt="flex13"><br>　　该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 页面布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网页从输入网址到渲染完成经历了哪些过程</title>
      <link href="/2019/02/23/HTTP/%E7%BD%91%E9%A1%B5%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/02/23/HTTP/%E7%BD%91%E9%A1%B5%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="过程概述"><a href="#过程概述" class="headerlink" title="过程概述"></a>过程概述</h4><p>　　从输入域名到网页打开的简单过程如下：<br><strong>1. DNS域名解析</strong><br>　　客户端输入域名后，由DNS服务器来将域名解析成对应服务器的IP地址<br>　　若未在缓存中找到，则不停的向上一级级请求DNS服务器<br><strong>2. 建立TCP连接</strong><br>　　客户端得到IP地址以后,会根据所获得的IP地址以及要访问的端口号发起网络连接， 即<font color="blue"><strong>tcp三次握手</strong></font>连接， 建立起TCP/IP网络连接， 具体过程如下：<a id="more"></a><br>　　第一次握手：<br>　　　　<font color="orange">主机向服务器发送一个建立连接的请求（您好，我想认识您）</font><br>　　　　<font color="red">建立连接时，客户端发送syn包(syn=j)到服务器，并进入<strong><em>SYN_SEND</em></strong>状态，等待服务器确认</font><br>　　第二次握手：<br>　　　　<font color="orange">服务器接到请求后发送同意连接的信号（好的，很高兴认识您）</font><br>　　　　<font color="red">服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器 进入SYN_RECV状态；</font><br>　　第三次握手：<br>　　　　<font color="orange">主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接</font><br>　　　　<font color="red">客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。<br>通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。</font></p><p>解释：<br>　　<code>SYN:synchronous</code>   建立联机<br>　　<code>ACK:acknowledgement</code>  确认<br>　　<code>SYN_SENT</code>:请求连接<br>　　<code>SYN_RECV</code>:服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的<code>ACK</code>就进入<code>ESTABLISHED</code>状态。<br>　　<code>tcp</code>在握手过程中并不携带数据，(就像你打电话给酒店订房时，在确认对方是酒店客服人员之前，你也不会马上把身份证号码报给他吧？)，而是在三次握手完成之后，才会进行数据传送。</p><p><strong>补充说明:</strong><br>　　　　TCP 协议：三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号。<br><strong>3. 发送HTTP请求</strong><br>　　与服务器建立连接之后，就可以向服务器发送请求了，请求需要遵循http协议<br>　　添加一些HTTP首部<br>　　根据同源政策添加cookie<br><strong>4.服务器处理HTTP请求报文</strong><br>　　被请求的服务器解析用户请求的有哪些资源，通过服务器返回数据给客户端<br><strong>5.返回响应HTTP响应报文</strong><br>　　给客户端返回请求的状态码，通过状态码可以知道服务器端的处理是否正常<br><strong>6.浏览器渲染：</strong><br>　　返回成功之后，浏览器拿到请求页面的代码，将其解析渲染出来。解析和渲染的过程主要由浏览器的渲染引擎实现。<br>　　浏览器处理服务器返回的HTTP响应报文，若为HTML则渲染页面，不包括脚本的简单渲染流程如下：<br>　　　　1、解析DOM、CSSOM<br>　　　　2、根据DOM、CSSOM计算render tree<br>　　　　3、根据render tree进行layout<br>　　　　4、paint，至此，用户可以看到页面了</p><h5 id="根据域名查找-IP-地址"><a href="#根据域名查找-IP-地址" class="headerlink" title="根据域名查找 IP 地址"></a>根据域名查找 IP 地址</h5><h6 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h6><p>　　<strong>IP 地址</strong>：IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址；<br>　　<strong>域名(DN)</strong>：IP 地址由四个数字组成，中间用点号连接，在使用过程中难记忆且易输入错误，所以用我们熟悉的字母和数字组合来代替纯数字的 IP 地址，比如我们只会记住 <code>www.baidu.com</code>（百度域名） 而不是 <code>220.181.112.244</code>（百度的其中一个 IP 地址）；<br>　　<strong>DNS</strong>： 每个域名都对应一个或多个提供相同服务服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。</p><p>　　知道了上面的概念，大概就知道了想要获得服务器的门牌号码，需要先将域名转换成 IP 地址。转换过程如下（以查询 <code>www.baidu.com</code> 的 IP 地址为例，其中2、3、4步均在上一步未查询成功的情况下进行）：</p><h6 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h6><ol><li>浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；</li><li>搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；</li><li>搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；</li><li>操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；<ol><li>LDNS 向 <code>Root Name Server</code>（根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，<code>Root Name Server</code>返回 com 域的顶级域名服务器的地址；</li><li>LDNS 向 com 域的顶级域名服务器发起请求，返回 <code>baidu.com</code>域名服务器地址；</li><li>LDNS 向 baidu.com 域名服务器发起请求，得到 <code>www.baidu.com</code>的 IP 地址；</li></ol></li><li>LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；</li><li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；</li><li>至此，浏览器已经得到了域名对应的 IP 地址。</li></ol><p><strong>补充说明</strong><br>　　域名与 URL 是两个概念：域名是一台或一组服务器的名称，用来确定服务器在 Internet 上的位置；URL 是统一资源定位符，用来确定某一个文件的具体位置，例如，<code>zhihu.com</code> 是 知乎的域名，根据这个域名可以找到知乎的服务器，<code>zhihu.com/people/CompileYouth</code> 是 URL ，可以根据这个 URL 定位我的知乎主页；<br>　　IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限；</p><h5 id="网页请求与显示"><a href="#网页请求与显示" class="headerlink" title="网页请求与显示"></a>网页请求与显示</h5><p>　　当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。</p><ol><li>服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；</li><li>服务器将得到的 HTML 文件发送给浏览器；</li><li>在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；</li><li>在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML </li></ol><h4 id="断开连接–四次挥手"><a href="#断开连接–四次挥手" class="headerlink" title="断开连接–四次挥手"></a>断开连接–四次挥手</h4><ol><li>主机向服务器发送一个断开连接的请求（不早了，我该走了）；</li><li>服务器接到请求后发送确认收到请求的信号（知道了）；</li><li>服务器向主机发送断开通知（我也该走了）；</li><li>主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；</li></ol><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><p>　　一个完整的URL地址由：<strong>协议</strong>、<strong>服务器地址(主机)</strong>、<strong>端口</strong>、<strong>资源路径(文件)</strong>。其中网络地址指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；协议是从 该计算机获取资源的方式，常见的是HTTP、FTP，不同协议有不同的通讯内容格式；资源路径指示从服务器上获取哪一项资源。<br>例如：<code>http://www.guokr.com/question/554991/</code><br>超文本传输协议：<code>http</code><br>服务器地址：<code>www.guokr.com</code><br>端口： http协议的默认<strong>端口</strong>为80<br>资源路径：是指要活的的文件的路径 -&gt;<code>/question/554991/</code></p><h5 id="TCP为什么要三次握手而不是两次握手"><a href="#TCP为什么要三次握手而不是两次握手" class="headerlink" title="TCP为什么要三次握手而不是两次握手"></a>TCP为什么要三次握手而不是两次握手</h5><p>TCP 采用三次握手的原因：<br>　　为了实现可靠数据传输，TCP 协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的。三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。<br>　　如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认。<br>　　三次握手主要是为了防止已失效的连接请求报文突然到达服务器，造成服务器的等待和资源的浪费。<br>举例：<br>　　如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。<br>　　如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h5 id="TCP-四次挥手能不能变成三次挥手呢？"><a href="#TCP-四次挥手能不能变成三次挥手呢？" class="headerlink" title="TCP 四次挥手能不能变成三次挥手呢？"></a>TCP 四次挥手能不能变成三次挥手呢？</h5><p>可以的<br>　　TCP是全双工通信，Client 在自己已经不会在有新的数据要发送给 Server 后，可以发送 FIN 信号告知 Server，这边已经终止 Client 到对端 Server 那边的数据传输。但是，这个时候对端 Server 可以继续往 Client 这边发送数据包。于是，两端数据传输的终止在时序上是独立并且可能会相隔比较长的时间，这个时候就必须最少需要2+2 = 4 次挥手来完全终止这个连接。但是，如果Server在收到Client的FIN包后，在也没数据需要发送给Client了，那么对Client的ACK包和Server自己的FIN包就可以合并成为一个包发送过去，这样四次挥手就可以变成三次了(似乎linux协议栈就是这样实现的)。<br>转载：<br>　　<a href="https://www.cnblogs.com/ishuanghe/p/5200775.html" target="_blank" rel="noopener">一个页面从输入url,到页面显示加载完成,这个过程中都发生了什么?</a><br>　　<a href="https://zhuanlan.zhihu.com/p/23155051" target="_blank" rel="noopener">从输入 URL 到页面加载完成的过程中都发生了什么</a><br>参考文章：<br>　　<a href="http://www.cnblogs.com/beyond-Acm/p/4309983.html" target="_blank" rel="noopener">从键入网址到页面显示经历了那些过程</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVVM开发模式的理解</title>
      <link href="/2019/02/23/Vue/MVVM%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2019/02/23/Vue/MVVM%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>　　MVVM（模型视图ViewModel 是一种基于MVC和MVP的架构模式，<font color="FF0000">它试图更清楚地将用户界面（UI）的开发与应用程序中的业务逻辑和行为的开发分开</font>。为此，此模式的许多实现都使用声明性数据绑定，以允许将视图上的工作与其他层分离。<a id="more"></a></p><h4 id="Model、View、ViewModel"><a href="#Model、View、ViewModel" class="headerlink" title="Model、View、ViewModel"></a>Model、View、ViewModel</h4><p>　　MVVM分为Model、View、ViewModel三者。</p><ul><li>Model 代表数据模型，数据和业务逻辑都在Model层中定义；</li><li>View 代表UI视图，负责数据的展示，是用户在屏幕上看到的结构；</li><li>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；<br>　　Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。<br>这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom。<br><img src="/assets/images/mvvm2.png" alt="mvvm"><br><img src="/assets/images/mvvm.png" alt="mvvm"></li></ul><h3 id="MVVM的实现原理："><a href="#MVVM的实现原理：" class="headerlink" title="MVVM的实现原理："></a>MVVM的实现原理：</h3><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><p>　　响应式：vue如何监听data的属性变化<br>　　模板解析：vue的模板是如何被解析的<br>　　渲染：vue模板是如何被渲染成HTML的</p><h5 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h5><h5 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h5><h5 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h5><h3 id="设计模式编辑"><a href="#设计模式编辑" class="headerlink" title="设计模式编辑"></a>设计模式编辑</h3><p>　　因为WPF技术出现，从而使MVC架构模式有所改进，MVVM模式便是使用的是数据绑定基础架构。它们可以轻松构建UI的必要元素。<br>可以参考<code>The Composite Application Guidance for WPF(prism)</code><br>View绑定到ViewModel，然后执行一些命令在向它请求一个动作。而反过来，ViewModel跟Model通讯，告诉它更新来响应UI。这样便使得为应用构建UI非常的容易。往一个应用程序上贴一个界面越容易，外观设计师就越容易使用Blend来创建一个漂亮的界面。同时，当UI和功能越来越松耦合的时候，功能的可测试性就越来越强。<br>在MVP模式中，为了让UI层能够从逻辑层上分离下来，设计师们在UI层与逻辑层之间加了一层interface。无论是UI开发人员还是数据开发人员，都要尊重这个契约、按照它进行设计和开发。这样，理想状态下无论是Web UI还是Window UI就都可以使用同一套数据逻辑了。借鉴MVP的IView层，养成习惯。View Model听起来比Presenter要贴切得多；会把一些跟事件、命令相关的东西放在MVC的’C’,或者是MVVM的’Vm’。</p><h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>　　MVVM模式和MVC模式一样，主要目的是<font color="#FF0000">分离视图（View）</font>和<font color="#FF0000">模型（Model）</font>，有几大优点:</p><ol><li><strong>低耦合</strong>: <strong>视图（View）</strong>可以独立于 <strong>Model</strong> 变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li><li><strong>可重用性</strong>: 你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li><li><strong>独立开发</strong>:开发人员可以专注于业务逻辑和数据的开发(ViewModel), 设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。</li><li><strong>可测试</strong>:界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</li><li>MVVM有助于更轻松地并行开发UI以及为其提供支持的构建块</li><li>抽象视图，从而减少其背后的代码所需的业务逻辑（或粘合剂）的数量</li><li>ViewModel比事件驱动的代码更容易进行单元测试</li><li>可以在不关心UI自动化和交互的情况下测试ViewModel（比View更多的模型）</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>对于更简单的UI，MVVM可能过度</li><li>虽然数据绑定可以是声明性的并且很好用，但它们比我们简单设置断点的命令式代码更难调试</li><li>非平凡应用程序中的数据绑定可以创建大量的簿记。您也不希望在绑定比绑定的对象更重的情况下结束</li><li>在较大的应用程序中，预先设计ViewModel以获得必要的泛化量可能更加困难</li></ol><p>参考文章：<br>　　<a href="https://www.cnblogs.com/iovec/p/7840228.html" target="_blank" rel="noopener">前后端分手大师——MVVM 模式</a><br>　　<a href="https://zhuanlan.zhihu.com/p/38296857" target="_blank" rel="noopener">简单理解MVVM–实现Vue的MVVM模式</a><br>　　<a href="https://addyosmani.com/blog/understanding-mvvm-a-guide-for-javascript-developers/" target="_blank" rel="noopener">了解MVVM - JavaScript开发人员指南</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>stylus基础</title>
      <link href="/2019/02/22/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/stylus%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/02/22/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/stylus%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> stylus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stylus基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis基础</title>
      <link href="/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
      <url>/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mongoose</title>
      <link href="/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/mongoose/"/>
      <url>/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/mongoose/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h4><h5 id="mongodb-的概念-amp-安装"><a href="#mongodb-的概念-amp-安装" class="headerlink" title="mongodb 的概念 &amp; 安装"></a>mongodb 的概念 &amp; 安装</h5><p>mongod</p><h5 id="mongodb-可视化工具-RoRo-3T-安装及应用"><a href="#mongodb-可视化工具-RoRo-3T-安装及应用" class="headerlink" title="mongodb 可视化工具 RoRo 3T 安装及应用"></a>mongodb 可视化工具 RoRo 3T 安装及应用</h5><h5 id="mongoose-的作用"><a href="#mongoose-的作用" class="headerlink" title="mongoose 的作用"></a>mongoose 的作用</h5><h5 id="mongoose-的应用"><a href="#mongoose-的应用" class="headerlink" title="mongoose 的应用"></a>mongoose 的应用</h5>]]></content>
      
      
      <categories>
          
          <category> mongoose </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongoose </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Koa2基础</title>
      <link href="/2019/02/21/Koa2/Koa2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/02/21/Koa2/Koa2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p><a href="https://koa.bootcss.com" target="_blank" rel="noopener">Koa官网</a><br><a href="https://chenshenhai.github.io/koa2-note/" target="_blank" rel="noopener">《Koa2进阶学习笔记》已完结</a></p><h3 id="使用koa-generator生成koa2项目"><a href="#使用koa-generator生成koa2项目" class="headerlink" title="使用koa-generator生成koa2项目"></a>使用koa-generator生成koa2项目</h3><p>全局安装koa-generator: <code>npm install -g koa-generator</code><br>使用koa-generator生成koa2项目: <code>koa2 -e koa2-learn</code><br>　　　　　　　　　　　　　　　　　<strong>-e 添加ejs模板引擎支持(默认是jade)</strong><br>　　　　　　　　　　　　　　　　　koa2-learn 项目名<a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ koa2 -e koa2-learning</span><br><span class="line"></span><br><span class="line">   create : koa2-learning</span><br><span class="line">   create : koa2-learning/package.json</span><br><span class="line">   create : koa2-learning/app.js</span><br><span class="line">   create : koa2-learning/public/javascripts</span><br><span class="line">   create : koa2-learning/routes</span><br><span class="line">   create : koa2-learning/routes/index.js</span><br><span class="line">   create : koa2-learning/routes/users.js</span><br><span class="line">   create : koa2-learning/public/images</span><br><span class="line">   create : koa2-learning/public/stylesheets</span><br><span class="line">   create : koa2-learning/public/stylesheets/style.css</span><br><span class="line">   create : koa2-learning/public</span><br><span class="line">   create : koa2-learning/views</span><br><span class="line">   create : koa2-learning/views/index.ejs</span><br><span class="line">   create : koa2-learning/views/error.ejs</span><br><span class="line">   create : koa2-learning/bin</span><br><span class="line">   create : koa2-learning/bin/www</span><br><span class="line"></span><br><span class="line">   install dependencies:</span><br><span class="line">     $ cd koa2-learning &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">   run the app:</span><br><span class="line">     $ DEBUG=koa2-learning:* npm start</span><br></pre></td></tr></table></figure></p><p>PS: 如果出现 <code>npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.7: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})</code>  不用担心。出现原因：<br><code>fsevents</code> 不在 <code>package.json</code>里，但是仍然安装了，是因为你的系统是Windows系统，fsevents是苹果系统的可选依赖,你的项目有可能是团队项目，别人在他的mac上安装了fsevents相关依赖库，所以到这边你也就安装到你的windows上边了。你可以检查你的package.json 文件中是不是有fsevents相关依赖，删除即好！<br>如果没有，其他的npm包也会有依赖fsevents的！！！<br><strong>这是warning错误，是因为mac下需要fsevents，这里是在windows环境，所以可以忽略这个警告，对你没什么影响的。</strong><br>运行: <code>DEBUG=koa2-learning:* npm start</code> || <code>npm run dev</code><br>效果： 出现 <strong>node bin/www</strong> 访问 <code>http://localhost:3000/</code><br>注意： npm start 、 npm test 、 npm run dev 、 npm run prd</p><h3 id="async-和-await-语法"><a href="#async-和-await-语法" class="headerlink" title="async 和 await 语法"></a>async 和 await 语法</h3><h4 id="异步概念"><a href="#异步概念" class="headerlink" title="异步概念"></a>异步概念</h4><blockquote><p>是指一个进程在执行某个请求的时候，如果这个请求没有执行完毕，进程不会等待，而是继续执行下面的请求。</p></blockquote><h4 id="理解async-和-await"><a href="#理解async-和-await" class="headerlink" title="理解async 和 await"></a>理解async 和 await</h4><h3 id="Koa2-中间件"><a href="#Koa2-中间件" class="headerlink" title="Koa2 中间件"></a>Koa2 中间件</h3><h4 id="koa2-中间件的原理"><a href="#koa2-中间件的原理" class="headerlink" title="koa2 中间件的原理"></a>koa2 中间件的原理</h4><p><img src="/assets/images/koa2.png" alt="koa2"><br><img src="/assets/images/koa2中间件.png" alt="koa2"></p><h4 id="自定义-koa2-中间件"><a href="#自定义-koa2-中间件" class="headerlink" title="自定义 koa2 中间件"></a>自定义 koa2 中间件</h4><h3 id="koa2-路由"><a href="#koa2-路由" class="headerlink" title="koa2 路由"></a>koa2 路由</h3><h4 id="路由写法"><a href="#路由写法" class="headerlink" title="路由写法"></a>路由写法</h4><h4 id="接口举例"><a href="#接口举例" class="headerlink" title="接口举例"></a>接口举例</h4><h3 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h3><h4 id="cookie-和-session-的定义"><a href="#cookie-和-session-的定义" class="headerlink" title="cookie 和 session 的定义"></a>cookie 和 session 的定义</h4><h4 id="cookie-和-session-的作用"><a href="#cookie-和-session-的作用" class="headerlink" title="cookie 和 session 的作用"></a>cookie 和 session 的作用</h4><p>推荐：<br>　　<a href="https://zhuanlan.zhihu.com/p/35040744" target="_blank" rel="noopener">从头实现一个koa框架</a><br>　　<a href="https://segmentfault.com/a/1190000013981513" target="_blank" rel="noopener">浅析koa的洋葱模型实现</a></p>]]></content>
      
      
      <categories>
          
          <category> Koa2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Koa2基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue.js基础</title>
      <link href="/2019/02/15/Vue/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/02/15/Vue/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- 目录 --><!-- toc --><p>Vue.js基础，模块化，单文件组件，路由，与服务器通信，状态管理，单元测试与生产发布，服务端渲染SSR与Nuxt.js，基于Vue.js企业级项目开发(Mint UI, Element UI)等 </p><h3 id="v-if-和-v-show-区别"><a href="#v-if-和-v-show-区别" class="headerlink" title="v-if 和 v-show 区别"></a>v-if 和 v-show 区别</h3><p>使用了 v-if 的时候，如果值为 false ，那么页面将不会有这个 html 标签生成。<br>v-show 则是不管值为 true 还是 false ，html 元素都会存在，只是 CSS 中的 display 显示或隐藏</p><h3 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别"></a>$route和$router的区别</h3><p>$router 为 VueRouter 实例，想要导航到不同 URL，则使用 $router.push 方法<br>$route 为当前 router 跳转对象里面可以获取 name 、 path 、 query 、 params 等</p><h3 id="NextTick-是做什么的"><a href="#NextTick-是做什么的" class="headerlink" title="NextTick 是做什么的"></a>NextTick 是做什么的</h3><p>$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM</p><h3 id="Vue-组件-data-为什么必须是函数"><a href="#Vue-组件-data-为什么必须是函数" class="headerlink" title="Vue 组件 data 为什么必须是函数"></a>Vue 组件 data 为什么必须是函数</h3><p>因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了</p><h3 id="计算属性computed-和事件-methods-有什么区别"><a href="#计算属性computed-和事件-methods-有什么区别" class="headerlink" title="计算属性computed 和事件 methods 有什么区别"></a>计算属性computed 和事件 methods 有什么区别</h3><p>我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的</p><p>不同点：</p><p>computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值<br>对于 method ，只要发生重新渲染，method 调用总会执行该函数</p><h3 id="Vue-中怎么自定义过滤器"><a href="#Vue-中怎么自定义过滤器" class="headerlink" title="Vue 中怎么自定义过滤器"></a>Vue 中怎么自定义过滤器</h3><p>可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值<br>Vue.filter(‘reverse’, function (value) {<br>  return value.split(‘’).reverse().join(‘’)<br>})<br><!-- 'abc' => 'cba' --><br><span v-text="message | reverse"></span><br>过滤器也同样接受全局注册和局部注册</p><h3 id="对-keep-alive-的了解"><a href="#对-keep-alive-的了解" class="headerlink" title="对 keep-alive 的了解"></a>对 keep-alive 的了解</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染</p><p><keep-alive><br>  <component><br>    <!-- 该组件将被缓存！ --><br>  </component><br></keep-alive><br>可以使用API提供的props，实现组件的动态缓存</p><h3 id="Vue-中-key-的作用"><a href="#Vue-中-key-的作用" class="headerlink" title="Vue 中 key 的作用"></a>Vue 中 key 的作用</h3><p>key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。<br>有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误</p><h3 id="vue-等单页面应用的优缺点"><a href="#vue-等单页面应用的优缺点" class="headerlink" title="vue 等单页面应用的优缺点"></a>vue 等单页面应用的优缺点</h3><p>优点：<br>良好的交互体验<br>良好的前后端工作分离模式<br>减轻服务器压力<br>缺点：<br>SEO难度较高<br>前进、后退管理<br>初次加载耗时多</p><h3 id="Doctype作用，HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt"><a href="#Doctype作用，HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt" class="headerlink" title="Doctype作用，HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;"></a>Doctype作用，HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;</h3><p>doctype是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档.&lt;!DOCTYPE&gt;声明必须是HTML文档的第一行，位于html标签之前<br>HTML5不基于SGML，所以不需要引用DTD。在HTML5中&lt;!DOCTYPE&gt;只有一种</p><p>SGML: 标准通用标记语言,是现时常用的超文本格式的最高层次标准</p><p>### </p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS布局</title>
      <link href="/2019/02/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/CSS3%E5%B8%83%E5%B1%80/"/>
      <url>/2019/02/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/CSS3%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载：<br>　　知乎专栏：<a href="https://zhuanlan.zhihu.com/p/25565751" target="_blank" rel="noopener">CSS布局十八般武艺都在这里了</a><br>参考：<br>　　<a href="https://juejin.im/post/599970f4518825243a78b9d5#heading-43" target="_blank" rel="noopener">CSS 常见布局方式</a><br>　　<a href="https://blog.csdn.net/weixin_37580235/article/details/82317240#行内元素" target="_blank" rel="noopener">CSS水平居中+垂直居中+水平/垂直居中的方法总结</a><br>　　<img src="https://user-gold-cdn.xitu.io/2017/8/21/395302ae7949d78570a6102e5ded1ff0?imageslim" alt="css布局"><br><!-- toc --></p><h4 id="常用居中方法"><a href="#常用居中方法" class="headerlink" title="常用居中方法"></a>常用居中方法</h4><p>　　居中在布局中很常见，我们假设DOM文档结构如下，子元素要在父元素中居中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"parent"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"child"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h5 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h5><p>　　子元素为行内元素还是块状元素，宽度一定还是宽度未定，采取的布局方案不同。<br>子元素为:<br>　　行内元素：对父元素设置<code>text-align:center</code>;<br>　　定宽块状元素: 设置左右<code>margin</code>值为<code>auto</code>;<br>　　不定宽块状元素: 设置子元素为<code>display:inline</code>,然后在父元素上设置<code>text-align:center;</code><br>　　通用方案: flex布局，对父元素设置<code>display:flex;justify-content:center;</code><br>例子：<br><strong>固定宽度</strong><br>　　这种方式是绝对定位居中，除了使用 margin，我们还可以使用 <code>transform</code>（注意浏览器兼容性，只适用于 ie9+，移动开发请忽略）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.inner&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-top: -25px;</span><br><span class="line">    margin-left: -50px;</span><br><span class="line">    background: <span class="comment">#fff;</span></span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.inner&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    /* transform: translate(-50%, -50%); */</span><br><span class="line">    transform: translate(-50px, -25px);</span><br><span class="line">    background: <span class="comment">#fff;</span></span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>宽度未知</strong><br>　　将子元素设置为<code>行内元素</code>，然后父元素设置 <code>text-align: center</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line">    position: relative;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.inner&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>多个块状元素</strong><br>　　上面的方式即使子元素不止一个也想实现水平居中也是有效的，（宽度固定不固定都可，不固定的话就不需要设置宽度，会被自动撑开，但是要考虑到撑爆的情况）例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    width: 250px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line">    position: relative;</span><br><span class="line">    text-align: center;</span><br><span class="line">    padding: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.inner&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    background: <span class="comment">#fff;</span></span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　当然也可以使用我们刚刚介绍的 <code>flex</code>，我们只需要让子元素在主轴上的对齐方式设置为居中就可以<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    width: 250px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    padding: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.inner&#123;</span><br><span class="line">    background: <span class="comment">#fff;</span></span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h5><p>　　垂直居中对于子元素是<code>单行内联文本</code>、<code>多行内联文本</code>以及<code>块状元素</code>采用的方案是不同的。<br><strong>父元素一定，子元素为单行内联文本</strong>:设置父元素的<code>height</code>等于行高<code>line-height</code><br><strong>父元素一定，子元素为多行内联文本</strong>:设置父元素的<code>display:table-cell</code>或<code>inline-block</code>，再设置<code>vertical-align:middle</code>;<br><strong>块状元素</strong>:设置子元素<code>position:absolute</code>并设置<code>top、bottom为0</code>，父元素要设置定位为<code>static</code>以外的值，<code>margin:auto</code>;<br><strong>通用方案</strong>:<code>flex</code>布局，给父元素设置<code>{display:flex; align-items:center;}</code>。</p><h4 id="单列布局"><a href="#单列布局" class="headerlink" title="单列布局"></a>单列布局</h4><p>　　<img src="/assets/images/css布局.png" alt="css布局"><br>特征：<strong>定宽、水平居中</strong><br>常见的单列布局有两种：<br>　　一种是header、content、footer宽度都相同，其一般不会占满浏览器的最宽宽度，但当浏览器宽度缩小低于其最大宽度时，宽度会自适应。<br>　　一种是header、footer宽度为浏览器宽度，但content以及header和footer里的内容却不会占满浏览器宽度。<br>对于第一种，对header、content、footer统一设置width或max-width，并通过margin:auto实现居中。<br>DOM文档:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"layout"</span>&gt;</span><br><span class="line">  &lt;div id=<span class="string">"header"</span>&gt;头部&lt;/div&gt;</span><br><span class="line">  &lt;div id=<span class="string">"content"</span>&gt;内容&lt;/div&gt;</span><br><span class="line">  &lt;div id=<span class="string">"footer"</span>&gt;尾部&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>CSS清单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.layout&#123;</span><br><span class="line">/*   width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/</span><br><span class="line">  max-width: 960px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　对于第二种，<code>header</code>、<code>footer</code>的内容宽度为100%，但<code>header</code>、<code>footer</code>的内容区以及<code>content</code>统一设置<code>width</code> 或 <code>max-width</code>，并通过<code>margin:auto</code>实现居中。<br>DOM文档:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"header"</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">"layout"</span>&gt;头部&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"content"</span> class=<span class="string">"layout"</span>&gt;内容&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"footer"</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">"layout"</span>&gt;尾部&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>CSS清单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.layout&#123;</span><br><span class="line">/*   width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/</span><br><span class="line">  max-width: 960px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二列-amp-三列布局"><a href="#二列-amp-三列布局" class="headerlink" title="二列&amp;三列布局"></a>二列&amp;三列布局</h4><p>　　<img src="/assets/images/css布局02.png" alt="css布局"><br>二列布局的特征是侧栏固定宽度，主栏自适应宽度。<br>三列布局的特征是两侧两列固定宽度，中间列自适应宽度。</p><p>之所以将二列布局和三列布局写在一起，是因为二列布局可以看做去掉一个侧栏的三列布局，其布局的思想有异曲同工之妙。对于传统的实现方法，主要讨论上图中前三种布局，经典的带有侧栏的二栏布局以及带有左右侧栏的三栏布局，对于flex布局，实现了上图的五种布局。</p><h5 id="float-margin"><a href="#float-margin" class="headerlink" title="float + margin"></a>float + margin</h5><p>　　原理说明：设置两个侧栏分别向左向右浮动，中间列通过外边距给两个侧栏腾出空间，中间列的宽度根据浏览器窗口自适应。<br>DOM文档:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"content"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"sub"</span>&gt;sub&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"extra"</span>&gt;extra&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;main&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>布局步骤:<br>　　对两边侧栏分别设置宽度，并对左侧栏添加左浮动，对右侧栏添加有浮动。<br>对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。<br>CSS清单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.sub&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.extra&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    <span class="built_in">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line">    margin-left: 100px; </span><br><span class="line">    margin-right: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一些说明:<br>　　注意DOM文档的书写顺序，先写两侧栏，再写主面板，更换后则侧栏会被挤到下一列（圣杯布局和双飞翼布局都会用到）。 　<br>这种布局方式比较简单明了，但缺点是渲染时先渲染了侧边栏，而不是比较重要的主面板。</p><p>二列的实现方法</p><p>如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。</p><h5 id="position-margin"><a href="#position-margin" class="headerlink" title="position + margin"></a>position + margin</h5><p>　　原理说明：通过绝对定位将两个侧栏固定，同样通过外边距给两个侧栏腾出空间，中间列自适应。<br>DOM文档:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"sub"</span>&gt;left&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"main"</span>&gt;main&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"extra"</span>&gt;right&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>布局步骤:<br>　　对两边侧栏分别设置宽度，设置定位方式为绝对定位。<br>　　设置两侧栏的top值都为0，设置左侧栏的left值为0， 右侧栏的right值为0。<br>　　对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。<br>CSS清单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.sub, .extra &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0; </span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.sub &#123; </span><br><span class="line">    left: 0;</span><br><span class="line">&#125;</span><br><span class="line">.extra &#123; </span><br><span class="line">    right: 0; </span><br><span class="line">&#125;</span><br><span class="line">.main &#123; </span><br><span class="line">    margin: 0 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一些说明:<br>　　本方法不限制DOM书写顺序，先写主面板会使主面板部分优先渲染（一般主面板会比侧栏内容重要）。<br>与上一种方法相比，本种方法是通过定位来实现侧栏的位置固定。<br>如果中间栏含有最小宽度限制，或是含有宽度的内部元素，则浏览器窗口小到一定程度，主面板与侧栏会发生重叠。<br>二列的实现方法<br>　　如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。</p><h5 id="圣杯布局-float-负margin"><a href="#圣杯布局-float-负margin" class="headerlink" title="圣杯布局 (float + 负margin)"></a>圣杯布局 (float + 负margin)</h5><p>原理说明：<br>　　主面板设置宽度为100%，主面板与两个侧栏都设置浮动，常见为左浮动，这时两个侧栏会被主面板挤下去。通过负边距将浮动的侧栏拉上来，左侧栏的负边距为100%，刚好是窗口的宽度，因此会从主面板下面的左边跑到与主面板对齐的左边，右侧栏此时浮动在主面板下面的左边，设置负边距为负的自身宽度刚好浮动到主面板对齐的右边。为了避免侧栏遮挡主面板内容，在外层设置左右padding值为左右侧栏的宽度，给侧栏腾出空间，此时主面板的宽度减小。由于侧栏的负margin都是相对主面板的，两个侧栏并不会像我们理想中的停靠在左右两边，而是跟着缩小的主面板一起向中间靠拢。此时使用相对布局，调整两个侧栏到相应的位置。</p><p>DOM文档:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=<span class="string">"bd"</span>&gt;         </span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;center&lt;/div&gt;        </span><br><span class="line">    &lt;div class=<span class="string">"sub"</span>&gt;left&lt;/div&gt;        </span><br><span class="line">    &lt;div class=<span class="string">"extra"</span>&gt;right&lt;/div&gt;  </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>布局步骤:<br>　　三者都设置向左浮动。<br>　　设置main宽度为100%，设置两侧栏的宽度。<br>　　设置 负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。<br>　　设置main的padding值给左右两个子面板留出空间。<br>　　设置两个子面板为相对定位，sub的left值为负的sub宽度，extra的right值为负的extra宽度。<br>CSS清单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;        </span><br><span class="line">    <span class="built_in">float</span>: left;       </span><br><span class="line">    width: 100%;   </span><br><span class="line"> &#125;  </span><br><span class="line"> .sub &#123;       </span><br><span class="line">    <span class="built_in">float</span>: left;        </span><br><span class="line">    width: 190px;        </span><br><span class="line">    margin-left: -100%;               </span><br><span class="line">    position: relative;  </span><br><span class="line">    left: -190px;  </span><br><span class="line">&#125;   </span><br><span class="line">.extra &#123;        </span><br><span class="line">    <span class="built_in">float</span>: left;        </span><br><span class="line">    width: 230px;        </span><br><span class="line">    margin-left: -230px; </span><br><span class="line">    position: relative; </span><br><span class="line">    right: -230px;  </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">#bd &#123;        </span></span><br><span class="line">    padding: 0 230px 0 190px;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>一些说明<br>　　DOM元素的书写顺序不得更改。<br>　　主面板部分优先渲染（一般主面板会比侧栏内容重要）。<br>　　当面板的main内容部分比两边的子面板宽度小的时候，布局就会乱掉。可以通过设置main的<code>min-width</code>属性或使用双飞翼布局避免问题。<br>二列的实现方法<br>　　如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的<code>padding-right</code>值，其他操作相同。反之亦然。</p><h5 id="双飞翼布局-float-负margin"><a href="#双飞翼布局-float-负margin" class="headerlink" title="双飞翼布局 (float + 负margin)"></a>双飞翼布局 (float + 负margin)</h5><p>原理说明：<br>　　双飞翼布局和圣杯布局的思想有些相似，都利用了浮动和负边距，但双飞翼布局在圣杯布局上做了改进，在main元素上加了一层div, 并设置<code>margin</code>,由于两侧栏的负边距都是相对于<code>main-wrap</code>而言，main的<code>margin</code>值变化便不会影响两个侧栏，因此省掉了对两侧栏设置相对布局的步骤。</p><p>DOM文档:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"main-wrap"</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">"main"</span>&gt;<span class="comment">#main&lt;/div&gt;</span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"sub"</span>&gt;left&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"extra"</span>&gt;right&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>布局步骤:<br>　　三者都设置向左浮动。设置<code>main-wrap</code>宽度为100%，设置两个侧栏的宽度。设置负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。<br>设置main的margin值给左右两个子面板留出空间。<br>CSS清单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.main-wrap &#123;        </span><br><span class="line">    <span class="built_in">float</span>: left;       </span><br><span class="line">    width: 100%;   </span><br><span class="line"> &#125;  </span><br><span class="line"> .sub &#123;       </span><br><span class="line">    <span class="built_in">float</span>: left;        </span><br><span class="line">    width: 190px;        </span><br><span class="line">    margin-left: -100%;   </span><br><span class="line">&#125;   </span><br><span class="line">.extra &#123;        </span><br><span class="line">    <span class="built_in">float</span>: left;        </span><br><span class="line">    width: 230px;        </span><br><span class="line">    margin-left: -230px; </span><br><span class="line"> &#125;</span><br><span class="line">.main &#123;    </span><br><span class="line">    margin: 0 230px 0 190px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一些说明<br>　　主面板部分优先渲染（一般主面板会比侧栏内容重要）。<br>圣杯采用的是padding，而双飞翼采用的margin，解决了圣杯布局main的最小宽度不能小于左侧栏的缺点。<br>双飞翼布局不用设置相对布局，以及对应的left和right值。<br>　　通过引入相对布局，可以实现三栏布局的各种组合，例如对右侧栏设置<code>position: relative; left: 190px;</code>,可以实现<code>sub+extra+main</code>的布局。<br>二列的实现方法<br>　　如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置main-wrap的margin-right值，其他操作相同。反之亦然。</p><h5 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h5><p>　　以下是五种布局的flex布局代码：<br>DOM文档：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"layout"</span>&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"layout"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"layout"</span>&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;左侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;右侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"layout"</span>&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;第1个侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;第2个侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"layout"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;第1个侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;aside class=<span class="string">"aside"</span>&gt;第2个侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>CSS清单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.layout &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">.aside &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　与之前所讲的几种传统布局方案相比，flex布局的代码可谓异常简洁，而且非常通用，利用简单的三行CSS即实现了常见的五种布局。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>　　传统的布局方法基于盒状模型，依赖 display属性 + position属性 + float属性，逻辑相对复杂，对于实现一些特殊效果，例如垂直居中，尤其复杂繁琐。而flex布局中的flex容器可以根据实际可用空间动态调整子元素的宽高比和顺序，使元素能够尽可能地利用可用空间，同时也能通过缩小来避免超出。flex布局提供了一套简便、完整、响应式的布局方案。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 页面布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>像素：(px、pt、em、rem、rpx)</title>
      <link href="/2019/02/14/%E5%83%8F%E7%B4%A0/%E5%83%8F%E7%B4%A0/"/>
      <url>/2019/02/14/%E5%83%8F%E7%B4%A0/%E5%83%8F%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a><p>参考资料：<br><a href="http://www.runoob.com/w3cnote/px-em-rem-different.html" target="_blank" rel="noopener">px、em、rem区别介绍</a><br><a href="https://www.cnblogs.com/zhaowy/p/8400271.html" target="_blank" rel="noopener">字体大小之px、em、rem、pt,字号详解</a><br><strong>px:</strong><br>　　px像素（Pixel）。相对长度单位。<code>像素px是相对于显示器屏幕分辨率而言的</code>。<br>　　PX特点:<br>　　　　1、 <code>IE无法调整那些使用px作为单位的字体大小</code>；<br>　　　　2、 <code>国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位</code>；<br>　　　　3、 <code>Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)</code>。<br><strong>pt:</strong><br>　　pt(point，磅)：是一个物理长度单位，指的是72分之一英寸。表示绝对长度。<br><strong>em:</strong><br>　　em是相对长度单位，<code>相对于父元素的font-size</code>。如当前对行内文本的字体尺寸未被人为设置，则相对浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。<br>　　em特点：<br>　　　　1、 <code>em的值并不是固定的</code>；<br>　　　　2、 <code>em会继承父级元素的字体大小</code>。<br>　　注意：任意浏览器的<code>默认字体高都是16px</code>。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px<em>62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。<br>所以我们在写CSS的时候，需要注意两点：<br>　　　　1、 <code>body选择器中声明Font-size=62.5%</code>；<br>　　　　2、 <code>将你的原来的px数值除以10，然后换上em作为单位</code>；<br>　　　　3、 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。也就是避免1.2 </em> 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承<code>#content</code>的字体高而变为了1em=12px。<br><strong>rem:</strong><br>　　rem（root em，根em）：是CSS3新增的一个相对单位，相对的是<code>HTML根元素</code>，可以只修改根元素就可以成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。兼容性IE9+都可以兼容，对于不兼容的浏览器写一个绝对单位的声明就可以了。<br><strong>rpx:</strong><br>　　rpx单位是微信小程序中css的尺寸单位，rpx可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。<br><strong>vw vh:</strong><br>vw,vh是css3的新单位，是相对于viewport视窗的宽高进行计算的单位。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1vw=1/100浏览器宽度</span><br><span class="line">1vh=1/100浏览器高度</span><br><span class="line">vmin：当前 vw 和 vh 中较小的一个值</span><br><span class="line">vmax：当前 vw 和 vh 中较大的一个值</span><br></pre></td></tr></table></figure></p><p><strong>vmin、vmax用处</strong><br>做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。<br>由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 像素 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>重绘(repaint)与回流(reflow)</title>
      <link href="/2019/02/14/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%87%8D%E7%BB%98(repaint)%E4%B8%8E%E5%9B%9E%E6%B5%81(reflow)/"/>
      <url>/2019/02/14/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%87%8D%E7%BB%98(repaint)%E4%B8%8E%E5%9B%9E%E6%B5%81(reflow)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>文章转载：<br>　<a href="http://www.cnblogs.com/blackmanba/p/browser-repaint-reflow.html" target="_blank" rel="noopener">浏览器重绘和重排</a><br>文章参考：<br>　<a href="https://www.cnblogs.com/jiayuexuan/p/7490140.html" target="_blank" rel="noopener">重构与回流</a><br>　<a href="https://kb.cnblogs.com/page/169820/" target="_blank" rel="noopener">浏览器的重绘与重排</a><br>　<a href="http://www.cnblogs.com/shenqi0920/p/3545820.html" target="_blank" rel="noopener">探讨css中repaint和reflow</a></p><h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言：</strong></h5><p>　　页面设计中，不可避免的需要浏览器进行repaint和reflow。那到底什么是repaint和reflow呢。下面谈谈自己对repaint和reflow的理解，以及结合其他技术牛的讲解，谈谈如何优化repaint和reflow。</p><h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述：</strong></h5><p>　　<strong>重排(回流)</strong>, 顾名思义就是重新排版的意思; <strong>重绘</strong>, 就是浏览器重新绘制。理解重排和重绘的含义十分重要, 因为在评审页面交互效果的时候, 重绘和重排是必须考虑的因素。并不是说交互效果实现了就可以了, 必须同时考虑到这样做会引发什么性能问题。也就是说, 浏览器在进行重绘和重排的时候是要付出高昂的性能代价的。<br>　　只有静态页面才会不存在repaint和reflow。repaint主要是针对某一个DOM元素进行的重绘，reflow则是回流，针对整个页面的重排。字面意思来说：repaint就是重绘，reflow就是回流。<strong>回流必将引起重绘，而重绘不一定会引起回流</strong>，repaint和reflow的目的是：展示一个新的页面样貌。<a id="more"></a></p><h5 id="浏览器执行流："><a href="#浏览器执行流：" class="headerlink" title="浏览器执行流："></a><strong>浏览器执行流：</strong></h5><p>　　浏览器每次从服务器下载完页面后就会对页面进行渲染(Render), 这里面就包含了重绘以及重排。每种浏览器虽然工作原理略有差别, 但也遵循以下流程:<br>　　览器引擎会解析HTML文档来构建DOM树。树的每个节点都是标签, 有大小边距等等的属性, 这是因为每个HTML元素都遵循<strong>盒子模型</strong>(隐藏元素不包括在文档树中, 浏览器不会将其渲染)。<br>　　渲染树构建完毕后, 浏览器就能够确定每个元素的位置并将元素放到正确的位置上, 再根据<strong><em>树节点的样式属性</em></strong>绘制出页面元素。<br>　　由于浏览器的流布局的方式, 对渲染树的计算通常只需要遍历一遍即可。但table及其内部元素除外, 可能需要执行多次计算才能确定好在渲染树中的属性,这个过程通常要耗费3倍以上的时间。<br>　　这也是我们要避免使用table标签的其中一个原因。<br>　　简言之浏览器执行顺序为：<br>  　　1. 首先获取html，然后构建dom树 ，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。<br>  　　2. 浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。<br>  　　3. DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，render tree不包含隐藏的节点 (比如display:none的节点，还有head节点)，因为这些节点不会用于呈现。<br>  　　4. 一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。　　</p><h5 id="严重性："><a href="#严重性：" class="headerlink" title="严重性："></a><strong>严重性：</strong></h5><p>　在性能优先的前提下，性能消耗 重排(reflow)大于重绘(repaint)。</p><h5 id="体现："><a href="#体现：" class="headerlink" title="体现："></a><strong>体现：</strong></h5><p>　repaint是某个DOM元素进行重绘；reflow是整个页面进行重排，也就是页面所有DOM元素渲染。</p><h5 id="如何触发："><a href="#如何触发：" class="headerlink" title="如何触发："></a><strong>如何触发：</strong></h5><p>　style变动造成repaint和reflow。<br>　不涉及任何DOM元素的排版问题的变动为repaint，例如元素的color/text-align/text-decoration等等属性的变动。<br>　除上面所提到的DOM元素style的修改基本为reflow。例如元素的任何涉及长、宽、行高、边框、display等style的修改。</p><h5 id="常见触发场景："><a href="#常见触发场景：" class="headerlink" title="常见触发场景："></a><strong>常见触发场景：</strong></h5><p>　　重绘是一个元素外观的改变所触发的浏览器行为，例如改变<code>visibility</code>、<code>outline</code>、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。重排(回流)是更明显的一种改变，可以理解为渲染树需要重新计算。</p><ol><li>触发repaint:<ol><li>color的修改，如color=#ddd；</li><li>text-align的修改，如text-align=center；</li><li>a:hover也会造成重绘。</li><li>:hover引起的颜色等不导致页面回流的style变动。</li></ol></li><li>触发reflow：<ol><li>width/height/border/margin/padding的修改，如width=778px；</li><li>动画，:hover等伪类引起的元素表现改动，display=none等造成页面回流；</li><li>appendChild等DOM元素操作；</li><li>font类style的修改；</li><li>background的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分background的修改只触发repaint，当然IE不用考虑；</li><li>scroll页面，这个不可避免；</li><li>resize页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize程序窗口大小的多窗口操作系统。</li><li>读取元素的属性(这个无法理解，但是技术达人是这么说的，那就把它当做定理吧)：读取元素的某些属性(offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE))</li></ol></li></ol><p><strong>如何避免：</strong><br>　　说避免那是不可能的，不然就是以前古老的静态页面了，没有交互，那在现在看来，就是一个失败的作品。所以，在我们进行网页设计的时候，就必须尽量减少页面的repaint和reflow。repaint和reflow的目的是为了展示一个新的页面，那么我们在进行页面交互时，尽量通过各种方法减少repaint和reflow但又能展示一个新的页面的目的。所以下面将结合其他技术达人的建议，通过自己的理解，给大家讲解如何避免和优化repaint和reflow：</p><ol><li>尽可能在DOM末梢通过改变class来修改元素的style属性： 将多次改变样式属性的操作合并成一次操作，尽可能的减少受影响的DOM元素。</li><li>避免设置多项内联样式：使用常用的class的方式进行设置样式，以避免设置样式时访问DOM的低效率。</li><li>设置动画元素position属性为fixed或者absolute：由于当前元素从DOM流中独立出来，因此受影响的只有当前元素，元素repaint。</li><li>牺牲平滑度满足性能：动画精度太强，会造成更多次的repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。</li><li>避免使用table进行布局：table的每个元素的大小以及内容的改动，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以进行针对性的repaint和避免不必要的reflow。</li><li>避免在CSS中使用运算式：学习CSS的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端性能优化</title>
      <link href="/2019/02/13/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/02/13/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- 目录 --><!-- toc --><p>转载：<br><a href="http://www.cnblogs.com/lei2007/archive/2013/08/16/3262897.html" target="_blank" rel="noopener">前端性能优化–yahoo前端性能团队总结的35条黄金定律</a><br>参考文章：<br><a href="https://www.zhihu.com/question/21658448/answer/18903129" target="_blank" rel="noopener">Web前端应该从哪些方面来优化网站? - 斯迪的回答 - 知乎</a><br><a href="https://segmentfault.com/a/1190000008829958" target="_blank" rel="noopener">WEB前端性能优化常见方法</a><br>　　前端是庞大的，包括 HTML、 CSS、 Javascript、Image 、Flash等等各种各样的资源。前端优化是复杂的，针对方方面面的资源都有不同的方式。那么，为什么要进行前端性能优化？ 怎么进行优化？ 优化到达的效果是什么？<br><a id="more"></a></p><h3 id="为什么需要前端性能优化-优化的好处-目的"><a href="#为什么需要前端性能优化-优化的好处-目的" class="headerlink" title="为什么需要前端性能优化[优化的好处/目的]"></a>为什么需要前端性能优化[优化的好处/目的]</h3><p>好处： </p><ol><li>从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。</li><li>从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。</li></ol><p>前端优化的途径有很多，按粒度大致可以分为两类，第一类是<code>页面级别</code>的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;第二类则是<code>代码级别</code>的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。</p><h3 id="怎么进行优化"><a href="#怎么进行优化" class="headerlink" title="怎么进行优化"></a>怎么进行优化</h3><ul><li><p>内容优化</p><ol><li>减少Http请求次数<ul><li>原因: 这条策略是最重要最有效的，因为一个完整的请求要经过DNS寻址，与服务器建立连接，发送数据，等待服务器响应，接收数据这样一个消耗时间成本和资源成本的复杂的过程。</li><li>使用方法：<ol><li>从设计实现层面简化页面</li><li>合并多个CSS文件和js文件</li><li>利用CSS Sprites整合图像</li><li>Inline Images(使用 data：URL scheme在实际的页面嵌入图像数据 )</li><li>合理设置HTTP缓存等。</li><li>使用懒加载进行图片的加载</li></ol></li></ul></li><li>减少DNS查询<ul><li>原因: DNS查询也消耗响应时间，如果我们的网页内容来自各个不同的domain (比如嵌入了开放广告，引用了外部图片或脚本)，那么客户端首次解析这些domain也需要消耗一定的时间。DNS查询结果缓存在本地系统和浏览器中一段时间，所以DNS查询一般是对首次访问响应速度有所影响。</li><li>使用方法: <a href="https://www.cnblogs.com/chenxizhang/archive/2013/05/02/3053996.html" target="_blank" rel="noopener">优化网站设计（九）：减少DNS查找的次数</a><ol><li>减少DNS查找次数，最理想的方法就是将所有的内容资源都放在同一个域(Domain)下面，这样访问整个网站就只需要进行一次DNS查找，这样可以提高性能。</li><li>但理想总归是理想，上面的理想做法会带来另外一个问题，就是由于这些资源都在同一个域，而HTTP /1.1 中推荐客户端针对每个域只有一定数量的并行度（它的建议是2），那么就会出现下载资源时的排队现象，这样就会降低性能。</li><li>所以，折衷的做法是：建议在一个网站里面使用至少2个域，但不多于4个域来提供资源。我认为这条建议是很合理的，也值得我们在项目实践中去应用。</li></ol></li></ul></li><li><p>避免重定向</p><ul><li><p>当客户端收到服务器的跳转回复时，客户端再次根据服务器回复中的location指定的地址再次发送请求，例如以下跳转回复:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Location: http://example.com/newuri</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure></li><li><p>当客户端遇到这种回复的时候，用户只能等待客户端再次发送请求，有的网站甚至会一直跳n次，跳到他想带你去的地方…当然在这个时候用户看不到任何页面内容，只有浏览器的进度条一直在刷新。</p></li></ul></li><li>使用Ajax缓存<ul><li>Ajax可以帮助我们异步的下载网页内容，但是有些网页内容即使是异步的，用户还是在等待它的返回结果，例如ajax的返回是用户联系人的下拉列表。所以我们还是要注意尽量应用以下规则提高ajax的响应速度。</li><li>使用方法：<ul><li>添加Expires 或 Cache-Control报文头使回复可以被客户端缓存</li><li>压缩回复内容</li><li>减少dns查询</li><li>精简javascript</li><li>避免跳转</li><li>配置Etags</li></ul></li></ul></li><li>延迟加载组件,预加载组件<ul><li>延迟加载<ul><li>这里讨论延迟加载需要我们知道我们的网页最初加载需要的最小内容集是什么。剩下的内容就可以推到延迟加载的集合中。</li><li>Javascript是典型的可以延迟加载内容。一个比较激进的做法是开发网页时先确保网页在没有Javascript的时候也可以基本工作，然后通过延迟加载脚本来完成一些高级的功能。</li></ul></li><li>预加载<ul><li>与延迟加载目的相反，提前加载的是为了提前加载接下来网页中访问的资源，下面是提前加载的类型</li><li>无条件提前加载：当前网页加载完成后，马上去下载一些其他的内容。例如google会在页面加载成功之后马上去下载一个所有结果中会用到的image sprite。</li><li>有预期的的加载：这种情况一般发生在网页重新设计时，由于用户经常访问旧网页，本地对旧的网页内容缓存充分从而显得旧网页速度很快，而新的网页内容却没有缓存，设计者可以在旧网页的内容中预先加载一些新网页中可能用到的内容，这样新的网页就会生下来一些需要下载的资源。</li></ul></li></ul></li><li>减少DOM元素数量:<ul><li>页面中存在大量DOM元素,会导致javascript遍历DOM的效率变慢。</li><li>网页中元素过多对网页的加载和脚本的执行都是沉重的负担，500个元素和5000个元素在加载速度上会有很大差别。</li><li>想知道你的网页中有多少元素，通过在浏览器中的一条简单命令就可以算出<code>document.getElementsByTagName(&#39;*&#39;).length</code></li></ul></li><li>最小化iframe的数量：<ul><li>iframes 提供了一个简单的方式把一个网站的内容嵌入到另一个网站中。但其创建速度比其他包括JavaScript和CSS的DOM元素的创建慢了1-2个数量级。</li><li>优点<ol><li>可以用来加载速度较慢的内容，例如广告。</li><li>安全沙箱保护。浏览器会对iframe中的内容进行安全控制。</li><li>脚本可以并行下载</li></ol></li><li>缺点<ol><li>即使iframe内容为空也消耗加载时间</li><li>会阻止页面加载</li><li>没有语义</li></ol></li></ul></li><li>避免404：HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。<ul><li>404我们都不陌生，代表服务器没有找到资源，我们要特别要注意404的情况不要在我们提供的网页资源上，客户端发送一个请求但是服务器却返回一个无用的结果，时间浪费掉了。更糟糕的是我们网页中需要加载一个外部脚本，结果返回一个404，不仅阻塞了其他脚本下载，下载回来的内容(404)客户端还会将其当成Javascript去解析。</li></ul></li></ol></li><li>服务器优化<ul><li>(1)使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。<ul><li>再次强调第一条黄金定律，减少网页内容的下载时间。提高下载速度还可以通过CDN(内容分发网络)来提升。CDN通过部署在不同地区的服务器来提高客户的下载速度。如果你的网站上有大量的静态内容，世界各地的用户都在访问，我说的是youtube么？那CDN是必不可少的。事实上大多数互联网中的巨头们都有自己的CDN。我们自己的网站可以先通过免费的CDN供应商来分发网页资源。</li><li>添加Expires 或Cache-Control报文头(这条规则分为两个方面)<ol><li>对于静态内容添加Expires，将静态内容设为永不过期，或者很长时间以后。在IIS中设置Expires可以看Configure the HTTP Expires Response Header (IIS 7)。</li><li>对于动态内容应用合适的Cache-Control，让浏览器根据条件来发送请求。关于asp.net的caching，可以看asp.net cache feature和asp.net caching best practices。</li></ol></li></ul></li><li>(2)GZIP压缩<ul><li>Gzip通常可以减少70%网页内容的大小，包括脚本、样式表、图片等文件。Gzip比deflate更高效，主流服务器都有相应的压缩支持模块。</li></ul></li><li>(3)设置ETag：ETags（Entity tags，实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。<ul><li>虽然标题叫配制ETags，但是这里你要根据具体情况进行一些判断。首先Etag简单来说是通过一个文件版本标识使得服务器可以轻松判断该请求的内容是否有所更新，如果没有就回复304 (not modified)，从而避免下载整个文件。</li></ul></li><li>(4)提前刷新缓冲区<br>+ </li><li>(5)对Ajax请求使用GET方法<ul><li>浏览器在实现XMLHttpRequest POST的时候分成两步，先发header，然后发送数据。而GET却可以用一个TCP报文完成请求。另外GET从语义上来讲是去服务器取数据，而POST则是向服务器发送数据，所以我们使用Ajax请求数据的时候尽量通过GET来完成。</li></ul></li><li>(6)避免空的图像src<ul><li>空的图片src仍然会使浏览器发送请求到服务器，这样完全是浪费时间，而且浪费服务器的资源。尤其是你的网站每天被很多人访问的时候，这种空请求造成的伤害不容忽略。</li></ul></li></ul></li><li>Cookie优化<ul><li>(1)减小Cookie大小<ul><li>去除没有必要的cookie，如果网页不需要cookie就完全禁掉</li><li>将cookie的大小减到最小</li><li>注意cookie设置的domain级别，没有必要情况下不要影响到sub-domain</li><li>设置合适的过期时间，比较长的过期时间可以提高响应速度。</li></ul></li><li>(2)针对Web组件使用域名无关的Cookie<ul><li>大多数网站的静态资源都没必要cookie，我们可以采用不同的domain来单独存放这些静态文件，这样做不仅可以减少cookie大小从而提高响应速度，还有一个好处是有些proxy拒绝缓存带有cookie的内容，如果能将这些静态资源cookie去除，那就可以得到这些proxy的缓存支持。</li><li>常见的划分domain的方式是将静态文件放在static.example.com，动态内容放在<a href="http://www.example.com。" target="_blank" rel="noopener">www.example.com。</a></li><li>也有一些网站需要在二级域名上应用cookie，所有的子域都会继承，这种情况下一般会再购买一个专门的域名来存放cookie-free的静态资源。例如Yahoo!的yimg.com，YouTube的ytimg.com等。</li></ul></li></ul></li><li>CSS优化<ul><li>(1)将CSS代码放在HTML页面的顶部<ul><li>经样式表(css)放在网页的HEAD中会让网页显得加载速度更快，因为这样做可以使浏览器逐步加载已将下载的网页内容。这对内容比较多的网页尤其重要，用户不用一直等待在一个白屏上，而是可以先看已经下载的内容。</li><li>如果将样式表放在底部，浏览器会拒绝渲染已经下载的网页，因为大多数浏览器在实现时都努力避免重绘，样式表中的内容是绘制网页的关键信息，没有下载下来之前只好对不起观众了。</li></ul></li><li>(2)避免使用CSS表达式<ul><li>CSS表达式可以动态的设置CSS属性，在IE5-IE8中支持，其他浏览器中表达式会被忽略。例如下面表达式在不同时间设置不同的背景颜色。</li><li>CSS表达式的问题在于它被重新计算的次数远比我们想象的要多，不仅在网页绘制或大小改变时计算，即使我们滚动屏幕或者移动鼠标的时候也在计算，因此我们还是尽量避免使用它来防止使用不当而造成的性能损耗。</li></ul></li><li>(3)使用<link>来代替@import<ul><li>避免使用@import的原因很简单，因为它相当于将css放在网页内容底部。</li></ul></li><li>(4)避免使用Filters<ul><li>AlphaImageLoad也是IE5.5 - IE8中支持，这种滤镜的使用会导致图片在下载的时候阻塞网页绘制，另外使用这种滤镜会导致内存使用量的问题。IE9中已经不再支持。</li></ul></li></ul></li><li>JS优化<ul><li>(1)将JavaScript脚本放在页面的底部。<ul><li>HTTP/1.1 specification建议浏览器对同一个hostname不要超过两个并行下载连接， 所以当你从多个domain下载图片的时候可以提高并行下载连接数量。但是当脚本在下载的时候，即使是来自不同的hostname浏览器也不会下载其他资源，因为浏览器要在脚本下载之后依次解析和执行。</li><li>因此对于脚本提速，我们可以考虑以下方式，<ul><li>把脚本置底，这样可以让网页渲染所需要的内容尽快加载显示给用户。</li><li>现在主流浏览器都支持defer关键字，可以指定脚本在文档加载后执行。</li><li>HTML5中新加了async关键字，可以让脚本异步执行。</li></ul></li></ul></li><li>(2)将JavaScript和CSS作为外部文件来引用：<ul><li>使用外部Javascript和CSS文件可以使这些文件被浏览器缓存，从而在不同的请求内容之间重用。</li><li>同时将Javascript和CSS从inline变为external也减小了网页内容的大小。</li><li>使用外部Javascript和CSS文件的决定因素在于这些外部文件的重用率，如果用户在浏览我们的页面时会访问多次相同页面或者可以重用脚本的不同页面，那么外部文件形式可以为你带来很大的好处。但对于用户通常只会访问一次的页面，例如microsoft.com首页，那inline的javascript和css相对来说可以提供更高的效率。</li></ul></li><li>(3)缩小JavaScript和CSS<ul><li>精简就是将Javascript或CSS中的空格和注释全去掉，</li></ul></li><li>(4)删除重复的脚本<ul><li>重复的脚本不仅浪费浏览器的下载时间，而且浪费解析和执行时间。一般用来避免引入重复脚本的做法是使用统一的脚本管理模块，这样不仅可以避免重复脚本引入，还可以兼顾脚本依赖管理和版本管理。</li></ul></li><li>(5)最小化DOM的访问：使用JavaScript访问DOM元素比较慢。<ul><li>通过Javascript访问DOM元素没有我们想象中快，元素多的网页尤其慢，对于Javascript对DOM的访问我们要注意<ul><li>缓存已经访问过的元素</li><li>Offline更新节点然后再加回DOM Tree</li><li>避免通过Javascript修复layout</li></ul></li></ul></li><li>(6)开发智能的事件处理程序<ul><li>这里说智能的事件处理需要开发者对事件处理有更深入的了解，通过不同的方式尽量少去触发事件，如果必要就尽早的去处理事件。</li><li>比如一个div中10个按钮都需要事件句柄，那么我们可以将事件放在div上，在事件冒泡过程中捕获该事件然后判断事件来源。</li></ul></li><li>(7)javascript代码注意：<ul><li>谨慎使用with,避免使用eval Function函数,减少作用域链查找。<ul><li>with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的 执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。</li><li>因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。</li></ul></li></ul></li></ul></li><li>图像优化<ul><li>(1)优化图片大小<ul><li>检查GIF图片中图像颜色的数量是否和调色板规格一致。如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。可以使用imagemagick检查：identify -verbose image.gif</li><li>尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。下面这条简单的命令可以安全地把GIF格式转换为PNG格式： convert image.gif image.png</li><li>在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如： pngcrush image.png -rem alla -reduce -brute result.png</li><li>在所有的JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息 jpegtran -copy none -optimize -perfect src.jpg dest.jpg</li></ul></li><li>(2)通过CSS Sprites优化图片<ul><li>Spirite中水平排列图片，垂直排列会增加文件大小；</li><li>Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；</li><li>不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小,但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100×100的图片为1万像素，1000×1000就是100万像素。</li></ul></li><li>(3)不要在HTML中使用缩放图片<ul><li>不要通过图片缩放来适应页面，如果你需要小图片，就直接使用小图片吧。</li></ul></li><li>(4)favicon.ico要小而且可缓存<ul><li>网站图标文件favicon.ico，不管你服务器有还是没有，浏览器都会去尝试请求这个图标。所以我们要确保这个图标<ol><li>存在</li><li>文件尽量小，最好小于1k</li><li>设置一个长的过期时间</li></ol></li></ul></li></ul></li><li>移动客户端<ul><li>保持单个内容小于25KB<ul><li>这限制是因为iphone，他只能缓存小于25K，注意这是解压后的大小。所以单纯gzip不一定够用，精简文件工具要用上了。</li></ul></li><li>打包组建成符合文档<ul><li>把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组建。当你使用这条规则时，首先要确定用户代理是否支持（iPhone不支持）。</li></ul></li></ul></li></ul><h3 id="待解决的方面"><a href="#待解决的方面" class="headerlink" title="待解决的方面"></a>待解决的方面</h3><blockquote><p>转载别人，如有错误请指出。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二分查找</title>
      <link href="/2019/01/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/01/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>二分查找又称折半查找，它是一种效率较高的查找方法。<br>二分查找要求：线性表是有序表，即表中结点按关键字有序，并且要用向量作为表的存储结构。不妨设有序表是递增有序的。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>二分查找的基本思想是：<br>设<code>R[low..high]</code>是当前的查找区间<br>（1）首先确定该区间的中点位置：<code>mid = [(low+hight)/2]</code><br>（2）然后将待查的K值与R[mid].key比较：若相等，则查找成功并返回此位置，否则须确定新的查找区间，继续二分查找，具体方法如下：<br>①  若<code>R[mid].key&gt;K</code>，则由表的有序性可知<code>R[mid..n].keys</code>均大于K，因此若表中存在关键字等于K的结点，则该结点必定是在位置mid左边的子表<code>R[1..mid-1]</code>中，故新的查找区间是左子表<code>R[1..mid-1]</code>。<br>②  若<code>R[mid].key&lt;K</code>，则要查找的K必在mid的右子表<code>R[mid+1..n]</code>中，即新的查找区间是右子表<code>R[mid+1..n]</code>。下一次查找是针对新的查找区间进行的。</p><p>因此，从初始的查找区间R[1..n]开始，每经过一次与当前查找区间的中点位置上的结点关键字的比较，就可确定查找是否成功，不成功则当前的查找区间就缩小一半。这一过程重复直至找到关键字为K的结点，或者直至当前的查找区间为空(即查找失败)时为止。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>二分查找(折半查找)优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。时间复杂度可以表示<code>O(h)=O(log2n)</code>，以2为底，n的对数。比如数组长度为10，最多找4次。</p><h3 id="储存结构"><a href="#储存结构" class="headerlink" title="储存结构"></a>储存结构</h3><p>二分查找只适用于顺序储存结构</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>伪元素和伪类</title>
      <link href="/2018/11/16/CSS3/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/"/>
      <url>/2018/11/16/CSS3/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- top --><a id="more"></a><h4 id="伪元素和伪类"><a href="#伪元素和伪类" class="headerlink" title="伪元素和伪类"></a>伪元素和伪类</h4><p><code>伪类</code>包含两种：<code>状态伪类</code>和<code>结构性伪类</code>。<br>　　<code>状态伪类</code>是基于<code>元素当前状态进行选择的</code>。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。<br>　　当元素处于某状态时会呈现该样式，而进入另一状态后，该样式也会失去。常见的状态伪类主要包括：<br>　　<code>:link</code> 应用于未被访问过的链接；<br>　　<code>:hover</code> 应用于鼠标悬停到的元素；<br>　　<code>:active</code> 应用于被激活的元素；<br>　　<code>:visited</code> 应用于被访问过的链接，与:link互斥。<br>　　<code>:focus</code> 应用于拥有键盘输入焦点的元素。</p><p>　　<code>结构性伪类</code>是css3新增选择器，利用dom树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少class和id属性的定义，使文档结构更简洁。常见的包括：<br>　　<code>:first-child</code> 选择某个元素的第一个子元素；<br>　　<code>:last-child</code> 选择某个元素的最后一个子元素；<br>　　<code>:nth-child()</code> 选择某个元素的一个或多个特定的子元素；<br>　　<code>:nth-last-child()</code> 选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算；<br>　　<code>:nth-of-type()</code> 选择指定的元素；<br>　　<code>:nth-last-of-type()</code> 选择指定的元素，从元素的最后一个开始计算；<br>　　<code>:first-of-type</code> 选择一个上级元素下的第一个同类子元素；<br>　　<code>:last-of-type</code> 选择一个上级元素的最后一个同类子元素；<br>　　<code>:only-child</code> 选择的元素是它的父元素的唯一一个子元素；<br>　　<code>:only-of-type</code> 选择一个元素是它的上级元素的唯一一个相同类型的子元素；<br>　　<code>:empty</code> 选择的元素里面没有任何内容。</p><p>　　<code>伪元素</code>是<code>对元素中的特定内容进行操作，而不是描述状态</code>。它的操作层次<code>比伪类更深一层</code>，因此动态性比伪类低很多。实际上，伪元素就是选取某些元素前面或后面这种普通选择器无法完成的工作。控制的内容和元素是相同的，但它本身是基于元素的抽象，并不存在于文档结构中！常见的伪元素选择器包括：<br>　　<code>:first-letter</code> 选择元素文本的第一个字（母）。<br>　　<code>:first-line</code> 选择元素文本的第一行。<br>　　<code>:before</code> 在元素内容的最前面添加新内容。<br>　　<code>:after</code> 在元素内容的最后面添加新内容。</p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>　　有时你会发现伪类元素使用了两个冒号 <code>(::)</code> 而不是一个冒号 <code>(:)</code>，这是 CSS3 规范中的一部分要求，<code>目的是为了区分伪类和伪元素，大多数浏览器都支持这两种表示方式</code>。单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。对于 CSS2 中已经有的伪元素，例如 <code>:before，单冒号和双冒号的写法 ::before 作用是一样的</code>。</p><p>　　所以，如果你的网站只需要兼容 webkit、firefox、opera 等浏览器，建议对于伪元素采用双冒号的写法，如果不得不兼容 IE 浏览器，还是用 CSS2 的单冒号写法比较安全。</p><p>参考文章：<br>　　<a href="https://segmentfault.com/a/1190000012156828" target="_blank" rel="noopener">谈谈css伪类与伪元素</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>盒子模型</title>
      <link href="/2018/11/06/CSS3/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/11/06/CSS3/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="盒子样式介绍"><a href="#盒子样式介绍" class="headerlink" title="盒子样式介绍"></a>盒子样式介绍</h4><ul><li>width和height：内容的宽度、高度（不是盒子的宽度、高度）</li><li>padding：内边距。</li><li>border：边框。</li><li>margin：外边距。</li></ul><hr><h4 id="盒子模型的分类与概念"><a href="#盒子模型的分类与概念" class="headerlink" title="盒子模型的分类与概念"></a>盒子模型的分类与概念</h4><p>　　盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是<strong><em>IE盒子模型</em></strong>和<strong><em>标准 w3c 盒子模型</em></strong>。<br>他们对盒子模型的解释各不相同:<br>　　IE 盒子模型的范围也包括 <strong><em>margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 padding</em></strong>。<br><img src="/assets/images/盒子模型-IE.jpg" alt="IE盒子模型"><br>　　标准 W3C 盒子模型的范围包括 <strong><em>margin、border、padding、content，并且 content 部分不包含其他部分</em></strong>。<br><img src="/assets/images/盒子模型-标准.jpg" alt="标准盒子模型"></p><p><strong>ps</strong>:<br>　　1. ie8以上都是w3c标准盒模型 　　<br>　　2. ie5极其以下都是ie盒子模型，ie6、ie7、ie8在混杂模式下ie盒模型，<br>　　3. 在标准模式下是w3c标准盒模型<br>　　4. 注意：ie6在混杂模式下一定是Ie盒模型，而ie7、ie8在混杂模式下不一定是ie盒模型</p><blockquote><p>border-box  width 和 height 属性包括内容，内边距和边框，但不包括外边距。<br>这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。注意，填充和边框将在盒子内 。<br>例如, .box {width: 350px; border: 10px solid black;} 导致在浏览器中呈现的宽度为350px<br>的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。<br>这里的维度计算为：<br>width = border + padding + 内容的  width，<br>height = border + padding + 内容的 height。</p></blockquote><p>box-sizing：<br>content-box（默认）<br>content-box 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。<br>border-box<br><code>border-box</code> 告诉浏览器去理解你设置的<code>边框</code>和<code>内边距</code>的值是包含在width内的。也就是说，如果你将一个元素的width设为100px,那么这100px会包含其<code>border</code>和<code>padding</code>，内容区的实际宽度会是<code>width</code>减去(<code>border + padding</code>)的计算值。大多数情况下这使得我们更容易的去设定一个元素的宽高。<br>inherit</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>H5新特性</title>
      <link href="/2018/11/06/H5/HTML5/"/>
      <url>/2018/11/06/H5/HTML5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>语义化标签: <code>header</code> <code>footer</code> <code>nav</code> <code>section</code> <code>article</code> <code>aside</code> 等<br>增强型表单：<br><code>HTML4</code>: <code>text</code>、<code>checkbox</code>、<code>password</code>、<code>radio</code>、<code>submit</code>、<code>reset</code>、<code>File</code><br><code>HTML5</code>： <code>date</code>(从一个日期选择器选择一个日期) <code>email</code>(包含 <code>e-mail</code> 地址的输入域) <code>number</code>(数值的输入域) <code>range</code>(一定范围内数字值的输入域) <code>search</code>(用于搜索域) <code>tel</code>(定义输入电话号码字段) <code>url</code>、 <code>color</code>、 <code>month</code>、week<code>等视频和音频：</code>audio<code></code>video<code></code>Canvas<code>绘图</code>SVG<code>绘图地理定位：</code>Geolocation<code>拖放API：</code>drag<code></code>web worker<code>：是运行在后台的</code>JavaScript<code>,独立于其他脚本，不会影响页面的性能</code>web storage<code>:</code>localStorage sessionStorage<code></code>WebSocket<code>:</code>HTML5<code>开始提供的一种在单个</code>TCP` 连接上进行全双工通讯的协议</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>块级元素行内元素</title>
      <link href="/2018/11/06/CSS3/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/"/>
      <url>/2018/11/06/CSS3/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><code>块级元素(display: block)</code>:<br>　　1. 每个块级元素都从新的一行开始，并且其后的元素也另起一行。<br>　　2. 元素的高度、宽度、行高以及顶和底边距都可设置。<br>　　3. 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致）。默认高度等于子元素高度。父子均是块级元素时，子块的高度可能冲破父级的限制</p><p><code>内联元素(display: inline)</code><br>　　1. 指的是书写完成后不会自动换行，并且元素没有宽和高。<br>　　2. 和其他内联元素都在一行上；<br>　　3. 可以通过<code>margin</code>、<code>padding</code>来改变左右的距离，但不可以改变上下的距离，导致<code>width</code>、<code>height</code>、<code>line-height</code>失效或。可以使用<code>border</code>。<br>　　4. 内联元素之间有空白区域，空白区域的形成是因为<code>&lt;span&gt;</code>之间有回车，在<code>html</code>中，空格、制表符、回车都属于空白符，多个空白符都会视为一个空格，空格的大小由父级<code>&lt;div&gt;</code>的<code>font-size</code>决定。注意：只有内联(内联块)与内联(内联块)之间的空白符才会形成一个空格，文本元素(除空白符)也是属于内联元素。常用解决方法，给<code>&lt;div&gt;</code>设置<code>font-size: 0;</code>，在<code>&lt;span&gt;</code>上把<code>font-size</code>设置回去</p><p><code>内联块状元素(display: inline-block)</code><br>　　1. 和其他元素都在一行上；<br>　　2. 元素的高度、宽度、行高以及顶和底边距都可设置。<br>　　3. 它也会有元素间出现空白区域的问题</p><p>空元素<br>没有内容的HTML元素<br><code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><strong>内联元素有</strong>：<code>span</code>、<code>img</code>、<code>a</code>、<code>lable</code>、<code>input</code>、<code>abbr</code>（缩写）、<code>em</code>（强调）、<code>big</code>、<code>cite</code>（引用）、<code>i</code>（斜体）、<code>q</code>（短引用）、<code>textarea</code>、<code>select</code>、<code>small</code>、<code>sub</code>、<code>sup</code>，<code>strong</code>、<br><code>u</code>（下划线）、<code>button</code>（默认<code>display：inline-block</code>）<br><strong>块级元素有</strong>：<code>div</code>、<code>p</code>、<code>h1~h6</code>、<code>ul</code>、<code>ol</code>、<code>dl</code>、<code>li</code>、<code>dd</code>、<code>table</code>、<code>hr</code>、<code>blockquote</code>、<code>address</code>、<code>menu</code>、<code>pre</code>，HTML5新增的<code>header</code>、<code>section</code>、<code>aside</code>、<code>footer</code><br><strong>内联块状元素</strong>： <code>a</code>, <code>br</code>, <code>em</code>, <code>font</code>, <code>img</code>, <code>input</code>, <code>label</code>, <code>select</code>, <code>small</code>, <code>span</code>, <code>textarea</code></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>README</title>
      <link href="/2018/10/22/README/README/"/>
      <url>/2018/10/22/README/README/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>It just a test music, but i like it </p>        <div id="aplayer-ranvCYmg" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ranvCYmg"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "起风了",              author: "买辣椒也用券",              url: "/assets/music/music.mp3",              pic: "/assets/music/music.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情感 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深浅拷贝</title>
      <link href="/2018/10/16/JavaScript/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2018/10/16/JavaScript/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载：<br>　　<a href="https://www.cnblogs.com/136asdxxl/p/8645750.html" target="_blank" rel="noopener">js 深浅拷贝 笔记总结</a><br>　　<a href="https://www.cnblogs.com/echolun/p/7889848.html" target="_blank" rel="noopener">[JS]深拷贝与浅拷贝的区别，实现深拷贝的几种方法</a></p><h5 id="JS-数据类型"><a href="#JS-数据类型" class="headerlink" title="JS 数据类型"></a>JS 数据类型</h5><p>JavaScript的数据类型有： <strong>数值类型</strong>(number) 、 <strong>字符串类型</strong>(string) 、 <strong>布尔类型</strong>(boolean) 、 <strong>null</strong> 、<strong>undefined</strong> 、<strong>对象(数组、正则表达式、日期、函数)</strong><a id="more"></a><br>大致分为两种： <strong>基本数据类型</strong> 和 <strong>引用数据类型</strong><br>基本数据类型： 数字类型(number)、字符串类型(string)、布尔类型(boolean)、null、undefined<br>引用数据类型： 常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等</p><h5 id="深浅拷贝区别"><a href="#深浅拷贝区别" class="headerlink" title="深浅拷贝区别"></a>深浅拷贝区别</h5><p>　　如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。</p><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p><code>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存</code><br>　　浅拷贝只是拷贝<code>基本类型的数据</code>，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，因此存在父对象被篡改的可能，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p><code>深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份</code>。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。<br>　　深拷贝就是能够实现真正意义上的数组和对象的拷贝。递归调用”浅拷贝”。（深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象）</p><h5 id="实现深浅拷贝"><a href="#实现深浅拷贝" class="headerlink" title="实现深浅拷贝"></a>实现深浅拷贝</h5><p>浅拷贝例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    b=a;</span><br><span class="line"><span class="built_in">console</span>.log(a===b);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/assets/images/浅拷贝1.png" alt="浅拷贝例子结果"><br>嗯？明明b复制了a，为啥修改数组a，数组b也跟着变了，这里我不禁陷入了沉思。<br>那么这里，就得引入基本数据类型与引用数据类型的概念了。</p><p>a.<strong>基本类型</strong>–名值存储在栈内存中，例如let a=1;<br><img src="/assets/images/拷贝2.jpg" alt="基本类型"><br>当你b=a复制时，栈内存会新开辟一个内存，例如这样：<br><img src="/assets/images/拷贝3.jpg" alt="基本类型"><br>所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。</p><p>b.<strong>引用数据类型</strong>–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：<br><img src="/assets/images/拷贝4.jpg" alt="引用数据类型"><br>当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。<br><img src="/assets/images/拷贝5.jpg" alt="引用数据类型"><br>而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。<br><img src="/assets/images/拷贝6.jpg" alt="引用数据类型"><br>那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，起步就达到深拷贝的效果了<br><img src="/assets/images/拷贝7.jpg" alt="引用数据类型"></p><p>1.我们怎么去实现深拷贝呢，这里可以递归递归去复制所有层级属性。<br>这么我们封装一个深拷贝的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objClone = <span class="built_in">Array</span>.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj===<span class="string">"object"</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">      <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">        <span class="comment">//判断ojb子元素是否为对象，如果是，递归复制</span></span><br><span class="line">        <span class="keyword">if</span>(obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] ===<span class="string">"object"</span>)&#123;</span><br><span class="line">          objClone[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//如果不是，简单复制</span></span><br><span class="line">          objClone[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="/assets/images/深拷贝1.png" alt="深拷贝例子结果"><br>跟之前想象的一样，现在b脱离了a的控制，不再受a影响了。<br>这里再次强调，深拷贝，是拷贝对象各个层级的属性，可以看个例子。JQ里有一个extend方法也可以拷贝对象，我们来看看<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    b=a.slice();</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/assets/images/深拷贝2.png" alt="深拷贝例子2结果"><br>那是不是说slice方法也是深拷贝了，毕竟b也没受a的影响，上面说了，深拷贝是会拷贝所有层级的属性，还是这个例子，我们把a改改<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">        b=a.slice();</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/assets/images/深拷贝3.png" alt="深拷贝例子3结果"><br>拷贝的不彻底啊，b对象的一级属性确实不受影响了，但是二级属性还是没能拷贝成功，仍然脱离不了a的控制，说明slice根本不是真正的深拷贝。<br>这里引用知乎问答里面的一张图<br><img src="/assets/images/拷贝知乎.jpg" alt="深拷贝知乎"></p><p>第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。</p><p>同理，concat方法与slice也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。</p><p>2.除了递归，我们还可以借用JSON对象的parse和stringify</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _obj = <span class="built_in">JSON</span>.stringify(obj),</span><br><span class="line">        objClone = <span class="built_in">JSON</span>.parse(_obj);</span><br><span class="line">    <span class="keyword">return</span> objClone</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/assets/images/json深拷贝.png" alt="深拷贝例子4结果"><br>可以看到，这下b是完全不受a的影响了。</p><p>附带说下，JSON.stringify与JSON.parse除了实现深拷贝，还能结合localStorage实现对象数组存储</p><p>3.除了上面两种方法之外，我们还可以借用JQ的extend方法。<br><code>$.extend( [deep ], target, object1 [, objectN ] )</code><br>deep表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝<br>target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。<br>object1  objectN可选。 Object类型 第一个以及第N个被合并的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">    b=$.extend(<span class="literal">true</span>,[],a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure></p><p>可以看到，效果与上面方法一样，只是需要依赖JQ库。<br><img src="/assets/images/深拷贝jquery.png" alt="深拷贝jquery方法"><br>　　说了这么多，了解深拷贝也不仅仅是为了应付面试题，在实际开发中也是非常有用的。例如后台返回了一堆数据，你需要对这堆数据做操作，但多人开发情况下，你是没办法明确这堆数据是否有其它功能也需要使用，直接修改可能会造成隐性问题，深拷贝能帮你更安全安心的去操作数据，根据实际情况来使用深拷贝，大概就是这个意思。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试题-思维</title>
      <link href="/2018/10/16/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/"/>
      <url>/2018/10/16/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="题目：-给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值"><a href="#题目：-给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值" class="headerlink" title="题目： 给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值"></a>题目： 给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值</h4><p>方法一：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a^b;</span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br></pre></td></tr></table></figure></p><h4 id="题目：-给两个杯子，一个5升，一个6升，水随便用，最后取出3升水"><a href="#题目：-给两个杯子，一个5升，一个6升，水随便用，最后取出3升水" class="headerlink" title="题目： 给两个杯子，一个5升，一个6升，水随便用，最后取出3升水"></a>题目： 给两个杯子，一个5升，一个6升，水随便用，最后取出3升水</h4><p>方法：</p><ol><li>6升装满倒入5升杯子，6升杯子里剩1升水；</li><li>6升杯子中的1升倒入5升杯子；</li><li>6升杯子装满水倒入5升杯子，6升杯子里剩2升水；把5升杯子水倒掉；</li><li>6升杯子中的2升倒入5升杯子；</li><li>6升杯子装满水倒入5升杯子，6升杯子里剩3升水，完成。</li></ol><h4 id="题目：-给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子"><a href="#题目：-给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子" class="headerlink" title="题目： 给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子"></a>题目： 给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子</h4><p>方法：<br>二分法：<br>用天平左右各五个进行称量，10 =&gt; 5<br>较轻的一组留下一个，继续进行分开称量，如果左右相等，则剩余的那一个为最轻的，否则剩下的两个继续进行比较5 =&gt; 1 || 5 =&gt; 2<br>最后一次比较 2 =&gt; 1</p>]]></content>
      
      
      <categories>
          
          <category> 思维能力 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP和HTTPS的区别</title>
      <link href="/2018/10/15/HTTP/HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/10/15/HTTP/HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>　　超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，<strong>HTTP协议以明文方式发送内容</strong>，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。<br>　　为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，<strong>HTTPS在HTTP的基础上加入了SSL协议</strong>，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。<br><!-- more --></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP的基本概念"><a href="#HTTP的基本概念" class="headerlink" title="HTTP的基本概念"></a>HTTP的基本概念</h4><p>　　HTTP: 是互联网上应用最为广泛的一种网络协议，是一个<code>客户端和服务器端请求和应答的标准（TCP）</code>，<code>用于从WWW服务器传输超文本到本地浏览器的传输协议</code>，它可以使浏览器更加高效，使网络传输减少。<br>　　HTTP: 是<code>超文本传输协议</code>，<code>信息是明文传输</code></p><h4 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h4><blockquote><p>通信使用明文，可能被窃听<br>不验证通信方的身份，可能遭遇伪装<br>无法证明报文的完整性，有可能遭遇篡改</p></blockquote><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="HTTPS的基本概念"><a href="#HTTPS的基本概念" class="headerlink" title="HTTPS的基本概念"></a>HTTPS的基本概念</h4><p>　　HTTPS(<code>Secure Hypertext Transfer Protocol</code>)是安全超文本传输协议,简单讲是HTTP的安全版，即<code>HTTP下加入SSL层</code>，<code>HTTPS的安全基础是SSL</code>，因此加密的详细内容就需要SSL。<br>　　https: 是具有安全性的ssl加密传输协议<br>　　HTTPS协议的主要作用可以分为两种：一种是建立一个<strong><em>信息安全通道</em></strong>，来保证数据传输的安全；另一种就是<strong><em>确认网站的真实性</em></strong>。<br><strong>注意：</strong><br>　　凡是用过网银的用户一定见过类似的网址 <code>https://bank.xxxx.com</code> ，这个就是传输层加密，报文格式：<code>IP + TCP + SSL + HTTP</code><br>　　<code>SSL</code>负责加密/解密工作，由于<code>SSL</code>工作在<code>传输层与应用层</code>之间，一般称之为<code>传输层加密</code>。<br>　　通常来说，<code>加密代理服务器，还有Cisco Anyconnect 都属于传输层加密，都是基于SSL/TLS加密</code>。</p><h4 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h4><ol><li>客户端发起HTTPS请求<br>　　用户在浏览器里输入一个https网址，然后连接到server的443端口。</li><li>服务端的配置<br>　　采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。<br>　　这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li><li>传送证书<br>　　这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等</li><li>客户端解析证书<br>　　这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。<br>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</li><li>传送加密信息<br>　　这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li><li>服务段解密信息<br>　　服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li><li>传输加密后的信息<br>　　这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</li><li>客户端解密信息<br>　　客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</li></ol><h4 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h4><ol><li>SEO方面<br>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li><li>安全性<br>　　使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；<br>　　HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。<br>　　HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、HTTPS具有更好的加密性能，避免用户信息泄露;</span><br><span class="line">2、HTTPS复杂的传输方式，降低网站被劫持的风险;</span><br><span class="line">3、搜索引擎已经全面支持HTTPS抓取、收录，并且会优先展示HTTPS结果;</span><br><span class="line">4、从安全角度来说个人觉得要做HTTPS，不过HTTPS可以采用登录后展示;</span><br><span class="line">5、HTTPS绿锁表示可以提升用户对网站信任程度;</span><br><span class="line">6、基础成本可控，证书及服务器已经有了成型的支持方案;</span><br><span class="line">7、网站加载速度可以通过cdn等方式进行弥补，但是安全不能忽略;</span><br><span class="line">8、HTTPS是网络的发展趋势，早晚都要做;</span><br><span class="line">9、可以有效防止山寨、镜像网站;</span><br></pre></td></tr></table></figure></li></ol><h4 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h4><ol><li>SEO方面<br>　　据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。<br>　　而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。<br>　　最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li><li>经济方面<br>　　SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。<br>　　SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。<br>　　HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。<br>　　HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去。<br>　　HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、HTTPS会降低用户访问速度，增加网站服务器的计算资源消耗;</span><br><span class="line">2、目前搜索引擎只是收录了小部分HTTPS内容，应该保持观望制度;</span><br><span class="line">3、HTTPS需要申请加密协议，增加了运营成本;</span><br><span class="line">4、百度目前对HTTPS的优先展现效果不明显，谷歌较为明显;</span><br><span class="line">5、技术门槛较高，无从下手;</span><br><span class="line">6、目前站点不涉及私密信息，无需HTTPS;</span><br><span class="line">7、兼容性有待提升，如robots不支持/联盟广告不支持等;</span><br><span class="line">8、HTTPS网站的安全程度有限，该被黑还是被黑;</span><br><span class="line">9、HTTPS维护比较麻烦，在搜索引擎支持HTTP的情况，没必要做HTTPS;</span><br></pre></td></tr></table></figure></li></ol><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><table><thead><tr><th>区别</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>端口号</td><td>80</td><td>443</td></tr><tr><td>安全性</td><td>http是<code>超文本传输协议</code>，<code>信息是明文传输</code>，因此使用HTTP协议传输隐私信息非常不安全</td><td>https 是具有安全性的ssl加密传输协议</td></tr><tr><td>连接</td><td>http的连接很简单，是无状态的</td><td>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</td></tr><tr><td>证书</td><td></td><td>https协议需要到ca申请证书，一般免费证书很少，需要交费。</td></tr></tbody></table><p>参考文章：<br>　　<a href="http://www.mahaixiang.cn/internet/1233.html" target="_blank" rel="noopener">HTTP和HTTPS的区别</a><br>　　<a href="https://www.cnblogs.com/wudaoyongchang/p/6253451.html" target="_blank" rel="noopener">HTTP与HTTPS的区别</a><br>　　<a href="http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/" target="_blank" rel="noopener">HTTP详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP连接性能优化</title>
      <link href="/2018/10/14/HTTP/HTTP%E8%BF%9E%E6%8E%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/10/14/HTTP/HTTP%E8%BF%9E%E6%8E%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h3 id="HTTP和TCP-IP的关系"><a href="#HTTP和TCP-IP的关系" class="headerlink" title="HTTP和TCP/IP的关系"></a>HTTP和TCP/IP的关系</h3><p>HTTP—&gt;(TSL/SSL)—&gt;TCP—&gt;IP<br>HTTP处于应用层、TCP处于传输层、IP处于网络层</p><ol><li>HTTP将所需要传输的数据以流的形式传递给TCP程序</li><li>TCP解析数据中的IP地址和端口号，将数据流分割成数据段，并添加上TCP段首部，如TCP握手（ACK、SYNC等），源端口，目的端口、TCP校验和等</li><li>TCP程序将包装好的TCP数据段叫给IP程序，IP程序在此基础上封装进去IP分组首部，如源IP地址、目的IP地址，数据报总长度、分组ID、首部长度、首部校验和等等</li><li>最后交给数据链路层去发送这个IP分组数据段<a id="more"></a><h3 id="TCP性能的考虑"><a href="#TCP性能的考虑" class="headerlink" title="TCP性能的考虑"></a>TCP性能的考虑</h3><strong>HTTP紧挨着TCP，所以TCP的链接性能考虑直接影响的HTTP事务的性能。</strong></li></ol><h4 id="HTTP事务时延"><a href="#HTTP事务时延" class="headerlink" title="HTTP事务时延"></a>HTTP事务时延</h4><p>一次HTTP请求可分为 <strong>DNS查询</strong>、<strong>连接</strong>、<strong>请求</strong>、<strong>事务处理</strong>、<strong>响应</strong>、<strong>关闭连接</strong>。每一步都会产生时延。其中，相对于<strong>连接</strong>、<strong>请求</strong>所消耗的时间，<strong><em>事务处理</em></strong>的时间是很短的。</p><p>对HTTP程序员产生影响的时延 </p><ul><li>TCP握手建立链接 </li><li>TCP慢启动拥塞控制 </li><li>数据聚集的Nagle算法 </li><li>用于捎带确认的TCP延迟确认算法 </li><li>TIME_WAIT 时延和端口耗尽</li></ul><h4 id="HTTP连接处理"><a href="#HTTP连接处理" class="headerlink" title="HTTP连接处理"></a>HTTP连接处理</h4><h5 id="Connection首部真正用途"><a href="#Connection首部真正用途" class="headerlink" title="Connection首部真正用途"></a>Connection首部真正用途</h5><p>HTTP允许客户端和源服务器之间存在多个代理服务器或高速缓存服务器，进行HTTP连接通信时，可以将HTTP首部逐跳的经过这些设备。这个时候，怎么在相邻的HTTP应用程序之间的连接应用一些特殊的选项呢？— Connection首部，可以承载3种不同类型的标签，这些标签不会传播到其它连接中去。<br>a、HTTP首部字段名，列出了只与此连接有关的选项<br>b、任意标签，用于描述此连接的非标准选项<br>c、值close，说明操作完成之后需关闭这条持久连接<br>由于添加Connection首部的其它首部字段，不能随着报文转发出去。因此将逐跳首部放入Connection首部，就可以达到对首部的保护。<br>例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Cache-control: max-age=<span class="number">3600</span></span><br><span class="line">Connection: meter,close,bill-my-credit-card</span><br><span class="line">Meter: max-uses=<span class="number">3</span>,max-refuses=<span class="number">6</span>,dont-report</span><br></pre></td></tr></table></figure></p><p>实例说明：不应该转发Meter首部，要应用假想的bill-my-credit-card选项，且本次事务后应关闭持久连接。</p><h5 id="串行事务处理延迟"><a href="#串行事务处理延迟" class="headerlink" title="串行事务处理延迟"></a>串行事务处理延迟</h5><p>如果只对HTTP事务进行简单管理，TCP的性能时延可能会叠加起来，包括多次的建立连接和断开连接。</p><h4 id="提高HTTP连接性能的四个方法："><a href="#提高HTTP连接性能的四个方法：" class="headerlink" title="提高HTTP连接性能的四个方法："></a>提高HTTP连接性能的四个方法：</h4><h5 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h5><p>通过多条TCP连接发起并发的HTTP请求<br>并行连接从理论上回提高页面的加载速度，因为多个请求同时发出，时延可以重叠起来。<br>但并行连接并不是一点更快，原因可能是：客户端带宽限制、消耗更多的内存和计算资源。<br>现代浏览器确实使用并行连接，但会限制连接数在一个较小的值（通常是4），并且服务器可以关闭来自特定客户端的超量连接。</p><h5 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h5><p>重用TCP连接，以消除连接及关闭的时延<br>重用连接：HTTP/1.1(HTTP/1.0增强版)允许HTTP设备在事务处理结束后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接。</p><h6 id="持久连接-并行连接"><a href="#持久连接-并行连接" class="headerlink" title="持久连接+并行连接"></a>持久连接+并行连接</h6><p>持久的连接的管理很重要，不小心会累积出大量的空闲连接</p><h6 id="HTTP-1-0-Keep-alive连接"><a href="#HTTP-1-0-Keep-alive连接" class="headerlink" title="HTTP/1.0 + Keep-alive连接"></a>HTTP/1.0 + Keep-alive连接</h6><p>Connection： Keep-alive属性出现在1996年HTTP/1.0版本中，当初也是被当做实验型持久连接。</p><p>可以用通用首部Keep-Alive属性指定由逗号分隔的选项来调节keep-alive的行为。例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection：Keep-alive</span><br><span class="line">Keep-Alive: max=<span class="number">5</span>,timeout=<span class="number">120</span></span><br></pre></td></tr></table></figure></p><p>说明：服务器还会为另外5个事务保持连接的打开状态，或者将打开状态保持到连接空闲后2分钟。</p><p>Connection属于逐跳首部，只适用于单条传输链路。</p><p>现在HTTP/1.1不再需要此属性，默认开启持久连接的。</p><h6 id="HTTP-1-1-持久连接"><a href="#HTTP-1-1-持久连接" class="headerlink" title="HTTP/1.1 持久连接"></a>HTTP/1.1 持久连接</h6><p>HTTP/1.1逐渐停止了对keep-alive连接的支持，用一种名为持久连接(persistentconnection)的改进型设计取代了它。</p><p>必须显示指定Connection: close才会指定TCP连接在响应后立即关闭。当客户端发送了Connection: close请求首部之后，客户端就无法在那条连接上发送更多请求了。<br>只有当连接上所有的报文都有正确的、自定义报文长度时，连接才能持久保持。</p><h5 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h5><p>通过共享的TCP连接发起并发的HTTP请求</p><p>HTTP/1.1 允许在持久连接上可选的使用请求管道。在响应到达之前，可以将多条请求放入队列，降低网络回环时间。</p><p>注：HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST），因为出错时，无法安全的重试POST这样的非幂请求。</p><h5 id="复用的连接"><a href="#复用的连接" class="headerlink" title="复用的连接"></a>复用的连接</h5><p>交替传送请求和相应报文（实验阶段）</p><h3 id="HTTP1-1-的特点"><a href="#HTTP1-1-的特点" class="headerlink" title="HTTP1.1 的特点"></a>HTTP1.1 的特点</h3><h4 id="持久连接-1"><a href="#持久连接-1" class="headerlink" title="持久连接"></a>持久连接</h4><p>每个TCP连接开始都有三次握手，要经历一次客户端与服务器间完整的往返，而开启了持久连接就不需要每次都要握手<br><img src="/assets/images/keep-alive.png" alt="开启Keep-Alive"><br>在连接中有这个属性的就是打开了持久化连接。下图展示了通过持久 TCP 连接取得 HTML 和 CSS 文件：<br><img src="/assets/images/keep-alive1.jpg" alt="开启Keep-Alive"></p><h3 id="HTTP2-0-的特点"><a href="#HTTP2-0-的特点" class="headerlink" title="HTTP2.0 的特点"></a>HTTP2.0 的特点</h3><h3 id="HTTP-长连接与短连接"><a href="#HTTP-长连接与短连接" class="headerlink" title="HTTP 长连接与短连接"></a>HTTP 长连接与短连接</h3><p><strong>HTTP  是无状态的</strong><br>也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话.<br>http1.0中默认是关闭的，需要在http头加入”Connection: Keep-Alive”，才能启用Keep-Alive<br>http 1.1中默认启用Keep-Alive，如果加入”Connection: close”才关闭。<br>目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。<br>下图是普通模式和长连接模式的请求对比：<br><img src="/assets/images/keep-alive2.png" alt="普通模式和长连接模式的请求对比"></p><h4 id="开启Keep-Alive的优缺点"><a href="#开启Keep-Alive的优缺点" class="headerlink" title="开启Keep-Alive的优缺点"></a>开启Keep-Alive的优缺点</h4><p>优点： Keep-Alive模式更加高效，因为避免了连接建立和释放的开销<br>缺点： 长时间的Tcp连接容易导致资源无效占用，浪费系统资源</p><h4 id="当保持长连接时，如何判断一次请求已经完成？"><a href="#当保持长连接时，如何判断一次请求已经完成？" class="headerlink" title="当保持长连接时，如何判断一次请求已经完成？"></a>当保持长连接时，如何判断一次请求已经完成？</h4><p>当保持长连接时，如何判断一次请求已经完成？ </p><h5 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h5><p>Content-Length表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。<br>所以，当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置Content-Length来控制请求的结束。但当服务器并不知道请求结果的长度时，如一个动态的页面或者数据，Content-Length就无法解决上面的问题，这个时候就需要用到Transfer-Encoding字段。</p><h5 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h5><p>Transfer-Encoding是指<strong>传输编码</strong>，在上面的问题中，当服务端无法知道实体内容的长度时，就可以通过指定Transfer-Encoding: chunked来告知浏览器当前的编码是将数据分成一块一块传递的。当然, 还可以指定Transfer-Encoding: gzip, chunked表明实体内容不仅是gzip压缩的，还是分块传递的。最后，当浏览器接收到一个长度为0的chunked时， 知道当前请求内容已全部接收。</p><h4 id="Keep-Alive-timeout："><a href="#Keep-Alive-timeout：" class="headerlink" title="Keep-Alive timeout："></a>Keep-Alive timeout：</h4><p>Httpd守护进程，一般都提供了keep-alive timeout时间设置参数。比如nginx的keepalive_timeout，和Apache的KeepAliveTimeout。这个keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住keepalive_timeout秒后，才开始关闭这个连接。<br>当httpd守护进程发送完一个响应后，理应马上主动关闭相应的tcp连接，设置 keepalive_timeout后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到浏览器发过来http请求，则关闭这个http连接。</p><h4 id="Tcp的Keepalive："><a href="#Tcp的Keepalive：" class="headerlink" title="Tcp的Keepalive："></a>Tcp的Keepalive：</h4><p>连接建立之后，如果客户端一直不发送数据，或者隔很长时间才发送一次数据，当连接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，连接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。<br>TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文（侦测包）给对方，如果对方回应了这个报文，说明对方还在线，连接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持连接。</p><p>tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。tcp keep-alive保鲜定时器，支持三个系统内核配置参数：<br>net.ipv4.tcp_keepalive_intvl = 15<br>net.ipv4.tcp_keepalive_probes = 5<br>net.ipv4.tcp_keepalive_time = 1800<br>keepalive是TCP保鲜定时器，当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）了tcp_keepalive_time后，服务器就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 tcp_keepalive_intvl后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试tcp_keepalive_probes,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。</p><p>参考文章： <a href="https://blog.csdn.net/weixin_37672169/article/details/80283935" target="_blank" rel="noopener">浅谈Http长连接和Keep-Alive以及Tcp的Keepalive</a>、<a href="https://blog.csdn.net/joye123/article/details/51931375?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">http性能优化</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git常用命令</title>
      <link href="/2018/10/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/10/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h3 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h3><h4 id="个人学习经历"><a href="#个人学习经历" class="headerlink" title="个人学习经历"></a>个人学习经历</h4><p>　　从认识到使用git命令已有两年多的时间了，记得刚刚认识它的时候很是害怕，害怕那看不懂的命令，以至于每次提交代码都要用github客户端进行提交。当然了，那是的我对客户端也是晦涩难懂（现在也是），以至于要彻底放弃。有时每次提交代码都要把文件拉到网页上面进行提交，很是麻烦。后来跟着老师的课程渐渐地认识了git，才发现是如此的好用，慢慢的发现自己已经离不开它了。虽然以前已经整理过一些关于git的命令，但却凌乱不堪，以至于自己常常自惭形秽。今天我根据阮一峰老师的博客对自己的这篇文章进行重构，让自己的博客文章慢慢的有自己的思想和见解。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　–2019-3-8<a id="more"></a></p><h4 id="GIT命令"><a href="#GIT命令" class="headerlink" title="GIT命令"></a>GIT命令</h4><h5 id="1-新建代码库"><a href="#1-新建代码库" class="headerlink" title="1.新建代码库"></a>1.新建代码库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">git <span class="built_in">clone</span> [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例： git clone git@github.com:aLittleLittleStar/Travel.git</span></span><br></pre></td></tr></table></figure><h5 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h5><p>　　Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">git config [--global] user.name <span class="string">"[name]"</span></span><br><span class="line">git config [--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure></p><h5 id="3-增加-删除文件"><a href="#3-增加-删除文件" class="headerlink" title="3.增加/删除文件"></a>3.增加/删除文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h5 id="4-代码提交"><a href="#4-代码提交" class="headerlink" title="4.代码提交"></a>4.代码提交</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交并添加注释</span></span><br><span class="line">git commit -am <span class="string">"init"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h5 id="5-分支"><a href="#5-分支" class="headerlink" title="5.分支"></a>5.分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地所有分支，当前分支会被星号标示出</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看见每一个分支的最后一次提交</span></span><br><span class="line">git branch -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以查看本地分支对应的远程分支</span></span><br><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将分支dev与当前分支进行合并</span></span><br><span class="line">git merge origin/dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给分支重命名</span></span><br><span class="line">git branch -m oldName newName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支，如果在分支中有一些未merge的提交，那么会删除分支失败</span></span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除dev分支</span></span><br><span class="line">git branch -D dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h5 id="6-标签"><a href="#6-标签" class="headerlink" title="6.标签"></a>6.标签</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建带附注标签</span></span><br><span class="line">git tag -a &lt;版本号&gt; &lt;SHA值&gt; -m <span class="string">"&lt;备注信息&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">git push origin --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h5 id="7-查看信息"><a href="#7-查看信息" class="headerlink" title="7.查看信息"></a>7.查看信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment">#  查询repo的状态. -s表示short, -s的输出标记会有两列,</span></span><br><span class="line"><span class="comment"># 第一列是对staging区域而言,第二列是对working目录而言.</span></span><br><span class="line">git status -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span></span><br><span class="line">git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">git <span class="built_in">log</span> --follow [file]</span><br><span class="line">git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><h5 id="8-远程同步"><a href="#8-远程同步" class="headerlink" title="8.远程同步"></a>8.远程同步</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">git push [remote] --all</span><br></pre></td></tr></table></figure><h5 id="9撤销"><a href="#9撤销" class="headerlink" title="9撤销"></a>9撤销</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git撤销本地所有未提交的更改</span></span><br><span class="line"><span class="comment"># 第一个命令只删除所有untracked的文件，如果文件已经被tracked,</span></span><br><span class="line"><span class="comment"># 修改过的文件不会被回退。而第二个命令把tracked的文件revert到</span></span><br><span class="line"><span class="comment"># 前一个版本，对于untracked的文件(比如编译的临时文件)都不会被删除。</span></span><br><span class="line">git clean -df</span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">git stash</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h5 id="10-其他"><a href="#10-其他" class="headerlink" title="10.其他"></a>10.其他</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line">git archive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看你commit的日志</span></span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">git checkout --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录</span></span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有目录</span></span><br><span class="line">ls -al</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line">cat git.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看git的版本信息</span></span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><h4 id="Git-fetch-amp-amp-Git-pull-详解"><a href="#Git-fetch-amp-amp-Git-pull-详解" class="headerlink" title="Git fetch &amp;&amp; Git pull 详解"></a>Git fetch &amp;&amp; Git pull 详解</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">__git fetch__是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</span><br><span class="line">__git pull__ 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</span><br><span class="line">__分支的概念：__</span><br><span class="line">分支是用来标记特定代码的提交，每一个分支通过SHA1sum值来标识，所以对分支的操作是轻量级的，你改变的仅仅是SHA1sum值。</span><br><span class="line"></span><br><span class="line">如下图所示，当前有2个分支，A,C,E属于master分支，而A,B，D,F属于dev分支</span><br><span class="line">``` js</span><br><span class="line">A----C----E（master）</span><br><span class="line"> \</span><br><span class="line">  B---D---F(dev)</span><br></pre></td></tr></table></figure><p>它们的head指针分别指向E和F，对上述做如下操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master <span class="comment">//选择or切换到master分支</span></span><br><span class="line">git merge dev      <span class="comment">//将dev分支合并到当前分支(master)中</span></span><br></pre></td></tr></table></figure></p><p>之后的情形是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---C---E---G(master)</span><br><span class="line"> \         /</span><br><span class="line">  B---D---F（dev）</span><br></pre></td></tr></table></figure></p><p>现在A，B,C,D,E,F,G属于master，G是一次合并后的结果，是将E和Ｆ的代码合并后的结果，可能会出现冲突。而A,B，D,F依然属于dev分支。可以继续在dev的分支上进行开发:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---C---E---G---H(master)</span><br><span class="line"> \         /</span><br><span class="line">  B---D---F---I（dev）</span><br></pre></td></tr></table></figure></p><p>理解gitfetch,关键是理解FETCH_HEAD，FETCH_HEAD指的是：某个branch在服务器上的最新状态。</p><h5 id="git-fetch-用法"><a href="#git-fetch-用法" class="headerlink" title="git fetch 用法"></a>git fetch 用法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; <span class="comment">//这个命令将某个远程主机的更新全部取回本地</span></span><br></pre></td></tr></table></figure><p>如果只想取回特定分支的更新，可以指定分支名：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; <span class="xml"><span class="tag">&lt;<span class="name">分支名</span>&gt;</span> //注意之间有空格</span></span><br></pre></td></tr></table></figure></p><p>最常见的命令如取回origin 主机的master 分支：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure></p><p>取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p FETCH_HEAD</span><br></pre></td></tr></table></figure><h5 id="git-pull-用法"><a href="#git-pull-用法" class="headerlink" title="git pull 用法"></a>git pull 用法</h5><p>前面提到，git pull 的过程可以理解为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master <span class="comment">//从远程主机的master分支拉取最新内容 </span></span><br><span class="line">git merge FETCH_HEAD    <span class="comment">//将拉取下来的最新内容合并到当前所在的分支中</span></span><br></pre></td></tr></table></figure></p><p>即将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; <span class="xml"><span class="tag">&lt;<span class="name">远程分支名</span>&gt;</span>:<span class="tag">&lt;<span class="name">本地分支名</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin next</span><br></pre></td></tr></table></figure></p><h5 id="git-fetch-更新远程代码到本地仓库"><a href="#git-fetch-更新远程代码到本地仓库" class="headerlink" title="git fetch 更新远程代码到本地仓库"></a>git fetch 更新远程代码到本地仓库</h5><p>　　理解 <strong>fetch</strong> 的关键, 是理解 FETCH_HEAD，FETCH_HEAD指的是: 某个branch在服务器上的最新状态’。 这个列表保存在 .Git/FETCH_HEAD 文件中, 其中每一行对应于远程服务器的一个分支。<br>当前分支指向的FETCH_HEAD, 就是这个文件第一行对应的那个分支.<br>一般来说, 存在两种情况:<br>如果没有显式的指定远程分支, 则远程分支的master将作为默认的FETCH_HEAD.<br>如果指定了远程分支, 就将这个远程分支作为FETCH_HEAD.<br><strong>git fetch origin branch1</strong><br>这个操作是<strong>git pull origin branch1</strong>的第一步, 而对应的pull操作,并不会在本地创建新的branch。设定当前分支的 FETCH_HEAD’ 为远程服务器的branch1分支`。 </p><p>这个命令可以用来测试远程主机的远程分支branch1是否存在, 如果存在, 返回0, 如果不存在, 返回128, 抛出一个异常.<br><strong>git fetch origin branch1:branch2</strong><br>首先执行上面的fetch操作，使用远程branch1分支在本地创建branch2(但不会切换到该分支),如果本地不存在branch2分支, 则会自动创建一个新的branch2分支,</p><p>如果本地存在branch2分支, 并且是`fast forward’, 则自动合并两个分支, 否则, 会阻止以上操作.<br>fetch更新本地仓库两种方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line">$ git fetch origin master <span class="comment">//从远程的origin仓库的master分支下载代码到本地的origin master</span></span><br><span class="line"></span><br><span class="line">$ git log -p master.. origin/master<span class="comment">//比较本地的仓库和远程参考的区别</span></span><br><span class="line"></span><br><span class="line">$ git merge origin/master<span class="comment">//把远程下载下来的代码合并到本地仓库，远程的和本地的合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">$ git fetch origin master:temp <span class="comment">//从远程的origin仓库的master分支下载到本地并新建一个分支temp</span></span><br><span class="line"></span><br><span class="line">$ git diff temp<span class="comment">//比较master分支和temp分支的不同</span></span><br><span class="line"></span><br><span class="line">$ git merge temp<span class="comment">//合并temp分支到master分支</span></span><br><span class="line"></span><br><span class="line">$ git branch -d temp<span class="comment">//删除temp</span></span><br></pre></td></tr></table></figure><p><strong>1、git reset </strong><br>没有push，这种情况发生在你的本地代码仓库,可能你add ,commit 以后发现代码有点问题.</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交commit_id(79f673d631b08907496ce792f429e1f00da25b73)，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard 79f673d631b08907496ce792f429e1f00da25b73。</p><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。<br><strong>2、git revert</strong><br>已经push，对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令</p><p>git revert用一个新提交来消除一个历史提交所做的任何修改.</p><p>revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题)</p><p>revert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看.</p><p>git revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c61<br><strong>3、两者区别</strong></p><p>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit看似达到的效果是一样的,其实完全不同.</p><p>第一:上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突（或git push -f强制推送）.但是revert 并不会.</p><p>第二:如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里.</p><p>第三:reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的. </p><!-- ![git常用命令图片](/assets/images/git.png) --><p>转载：<br>　　<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单</a><br>参考文章:<br>　　<a href="https://www.cnblogs.com/chenlogin/p/6592228.html" target="_blank" rel="noopener">git fetch 更新远程代码到本地仓库</a><br>　　<a href="https://blog.csdn.net/tomatozaitian/article/details/73515849" target="_blank" rel="noopener">Git 常用命令总结</a><br>　　<a href="https://blog.csdn.net/halaoda/article/details/78661334" target="_blank" rel="noopener">git常用命令大全</a><br>　　<a href="https://blog.csdn.net/hangyuanbiyesheng/article/details/6731629" target="_blank" rel="noopener">Git常用命令解说</a><br>　　<a href="https://blog.csdn.net/qq_36113598/article/details/78906882" target="_blank" rel="noopener">Git fetch &amp; pull 详解</a></p><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用的状态响应码</title>
      <link href="/2018/10/10/HTTP/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81/"/>
      <url>/2018/10/10/HTTP/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- 设置目录 --><!-- toc --><h3 id="状态码大类"><a href="#状态码大类" class="headerlink" title="状态码大类"></a>状态码大类</h3><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:right">说明</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:left">1XX</td><td style="text-align:right"><strong>响应中</strong>——表示请求已经接受，继续处理</td><td style="text-align:center">消息：一般是告诉<strong>客户端请求已经收到了</strong>，正在处理，别急</td></tr><tr><td style="text-align:left">2XX</td><td style="text-align:right"><strong>成功</strong>——表示请求已经被成功接收、理解、接受。</td><td style="text-align:center"><strong> 处理成功</strong>：一般表示请求收悉、我明白你要的、请求已受理、已经处理完成等信息</td></tr><tr><td style="text-align:left">3XX</td><td style="text-align:right"><strong> 重定向</strong>——要完成请求必须进行更进一步的操作</td><td style="text-align:center">重定向到其它地方：它让客户端再发起一个请求以完成整个处理</td></tr><tr><td style="text-align:left">4XX</td><td style="text-align:right"><strong>客户端错误</strong>——请求有语法错误或请求无法实现</td><td style="text-align:center">处理发生错误，责任在客户端：如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。</td></tr><tr><td style="text-align:left">5XX</td><td style="text-align:right"><strong> 服务器端错误</strong>——服务器未能实现合法的请求。</td><td style="text-align:center">处理发生错误，责任在服务端：如服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><blockquote><p>HTTP响应状态码有很多，但是实际经常使用的大概只有14个。<br><a id="more"></a></p></blockquote><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul><li>200 OK            //表示从客户端发来的请求在服务器端被正常处理了。</li><li>204 No Content该状态码表示服务器接收的请求已成功处理 ，但在返回的响应报文中不含实体的主体部分。<ul><li>HTTP协议中 204 No Content 成功状态响应码表示目前请求成功，但客户端不需要更新其现有页面。204 响应默认是可以被缓存的。在响应中需要包含头信息 ETag。</li><li>比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。</li></ul></li><li>206 Partial Content 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。</li><li>301 Moved Permanently 永久性重定向。该状态码表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。<ul><li>像下方给出的请求URI，当指定的资源路径的最后忘记添加斜杠”/“，就会产生301状态码</li></ul></li><li>302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户(本次)能使用新的URI访问。</li><li>303 Other         //我把你redirect到其它的页面，目标的URL通过响应报文头的Location告诉你。<ul><li>See Other 该状态码表示由于请求对应的资源存在另外一个URI，应使用GET方法定向获取请求的资源。 303状态码和302状态码有着相同的功能，但303状态码明确表明客户端应当采用GET方法获取资源。 当301，302，303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文的主体，之后请求会自动再次发送。 301，302标准是禁止将POST方法改变成GET方法的，但实际上使用时大家都会这么做。</li></ul></li><li>304 Not Modified  // 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。<ul><li>304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。</li><li>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</li><li>如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。</li></ul></li><li>307 Temporary Redirect 临时重定向。该状态码与302 Found有着相同的含义。307会遵照浏览器标准，不会从POST变成GET<ul><li>HTTP1.1文档中307状态码则相当于HTTP1.0文档中的302状态码，当客户端的POST请求收到服务端307状态码响应时，需要跟用户询问是否应该在新URI上发起POST方法，也就是说，307是不会把POST转为GET的。</li></ul></li><li>400 Bad Request   //客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized  //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<ul><li>该状态码表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过1此请求，则表示用户认证失败。</li></ul></li><li>403 Forbidden     //服务器收到请求，但是拒绝提供服务</li><li>404 Not Found     //该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</li><li>408      //服务器等候请求时发生超时。</li><li>413（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</li><li>414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</li><li>500 Internal Server Error //该状态码表明服务器端在执行请求时发生了错误。</li><li>501（尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</li><li>503 Server Unavailable    //该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li><li>505（HTTP 版本不受支持）  服务器不支持请求中所用的 HTTP 协议版本。</li></ul><blockquote><p>参考文章 <a href="https://www.cnblogs.com/jpdoutop/p/HTTP-Status-Code.html" target="_blank" rel="noopener">常见的HTTP响应状态码解析</a>、<a href="https://www.jianshu.com/p/e358607a3e1b" target="_blank" rel="noopener">常见的响应状态码</a><br><a href="https://blog.csdn.net/huwei2003/article/details/70139062" target="_blank" rel="noopener">HTTP 304状态码的详细讲解</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>冒泡和捕获</title>
      <link href="/2018/10/10/JavaScript/%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7/"/>
      <url>/2018/10/10/JavaScript/%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>　　描述的是从页面中接收事件的顺序。<br>　　事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？</p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>　　冒泡型事件：<code>事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。`</code><br>　　事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。<br>　　因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是: <code>p -&gt; div -&gt; body -&gt; html -&gt; document</code></p><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>　　捕获型事件(event capturing)：<code>事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)</code><br>　　上面的例子在事件捕获的概念下发生click事件的顺序应该是: <code>document -&gt; html -&gt; body -&gt; div -&gt; p</code></p><p>　　IE只支持事件冒泡，Chrome,Mozilla, Opera 7 和 Konqueror两种都支持，旧版本的Opera’s 和 iCab两种都不支持 。</p><h4 id="捕获和冒泡过程图"><a href="#捕获和冒泡过程图" class="headerlink" title="捕获和冒泡过程图"></a>捕获和冒泡过程图</h4><p><img src="/assets/images/maopao.png" alt="冒泡和捕获"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>event<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"obj1"</span>&gt;</span></span><br><span class="line">        welcome</span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span> <span class="attr">id</span>=<span class="string">"obj2"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span> <span class="attr">id</span>=<span class="string">"obj3"</span>&gt;</span>world<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        var obj1=document.getElementById('obj1');</span></span><br><span class="line"><span class="undefined">        var obj2=document.getElementById('obj2');</span></span><br><span class="line"><span class="undefined">        obj1.addEventListener('click',function()&#123;</span></span><br><span class="line"><span class="undefined">            alert('hello');</span></span><br><span class="line"><span class="undefined">        &#125;,false);</span></span><br><span class="line"><span class="undefined">        obj2.addEventListener('click',function()&#123;</span></span><br><span class="line"><span class="undefined">            alert('world');</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　并且分别在obj1,obj2上绑定了一个点击事件，由于addEventListener的第三个参数为false,所以页面是在冒泡阶段处理绑定事件。此时整个页面可以有三种行为出现: </p><ol><li>点击文字welcome时，弹出hello。<br>此时就只触发了绑定在obj1上的点击事件。具体冒泡实现过程如下：welcome 属于文本节点，点击后，开始从文本节点查找，当前文本节点没有绑定点击事件，继续向上找，找到父级（id为obj1的div），有绑定的点击事件，执行，再向上找，body，没有绑定点击事件，再到html,document,都没再有绑定的点击事件，好，整个冒泡过程结束。</li><li>点击文字hello时，先弹出world，再弹出hello</li><li>点击world时，弹出hello。</li></ol><h4 id="addEventListener的第三个参数"><a href="#addEventListener的第三个参数" class="headerlink" title="addEventListener的第三个参数"></a>addEventListener的第三个参数</h4><p><code>lement.addEventListener(event, function, useCapture)</code></p><p>　　第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。</p><p>　　我们想要在点击每个h5标签时，弹出对应的innerHTML 。常规做法是遍历每个h5,然后在每个h5上绑定一个点击事件，这种做法在h5较少的时候可以使用，但如果有一万个h5，那就会导致性能降低。这时就需要事件代理出场了。 </p><h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><p>　　使用事件代理的好处不仅在于将多个事件处理函数减为一个，而且对于不同的元素可以有不同的处理方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> e=e||<span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">if</span>(e.target.nodeName.toLowerCase()==<span class="string">'h5'</span>)&#123;</span><br><span class="line">      alert(e.target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>　　由于事件冒泡机制，点击了h5后会冒泡到div,此时就会触发绑定在div上的点击事件，再利用target找到事件实际发生的元素，就可以达到预期的效果。</p><h4 id="阻止冒泡的方法，阻止默认事件的方法-兼容IE"><a href="#阻止冒泡的方法，阻止默认事件的方法-兼容IE" class="headerlink" title="阻止冒泡的方法，阻止默认事件的方法(兼容IE)"></a>阻止冒泡的方法，阻止默认事件的方法(兼容IE)</h4><h5 id="w3c的方法是e-stopPropagation-，IE则是使用e-cancelBubble-true"><a href="#w3c的方法是e-stopPropagation-，IE则是使用e-cancelBubble-true" class="headerlink" title="w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true"></a>w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true</h5><p><strong>阻止事件的传播兼容</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=e||<span class="built_in">window</span>.event; <span class="comment">// window.event 这是IE浏览器</span></span><br><span class="line">    e.stopPropagation();<span class="comment">//阻止事件的传播(包括捕获也包括冒泡)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兼容处理</span></span><br><span class="line">    <span class="keyword">if</span> (e &amp;&amp; e.stopPropagation) &#123; <span class="comment">//这是其他浏览器</span></span><br><span class="line">        e.stopPropagation(); <span class="comment">//阻止冒泡事件</span></span><br><span class="line">        e.preventDefault();<span class="comment">//阻止默认事件</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// IE浏览器</span></span><br><span class="line">        e.cancelBubble=<span class="literal">true</span>; <span class="comment">//阻止冒泡事件</span></span><br><span class="line">        e.returnValue=<span class="literal">false</span>;<span class="comment">//阻止默认事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>阻止冒泡事件的兼容性处理</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopBubble</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(e &amp;&amp; e.stopPropagation) &#123; <span class="comment">//非IE </span></span><br><span class="line">    e.stopPropagation(); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//IE </span></span><br><span class="line">    <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h5><p>　　w3c的方法是<code>e.preventDefault()</code>，IE则是使用<code>e.returnValue = false</code>;<br>　　我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，会执行几次事件，会先执行冒泡还是捕获？<br><code>首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段</code></p><h4 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h4><p>　　“DOM2级事件”规定的事件流包括三个阶段：<code>事件捕获、处于目标阶段和事件冒泡阶段</code>。发生的顺序是事件<code>捕获阶段==&gt;目标阶段==&gt;事件冒泡阶段</code>。<strong> DOM2级事件规定</strong> ：<code>捕获阶段不会涉及目标事件</code>。</p><blockquote><p>参考文章 <a href="https://blog.csdn.net/chenjuan1993/article/details/81347590" target="_blank" rel="noopener">终于弄懂了事件冒泡和事件捕获</a><br><a href="https://segmentfault.com/a/1190000000749838" target="_blank" rel="noopener">浅谈事件冒泡与事件捕获</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GET和POST请求</title>
      <link href="/2018/10/10/HTTP/get%E5%92%8Cpost%E8%AF%B7%E6%B1%82/"/>
      <url>/2018/10/10/HTTP/get%E5%92%8Cpost%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h5 id="关于HTTP协议"><a href="#关于HTTP协议" class="headerlink" title="关于HTTP协议"></a>关于HTTP协议</h5><p>　　HTTP（即超文本传输协议）是现代网络中最常见和常用的协议之一，设计它的目的是保证客户机和服务器之间的通信。<br>　　HTTP 的工作方式是客户机与服务器之间的 “请求-应答” 协议。<br>　　在HTTP中，与服务器交互的方法，最常用的有4种：即Put（增）、Delete（删）、Post（改）、Get（查）。<br>get是获取数据，post是修改数据。<a id="more"></a><br><!-- more --></p><h5 id="两种常见的HTTP请求：GET-和-POST"><a href="#两种常见的HTTP请求：GET-和-POST" class="headerlink" title="两种常见的HTTP请求：GET 和 POST"></a>两种常见的HTTP请求：GET 和 POST</h5><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的请求方式是：<code>GET</code>和 <code>POST</code>。<br><code>GET</code> - 从指定的资源请求数据。<br><code>POST</code> - 向指定的资源提交要被处理的数据</p><h5 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h5><p>get把请求的数据放在url上，即HTTP协议头上，其格式为：<br>　　以?分割URL和传输数据，参数之间以&amp;相连。<br>　　数据如果是英文字母/数字，原样发送，<br>　　如果是空格，转换为+，<br>　　如果是中文/其他字符，则直接把字符串用BASE64加密，及“%”加上“字符串的16进制ASCII码”。<br><strong>特点</strong><br>　　GET 请求可被缓存<br>　　GET 请求保留在浏览器历史记录中<br>　　GET 请求可被收藏为书签<br>　　GET 请求不应在处理敏感数据时使用<br>　　GET 请求有长度限制<br>　　GET 请求只应当用于取回数据</p><h5 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h5><p>post把数据放在HTTP的包体内（requrest body）。<br><strong>特点</strong><br>　　POST 请求不会被缓存<br>　　POST 请求不会保留在浏览器历史记录中<br>　　POST 不能被收藏为书签<br>　　POST 请求对数据长度没有要求</p><h5 id="比较-GET-和-POST"><a href="#比较-GET-和-POST" class="headerlink" title="比较 GET 和 POST"></a>比较 GET 和 POST</h5><p>　　get提交的数据最大是<code>2k</code>（原则上url长度无限制，那么get提交的数据也没有限制咯？限制实际上取决于浏览器，(大多数)浏览器通常都会限制url长度在2K个字节，即使(大多数)服务器最多处理64K大小的url。也没有卵用。）。<br>　　post理论上没有限制。实际上IIS4中最大量为80KB，IIS5中为100KB。<br>　　GET产生一个TCP数据包，浏览器会把<code>http</code> <code>header</code>和<code>data</code>一并发送出去，服务器响应200(返回数据);<br>　　POST产生两个TCP数据包，浏览器先发送<code>header</code>，服务器响应100 <code>continue</code>，浏览器再发送<code>data</code>，服务器响应200 ok(返回数据)。<br>　　GET在浏览器回退时是无害的，POST会再次提交请求。<br>　　GET产生的URL地址可以被Bookmark，而POST不可以。<br>　　GET请求会被浏览器主动cache，而POST不会，除非手动设置。<br>　　GET请求只能进行url编码，而POST支持多种编码方式。<br>　　GET只接受ASCII字符的参数的数据类型，而POST没有限制<br>那么，post那么好为什么还用get？get效率高！。<br><img src="/assets/images/get-post.png" alt="get post"></p><h5 id="其他-HTTP-请求方法"><a href="#其他-HTTP-请求方法" class="headerlink" title="其他 HTTP 请求方法"></a>其他 HTTP 请求方法</h5><p><img src="/assets/images/http.png" alt="get post"><br>转载：<br>　　<a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">HTTP 方法：GET 对比 POST</a><br>参考文章:<br>　　<a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">HTTP 方法：GET 对比 POST</a><br>　　<a href="https://blog.csdn.net/qq_26360877/article/details/70665820" target="_blank" rel="noopener">get和post的区别–面试经常被问到！</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS模块化</title>
      <link href="/2018/10/10/CSS3/CSS3%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2018/10/10/CSS3/CSS3%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>未完成ing…</p><ul><li>设计原则<ul><li>可复用能继承要完整</li><li>周期性迭代<ul><li>优秀的代码是模仿/设计/重构出来的</li></ul></li></ul></li><li>设计方法<ul><li>先整体后部分再颗粒化<ul><li>布局-&gt; 页面 -&gt; 功能-&gt;业务</li></ul></li><li>先抽象再具体</li></ul></li></ul><p>css模块化设计<br><img src="/assets/images/css模块化.webp" alt="模块化"></p><p>reset.scss：<br>浏览器不同，对默认的标签有默认的样式，为了表现统一化，要加一个这个。<br>layout.scss:<br>布局抽象成这个<br>element.scss:<br>列表、按钮</p><p>global的方式引用，比如说直接把某个模块引用进来，然后就可以写具体的样式了。<br>scope就是用的module方法。比如说两个组件都叫做.btn，这样在之前会导致两个样式的名称一致，会被覆盖，如果想用相同的名称，样式不一样，就要用css module这样就不一致，因为编译出来的class带了一串编码。</p><ul><li>优点：<ul><li>提高代码重用率</li><li>提高开发效率、减少沟通成本</li><li>降低耦合</li><li>降低发布风险</li><li>减少Bug定位时间和Fix成本</li><li>提高页面容错</li><li>更好的实现快速迭代</li><li>更好的支持灰度发布</li></ul></li></ul><p>参考: <a href="https://www.aliyun.com/jiaocheng/693575.html" target="_blank" rel="noopener">CSS模块化如何实现？</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>清除浮动</title>
      <link href="/2018/10/10/CSS3/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
      <url>/2018/10/10/CSS3/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载：<a href="https://segmentfault.com/a/1190000004865198" target="_blank" rel="noopener">CSS-清除浮动</a></p><h4 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h4><p>　　浮动的元素是<code>脱离文档标准流</code>的，如果我们不清楚浮动，那么就会造成<code>父元素高度塌陷</code>，<code>影响页面布局</code>。<a id="more"></a></p><h4 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h4><h5 id="使用带clear属性的空元素-div、hr、br都可以"><a href="#使用带clear属性的空元素-div、hr、br都可以" class="headerlink" title="使用带clear属性的空元素 div、hr、br都可以"></a>使用带clear属性的空元素 div、hr、br都可以</h5><p>　　使用clear:both会<code>把浮动元素的边界拉下来到标准流，从而把对应标准流的位置撑开</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">"clear"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;br class=<span class="string">"clear"</span> /&gt;</span><br><span class="line">&lt;hr class=<span class="string">"clear"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#css</span></span><br><span class="line">.clear &#123;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　优点：<code>通俗易懂，容易掌握</code><br>　　缺点：<code>需要添加大量无语义的html元素，代码不够优雅，后期不容易维护</code>。</p><h5 id="使用CSS的-overflow-属性"><a href="#使用CSS的-overflow-属性" class="headerlink" title="使用CSS的 overflow 属性"></a>使用CSS的 overflow 属性</h5><p>　　给浮动元素的容器添加<code>overflow:hidden</code>;或<code>overflow:auto</code>;可以清除浮动，另外<code>在 IE6 中还需要触发hasLayout</code>，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.news &#123;</span><br><span class="line">  background-color: gray;</span><br><span class="line">  border: solid 1px black;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  *zoom: 1;</span><br><span class="line">  &#125;</span><br><span class="line">.news img &#123;</span><br><span class="line">  <span class="built_in">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line">.news p &#123;</span><br><span class="line">  <span class="built_in">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;div class=<span class="string">"news"</span>&gt;</span><br><span class="line">  &lt;img src=<span class="string">"news-pic.jpg"</span> /&gt;</span><br><span class="line">  &lt;p&gt;some text&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>　　优点：<code>不存在结构和语义化问题，代码量极少</code><br>　　缺点：<code>内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素</code>；04年POPO就发现overflow:hidden会导致中键失效，这是我作为一个多标签浏览控所不能接受的。所以还是不要使用.</p><h5 id="父元素也设置浮动-给浮动的元素的容器添加浮动"><a href="#父元素也设置浮动-给浮动的元素的容器添加浮动" class="headerlink" title="父元素也设置浮动(给浮动的元素的容器添加浮动)"></a>父元素也设置浮动(给浮动的元素的容器添加浮动)</h5><p>　　优点：不存在结构和语义化问题，代码量极少<br>　　缺点：给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。</p><h5 id="使用邻接元素处理"><a href="#使用邻接元素处理" class="headerlink" title="使用邻接元素处理"></a>使用邻接元素处理</h5><p>　　什么都不做，<code>给浮动元素后面的元素添加clear属性</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.news &#123;</span><br><span class="line">  background-color: gray;</span><br><span class="line">  border: solid 1px black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news img &#123;</span><br><span class="line">  <span class="built_in">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news p &#123;</span><br><span class="line">  <span class="built_in">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.content&#123;</span><br><span class="line">  clear:both;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=<span class="string">"news"</span>&gt;</span><br><span class="line">  &lt;img src=<span class="string">"news-pic.jpg"</span> /&gt;</span><br><span class="line">  &lt;p&gt;some text&lt;/p&gt;</span><br><span class="line">  &lt;div class=<span class="string">"content"</span>&gt;***&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h5 id="使用-after-伪元素"><a href="#使用-after-伪元素" class="headerlink" title="使用 :after 伪元素"></a>使用 :after 伪元素</h5><p>　　结合 <code>:after</code> 伪元素（注意这不是伪类，而<code>是伪元素</code>，<code>代表一个元素之后最近的元素</code>）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。<br>给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（<code>Block element</code>）清理浮动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.news &#123;</span><br><span class="line">  background-color: gray;</span><br><span class="line">  border: solid 1px black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news img &#123;</span><br><span class="line">  <span class="built_in">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news p &#123;</span><br><span class="line">  <span class="built_in">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment"># 清除浮动</span></span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">  content: <span class="string">" "</span>; </span><br><span class="line">  display: block; </span><br><span class="line">  height: 0; </span><br><span class="line">  clear: both; </span><br><span class="line">  visibility: hidden;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.clearfix &#123;</span><br><span class="line">  /* 触发 hasLayout */ </span><br><span class="line">  zoom: 1; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=<span class="string">"news clearfix"</span>&gt;</span><br><span class="line">&lt;img src=<span class="string">"news-pic.jpg"</span> /&gt;</span><br><span class="line">&lt;p&gt;some text&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><p>　　清除浮动：清除对应的单词是 clear，对应CSS中的属性是 <code>clear：left | right | both | none</code>；<br>　　闭合浮动：更确切的含义是<code>使浮动元素闭合，从而减少浮动带来的影响</code>。其中涉及的原理有：<code>hasLayout</code> 和 <code>Block formatting contexts</code> 。</p><p>通过上面的例子，我们不难发现清除浮动的方法可以分成两类：<br>　　一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 <code>:after</code> 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 <code>clear: both</code> 属性的元素实现的。<br>　　二是触发浮动元素父元素的 BFC (Block Formatting Contexts, <code>块级格式化上下文</code>)，使到该父元素可以包含浮动元素.<br>　　在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。<br>　　最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>语义化标签</title>
      <link href="/2018/10/10/H5/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"/>
      <url>/2018/10/10/H5/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="H5中关于语义化的标签"><a href="#H5中关于语义化的标签" class="headerlink" title="H5中关于语义化的标签"></a>H5中关于语义化的标签</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>　　语义化是指根据内容的结构化（<code>内容语义化</code>），选择合适的标签（<code>代码语义化</code>），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。</p><h5 id="为什么要语义化"><a href="#为什么要语义化" class="headerlink" title="为什么要语义化"></a>为什么要语义化</h5><p>　　1. 有利于SEO，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重。<br>　　2. 语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构<br>　　3. 方便其他设备解析（如移动设备、盲人阅读器等）<br>　　4. 比div标签有更加丰富的含义，便于团队开发和维护</p><h5 id="关于语义化的标签有哪些"><a href="#关于语义化的标签有哪些" class="headerlink" title="关于语义化的标签有哪些"></a>关于语义化的标签有哪些</h5><p><code>title</code> 简短、描述性、唯一（提升搜索引擎排名）<br><code>header</code> 页眉通常包括网站标志、主导航、全站链接以及搜索框。<br><code>section</code> 具有相似主题的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。<br><a id="more"></a><br><code>footer</code> 页脚，只有当父级是body时，才是整个页面的页脚。<br><code>article</code> 包含像报纸一样的内容，表示文档、页面、应用或一个独立的容器<br><code>a</code><br><code>ahgroup</code> 标签用于对网页或区段（section）的标题进行组合<br><code>nav</code> 标记导航，仅对文档中重要的链接群使用。<br><code>aside</code> 指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。<br><code>address</code> 作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）<br><code>mark</code> 突出显示文本（yellow），提醒读者。<br><code>time</code> 标记时间。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式<br><code>figure</code> 创建图（默认有40px左右margin）<br><code>figcaption</code> figure的标题，必须是figure内嵌的第一个或者最后一个元素。<br><code>datailst</code><br><code>details</code><br><code>summary</code><br><code>dialog</code><br><code>dd</code><br><code>progress</code> 完成进度。可通过js动态更新value<br><code>keygen</code><br><code>small</code> 指定细则，输入免责声明、注解、署名、版权。</p><h5 id="H5新增的语义化标签"><a href="#H5新增的语义化标签" class="headerlink" title="H5新增的语义化标签"></a>H5新增的语义化标签</h5><p><code>header</code> 是一种具有引导和导航作用的结构元素，通常用来放置整个页面或页面内的一个内容区块的标题，但也可以包含搜索表单或logo。<br><code>footer</code> footer通常包括其相关区块的脚注信息，如作者，相关阅读连接以及版权信息等。<br><code>article</code> 代表文档，页面或应用程序中独立的，完整的，可以独自被外部引用的内容，也可以嵌套使用。可以是一篇博客或者报刊中的文章，一篇论坛帖子，一段用户评论或者独立的插件，或其他任和独立的内容。<br><code>aside</code> 定义页面的侧边栏内容<br><code>address</code> 用来在文档中呈现联系信息，包括文档作者或文档维护者名字，他们的网站链接，电子邮箱，真实地址，电话号码，以及跟文档相关的联系人的所有联系信息。<br><code>time</code><br><code>details</code> 用于描述文档或者文档某一部分细节，summary是details元素的标题<br>ruby 加注释，ruby标签有两个子元素，rt注释的内容，rp是该标签不显示时显示的文字<br><code>mark</code> 定义带有几号的文本，它会给你想要突出显示的文本加个 背景色<br><code>nav</code> 是一个可以用作页面导航的链接组，其中导航元素链接到其他页面或当前页面的其他部分。<br><code>progress</code><br><code>section</code> 作为Html文档独立的功能。<br><code>video</code> 定义视频，属性src引入资源，controls视频的控制控件<br><code>audio</code>该标签可定义声音，及其他的音频文件，不加controls不显示音频的控制界面<br><code>datalist</code> 提示可能的值，datalist及其选项不会被显示出来，它仅仅是合法输入值的列表使用input元素的list属性来邦定datalist<br><code>embed</code> 定义插入的内容，如插件，flash，标签中间不要加内容会显现出来<br><code>canvas</code> canvas画布只是个容器，你可以通过控制坐标在canvas上绘制图形，一般配合js可以实现非常复杂的动画效果。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>渐进增强和优雅降级</title>
      <link href="/2018/10/10/CSS3/%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7/"/>
      <url>/2018/10/10/CSS3/%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="渐进增强"><a href="#渐进增强" class="headerlink" title="渐进增强"></a>渐进增强</h3><blockquote><p>一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.transition</span> &#123; <span class="comment">/*渐进增强写法*/</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">     <span class="attribute">-moz-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">       <span class="attribute">-o-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">          <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h3><blockquote><p>一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.transition</span> &#123; <span class="comment">/*优雅降级写法*/</span></span><br><span class="line">          <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">       <span class="attribute">-o-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">     <span class="attribute">-moz-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渐进增强和优雅降级的区别"><a href="#渐进增强和优雅降级的区别" class="headerlink" title="渐进增强和优雅降级的区别"></a>渐进增强和优雅降级的区别</h3><blockquote><p>渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的</p></blockquote><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>渐进增强和优雅降级如何抉择<ul><li>如果你采用渐进增强的开发流程，先做一个基本功能版，然后针对各个浏览器进行渐进增加，增加各种功能。相对于优雅降级来说，开发周期长，初期投入资金大。</li><li>那采用优雅降级呢，这样可以在较短时间内开发出一个只用于一个浏览器的完整功能版，然后就可以拿给PM找客户谈呀，可以拿去测试，市场试水呀，对于功能尚未确定的 产品，优雅降级不失为一种节约成本的方法。</li><li>采用优雅降级的写法，如果一个浏览器同时支持前缀写法和正常写法，后面的旧版浏览器样式就覆盖了新版样式，出现一些奇怪的问题 ，但是用渐进增强的写法就不存在这个问题。这种属性不止border-radius一个，所以为了避免这个不必要的错误，建议大家都采用渐进增强的写法。</li><li>绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。</li></ul></li></ul><blockquote><p>参考文章 <a href="https://blog.csdn.net/jnshu_it/article/details/77016996" target="_blank" rel="noopener">渐进增强和优雅降级之间有什么不同?</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>bind、apply和call的区别</title>
      <link href="/2018/10/10/JavaScript/bind%E5%92%8Ccall/"/>
      <url>/2018/10/10/JavaScript/bind%E5%92%8Ccall/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ing…<br>bind和call的作用都是将某个函数的this指向绑定到另外一个作用域中，他们的参数调用都是相同的，第一个参数为绑定的作用域对象是什么，接下来就是可以添加不限的参数，而区别就是call在绑定的同时调用函数，bind是返回一个改变this指向的函数。apply方法和call方法有些相似，它也可以改变this的指向同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>跨域的方法</title>
      <link href="/2018/10/10/%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95/%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/10/10/%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95/%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端本地储存</title>
      <link href="/2018/10/10/JavaScript/%E5%89%8D%E7%AB%AF%E6%9C%AC%E5%9C%B0%E5%82%A8%E5%AD%98/"/>
      <url>/2018/10/10/JavaScript/%E5%89%8D%E7%AB%AF%E6%9C%AC%E5%9C%B0%E5%82%A8%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>本地存储主要有以下几种，<code>cookie</code>，<code>localStorage</code>和<code>sessionStorage</code>，<code>WebSql</code>和<code>IndexDB</code>主要用在前端有大容量存储需求的页面上，例如，在线编辑浏览器或者网页邮箱。他们都可以将数据存储在浏览器，应该根据不同的场景进行使用。本文主要讲前三个。<a id="more"></a></p><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p><strong>cookie机制采用的是在客户端保持状态的方案</strong><br><code>Cookie</code>的主要内容包括：名字，值，过期时间，路径和域。<br>可设置失效时间，没有设置的话，默认是关闭浏览器后失效。<br>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>　　1. 给用户更人性化的使用体验，如记住“密码功能”、老用户登录欢迎语<br>　　2. 弥补了HTTP无连接特性<br>　　3. 站点统计访问人数的一个依据<br>　　4. 所有新旧浏览器都支持。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>　　1. 它无法解决多人共用一台电脑的问题，带来了不安全因素<br>　　2. Cookie文件容易被误删除<br>　　3. 一人使用多台电脑<br>　　4. Cookies欺骗。修改host文件，可以非法访问目标站点的Cookie<br>　　5. 容量有限制，不能超过4kb<br>　　6. 在请求头上带着数据安全性差</p><h5 id="为什么需要cookie"><a href="#为什么需要cookie" class="headerlink" title="为什么需要cookie"></a>为什么需要cookie</h5><p>　　当 <code>web</code> 服务器向浏览器发送 <code>web</code> 页面时，在连接关闭后，服务端不会记录用户的信息。<br><code>Cookie</code> 的作用就是用于解决 “如何记录客户端的用户信息”:<br>　　当用户访问 <code>web</code> 页面时，他的名字可以记录在 <code>cookie</code> 中。<br>　　在用户下一次访问该页面时，可以在 <code>cookie</code> 中读取用户访问记录。<br><code>Cookie</code> 以名/值对形式存储，如下所示:<br><code>username=John Doe</code><br>当浏览器从服务器上请求 <code>web</code> 页面时， 属于该页面的 <code>cookie</code> 会被添加到该请求中。服务端通过这种方式来获取用户的信息。</p><h5 id="如何使用cookie"><a href="#如何使用cookie" class="headerlink" title="如何使用cookie"></a>如何使用cookie</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Cookie</span></span><br><span class="line">document.cookie=<span class="string">"username=John Doe"</span>;</span><br><span class="line"><span class="comment"># 读取 Cookie</span></span><br><span class="line">var x = document.cookie;</span><br><span class="line"><span class="comment"># 修改 Cookie</span></span><br><span class="line">document.cookie=<span class="string">"username=John Smith; </span></span><br><span class="line"><span class="string">expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/"</span>;</span><br><span class="line"><span class="comment"># 删除 Cookie</span></span><br><span class="line"><span class="comment"># 删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可</span></span><br><span class="line">document.cookie = <span class="string">"username=; expires=Thu, 01 Jan 1970 00:00:00 GMT"</span>;</span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>如果 cookie 被篡改了怎么办？<br>预防 Cookie 被篡改<br>set-cookie时加上防篡改验证码。 </p><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p>　　<code>localStorage</code>主要是前端开发人员，在前端设置，一旦数据保存在本地后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要地来回传递。<br>　　可以长期存储数据，没有时间限制，一天，一年，两年甚至更长，数据都可以使用。<br><code>localStorage</code>中一般浏览器支持的是5M大小，这个在不同的浏览器中<code>localStorage</code>会有所不同</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>　　1. localStorage拓展了cookie的4k限制<br>　　2. localStorage可以将第一次请求的5M大小数据直接存储到本地，相比于cookie可以节约带宽<br>　　3. localStorage的使用也是遵循<code>同源策略</code>的，所以不同的网站直接是不能共用相同的localStorage</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>　　1. 需要手动删除，否则长期存在<br>　　2. 浏览器大小不一，版本的支持也不一样<br>　　3. localStorage只支持string类型的存储，JSON对象需要转换<br>　　4. localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'x'</span>, 121313);</span><br><span class="line">localStorage.setItem(<span class="string">'xxxx'</span>, <span class="string">'baozhen'</span>);</span><br><span class="line">localStorage.getItem(<span class="string">'x'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i = 0; i&lt; localStorage.length; i++) &#123;</span><br><span class="line">  var name = localStorage.key(i);</span><br><span class="line">  var value = localStorage.getItem(name)</span><br><span class="line">  console.log(<span class="string">"name:"</span>, name, <span class="string">"value:"</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">localStorage.removeItem(<span class="string">"x"</span>);</span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure></p><h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><p>　　<code>sessionStorage</code> 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。<br><code>存储上限限制</code>：不同的浏览器存储的上限也不一样，但大多数浏览器把上限限制在5MB以下。</p><h5 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存数据语法：</span></span><br><span class="line">sessionStorage.setItem(<span class="string">"key"</span>, <span class="string">"value"</span>);</span><br><span class="line"><span class="comment"># 读取数据语法：</span></span><br><span class="line">var lastname = sessionStorage.getItem(<span class="string">"key"</span>);</span><br><span class="line"><span class="comment"># 删除指定键的数据语法：</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">"key"</span>);</span><br><span class="line"><span class="comment"># 删除所有数据：</span></span><br><span class="line">sessionStorage.clear();</span><br></pre></td></tr></table></figure><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>　　由于<code>HTTP</code>协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是<code>Session</code>。<br>　　<code>Session</code>是在<code>服务端</code>保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。<br>　　典型的场景比如购物车，当你点击下单按钮时，由于<code>HTTP</code>协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的<code>Session</code>，用用于标识这个用户，并且跟踪用户的状态，这样才知道购物车里面有几本书。这个<code>Session</code>是保存在服务端的，有一个唯一标识。在服务端保存<code>Session</code>的方法很多，内存、数据库、文件都有。<br>　　<code>session</code>机制采用的是在<code>服务器端</code>保持状态的方案。存在服务器的一种用来存放用户数据的类HashTable结构。<br>　　浏览器第一次发送请求时，服务器自动生成了<code>一HashTable</code>和<code>一SessionID</code>来唯一标识这个<code>HashTable</code>，并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应的<br><code>Session ID</code>放在请求中一并发送到服务器上，服务器从请求中提取出<code>Session ID</code>，并和保存的所有<code>Session ID</code>进行对比，找到这个用户对应的<code>HashTable</code>。</p><h4 id="cookie-和-session-的区别"><a href="#cookie-和-session-的区别" class="headerlink" title="cookie 和 session 的区别"></a>cookie 和 session 的区别</h4><ul><li>cookie数据存放在客户的<code>浏览器</code>上，session数据放在<code>服务器</code>上。</li><li>session 中保存的是<code>对象</code>，cookie 中保存的是<code>字符串</code>。</li><li>session 不能区分路径，同一个用户在访问一个网站期间，所有的session在任何地方都可以访问到。而 cookie 中如果设置了路径参数，那么同一个网站不同路径下的 cookie 互相是不可以访问的。</li><li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。</li><li>session会在一定时间内保存在<code>服务器</code>上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li></ul><h4 id="localStorage-和-sessionStorage"><a href="#localStorage-和-sessionStorage" class="headerlink" title="localStorage 和 sessionStorage"></a>localStorage 和 sessionStorage</h4><p>　　<code>localStorage</code> 和 <code>sessionStorage</code>两者的区别在于储存的<code>有效期</code>和<code>作用域</code>的不同：数据可以储存多长时间以及谁拥有数据的访问权。</p><table><thead><tr><th>名称</th><th>有效期</th><th>作用域</th></tr></thead><tbody><tr><td>localStorage</td><td>永久性</td><td>同源文档</td></tr><tr><td>sessionStorage</td><td>当前窗口</td><td>同源文档</td></tr></tbody></table><h4 id="cookie-和-webStorage-的区别"><a href="#cookie-和-webStorage-的区别" class="headerlink" title="cookie 和 webStorage 的区别"></a>cookie 和 webStorage 的区别</h4><ul><li>webStorage 的优势<ul><li>从容量上讲WebStorage一般浏览器提供5M的存储空间。</li><li>安全性上WebStorage 并不作为 HTTP header 发送的浏览器，所以相对安全。</li><li>从流量上讲，因为WebStorage不传送到服务器，所以不必要的流量可以节省。 Cookie和webstorage区别 </li><li>数据的有效期不同<ul><li>Webstorage:1.localstorage 2.sessionstorage </li><li>sessionStorage：仅在当前的浏览器窗口关闭有效；</li><li>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据,除非手动删除；</li><li>cookie：只在设置的cookie过期时间之前一直有效，即使窗口和浏览器关闭</li></ul></li><li>作用域不同<ul><li>sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；</li><li>localStorage：在所有同源窗口都是共享的；</li><li>cookie：也是在所有同源窗口中共享的</li></ul></li><li>webStorage支持事件通知机制，可以将数据更新的通知发生给监听者</li><li><img src="/assets/images/session.png" alt="WebStorage"></li></ul></li></ul><p>转载：<br>　　<a href="https://blog.csdn.net/statham_li/article/details/80226447" target="_blank" rel="noopener">cookie和session, cookie和webStorage的区别</a><br>　　<a href="https://segmentfault.com/a/1190000017185195" target="_blank" rel="noopener">浏览器缓存原理以及本地存储</a><br>　　<a href="https://www.zhihu.com/question/19786827" target="_blank" rel="noopener">知乎问答</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端本地储存 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
