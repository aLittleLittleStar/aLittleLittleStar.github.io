<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[优化DOM]]></title>
    <url>%2F2019%2F03%2F31%2FJavaScript%2F%E4%BC%98%E5%8C%96DOM%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM基本操作]]></title>
    <url>%2F2019%2F03%2F31%2FJavaScript%2FDOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[获取节点 document getElementById 语法： document.getElementById(元素ID) 功能： 通过元素ID获取节点 getElementsByName 语法： document.getElementsByName(元素name属性) 功能： 通过元素name属性获取节点 getElementsByTagName 语法： document.getElementsByTagName(元素标签) 功能： 通过元素标签获取节点 getElementsByClassName 语法： document.getElementsByClassName(“classname”) 功能： 根据class获取元素节点 CSS选择器 querySelector() 语法： document.querySelector() 功能： 根据CSS选择器的规则，返回第一个匹配到的元素 querySelectorAll() 语法： document.querySelectorAll() 功能： 根据CSS选择器的规则，返回所有匹配到的元素 节点指针 firstChild 语法： 父节点.firstChild 功能： 获取元素首个节点 lastChild 语法： 父节点.lastChild 功能： 获取元素最后一个节点 childNodes 语法： 父节点.childNodes 功能： 获取元素子节点列表 previousSibling 语法： 兄弟节点.previousSibling 功能： 获取已知节点前一个节点 nextSibling 语法： 兄弟节点.nextSibling 功能： 获取已知节点后一个节点 parentNode 语法： 子节点.parentNode 功能： 获取已知节点的父节点 节点操作 创建节点 createElement 语法： document.createElement(元素标签) 功能： 创造元素节点 createAttribute 语法： document.createAttribute(元素属性) 功能： 创建属性节点 createTextNode 语法： document.createTextNode(文本内容) 功能： 创建文本节点 插入节点 appendChild 语法： appendChild(所添加的新节点) 功能： 向节点的子节点列表的末尾添加新的子节点 insertBefore 语法： insertBefore(所要添加的新节点, 已知子节点) 功能： 向已知的子节点前插入一个新的子节点 替换节点 replaceChild 语法： replaceChild(要插入的新元素， 将被替换的老元素) 功能： 将子节点替换成另一个 复制节点 cloneNode 语法： 需要被复制的节点.cloneNode(true/false) 功能： 创建指定节点的副本 参数： true 复制当前节点以及其他所有子节点 false 仅复制当前节点 删除节点 removeChild 语法： removeChild(要删除的节点) 功能： 删除指定的节点 属性操作 获取属性 getAttribute 语法： 元素节点.getAttribute(元素属性名) 功能： 获取元素节点中指定属性的属性值 设置属性 setAttribute 语法： 元素节点.setAttribute(属性名， 属性值) 功能： 创建或者改变元素的属性 删除属性 removeAttribute 语法： 元素节点.removeAttribute(属性名) 功能： 删除元素中的指定属性 文本操作 文本操作 insterData(offset, string) 从offset指定的位置插入string appendData(string) 将string插入到文本节点的末尾处 deleteData(offset, count) 从offset起删除count个字符 replaceData(off, count, string) 从off将count个字符用string splitData(offset) 从offset起将文本节点分成两个节点 substring(offset, count) 返回由offset起的count个节点]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中使用Axios]]></title>
    <url>%2F2019%2F03%2F30%2FAjax%2FAxios%2F</url>
    <content type="text"><![CDATA[转载： axios参考： axio github Axios中文 基本流程安装: npm install axios --save设置全局都可以使用axios设置在 main.js 中引入 axios: import axios from &#39;axios&#39;axios 改写为 Vue 的原型属性（不推荐这样用） Vue.prototype.$http= axios在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $http命令例如1234567891011methods: &#123; show() &#123; this.$http(&#123; method: 'get', url: '/user', data: &#123; name: 'virus' &#125; &#125;)&#125;&#125; 发送请求GET请求1234567891011121314151617181920# 通过给定的ID来发送请求axios.get('/user?ID=12345') .then(function(response)&#123; console.log(response); &#125;) .catch(function(err)&#123; console.log(err); &#125;);# 以上请求也可以通过这种方式来发送axios.get('/user',&#123; params:&#123; ID:12345 &#125;&#125;).then(function(response)&#123; console.log(response);&#125;).catch(function(err)&#123; console.log(err);&#125;); POST请求12345678910axios.post('/user',&#123; firstName:'Fred', lastName:'Flintstone'&#125;).then(function(res)&#123; console.log(res);&#125;).catch(function(err)&#123; console.log(err);&#125;); 一次性并发多个请求12345678910function getUserAccount()&#123; return axios.get('/user/12345');&#125;function getUserPermissions()&#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(),getUserPermissions()]) .then(axios.spread(function(acct,perms)&#123; # 当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果 &#125;)) axios的APIaxios可以通过配置（config）来发送请求axios(config)123456789# 发送一个`POST`请求axios(&#123; method:"POST", url:'/user/12345', data:&#123; firstName:"Fred", lastName:"Flintstone" &#125;&#125;); axios(url[,config])12# 发送一个`GET`请求（默认的请求方式）axios('/user/12345'); 请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名1234567axios.request(config);axios.get(url[,config]);axios.delete(url[,config]);axios.head(url[,config]);axios.post(url[,data[,config]]);axios.put(url[,data[,config]])axios.patch(url[,data[,config]]) 注意：当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明 并发请求（concurrency）,即是帮助处理并发请求的辅助函数1234# iterable是一个可以迭代的参数如数组等axios.all(iterable)# callback要等到所有请求都完成才会执行axios.spread(callback) 创建一个axios实例，并且可以自定义其配置123456# axios.create([config])var instance = axios.create(&#123; baseURL:"https://some-domain.com/api/", timeout:1000, headers: &#123;'X-Custom-Header':'foobar'&#125;&#125;); 123456789# 实例的方法# 一下是实例方法，注意已经定义的配置将和利用create创建的实例的配置合并axios#request(config)axios#get(url[,config])axios#delete(url[,config])axios#head(url[,config])axios#post(url[,data[,config]])axios#put(url[,data[,config]])axios#patch(url[,data[,config]]) 请求的配置（request config） 以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&#123; # `url`是请求的服务器地址 url:'/user', # `method`是请求资源的方式 method:'get'# default # 如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面 # 当`url`是相对地址的时候，设置`baseURL`会非常的方便 baseURL:'https://some-domain.com/api/', # `transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动 # 该选项只适用于以下请求方式：`put/post/patch` # 数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream` transformRequest:[function(data)&#123; # 在这里根据自己的需求改变数据 return data; &#125;], # `transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动 transformResponse:[function(data)&#123; # 在这里根据自己的需求改变数据 return data; &#125;], # `headers`选项是需要被发送的自定义请求头信息 headers: &#123;'X-Requested-With':'XMLHttpRequest'&#125;, # `params`选项是要随请求一起发送的请求参数----一般链接在URL后面 # 他的类型必须是一个纯对象或者是URLSearchParams对象 params: &#123; ID:12345 &#125;, # `paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化 # 例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param) paramsSerializer: function(params)&#123; return Qs.stringify(params,&#123;arrayFormat:'brackets'&#125;) &#125;, # `data`选项是作为一个请求体而需要被发送的数据 # 该选项只适用于方法：`put/post/patch` # 当没有设置`transformRequest`选项时dada必须是以下几种类型之一 # string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams # 仅仅浏览器：FormData/File/Bold # 仅node:Stream data &#123; firstName:"Fred" &#125;, # `timeout`选项定义了请求发出的延迟毫秒数 # 如果请求花费的时间超过延迟的时间，那么请求会被终止 timeout:1000, # `withCredentails`选项表明了是否是跨域请求 withCredentials:false,# default # `adapter`适配器选项允许自定义处理请求，这会使得测试变得方便 # 返回一个promise,并提供验证返回 adapter: function(config)&#123; /*..........*/ &#125;, # `auth`表明HTTP基础的认证应该被使用，并提供证书 # 这会设置一个authorization头（header）,并覆盖你在header # 设置的Authorization头信息 auth: &#123; username:"zhangsan", password: "s00sdkf" &#125;, # 返回数据的格式 # 其可选项是arraybuffer,blob,document,json,text,stream responseType:'json',# default # xsrfCookieName: 'XSRF-TOKEN',# default xsrfHeaderName:'X-XSRF-TOKEN',# default # `onUploadProgress`上传进度事件 onUploadProgress:function(progressEvent)&#123; # 下载进度的事件onDownloadProgress:function(progressEvent)&#123;&#125; &#125;, # 相应内容的最大值 maxContentLength:2000, # `validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise # 如果`validateStatus`返回true(或者设置为`null`或者`undefined`), # 那么promise的状态将会是resolved,否则其状态就是rejected validateStatus:function(status)&#123; return status &gt;= 200 &amp;&amp; status &lt;300;# default &#125;, # `maxRedirects`定义了在nodejs中重定向的最大数量 maxRedirects: 5,# default # `httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理 # keeyAlive在选项中没有被默认激活 httpAgent: new http.Agent(&#123;keeyAlive:true&#125;), httpsAgent: new https.Agent(&#123;keeyAlive:true&#125;), # proxy定义了主机名字和端口号， # `auth`表明http基本认证应该与proxy代理链接，并提供证书 # 这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的 # Proxy-Authorization header proxy: &#123; host:'127.0.0.1', port: 9000, auth: &#123; username:'skda', password:'radsd' &#125; &#125;, # `cancelToken`定义了一个用于取消请求的cancel token # 详见cancelation部分 cancelToken: new cancelToken(function(cancel)&#123; &#125;)&#125; 请求返回的内容1234567891011&#123; data:&#123;&#125;, status:200, # 从服务器返回的http状态文本 statusText:'OK', # 响应头信息 headers: &#123;&#125;, # `config`是在请求的时候的一些配置信息 config: &#123;&#125;&#125; 123456789# 你可以这样来获取响应信息axios.get('/user/12345') .then(function(res)&#123; console.log(res.data); console.log(res.status); console.log(res.statusText); console.log(res.headers); console.log(res.config); &#125;) 默认配置你可以设置默认配置，对所有请求都有效12341、 全局默认配置axios.defaults.baseURL = 'http://api.exmple.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['content-Type'] = 'appliction/x-www-form-urlencoded'; 2、 自定义的实例默认设置1234567# 当创建实例的时候配置默认配置var instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);# 当实例创建时候修改配置instance.defaults.headers.common["Authorization"] = AUTH_TOKEN; 3、 配置中的有优先级 config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。12345678910# 创建一个实例的时候会使用libray目录中的默认配置# 在这里timeout配置的值为0，来自于libray的默认值var instance = axios.create();# 回覆盖掉library的默认值# 现在所有的请求都要等2.5S之后才会发出instance.defaults.timeout = 2500;# 这里的timeout回覆盖之前的2.5S变成5sinstance.get('/longRequest',&#123; timeout: 5000&#125;); 拦截器你可以在请求、响应在到达then/catch之前拦截他们12345678910111213141516# 添加一个请求拦截器axios.interceptors.request.use(function(config)&#123; # 在请求发出之前进行一些操作 return config;&#125;,function(err)&#123; # Do something with request error return Promise.reject(error);&#125;);# 添加一个响应拦截器axios.interceptors.response.use(function(res)&#123; # 在这里对返回的数据进行处理 return res;&#125;,function(err)&#123; # Do something with response error return Promise.reject(error);&#125;) 2、取消拦截器12var myInterceptor = axios.interceptor.request.use(function()&#123;/*....*/&#125;);axios.interceptors.request.eject(myInterceptor); 3、 给自定义的axios实例添加拦截器12var instance = axios.create();instance.interceptors.request.use(function()&#123;&#125;) 错误处理12345678910111213axios.get('/user/12345') .catch(function(error)&#123; if(error.response)&#123; # 请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.header); &#125;else &#123; # 一些错误是在设置请求的时候触发 console.log('Error',error.message); &#125; console.log(error.config); &#125;); 取消1、你可以通过一个cancel token来取消一个请求你可以通过CancelToken.source工厂函数来创建一个cancel token123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345',&#123; cancelToken: source.token&#125;).catch(function(thrown)&#123; if(axios.isCancel(thrown))&#123; console.log('Request canceled',thrown.message); &#125;else &#123; # handle error &#125;&#125;);# 取消请求（信息的参数可以设置的）source.cance("操作被用户取消"); 2、你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:12345678910var cancelToken = axios.CancelToken;var cance;axios.get('/user/12345',&#123; cancelToken: new CancelToken(function(c)&#123; # 这个executor函数接受一个cancel function作为参数 cancel = c; &#125;)&#125;)# 取消请求cancel(); 创建axios实例123456789101112131415161718192021222324252627282930313233343536# helpers.jsimport axios from 'axios'# 定义常量ERR_OKconst ERR_OK = 0# 导出一个getDate方法export default getDate(url) &#123; return function(params) &#123; return axios.get(url, &#123; params # 成功之后的.then方法 &#125;).then((res) =&gt; &#123; # 通过结构赋值的方法难道error和data的数值 const &#123; error, data&#125; = res.data # 如果成功的话，返回data数据 if(error === ERR_OK) &#123; return data &#125; # 如果失败的话打印失败的原因 &#125;).catch(function(error) =&gt; &#123; console.log("error:", error) &#125;) &#125;&#125;# 出口文件# index.jsimport &#123; getDate &#125; from './helpers'# 定义getSeller方法const getSeller = getDate('./api/seller')# 导出getSeller方法export &#123; getSeller&#125;]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2F2019%2F03%2F30%2FAjax%2FAJAX%2F</url>
    <content type="text"><![CDATA[AJAX简介 AJAX全称为“Asynchronous Javascript And XML”， 即“异步JavaScript和XML”的意思。通过AJAX我们可以向服务器发送请求，在不阻塞页面的情况下进行数据交互，也可以理解为异步数据传输。在AJAX的帮助下我们的网页只需局部刷新即可更新数据的显示，减少了不必要的数据量，大大提高了用户体验，缩短了用户等待的时间，使得web应用程序更小、更快，更友好。 优点页面无刷新，用户体验好。异步通信，更加快的响应能力。减少冗余请求，减轻了服务器负担基于标准化的并被广泛支持的技术，不需要下载插件或者小程序 缺点ajax干掉了back按钮，即对浏览器后退机制的破坏。存在一定的安全问题。对搜索引擎的支持比较弱。破坏了程序的异常机制。无法用URL直接访问 使用场景场景 1. 数据验证场景 2. 按需取数据场景 3. 自动更新页面 AJAX的核心 XMLHttpRequest对象创建XML对象的实例：const xhr = new XMLHttpRequest() 方法123456789101112# 准备启动一个AJAX请求.open()# 设置请求头部信息.setRequestHeader()# 发送AJAX请求.send()# 获得响应头部信息.getResponseHeader()# 获得一个包含所有头部信息的长字符串.getAllResponseHeader()# 取消异步请求.abort() 属性1234567891011# 包含响应主体返回文本.responseText# 如果响应的内容类型时text/xml或application/xml，# 该属性将保存包含着相应数据的XML DOM文档.responseXML# 响应的HTTP状态.status# HTTP状态的说明.statusText# 表示“请求”/“响应”过程的当前活动阶段.readyState 发送AJAX请求设置请求头部信息 每个HTTP请求和响应都会带有相应的头部信息，包含一些与数据，收发者网络环境与状态等相关信息。XMLHttpRequest对象提供的.setRequestHeader()方法为开发者提供了一个操作这两种头部信息的方法，并允许开发者自定义请求头的头部信息。默认情况下，当发送AJAX请求时，会附带以下头部信息：123456789101112131415161718# 浏览器能够处理的内容类型Accept# 浏览器能够显示的字符集Accept-Charset# 浏览器能够处理的压缩编码Accept-Encoding# 浏览器当前设置的语言Accept-Language# 浏览器与服务器之间连接的类型Connection# 当前页面设置的任何CookieCookie# 发出请求的页面所在的域Host# 发出请求的页面URIReferer# 浏览器的用户代理字符串User-Agent 注意: 部分浏览器不允许使用.setRequestHeader()方法重写默认请求头信息，因此自定义请求头信息是更加安全的方法：# 自定义请求头xhr.setRequestHeader(&quot;myHeader&quot;, &quot;MyValue&quot;) 发送AJAX请求123456789101112# 发送AJAX请求# 使用get方法发送同步请求(false)let xhr = new XMLHttpRequest()xhr.open('get', 'example.php', false)xhr.setRequestHeader('myHeader', 'goodHeader')xhr.send(null)# POST请求let xhr = new XMLHttpRequest()xhr.open('post', 'example.php', false)xhr.setRequestHeader('myHeader', 'goodHeader')shr.send(some_data) 处理响应同步的GET请求响应：1234567891011const xhr = new XMLHttpRequest()xhr.open("get", "example.php", false)xhr.setRequestHeader("myHeader", "goodHeader")xhr.send(null)# 由于是同步的AJAX请求，因此只有当服务器响应后才会继续执行下面的代码# 因此xhr.status的值一定不为默认值if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log("xhr.responseText:", xhr.responseText);&#125; else &#123; console.log("Request was unsuccessful:", xhr.status);&#125; 上面的代码不难理解，我们通过之前提到的xhr.status属性（如果你忘记了，它存储着响应的HTTP状态）判断请求是否成功，如果成功的话，我们将读取xhr.responseText属性中存储的返回值。但是，当我们的请求为异步时，问题就稍微变得复杂了，由于是异步的请求，在xhr.send(null)语句被执行后，JavaScript引擎会紧接着执行下面的判断语句，而这时由于尚未来得及响应，我们注定会得到一个默认的xhr.status值，因此，我们永远都不可能获取请求的资源了。如何解决这个问题？答案是通过为XMLHTTPRequest实例添加onreadystatechange事件处理程序（当然你也可以直接使用DOM2级规范规定的.addEventListener()方法，但是注意，IE8是不支持该方法的）。 xhr实例的readystatechange事件会监听xhr.readyState属性的变化，你可以将这个属性想象为一个计数器，随着AJAX流程的推进而不断累加，其可取的值如下：12345 0：未初始化 -- 尚未调用.open()方法 1：启动 -- 已经调用.open()方法，但尚未调用.send()方法 2：发送 -- 已经调用.send()方法，但尚未接收到响应 3：接收 -- 已经接收到部分响应数据 4：完成 -- 已经接收到全部响应数据，而且已经可以在客户端使用了 有了这个时间处理程序对AJAX进程做监听，剩下的事就简单多了，一个异步的GET请求代码如下：12345678910111213141516const xhr = new XMLHttpRequest()# 等价于 xhr.onreadystatechange = function()&#123;&#125;# 利用onreadystatechange监测状态xhr.onreadystatechange = () =&gt; &#123; # readyState为4表示请求响应完成 if(xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log("xhr.responseText:", xhr.responseText); &#125; else &#123; console.log("Request was unsuccessful:", xhr.status); &#125; &#125;&#125;xhr.open('GET', 'example.php', true)xhr.send(null) 其他库框架中的AJAXjQuery中的AJAX1234567891011$.ajax(&#123; method: 'GET', # 1.9.0本版前用'type' url: "/test/", dataType: 'json'&#125;).done(function() &#123; console.log('执行成功');&#125;).fail(function() &#123; console.log('执行出错');&#125;) Vue.js中的AJAX12345Vue.http.get('/test/').then((response) =&gt; &#123; console.log('执行成功');&#125;, (response) =&gt; &#123; console.log('执行出错');&#125;); 转载： 使用AJAX]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM结构]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2FDOM%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[定义DOM是个缩写，全称是Document Object Model。D表示Document，就是DOM将HTML页面解析为一个文档，同时提供了document对象。O表示Object，就是DOM将HTML页面中每一个元素解析为一个对象。M表示Model，就是DOM中表示各个对象之间的关系。 作用用于解析HTML页面文档，方便JavaScript语言通过DOM访问和操作HTML页面中的内容。 DOM结构DOM树结构DOM可以访问和更新HTML中的内容、结构和样式，是因为DOM将HTML解析为一个树状结构。1234567891011&lt;!DOCTYPE html&gt;&lt;html lang='en'&gt;&lt;head&gt; &lt;meta charset='UTF-8'&gt; &lt;title&gt;示例页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;这是一个示例页面&lt;/h2&gt; &lt;p id="p" title="this is p."&gt;这是一个段落内容。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 将上面的 HTML 页面绘制成 DOM 树结构，如下效果: 通过上面的 DOM 树结构，我们可以看到，Document 对象是作为 DOM树结构的入口。再根据 DOM 树结构的特点，我们就可以定位到 HTML 页面中任意一个元素、属性或文本内容。 浏览器加载并运行 HTML 页面时，会创建 DOM 树结构这个模型。并且 DOM 树结构模型会被存储在浏览器的内存中。当 HTML 页面内容过于庞大和复杂时，生成的 DOM 树结构就越复杂。进而，浏览器加载 HTML 页面的耗时就越长。 DOM树中的节点在 DOM 树结构中，主要由以下 4 种节点组成: 节点名称 含义 描述 文档节点 表示整个HTML页面(相当于document对象) 当需要访问任何标签、属性或文本时，都可以通过文档节点进行导航 元素节点 表示HTML页面中的标签(即HTML页面结构) 访问DOM树时，需要从查找元素节点开始 属性节点 表示HTML页面中的开始标签包含的属性 文本节点 表示整个HTML页面中的标签所包含的文本内容 节点（Node）作为DOM树结构中的连接点，最终构成了完整的DOM树结构 节点树结构通过节点概念，我们可以将原本的 DOM 树结构改成 DOM 节点树结构进行表示。 操作节点1、获取节点12345678910111213# 1、标准DOM APIdocument.getElementByIddocument.getElementsByTagNamedocument.getElementsByNamedocument.getElemensByClassName# 功能强大，但是也许会有浏览器不兼容的情况存在document.querySelectorAll 2、 亲属访问3、 属性获取getAttributegetAttributeNode 2、 创建123456789# 创建元素document.createElement # 创建文本节点document.createTesxtNode # 属性节点document.createAttribute innerHTMLinnerTextnode.cloneNode() 3、 加入12345# 追加到结尾处appendChild innerHTML# 用法：将元素插入到某一个元素的前面 父元素.insertBefore(新元素, 旧元素);insertBefore 4、 其他12style 的操作setAttribute(属性名， 属性值) 5、 删除123# 用法：父元素.removeChild()removeChild removeAttributeNode 6、 修改123456789101112131415161.修改节点删除节点再加入2.修改样式style.xxx = vvv;setAttribute3.修改文本innerHTMLinnerText节点操作nodeValue4.修改属性.xxx = vvvsetAttribute]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器渲染流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染流程]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[转载： 浏览器加载、解析、渲染的过程 【干货】十分钟读懂浏览器渲染流程 为什么要了解浏览器加载、解析、渲染这个过程 了解浏览器如何进行加载，可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。 了解浏览器如何进行解析，可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。 了解浏览器如何进行渲染，明白渲染的过程，在设置元素属性，编写js文件时，可以减少”reflow“”repaint“的消耗。 浏览器的主要功能 浏览器的主要功能是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式。用户用URI（Uniform Resource Identifier统一资源标识符）来指定所请求资源的位置，通过DNS查询，将网址转换为IP地址。整个浏览器工作的流程为： 1、 输入网址。 2、 浏览器查找域名的IP地址。 3、 浏览器给web服务器发送一个HTTP请求 4、 网站服务的永久重定向响应 5、 浏览器跟踪重定向地址。现在，浏览器知道了要访问的正确地址，所以它会发送另一个获取请求。 6、 服务器“处理”请求，服务器接收到获取请求，然后处理并返回一个响应。 7、 服务器发回一个HTML响应 8、 浏览器开始显示HTML 9、 浏览器发送请求，以获取嵌入在HTML中的对象。在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。这些文件就包括CSS/JS/图片等资源，这些资源的地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等… 那么，一个页面，究竟是如何从我们输入一个网址到最后完整的呈现在我们面前的呢？还需要了解一下浏览器是如何渲染的： 浏览器的渲染渲染引擎在取得内容之后的基本流程：解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树所以，浏览器会解析三个东西：（1） HTML/SVG/XHTML，解析这三种文件会产生一个 DOM Tree。（2） CSS，解析 CSS 会产生 CSS 规则树。（3） Javascript脚本，主要是通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree. 关键渲染路径 关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。 当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。解析： 1、 DOM Tree: 浏览器会将HTML解析成一个DOM树。DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 2、 CSS Rule Tree: 将CSS解析成 CSS Rule Tree 。 3、 Render Tree: 根据DOM树和CSSOM来构造 Rendering Tree。 注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。 4、 layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。 （遍历渲染树开始布局，计算每个节点的位置大小信息） 5、 painting: 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。 (将渲染树每个节点绘制到屏幕。) 构建DOM树 当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。需要注意的是，DOM树的生成过程中可能会被CSS和JS的加载执行阻塞。渲染阻塞问题下文会讲。 构建CSSOM规则树 浏览器解析CSS文件并生成CSS规则树，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。 渲染阻塞 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建DOM。每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。 所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：CSS 优先：引入顺序上，CSS 资源先于 JavaScript资源。JS置后：我们通常把JS代码放到页面底部，且JavaScript 应尽量少影响 DOM 的构建。当解析html的时候，会把新来的元素插入dom树里面，同时去查找css，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。例如： div p {font-size: 16px}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染）。所以，我们平时写CSS时，尽量用id和class，千万不要过渡层叠。 构建渲染树 通过DOM树和CSS规则树我们便可以构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的CSS样式规则并应用。渲染树构建完成后，每个节点都是可见节点并且都含有其内容和对应规则的样式。这也是渲染树与DOM树的最大区别所在。渲染树是用于显示，那些不可见的元素当然就不会在这棵树中出现了，譬如。除此之外，display等于none的也不会被显示在这棵树里头，但是visibility等于hidden的元素是会显示在这棵树里头的。 渲染树布局 布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。 渲染树绘制 在绘制阶段，遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。 重点 上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。几个概念： （1）Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。 （2）Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。Reflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。 reflow （1）页面初始化的时候； （2）操作DOM时； （3）某些元素的尺寸变了； （4）如果 CSS 的属性发生变化了。 减少reflow/repaint （1）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。 （2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。 （3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。 （4）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。 注意注意： (1)display:none 的节点不会被加入Render Tree，而visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。 (2)display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。 (3)有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步reflow 或增量异步 reflow。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。 HTML页面加载和解析流程 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件； 浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件； 浏览器又发出CSS文件的请求，服务器返回这个CSS文件； 浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了； 浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； 浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它； Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码； 终于等到了＜/html＞的到来，浏览器泪流满面…… 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径； 浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。 编写CSS时应该注意 CSS选择符是从右到左进行匹配的。从右到左！所以，#nav li 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的li，然后再去确定它的父元素是不是#nav。，因此，写css的时候需要注意： 1、dom深度尽量浅。 2、减少inline javascript、css的数量。 3、使用现代合法的css属性。 4、不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。 5、避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;#tp p{}子选择符：#tp&gt;p{}` 6、避免使用通配符，举一个例子，.mod .hd *{font-size:14px;}根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知. 关于Script标签位置Javascript的加载和执行的特点： （1）载入后马上执行； （2）执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）。原因：因为浏览器需要一个稳定的DOM树结构，而JS中很有可能有 代码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修 改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现。 减少JavaScript对性能的影响 （1）将所有的script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染。 （2）尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。 （3）采用无阻塞下载 JavaScript 脚本的方法： （1）使用script标签的 defer 属性（仅适用于 IE 和 Firefox 3.5 以上版本）； （2）使用动态创建的script元素来下载并执行代码；]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器渲染流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC&IFC&GFC&FFC]]></title>
    <url>%2F2019%2F03%2F29%2F%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%2FBFC%26IFC%2F</url>
    <content type="text"><![CDATA[BFC理解 对CSS有了解的道友们肯定都知道盒式模型这个概念，对一个元素设置CSS，首先需要知道这个元素是block还是inline类型。而BFC就是用来格式化块级盒子，同样管理inline类型的盒子还有IFC，以及其他的FC。那首先我们就来看一下FC的概念。 Formatting Context：指页面中的一个渲染区域，并且拥有一套渲染规则，他决定了其子元素如何定位，以及与其他元素的相互关系和作用。 BFC：块级格式化上下文，它是指一个独立的块级渲染区域，只有Block-level BOX参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 BFC生成BFC(Block Formatting Context)是Web页面中盒模型布局的CSS渲染模式。它属于常规文档流。CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC:（1）float的值不为none（2）position的值为absolute或者fixed（3）display的值为table-cell、table-caption、inline-block、flex或者inline-flex的其中一个（4）overflow的值不为visible BFC的约束规则浏览器对于BFC这块区域的约束规则如下： 生成BFC元素的子元素会一个接一个的放置。垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的margin特性。在BFC中相邻的块级元素外边距会折叠。 生成BFC元素的子元素中，每一个子元素做外边距与包含块的左边界相接触，（对于从右到左的格式化，右外边距接触右边界），即使浮动元素也是如此（尽管子元素的内容区域会由于浮动而压缩），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。有道友对它做了分解，我们直接拿来： （1）内部的Box会在垂直方向上一个接一个的放置 （2）垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关。） （3）每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界） （4）BFC的区域不会与float box的元素区域重叠 （5）计算BFC的高度时，浮动子元素也参与计算 （6）BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然 BFC的用处防止发生因浮动导致的高度塌陷防止margin重叠 同一个BFC中的两个相邻Box才会发生重叠与方向无关，不过由于上文提到的第一条限制，我们甚少看到水平方向的margin重叠。这在IE中是个例外，IE可以设置write-mode123456789101112131415161718# html&lt;div class="first-block"&gt;&lt;/div&gt;&lt;div class="second-block"&gt; &lt;h2&gt;DDFE&lt;/h2&gt;&lt;/div&gt;# css.first-block &#123; background: #F44336; width: 200px; height: 200px;&#125;.second-block &#123; background: #00BCD4; width: 200px; height: 200px; overflow: hidden; //添加溢出隐藏&#125; first-block和second-block之间存在间距，这个间距是 h2 的上外边距引起的通过把 overflow 把 second-block 元素形成一个 BFC，完美解决！ CSS 里面关于折叠的条件：两个块元素要产生折叠现象，必须满足一个必备条件：这两个元素的 margin 必须是 相邻 的；那么如果定义相邻呢，w3c 规范，两个 margin 是邻接的必须满足以下条件：必须是处于常规文档流（非float和绝对定位）的块级盒子,并且处于同一个 BFC 当中。没有inline盒子，没有空隙，没有 padding 和 border 将他们分隔开。 IFC 在一个IFC中，从父级元素的顶部开始，盒子一个接一个横向排列。此时，横向的margin、borders、padding在这些盒子中都是有效的。这些盒子有可能通过不同的方式垂直对齐：1、他们底部或者顶部可以对齐，2、或者可以他们内部的文字基线可以对齐。如果一个矩形区域，包含着一些排成一条线的盒子，称为line box。 什么是IFC IFC(Inline Formatting Contexts)直译为”行内格式化上下文“，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来(不受到竖直方向的 padding/margin 影响) IFC特性 IFC中的linebox一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。 IFC的应用 水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。 垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。 参考文章： 我对BFC的理解 细说CSS中的BFC]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>页面布局</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F29%2F%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%2F%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端知识点]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[HTML+CSS布局 内容+样式 基础 重点了解布局、流 less、sass、stylus CSS px、em、rem、vw、vh 设置html的font-size大小，统一标准 小程序单位rpx 布局 相对、绝对 流式、响应式布局 flex布局 CSS3 透明度、文字阴影、圆角、渐变色 盒阴影、边框图片、媒体查询 transition过渡、transform变形、animation动画 CSS优化 选择器原理: 从右向左 避免后台、链式、重复 避免!important BFC &amp; IFC float不是none，绝对定位，表格，overflow不是visable，flex盒子 创建BFC后，元素会一个个的摆放 外边距折叠 最常见的：overflow:hidden、 float:left/right、 position: absolut、 ES6 &amp; ES7 let、const、解构(结构)、 箭头函数、SymboL、Set Proxy、Class、generator、模块化 函数 默认参数、返回值、原型链 箭头函数、this、作用域、闭包、bind、apply 高阶函数、递归、Decorator、Compose、Currying… 面向对象 class、实例方法、静态属性和方法 构造函数、super 继承 JS异步 解决回调 Promise Generator Async + await 模块化 最早期AMD、CMD、commonjs import export ES6加载原理和node加载原理 面试题 Promise相当于一个状态机 pending、rejected、fulfilled状态 维护callback队列 掘金 Vue Vue-cli3.0+ 组件化通讯 父子组件 props $emit 兄弟组件可以让父母代理中转 祖先后代关系eventbus 或者自己实现dispath&amp;boardcast 没关系eventbus或者Vuex 生命周期 组件化设计 源码 全家桶、服务端渲染 复用.Vue组件 props、event、slot 手动挂载的组件$emit 递归组件和动态组件 双向绑定 Object.defineProperty 依赖机制 异步更新队列 Vuex + vue-router 单页应用 依赖加载模块 vue单行数据流 数据交给专门的store管理，全局数据中心、 服务端渲染 服务端解析vue组件成html渲染首屏 速度 SEO nuxt.js Typescript+ Webpack 基础配置 性能优化，缩小搜索范围，DllPlugin，多进程、tree-shaking，代码抽取，按需加载 定制loader和plugin loader定义自己的转换规则 plugin 整个webpack工作流程定义，有一个apply方法获取compiler对象 loader单一职责，链式组合，模块化，无状态 plugin 修改输出资源 读取模块和依赖 监听文件变化 异步 浏览器 性能优化 抛开场景谈优化，就是耍流氓 常见性能优化策略,文件少加载，代码少执行，多用缓存，少计算， 性能如何分析 devtools代码打包压缩，图片压缩，gzip，缓存，cdn，SSR，框架对应的优化策略，lazy-load,节流防抖 服务端渲染 安全 常见漏洞，如何防御 XSS、CSRF、Cookie劫持、点击劫持 传输安全、接入层 Oauth 多端（Node，小程序，App） 微信小程序 测试 微服务 Node.js 监控 部署 自动化 云开发 RN flutter 小程序生态 nodejs Node核心概念 events，fs，stream，buffer IO，event-loop，线程池 libuv，V8 Node应用场景 Express、Koa等web开方 自动化，微服务 express/koa网站 前端工具 webpack/ gulp API/hapi 跨平台/ electron 区块链/ ipfs 命令行工具/ shell.js Express/koa代理 硬件/ ruff 微服务 企业级框架eggj 实时/socket.io Event-loop 代码到底咋执行的 执行微任务 比如promise 同步代码，完事之后查询是否有异步 执行宏任务，setTimeout,SetImmediate,等 自动化测试 代码的健壮性，改代码不再胆战心惊 E2E测试Puppeteer，代码覆盖率istanbul 单元测试，mocha，jest ，jasmine 测试驱动开发TDD，先写测试，再写代码 前端监控 对运行状况了然于胸 前端错误监控 onerror Sentry 前端性能监控 性能参数 berserkJS 屏幕补货，网络监控 上报 img 的src 浏览器 最重要的一端 缓存机制 性能优化重要策略 memory cache，disk cache 网络请求，强缓存弱缓存 如何渲染的 收到html=》解析dom树 css =&gt; css 树 和dom结合 形成render tree 开始渲染 少操作dom，重绘回流 输入url发生了啥 部署 项目总要上线 Nginx Pm2 Docker + 自动化 特殊场景 不算通用能力，但是特殊业务需求 可视化 echarts (canvas)，d3(svg)，three.js(webgl) 小游戏 PS切图 软件工程师 算法 排序 搜索 遍历 贪婪 动态规划 编译原理 设计模式 网络协议 数据库 数据结构 数组、字符串、队列、堆、链表 二叉树 图 软件工程 数学基础 编码 网络协议 IP TCP/UDP HTTP / HTTPS / SSH / FTP 设计模式 常见设计模式，单例，装饰器，代理，观察者，发布订阅 前端常用的设计模式 如何使用、不要滥用 数据库 Mysql 关系型数据库，多表join Mongodb json数据库 Redis 内存数据库 速度快 面试题 跨域方案 强缓存弱缓存 输入url发生啥 DNS解析 ， 三次握手，建立链接 接受相应，查库查文件，等待数据返回，拼接响应报文 浏览器接受报文，解析html 渲染页面 渲染原理 业余干啥 可访问性 箭头函数优点 前后端分离JWT 垃圾回收 基础vuejs 组件通讯 prop 父组件通过 Prop 往子组件传递数据 Prop 让组件更加灵活 不要直接修改 Prop event 子组件往当前实例上派发事件 子组件在父组件中使用，可以监听到该事件，并做出响应 golbal event bus 非父子组件通讯 可以基于新的 Vue 实例实现 Vuex 非父子组件通讯（数据共享） 数据状态管理 插槽 普通插槽 组件的实现更加灵活 内容分发 插槽访问的数据作用域是父组件 作用域插槽 插槽可以访问到子组件中的数据 过度动画 触发条件 Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡： 条件渲染 (使用 v-if) 动态组件 条件展示 (使用 v-show) 组件根节点 过渡类名 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 &lt;transition&gt;，则 v- 是这些类名的默认前缀。如果你使用了 &lt;transition name=&quot;my-transition&quot;&gt;，那么 v-enter 会替换为 my-transition-enter v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时v-enter 被移除)，在过渡/动画完成之后移除。 v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to：定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除 JavaScript 钩子 可以在属性中声明JavaScript 当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用done 进行回调。否则，它们将被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=&quot;false&quot;，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 DOM操作 操作CSS 某些交互可以通过手动操作CSS 做精细的控制 配合原生JS库使用 与原生 JS 库配合使用，再做一层 Vue 化的封装 cube-ui 对 better-scroll 的封装 element-ui 对 popper.js 的封装 组件封装 就近管理 单文件开发 依赖的静态资源放在同级目录 相关联组件也放在同级目录 分层设计 通过分层设计的思想设计复杂组件 高度复用 页面级别的复用（基础组件） 项目级别的复用 —私有组件库（业务组件） 公司级别的复用 —开源组件库（element-ui、cube-ui） 灵活扩展 组件设计要尽量灵活可扩展，除了提供丰富的 Props，还可以利用 slot插槽完成用户个性化定制需求） Keep-alive 使用场景 保留组件状态或避免重新渲染 可以配合路由组件使用 生命周期 activated：组件激活时触发 deactivate：组件失活时触发 内存泄漏 产生的原因 未清理的定时器 未清理的全局注册的自定义事件 未清理的全局注册的 DOM 事件 如何避免 编写组件要有相关意识 检查是否有上述造成内存泄漏的可能 利用 beforeDestroy 生命周期函数，做对应的内存清理工作 错误回调 常见的错误 深层对象数据访问问题 对计算属性赋值 对 Prop 直接修改 使用了未注册的组件 调试工具 Chrome 开发者工具，学会查找错误堆栈 vue-devtools https://github.com/vuejs/vue-devtools vConsole https://github.com/Tencent/vConsole 性能优化 数据定义 不需要把所有的数据都定义在 data 上，可以直接挂载到实例上 按需加载 对于首次渲染，我们只需要加载首屏渲染所需的资源，其他资源可以异步按需加载。这样可以减少首屏加载的资源包大小，加速渲染 异步组件 异步组件——比如我们使用一些图标库，如 echart，我们可以考虑做成异步组件，单独打包 异步路由 异步路由——比如单页应用，我们的导航切换是基于路由切换，那么其他页面可以考虑做成异步路由 预渲染 由于基于 Vue.js 的单页应用是由 Vue.js 渲染页面，所以页面下载后到渲染会有一定白屏时间 我们可以不依赖 JS，在页面下载后先渲染一张 Loading图片或者是骨架屏结构 当主页面渲染时，把这张占位图片或者结构隐藏 用户看到的不是白屏，有等待预期 后编译 编译代码冗余？ 依赖包本身不编译，它的编译交给应用来做。通过修改 webpack 配置 rules 中的 include 后编译依赖嵌套？ webpack-post-compile-plugin需要后编译的依赖包在 package.json 中声明&quot;postCompile&quot;: true 性能优化 一份编译代码 主题定制 一份 ployfill rem布局 NPM包无需编译发布 深入理解Vue.js Vue.js渲染原理 响应式实现原理 组件化实现原理 前端工程 脚手架 Vue-cli 3.0 是一个基于 Vue.js 进行快速开发的完整系统 通过 @vue/cli 搭建交互式的项目脚手架 通过 @vue/cli + @vue/cli-service-global 快速开始零配置原型开发 一个运行时依赖 (@vue/cli-service) 一个丰富的官方插件集合，集成了前端生态中最好的工具。 一套完全图形化的创建和管理 Vue.js 项目的用户界面 插件化机制 Vue CLI 使用了一套基于插件的架构。在项目创建的过程中，绝大部分列出的特性都是通过插件来实现的 插件可以帮助我们生成初始化代码， 安装指定的依赖包 webpack 配置 调整 webpack 配置最简单的方式就是在 vue.config.js中的 configureWebpack 选项提供一个对象 因为 @vue/cli-service 对 webpack 配置进行了抽象，所以理解配置中包含的东西会比较困难，可以通过下面命令查看 webpack 配置vue inspect &gt; output.js webpack 现代 JavaScript 应用程序的静态模块打包器 module 开发者将程序分解成离散功能块（discrete chunks offunctionality），并称之为模块 每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的 前端模块化面对的挑战 —处理JS之外的静态资源、资源的依赖关系加载顺序、资源的请求和加载是异步的 ES2015 import 语句 CommonJS require() 语句 AMD define 和 require 语句 css/sass/less 文件中的 @import 语句 样式(url(...))或 HTML 文件(&lt;img src=...&gt;)中的图片链接(image url) entry 入口起点(entry point)指示 webpack应该使用哪个模块，来作为构建其内部依赖图的开始，webpack会找出有哪些模块和 library是入口起点（直接和间接）依赖的 多入口：数组结构 多入口：对象结构 多页面应用程序 output 配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。即使可以存在多个入口起点，也只指定一个输出配置 如果配置创建了多个单独的 “chunk”，则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 线上运行时需要通过设置 public path 指向 CDN 地址 loader loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件 Typescript -&gt; JavaScript Image -&gt; data URL JavaScript import CSS loader 支持链式传递 loader 可以是同步的，也可以是异步的 loader 运行在 Node.js 中，并且能够执行任何可能的操作 loader 能够使用options 对象进行配置 babel-loader 加载ES2015+ 代码，然后使用 Babel 转译为 ES5 style-loader 将模块的导出作为样式添加到 DOM 中 css-loader 解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码 less-loader 加载和转译 LESS 文件 file-loader 将文件发送到输出文件夹，并返回（相对）URL url-loader 像 file loader 一样工作，但如果文件小于限制，可以返回 data URL vue-loader 加载和转译 Vue 组件 plugins 插件比 loader 更加强大，可以帮助用户直接触及到编译过程。 插件可以将处理函数注册到编译过程中的不同时间点上运行的生命周期钩子函数上。 打包优化 资源管理 注入环境变量 CommonsChunkPlugin 提取 chunks 之间共享的通用模块 DefinePlugin 允许在编译时(compile time)配置的全局常量 ExtractTextWebpackPlugin 从 bundle 中提取文本（CSS）到单独的文件 UglifyjsWebpackPlugin 使用 UglifyJS 压缩 JS HtmlWebpackPlugin 创建HTML文件来服务打包文件 开发&amp;部署 开发阶段 需求阶段 前后端共同参与产品需求评审，并做一轮技术评审 技术评审过程中，梳理所有交互通讯的接口 把接口落地成文档，并约定好所有字段 开发阶段 前后端独立开发 前端伪造 mock 数据 可以使用 mock webpack 插件 联调阶段 预留联调的时间 前后端开发完成后开始联调 前端把接口请求指向后端的联调地址（可自动完成） 上线阶段 前端把接口请求指向后端的线上地址（可自动完成） 一定要后端先上线 部署流程 预留联调的时间后端先上线 API 接口（若需要） 前端项目最终编译生成静态资源文件（HTML、JS、CSS 等） 增量发布，前端先全量上线 JS、CSS 等静态资源 前端接着上线模板 HTML，先发布到一台 pre 机器，QA 回归 回归通过后，逐步放量模板直至全量 知识点 HTPP相关 常见 HTTP 状态码 浏览器缓存原理 抓包工具（fiddler、charles） 跨域 CORS JSONP 性能优化 性能监测：https://github.com/GoogleChrome/lighthouse 数据埋点 雅虎军规：https://developer.yahoo.com/performance/rules.html、https://juejin.im/post/5b73ef38f265da281e048e51 Web安全 XSS CSRF HTTPS https://zhuanlan.zhihu.com/p/561228 数据结构&amp;算法 栈/队列/树/ 图 排序/递归 算法设计技巧 浏览器渲染原理 https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/ 正则表达式 匹配原理 基本语法 实用技巧 设计模式 订阅发布模式 工厂模式 适配器模式 后端语言 PHP JAVA Node.js]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[参考： 类型检测 分类基本数据类型Number、String、Boolean、Undefined、NullNumber Number类型包含整数和浮点数（浮点数数值必须包含一个小数点，且小数点后面至少有一位数字）两种值。NaN:非数字类型。特点：① 涉及到的 任何关于NaN的操作，都会返回NaN ② NaN不等于自身。isNaN() 函数用于检查其参数是否是非数字值。isNaN(123) //false isNaN(&quot;hello&quot;) //trueString 字符串有length属性。字符串转换：转型函数String(),适用于任何数据类型（null,undefined 转换后为null和undefined）；toString()方法（null,defined没有toString()方法）。Boolean 该类型只有两个值，true和falseUndefined 只有一个值，即undefined值。使用var声明了变量，但未给变量初始化值，那么这个变量的值就是undefined。Null null类型被看做空对象指针，前文说到null类型也是空的对象引用。 复杂数据类型ObjectObject本质上是由一组无序的名值对组成的.js中对象是一组属性与方法的集合。这里就要说到引用类型了，引用类型是一种数据结构，用于将数据和功能组织在一起。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。 引用类型Object、Array、Function、Date、RegExp等 基本类型与引用类型基本类型又叫原始类型（primitive type）栈：原始数据类型（Undefined，Null，Boolean，Number、String）堆：引用数据类型（Object、Array、Function）两种类型的区别是：存储位置不同：原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 变量 ECMAScript中用var关键字来定义变量，因为js是弱类型的，所以无法确定变量一定会存储什么值，也就不知道变量到底会是什么类型，而且变量的类型可以随时改变。这就是ECMAScript是松散类型的来由，所谓松散类型就是可以用来保存任何类型的数据。ps:es6中新增了let命令来声明变量、const命令声明一个只读的常量。let的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。const一旦声明，常量的值就不能改变。 类型检测typeof、Object.prototype.toString() typeof12345678typeof 2 输出 numbertypeof null 输出 objecttypeof &#123;&#125; 输出 objecttypeof [] 输出 objecttypeof (function()&#123;&#125;) 输出 functiontypeof undefined 输出 undefinedtypeof '222' 输出 stringtypeof true 输出 boolean Object.prototype.toString() toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]]。这是一个内部属性，其格式为 [object xxx] ，其中 xxx 就是对象的类型。12345678910var gettype=Object.prototype.toString;gettype.call('aaaa') 输出 [object String]gettype.call(2222) 输出 [object Number]gettype.call(true) 输出 [object Boolean]gettype.call(undefined) 输出 [object Undefined]gettype.call(null) 输出 [object Null]gettype.call(&#123;&#125;) 输出 [object Object]gettype.call([]) 输出 [object Array]gettype.call(function()&#123;&#125;) 输出 [object Function] 封装可以分辨所有数据类型的方法12345678910111213141516171819202122232425var typeName = &#123; '[object Function]': 'function', '[object Boolean]': 'boolean - object', '[object Number]': 'number - object', '[object String]': 'string - object', '[object Object]': 'object', '[object RegExp]': 'regExp', '[object Array]': 'array', '[object Error]': 'error', '[object Date]' : 'date' &#125;;//获取Object的toString方法，通过call调用var toStringFn = Object.prototype.toString;function checkType(obj)&#123; if( obj == null )&#123; //js自带的的String方法，用于检测null和undefined return String( obj ); &#125; //safari5及之前版本，Chrome7, typeof RegExp返回的是function return typeof obj === 'object' || typeof obj === 'function' ? typeName[toStringFn.call(obj)]:typeof obj;&#125;// 调用函数checkType("123")]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[媒体查询]]></title>
    <url>%2F2019%2F03%2F26%2FCSS3%2F%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[css的媒体查询允许通过@media标签为特定媒体的浏览器设定样式，其中包含众多筛选，功能强大。 定义 HTML4和CSS2支持为不同的媒体类型指定专用的样式表，screen和print, projection是已定义的媒体类型媒体查询由 媒体类型 和 一个或多个检测媒体特性的的条件表达式组成。相对于CSS2只支持对媒体类型进行判断，媒体查询增加了媒体特性的判断，能够更准确地根据设备特性指定专用的样式。 语法逻辑123456789# 和and# 也就是 or 的逻辑,# 对查询结果取反not# only操作符仅在媒体查询匹配成功的情况下被用于应用一个样式，# 这对于防止让选中的样式在老式浏览器中被应用到。only 使用语法 媒体查询包含一个可选的媒体类型和媒体特性表达式(0或多个)最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示文档所使用的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。1234567891011# link元素中的CSS媒体查询&lt;link rel="stylesheet" media="(max-width: 800px)" href="example.css" /&gt;# 样式表中的CSS媒体查询&lt;style&gt;@media (max-width: 600px) &#123; .facet_sidebar &#123; display: none; &#125;&#125;&lt;/style&gt; 使用媒体类型12&lt;link rel="stylesheet" type="text/css" href="site.css" media="screen" /&gt;&lt;link rel="stylesheet" type="text/css" href="print.css" media="print" /&gt; media 属性定义了应该用于指定每种媒体类型的样式表： screen 适用于计算机彩色屏幕。 print 适用于打印预览模式下查看的内容或者打印机打印的内容。 作为 CSS v3 规范的一部分，可以扩展媒体类型函数，并允许在样式表中使用更精确的显示规则。媒体查询 是评估 True 或 False 的一种表达。如果为 True，则继续使用样式表。如果为 False，则不能使用样式表。这种简单逻辑通过表达式变得更加强大，使您能够更灵活地对特定的设计场景使用自定义的显示规则。 媒体查询规则@media all and (min-width: 800px) { ... }@media all 是媒体类型，也就是说，将此 CSS 应用于所有媒体类型(min-width:800px) 是包含媒体查询的表达式，如果浏览器的最小宽度为 800 像素，则会告诉浏览器只运用下列 CSS。请注意:可以省略关键词 all 和 and。在将某个媒体查询应用于所有媒体类型时，会省略all。后面的 and 也是可选的。使用简写语法重新编写媒体查询 简写语法@media (min-width:800px) { ... } 复杂表达式创建一个仅在最小宽度为 800 像素且最大宽度为 1200 像素时应用的样式@media (min-width:800px) and (max-width:1200px) { ... } and 条件在您的表达式中，您可以根据自己的喜好使用任意数量的 and 条件。如果您想要增加其他条件来检查特定的屏幕方向，只需添加另一个 and 关键词，后跟 orientation 媒体查询.@media (min-width:800px) and (max-width:1200px) and (orientation:portrait) { ... }仅在宽度为 800 到 1200 像素且方向是纵向时才能激活. or 关键词and 关键词的反义词是 or 关键词。和 and 一样，这些条件组合在一起会构成复杂表达式。如果其中有一个条件为 True，那么整个表达式或分离的两个条件都会为 True，如清单 6 所示。@media (min-width:800px) or (orientation:portrait) { ... }如果宽度至少是 800 像素或方向是纵向的，则会应用该规则。 使用 not@media not all and (min-width: 800px) { ... }@media not (all and (min-width: 800px)) { ... }当最小宽度不是 800 像素时，会应用下列 CSS 规则。这些示例只是将像素作为媒体查询中的测量单位，但是测量单位并不仅限于像素。您可以使用任何有效的 CSS 测量单位，比如厘米 (cm)、英寸 (in)、毫米 (mm) 等。 only@media only (min-width: 300px) { ... } 有用的媒体特性orientation 媒体查询方向： orientation值为：横排方向（ landscape）竖排方向（portrait）@media (orientation: portrait) { ... }高度和宽度行为十分相似，都支持以 min- 和 max- 为前缀 高度和宽度媒体查询@media (min-width:800px) and (min-height:400px) { ... } 不带 min- 和 max- 前缀@media (width:800px) and (height:400px) { ... } 媒体属性特征12前缀`min-`表示“至少”，即“大于等于”的意思。前缀`max-`表示“至多”，即“小于等于”的意思。 12345678910111213width: 视口宽度height: 视口高度device-width: 渲染表面的高度(设备高度)device-height: 渲染表面的宽度(设备宽度)orientation: 检测设备是处于横向(landscape)还是纵向(portrait)aspect-ratio: 基于视口宽度和高度的宽高比device-aspect-ratio: 基于设备渲染表面的宽度和高度的宽高比color: 每种颜色的位数color-index: 设备的颜色索引表中的颜色数monochrome: 检测单色帧缓冲区中每像素所使用的位数resoluion: 用来检测屏幕和打印机的分辨率,dpi/dpcmscan: 电视机的扫描方式,逐行扫描(progressive)或隔行扫描(interlace)grid: 用来检测输出设备是网格设备还是位图设备 参考： 使用 CSS 媒体查询创建响应式网站 CSS媒体查询]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mate标签]]></title>
    <url>%2F2019%2F03%2F26%2FH5%2Fmate%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[转载: 2018前端面试总结，看完弄懂，工资少说加3K | 掘金技术征文参考: 移动前端开发之viewport的深入理解&lt;mate&gt;标签: 提供页面的元信息但和内容无关，元数据可以被浏览器、搜索引擎和其他web服务器使用。 mate两种属性：http-equiv和name http-equiv 相当于HTTP头 content-type 定义文档的字符集 &lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; expires网页到期时间 &lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri, 12 Jan 2001 18:18:18 GMT&quot;&gt; X-UA-Compatible 浏览器采取何种版本渲染当前页面 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; 指定IE和Chrome使用最新版本渲染当前页面 cache-control 指定请求和响应遵循的缓存机制 refresh 自动刷新，病指向某个页面 &lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2; URL=http://www.root.net&quot;&gt; set-cookie 设置cookie &lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx; expires=Friday, 12-Jan-2001 18:18:18 GMT; path=/&quot;&gt; cleartype只对IE有用，用于平滑字体,不推荐使用 &lt;!--[if IEMobile]&gt;&lt;meta http-equiv=&quot;cleartype&quot; content=&quot;on&quot;&gt;&lt;![endif]--&gt;`name 描述网页 author 作者 &lt;meta name=&quot;author&quot; content=&quot;xx@xx&quot;&gt; description 描述，网站主要内容 &lt;meta name=&quot;description&quot; content=&quot;This page is about&quot;&gt; keywords 关键字，搜索引擎会使用这些关键字分类 &lt;meta name =&quot;keywords&quot; content=&quot;science, education&quot;&gt; renderer 双核浏览器渲染方式，指定以哪种渲染方式 &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; viewport视口，定义设备的大小 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; HandheldFriendly针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;True&quot;&gt; MobileOptimized 微软为IE Mobile版设置的定义宽度标记 &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt; apple-mobile-web-app-capable 是否启动webapp功能（全屏），会删除默认的苹果工具栏和菜单栏。 apple-mobile-web-app-capable &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; apple-mobile-web-app-status-bar-style 当启动webapp功能时，手机顶部导航栏的颜色 &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt; apple-mobile-web-app-title 添加到主屏后的标题 &lt;meta name=&quot;apple-mobile-we-app-title&quot; content=&quot;&quot;&gt; format-detection 格式检测，识别页面中的电话号码 &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; format-detection 格式检测，识别页面中的email &lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;&gt; viewPort|属性|作用||—-|—–||width| 设置layout viewport 的宽度，为一个正整数，或字符串”width-device”||initial-scale| 设置页面的初始缩放值，为一个数字，可以带小数||minimum-scale| 允许用户的最小缩放值，为一个数字，可以带小数||maximum-scale| 允许用户的最大缩放值，为一个数字，可以带小数||height | 设置layout viewport 的高度，这个属性对我们并不重要，很少使用||user-scalable | 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许| 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# H5标准声明，使用 HTML5 doctype，不区分大小写&lt;!DOCTYPE html&gt;# 标准的 lang 属性写法&lt;head lang=”en”&gt;# 声明文档使用的字符编码&lt;meta charset=’utf-8′&gt;# 优先使用 IE 最新版本和 Chrome&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; # 页面描述&lt;meta name=”description” content=”不超过150个字符”/&gt;# 页面关键词&lt;meta name=”keywords” content=””/&gt;# 网页作者&lt;meta name=”author” content=”name, email@gmail.com”/&gt;# 搜索引擎抓取&lt;meta name=”robots” content=”index,follow”/&gt;# 为移动设备添加 viewport&lt;meta name=”viewport” content=”initial-scale=1,maximum-scale=3, minimum-scale=1, user-scalable=no”&gt;# iOS 设备 begin&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt;# 添加到主屏后的标题（iOS 6 新增）&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt;# 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, 1affiliate-data=myAffiliateData, app-argument=myURL”&gt;# 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;# 设置苹果工具栏颜色&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt; # 启用360浏览器的极速模式(webkit)&lt;meta name=”renderer” content=”webkit”&gt; # 避免IE使用兼容模式&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt;# 不让百度转码&lt;meta name=”HandheldFriendly” content=”true”&gt;# 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt;# 微软的老式浏览器&lt;meta name=”MobileOptimized” content=”320″&gt;# uc强制竖屏&lt;meta name=”screen-orientation” content=”portrait”&gt;# QQ强制竖屏&lt;meta name=”x5-orientation” content=”portrait”&gt;# UC强制全屏&lt;meta name=”full-screen” content=”yes”&gt;# QQ强制全屏&lt;meta name=”x5-fullscreen” content=”true”&gt;# UC应用模式&lt;meta name=”browsermode” content=”application”&gt;# QQ应用模式&lt;meta name=”x5-page-mode” content=”app”&gt;# windows phone 点击无高光&lt;meta name=”msapplication-tap-highlight” content=”no”&gt;设置页面不缓存&lt;meta http-equiv=”pragma” content=”no-cache”&gt;&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;&lt;meta http-equiv=”expires” content=”0″&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F25%2FHTTP%2FTCP%E3%80%81UDP%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E3%80%81DNS%2F</url>
    <content type="text"><![CDATA[转载： 一篇文章搞定前端面试 TCPUDP套接字socketHTTP协议DNS解HTTP请求发起和响应页面渲染的过程页面的性能优化]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F25%2FJavaScript%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一行代码实现数组去重？[...new Set([1,2,3,1,&#39;a&#39;,1,&#39;a&#39;])]怎么判断两个对象相等？12345678910111213141516obj=&#123; a:1, b:2&#125;obj2=&#123; a:1, b:2&#125;obj3=&#123; a:1, b:&apos;2&apos;&#125;JSON.stringify(obj)==JSON.stringify(obj2);//trueJSON.stringify(obj)==JSON.stringify(obj3);//false CommonJS 中的 require/exports 和 ES6 中的 import/export 区别？ CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。import/export 最终都是编译为 require/exports 来执行的。CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 浏览器缓存浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下： 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；区别是，强缓存不对发送请求到服务器，但协商缓存会。当协商缓存也没命中时，服务器就会将资源发送回客户端。当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存； 强缓存 Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒） 协商缓存 Last-Modified（值为资源最后更新时间，随服务器response返回）If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）ETag（表示资源内容的唯一标识，随服务器response返回）If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存） 页面渲染的完整流程是怎样的？ 图片里的 alt 属性是做什么的？查看答案如果用户看不到图像，alt 属性可以提供替代信息。alt 属性应该用于描述，而那些仅仅是装饰目的图像，可以为空 小贴士装饰性的图像应该有一个空的 alt 属性web 爬虫可以通过 alt 属性理解图像的信息，因此认为它对于搜索引擎优化（SEO）非常重要在 alt 末尾加 . 可以提高访问性 不采用缓存的目的是什么，你如何实现它？查看答案浏览器有一个临时的存储网站文件的缓存，所以他们不需要在切换或重新加载同一个页面时再次重新下载。服务器设置发送头信息告诉浏览器在给定的一段时间内使用存储文件。这极大加快了网站的速度和节省了带宽 然而，当开发人员网站更新时，因为用户的缓存依然指向旧的文件，这会造成问题。如果缓存的 CSS 和 JavaScript 文件引用的元素不再存在，已移除或已重命名时，它会保留原有功能或破坏网站 禁用缓存是一个强制浏览器下载新文件的过程。通过命名来区分于旧文件 一个常用的强制浏览器重新下载文件的技术是在文件的结尾处增加一个查询字符串 src=”js/script.js” =&gt; src=”js/script.js?v=2”浏览器认为这是一个不同的文件但是避免了修改文件名的必要 一个页面里是否可以包含多个 元素， 元素呢？查看答案都可以。W3C 文档声明这些标签代表离它们最近祖先区域的页眉（）和页脚（）。因此，不只是可以在页面的 里包含页眉和页脚，而且每一个 和 元素都可以包含 小贴士W3C 推荐你想用多少就用多少，但是每一个页面的区域只能有一个，即，body，section 等等 &lt;script&gt; 标签的 defer 和 async 是什么？查看答案如果两个属性都没有的话，脚本将同步下载和执行，并且会阻塞 document 解析，直到脚本执行完成（默认行为）。脚本下载和执行按它们书写的顺序进行 defer 属性在 document 解析的过程中下载脚本，但是在 document 解析完成之前执行，等价于执行了一个内置的事件监听器 DOMContentLoaded。defer 脚本顺序执行 async 属性在 document 解析过程中下载脚本，但是会暂停解析器，直到脚本解析执行完成。async 不一定按顺序执行 注意：两个属性必须在脚本拥有 src 属性时才起作用（即，在内联脚本不起作用） 小贴士请用 中放置一个 defer，允许浏览器在页面还在解析过程中下载脚本，因此把脚本放到 body 之前是更好的选择如果脚本之间相互依赖，请用 defer.如果脚本是独立的，请用 async.如果 DOM 必须加载完并且内容还未放置到 DOMContentLoaded 监听器中时，请用 defer 相比 HTML，XHTML 有哪些不同？查看答案有一些关键区别： 一个 XHTML 元素必须要有一个 XHTML 属性值必须用引号包裹禁止属性简写（例如，checked=”checked” 不能简写为 checked）元素必须正确的被嵌套元素必须闭合特殊字符必须被转义小贴士任何被标签都是自闭合标签和属性区分大小写，通常小写 你能说出 @media 属性的四种类型吗？查看答案all，适用于所有媒体设备print，仅适用于打印机screen，仅适用于屏幕设备（台式电脑、平板电脑、移动设备等）speech，仅适用于屏幕阅读器 如何统计网页里出现多少种html标签12345678910111213141516171819# 获取所有标签var doms = document.getElementsByTagName("*")#去重var obj = &#123;&#125;var ret = []for (var j = 0; j &lt; doms.length; i++) &#123; var name = doms[j].nodeName if(!obj[name]) &#123; ret.push(name) obj[name] = true &#125;&#125;console.log(ret.length);# ES6方法const names = [...document.getElementsByTagName("*")].map(v=&gt;v.nodeName)console.log(new Set(names).size); 手写bind call1234567891011121314151617181920Function.prototype.call = function(context) &#123; context = context || window context.fn = this const args = [...arguments].slice(1) const result = context.fn(...args) delete context.fn return result&#125;Function.prototype.bind = function(context) &#123; const _this = this const args = [...arguments].slice(1) // 返回一个高阶函数 return function F() &#123; if(this instanceof F) &#123; return new _this(...args, ...arguments) &#125; return _this.apply(context, args.concat(...arguments)) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[定位]]></title>
    <url>%2F2019%2F03%2F22%2FCSS3%2F%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[positionstatic表示没有定位，元素出现在正常的文档流中。为静态定位的元素设置 top|bottom|left|right 不起作用。fixed元素的位置相对于浏览器窗口是固定位置。即使浏览器的窗口是滚动的它也不会移动。fixed定位使得元素脱离了文档流，因而不占据空间。设置了固定定位的元素宽高由其内部元素撑起。relative相对定位的元素是相对其正常位置。1.使用了相对定位元素的元素，其参照物是其本身，其偏移量由TRBL(top，right,bottom,left)的值确定。2.使用了相对定位的元素，仍然会在标准流中占据原来的位置，它对父元素和兄弟元素没有影响。3.相对定位的使用场景往往是作为绝对定位元素的参照物。absolute绝对定位的元素的位置是相对其最近的已定位父元素（也就是除static之外），如果找不到已定位的父元素，那么就相对于&lt;html&gt;元素。absolute定位使得元素脱离了文档流，因而不占据空间。设置了绝对定位的元素宽高由其内部元素撑起。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F22%2FVue%2FVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[vue 生命周期 详解]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络安全(SQL、XSS、CSRF)]]></title>
    <url>%2F2019%2F03%2F21%2FJavaScript%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[转载： 3大Web安全漏洞防御详解：XSS、CSRF、以及SQL注入解决方案参考： 前端安全（XSS、CSRF防御） 用大白话谈谈XSS与CSRF常见的Web安全分为两种前端安全(XSS攻击、CSRF攻击)和后端安全(SQL注入) XSS攻击定义 XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码。 XSS攻击的危害 1. 盗取用户资料，比如：登录帐号、网银帐号等 2. 利用用户身份，读取、篡改、添加、删除数据等 3. 盗窃重要的具有商业价值的资料 4. 非法转账 5. 强制发送电子邮件 6. 网站挂马 7. 控制受害者机器向其它网站发起攻击 防止XSS的解决方法XSS的根源主要是没完全过滤客户端提交的数据 ，所以重点是要过滤用户提交的信息。 1. 将重要的cookie标记为http only, 这样的话js 中的document.cookie语句就不能获取到cookie了. 2. 只允许用户输入我们期望的数据。 例如：age用户年龄只允许用户输入数字，而数字之外的字符都过滤掉。 3. 对数据进行Html Encode处理：用户将数据提交上来的时候进行HTML编码，将相应的符号转换为实体名称再进行下一步的处理。 4. 过滤或移除特殊的Html标签。 5. 过滤js事件的标签。例如 &quot;onclick=&quot;, &quot;onfocus&quot;等等。 CSRF攻击定义 CSRF:跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 XSS主要是利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求，来利用受信任的网站。与XSS攻击相比，CSRF更具危险性。 CSRF攻击危害 主要的危害来自于，攻击者盗用用户身份，发送恶意请求。比如：模拟用户发送邮件，发消息，以及支付、转账等。 防止CSRF的解决方法 1. 重要数据交互采用POST进行接收，当然是用POST也不是万能的，伪造一个form表单即可破解。 2. 使用验证码，只要是涉及到数据交互就先进行验证码验证，这个方法可以完全解决CSRF。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。 3. 验证HTTP Referer字段，该字段记录了此次HTTP请求的来源地址，最常见的应用是图片防盗链。 4. 为每个表单添加令牌token并验证。 SQL注入定义 SQL注入是比较常见的网络攻击方式之一，主要是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，实现无帐号登录，甚至篡改数据库。 SQL注入的危害 1. 数据库信息泄漏：数据库中存放的用户的隐私信息的泄露 2. 网页篡改：通过操作数据库对特定网页进行篡改 3. 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改 4. 服务器被远程控制，被安装后门 5. 删除和修改数据库表信息 SQL注入的方式通常情况下，SQL注入的位置包括： 1. 表单提交，主要是POST请求，也包括GET请求; 2. URL参数提交，主要为GET请求参数; 3. Cookie参数提交; 4. HTTP请求头部的一些可修改的值，比如Referer、User_Agent等; 防止SQL注入的解决方法 1. 对用户的输入进行校验，使用正则表达式过滤传入的参数 2. 使用参数化语句，不要拼接sql，也可以使用安全的存储过程 3. 不要使用管理员权限的数据库连接，为每个应用使用权限有限的数据库连接 4. 检查数据存储类型 5. 重要的信息一定要加密]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F21%2FJavaScript%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[. vue的生命周期?Mvvm响应式原理？常见设计模式及其应用场景？原型链？闭包？应用场景？Es6的新特性？Css position相关？Html语义化？冒泡排序？ Html大纲？ 浏览器兼容性？腾讯二面（视频，24min左右）：vue的生命周期？ Js数据类型，堆和栈的区别？ Vue的diff算法？怎么样才算samenode（源码相关）？比较子节点的时候顺序比较行不行？ 用defineProperty进行数据劫持的缺点？怎么办（考察vue3.0数据劫持的方式proxy）？ 手写二分查找 Css盒子模型？ Express中间件？ Symbol？作用？三面约的19：10，结果前面面试的同学太多了，到19：45才面上腾讯三面（电话，20min左右）： 从输入url到显示页面的过程？ 这个过程中有哪些会影响性能？ 闭包原理？适用场景？ 5、闭包的优点（1）逻辑连续，当闭包作为另一个函数调用参数时，避免脱离当前逻辑而单独编写额外逻辑。 （2）方便调用上下文的局部变量。 （3）加强封装性，是第2点的延伸，可以达到对变量的保护作用。 6、使用闭包的注意点（缺点）（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 （2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 7、闭包的特性（1）作为函数变量的一个引用。当函数返回时，其处于激活状态。 （2）闭包就是当一个函数返回时，并没有释放资源的栈区。 Es6有哪些了解？ 1.自我介绍2.做过什么项目？3.了解es6吗4.promise原理5.了解什么算法？6.堆排序过程，时间复杂度（nlogn,他还让我再想一下？？），应用场景（没答出来，哭）。7.用过的技术栈8.怎么学习前端9.问题：公司主要用react，vue哪个，为什么用它呢？ 什么时候开始学习的前端？==和===的区别JS 继承（ES6 extends、ES5 各种继承）怎么判断参数是数组还是对象？（Array.isArray、toString、instanceOf）问项目，技术方案，话题转 VueVue 生命周期有哪些？（Create、Mount、Active、Update、Deactive、Destory）DOM 结点在什么时候挂载？Vue 能不能挂载到body或html标签上，为什么？项目开发联调方式？自我介绍 写一个两边定宽，中间自适应的布局（dispaly: flex、双飞翼/圣杯、position: absolute）垂直居中方案（line-height、transform）JS 怎么对象的属性是数组还是对象（参考一面第 8 问），解释下每个方法怎么判断（数组 Object.prototype.toString.call之后是[object, Array]，对象toString之后是[object, object]，instanceOf就是返回true还是false）JS 继承（ES6 extends、原型链、构造），解释下原型链和构造哪个好，好在哪里，原型链继承的时候，可不可以直接A.prototype = B()，而不是A.prototype = new B()，为什么构造继承为什么用call，而不是apply？（参数不同，一个数组，一个不定参数），追问哪个参数是数组？（apply）实现一个数组去重（Array.from(new Set(arr))），不用 ES6 实现一个对所有数组有可以调用的去重（forindexOf，添加到Array.prototype），面试官说i 跨域的方式websocket和Http的区别长轮询cookie和session，没有cookie的话session能不能使用浏览器缓存机制，304是协商缓存还是强缓存类数组变成数组let和var的区别CSRF以及Token验证的Token放在哪里TCP三次握手，如果没有三次握手会怎样Vue用watch实现数据双向绑定重绘和重排，什么操作会造成重排LESS怎么遍历一个列表await语法JS继承有哪几种，具体的实现及原理常见的HTTP状态码各个是什么意思介绍浏览器缓存？各个响应头优先级？以及之间的区别，可以取的值，分别是什么意思介绍浏览器时间介绍一下跨域，各个跨域的具体实现方法？以及JSONP实现方式中服务器是怎样交互的介绍一下网络安全（xss以及csrf具体防范方法） 行内元素和块级元素二者区别css选择器有哪些，怎么样计算JS面向对象的理解盒子模型，box-sizing常用的设计模式，封装一个函数判断数据类型，数组还是对象状态码404 400 502 304http底层协议http协议用在tcp还是udp三次握手，四次握手，两次握手，time wait 2ml 的原因浏览器缓存，硬盘（持久化）数据结构，快速排序，稳定的还是不稳定的。最差的时间复杂度内存存不下，很多个数据，找出最大的10个或者100个哈希操作系统 nio, i/o操作计算机组成原理，数据用什么码储存的，正负数的储存，负数的源码补码基址寻址和变址寻址get，post请求最本质的区别多路复用事件代理。常规做法的优势体现在哪里session。分布式集群，如何保障session可以保持相同浏览器cookie禁掉session是哪一端session特别多怎么办 OSI七层模型及作用http。tcp三次握手四次挥手、http和httpstcp、cdppost和get进程和线层的区别输入一个url发生了什么内存分配闭包、作用域链vue生命周期css3动画，怎么做单行文本溢出，多行文本溢出代码实现bfc布局js类型，封装一个类型鉴定函数闭包，哪里用到立即执行函数解决闭包中访问变量的问题时间轮询机制原生js实现bind函数一个函数，然后让你说他们的值是多少，为什么预编译、严格模式、作用域链算法 快排 选择排序浏览器渲染原理 实现一个构造函数new的时候每次加一计算机网络tcp与udp区别，tcp拥塞机制，tcp三次握手四次挥手css性能优化 js作用域链怎么来的thisurl到浏览器解析过程dns解析tcp连接http和https。ssl层在哪里加入浏览器解析过程cdn有存在的必要吗]]></content>
  </entry>
  <entry>
    <title><![CDATA[主流浏览器内核]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[浏览器内核 浏览器内核可以分为两部分：渲染引擎(layout engineer 或者 Rendering Engine)和JS引擎 浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 渲染引擎 渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等）、以及计算网页的显示方式，然后会输出至显示器或打印机。 JS引擎 JS 引擎则是解析Javascript语言，执行javascript语言来实现网页的动态效果。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS引擎越来越独立，内核就倾向于只指渲染引擎。 主流浏览器内核Trident内核：IEGecko内核：NETSCAPE6及以上版本，火狐(Mozilla FireFox)Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink;]Webkit内核：Safari，Chrome等。Chrome的：Blink（WebKit的分支） 移动端移动端的浏览器内核主要说的是系统内置浏览器的内核。目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 。1、iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit。2、Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink。3、Windows Phone 8 系统浏览器内核是 Trident。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3新特性]]></title>
    <url>%2F2019%2F03%2F18%2FCSS3%2FCSS3%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[实现圆角border-radius，阴影box-shadow，边框图片border-image对文字加特效text-shadow，强制文本换行word-wrap，线性渐变linear-gradient实现旋转transform:rotate(90deg),缩放scale(0.85,0.90),定位translate(0px,-30px),倾斜skew(-9deg,0deg);增加了更多的CSS选择器、多背景、rgba()唯一引入的伪元素是::selection；实现媒体查询@media，多栏布局flex过渡transition动画animationtext-overflow(文本溢出隐藏)CSS3中，text-shadow可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。CSS3新增了几个关于背景的属性，分别是background-clip、background-origin、background-size和background-break。text-decoration:CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置： text-fill-color: 设置文字内部填充颜色 text-stroke-color: 设置文字边界填充颜色 text-stroke-width: 设置文字边界宽度]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Url、Href、Src、Link详解]]></title>
    <url>%2F2019%2F03%2F18%2FCSS3%2FUrl%E3%80%81Href%E3%80%81Src%E3%80%81Link%2F</url>
    <content type="text"><![CDATA[转载： url、href、src 详解 Url定义 URL(Uniform Resource Locator)统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 Url格式标准格式 协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名?查询完整格式 协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名?查询 Url语法规则 比如网址http://segmentfault.com/html/index.asp必须遵守以下的语法规则:scheme://host.domain:port/path/filename说明 scheme - 定义因特网服务的类型。最常见的类型是 http host - 定义域主机（http 的默认主机是 www） domain - 定义因特网域名，比如 w3school.com.cn :port - 定义主机上的端口号（http 的默认端口号是 80） path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称 URL Schemes Scheme 访问 用于 http 超文本传输协议 以 http:// 开头的普通网页。不加密。 https 安全超文本传输协议 安全网页。加密所有信息交换。 ftp 文件传输协议 用于将文件下载或上传至网站。 file 您计算机上的文件。 URL的类型绝对URL 绝对URL（absolute URL）显示文件的完整路径，这意味着绝对URL本身所在的位置与被引用的实际文件的位置无关。相对URL 相对URL（relative URL）以包含URL本身的文件夹的位置为参考点，描述目标文件夹的位置。 一般来说，对于同一服务器上的文件，应该总是使用相对URL，它们更容易输入，而且在将页面从本地系统转移到服务器上时更方便，只要每个文件的相对位置保持不变，链接就仍然是有效地。.：代表目前所在的目录，相对路径。例： &lt;a href=&quot;./abc&quot;&gt;文本&lt;/a&gt; 或 &lt;img src=&quot;./abc&quot; /&gt;..：代表上一层目录，相对路径。例： &lt;a href=&quot;../abc&quot;&gt;文本&lt;/a&gt;或 &lt;img src=&quot;../abc&quot; /&gt;../../：代表的是上一层目录的上一层目录，相对路径。例： &lt;img src=&quot;../../abc&quot; /&gt;/：代表根目录，绝对路径。例： &lt;a href=&quot;/abc&quot;&gt;文本&lt;/a&gt; 或 &lt;img src=&quot;/abc&quot; /&gt; Href定义 href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。 通俗理解 href: 目的不是为了引用资源，而是为了建立这个标签与外部资源之间的关系，让当前标签能够链接到目标地址。&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;浏览器加载到这里的时候，html的渲染和解析不会暂停，css文件的加载是同时进行的 Src src用于替代这个元素: &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个js文件 Href和Src的区别请求资源类型不同 href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。 在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；作用结果不同 href 用于在当前文档和引用资源之间确立联系； src 用于替换当前内容；浏览器解析方式不同 若在文档中添加 &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;/&gt;，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用@import 方式。 当浏览器解析到 &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。 Link和@import的区别两者都是外部引用 CSS 的方式，但是存在一定的区别：（1）link是XHTML标签，除了能够加载CSS，还可以定义RSS等其他事务；而@import属于CSS范畴，只可以加载CSS。（2）link引用CSS时，在页面载入时同时加载；@import需要页面完全载入以后再加载。（3）link是XHTML标签，无兼容问题；@import则是在CSS2.1提出的，低版本的浏览器不支持。（4）link支持使用Javascript控制DOM改变样式；而@import不支持。 为什么尽量不要使用@import加载css使用@import会导致和预期不一致的下载顺 序。我们确实要避免使用css @import，但原因却不是什么相当于放在了页面底部，而是这样做会导致css无法并行下载，因为使用@import引用的文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。 浏览器在页面所有css下载并解析完成后才会开始渲染页面（Before a browser can begin to render a web page, it mustdownload and parse any stylesheets that are required to lay out thepage. Even if a stylesheet is in an external file that is cached,rendering is blocked until the browser loads the stylesheet from disk.），因此css @import引起的css解析延迟会加长页面留白期。 所以，要尽量避免使用css @import而尽量采用link标签的方式引入。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源策略和跨域]]></title>
    <url>%2F2019%2F03%2F17%2FAjax%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[转载: ajax跨域，这应该是最全的解决方案了参考: 浏览器同源政策及其规避方法 跨域资源共享 CORS 详解 同源策略概念同源即指：协议相同、域名相同、端口号相同。举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。1234http://www.example.com/dir2/other.html：同源http://example.com/dir/other.html：不同源（域名不同）http://v2.www.example.com/dir/other.html：不同源（域名不同）http://www.example.com:81/dir/other.html：不同源（端口不同） 目的 同源政策的目的，是为了为了保证使用者信息的安全，防止恶意网站篡改用户数据。 设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的Cookie，会发生什么？ 很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。 由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 限制范围 随着互联网的发展，”同源政策”越来越严格。目前，非同源的网站之间，共有四种行为受到限制。1234（1） Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。（4）无法通过 flash 发送 http 请求 跨域 同源策略做了很严格的限制，但是在实际的场景中，又确实有很多地方需要突破同源策略的限制，也就是我们常说的跨域。 Cookie 同源策略最早被提出的时候，为的就是防止不同域名的网页之间共享 cookie。Cookie是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享Cookie。举个例子，https://market.douban.com和https://book.douban.com，这两个网页的一级域名都是 douban.com，如果我在 market.douban.com中执行了12345678#A、B页面设置相同的document.domaindocument.domain = 'douban.com'# A页面通过脚本设置一个Cookiedocument.cookie = 'cross=yes'或document.cookie = 'cross=yes;path=/;domain=douban.com'# B页面就可以读取到Cookievar allCookie = document.cookie 这样设置了 cookie之后，在book.douban.com中是可以取到这个cookie的。除了在前端设置之外，也可以直接在response里将cookie的domain设置成 .douban.com。 Ajax什么是Ajax跨域ajax跨域的原理 ajax出现请求跨域错误问题,主要原因就是因为浏览器的“同源策略”,可以参考 ajax跨域的表现 ajax请求时,如果存在跨域现象,并且没有进行解决,会有如下表现:(注意，是ajax请求，请不要说为什么http请求可以，而ajax不行，因为ajax是伴随着跨域的，所以仅仅是http请求ok是不行的)第一种现象:No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且The response had HTTP status code 404出现这种情况的原因如下： 本次ajax请求是“非简单请求”,所以请求前会发送一次预检请求(OPTIONS) 服务器端后台接口没有允许OPTIONS请求,导致无法找到对应接口地址解决方案: 后端允许options请求第二种现象:No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且The response had HTTP status code 405这种现象和第一种有区别,这种情况下，后台方法允许OPTIONS请求,但是一些配置文件中(如安全配置),阻止了OPTIONS请求,才会导致这个现象解决方案: 后端关闭对应的安全配置第三种现象:No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且status 200这种现象和第一种和第二种有区别,这种情况下，服务器端后台允许OPTIONS请求,并且接口也允许OPTIONS请求,但是头部匹配时出现不匹配现象比如origin头部检查不匹配,比如少了一些头部的支持(如常见的X-Requested-With头部),然后服务端就会将response返回给前端,前端检测到这个后就触发XHR.onerror,导致前端控制台报错解决方案: 后端增加对应的头部支持第四种现象:heade contains multiple values &#39;*,*&#39;表现现象是，后台响应的http头部信息有两个Access-Control-Allow-Origin:*说实话，这种问题出现的主要原因就是进行跨域配置的人不了解原理，导致了重复配置，如:常见于.net后台(一般在web.config中配置了一次origin,然后代码中又手动添加了一次origin(比如代码手动设置了返回*))常见于.net后台(在IIS和项目的webconfig中同时设置Origin:*)解决方案(一一对应): 建议删除代码中手动添加的*，只用项目配置中的即可 建议删除IIS下的配置*，只用项目配置中的即可 如何解决ajax跨域 一般ajax跨域解决就是通过JSONP解决或者CORS解决,如以下:(注意，现在已经几乎不会再使用JSONP了，所以JSONP了解下即可) JSONPjsonp 其实算是一种 hack 形式的请求。jsonp 的本质其实是请求一段 js 代码，是对静态文件资源的请求，所以并不遵循同源策略。但是因为是对静态文件资源的请求，所以只能支持 GET 请求，对于其他方法没有办法支持。 设置CORS CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。本文详细介绍CORS的内部机制。 CORS简介 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 CORS两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。12345678910111213（1) 请求方法是以下三种方法之一： HEAD GET POST（2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、 multipart/form-data、 text/plain 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 CORS简单请求对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin(protocal + host + path + port)字段,来标明这个请求是来自哪里。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。1234567GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...` 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。（1）Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。（2）Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。（3）Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。Access-Control-Allow-Credentials: true另一方面，开发者必须在AJAX请求中打开withCredentials属性。12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 CORS非简单请求与简单请求最大的不同在于，非简单请求实际上是发送了两个请求。预请求首先，在正式请求之前，会先发送一个预请求(preflight-request)，这个请求的作用是尽可能少的携带信息，供服务端判断是否响应该请求。浏览器浏览器发送预请求，请求的 Request Method 会设置为 options。另外，还会带上这几个字段：123Origin: 同简单请求的originAccess-Control-Request-Method: 请求将要使用的方法Access-Control-Request-Headers: 浏览器会额外发送哪些头信息 服务端服务端收到预请求之后会根据request中的origin,Access-Control-Request-Method和Access-Control-Request-Headers判断是否响应该请求。如果判断响应这个请求，返回的response中将会携带：123Access-Control-Allow-Origin: originAccess-Control-Allow-Methods: like requestAccess-Control-Allow-Headers: like request 如果否定这个请求，直接返回不带这三个字段的response就可以，浏览器将会把这种返回判断为失败的返回，触发onerror方法正式响应如果预请求被正确响应，接下来就会发送正式请求，正式请求的request和正常的 ajax 请求基本没有区别，只是会携带 origin 字段；response和简单请求一样，会携带上Access-Control-*这些字段 WebScoketwebsocket 不遵循同源策略。 但是在 websocket 请求头中会带上 origin 这个字段，服务端可以通过这个字段来判断是否需要响应，在浏览器端并没有做任何限制。 iframe代理请求方式]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F15%2FJavaScript%2Findex%2F</url>
    <content type="text"><![CDATA[test body { background: yellow; } @media not all and (min-width: 400px) { body { background: pink; } } 点击按钮 1 2 3 4 5 6 window.onload = function () { let node = document.querySelector('.container .box > ul') console.log("node:", node); let ul = document.getElementsByClassName("ul") ul[0].style.background = "red" console.log("ul:", ul); } function username() { let username = document.getElementsByName('username')[0].value console.log("username:", username); }]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F15%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4%2Fvue%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[简单自我介绍, 做过哪些项目, 使用哪些技术栈 ?如何看待前端框架选型 ?vue的如何实现双向绑定的 ？react 虚拟DOM 是什么? 如何实现? 说一下diff算法 ?工作中最出色的点, 和你最头疼的问题 如何解决的 ?平时如何学习, 最近接触了解了哪些新的知识 ?技术一面简单自我介绍, 介绍一下你的项目, 技术栈 ?react和vue的比较 ?React Diff 算法 ?观察者模式实现 ?http报文头部有哪些字段? 有什么意义 ?移动端高清方案如何解决 ?webpack的原理, loader 和 plugin 是干什么的? 有自己手写过么 ?简述从网页输入url到网页展示的过程发生了哪些事情 ?SSR 和 客户端渲染有什么区别 , vue是如何实现绑定事件的 ?简述公司node架构中容灾的实现 ?浏览器事件有哪些过程? 为什么一般在冒泡阶段, 而不是在捕获阶段注册监听? addEventListener 参数分别是什么 ?面向对象如何实现? 需要复用的变量 怎么处理 ?移动端300ms延时的原因? 如何处理?主流框架的数据单向/双向绑定实现原理 ?简述转行经历, 如何学习 ?你觉得自己在前端工作的最大的优点是什么 拿实际工作的内容举例?技术二面和一面前3问基本一致,简述项目,React vue区别 virsualDOM实现DIFF算法为什么是O(n)复杂度而不是O(n^3)http code码?移动端rem布局如何实现? 简述原理?JSbridge原理, js和native是如何通信的?Rollup和webpack区别, treeshaking是什么?TCP三次握手的过程, get post请求的区别 ?静态文件的浏览器缓存如何实现?前端跨域方案http 请求包含哪些字段 分别是什么意思js 有哪些数据类型 如何判断? null 和 undefined区别 应用场景?new String(‘a’) 和 ‘a’ 是一样的么?移动端如何实现下拉到底部 跟随移动 结束后回弹的动画?移动端如何优化首页白屏时间过长 ?ES6 generator函数简述数组去重实现?js浮点数运算不精确 如何解决?工作中最得意和出色的点, 头疼的点, 问题如何解决的为何换工作?聊了下阿里的压力,文化技术三面公司的前端工程化实践转行之后是如何自学前端的, 学习途径 有没有一些自己的代码DOM基础知识,添加元素,删除元素等等…DOM节点类型正则表达式如何匹配一段url ?在正则表达式中有哪几种作用?移动端优化方式? 离线包是如何实现的? https://ustbhuangyi.github.io/vue-analysis/ 我的手机 2019/3/14 10:04:34https://www.jianshu.com/p/a804606ad8e9 我的手机 2019/3/14 10:04:50https://www.cnblogs.com/chinabin1993/p/9115396.html 我的手机 2019/3/14 10:05:03https://segmentfault.com/a/1190000012996217 我的手机 2019/3/14 10:05:20https://blog.csdn.net/qq_35430000/article/details/79291287 我的手机 2019/3/14 10:05:37https://m.jb51.net/article/140581.htm https://yukwan.cn/fronttech/front-end/2019/3/8 16:31:10我的手机 2019/3/8 16:31:10https://mp.weixin.qq.com/s/L8P0RIXym4myfknzM5Nsog2019/3/9 16:28:42我的手机 2019/3/9 16:28:42https://campushr.hikvision.com/JobDetails.html?id=057c01652bb444b597345337c7b8c14f&amp;type=0 https://wx2.sinaimg.cn/mw690/005NaMhPly1g0nayy8lbij30hs59p7wh.jpg?from=singlemessage]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F15%2FJavaScript%2F%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[JavaScript简介在HTML中使用JavaScript混杂模式与标准模式基本概念语法变量、函数名和操作符都区分大小写 标识符，就是指变量、函数、属性的名字，或者函数的参数。ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写 严格模式： “use strict”; 数据类型 简单数据类型(基本数据类型)：Undefined、Null、Boolean、Number、String 复杂数据类型：Object typeof 操作符来区分函数和其他对象是有必要的 Undefind 即便未初始化的变量会自动被赋予 undefined 值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当 typeof 操作符返回”undefined”值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。 NullBooleanNumber整数浮点数NaN即非数值（Not a Number）ECMAScript 定义了 isNaN()函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。 数值转换把非数值转换为数值：Number()、parseInt()和 parseFloat()。 String流控制语句函数变量、作用域和内存问题基本类型和引用类型基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象 复制变量值如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上.当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量1234var obj1 = new Object(); var obj2 = obj1; obj1.name = "Nicholas"; alert(obj2.name); //"Nicholas" 检测类型typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具 虽然在检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了 instanceof 操作符，其语法如下所示：result = variable instanceof constructor 执行环境垃圾收集标记清除引用计数小结 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中； 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本； 引用类型的值是对象，保存在堆内存中； 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针； 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象； 确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用instanceof 操作符。 所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。 以下是关于执行环境的几点总结： 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分； 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境； 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据； 变量的执行环境有助于确定应该何时释放内存。 JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。 可以对 JavaScript 的垃圾收集例程作如下总结： 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题。 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。 引用类型使用对象Object类型 Array类型 检测数组 value instanceof Array、 Array.isArray()方 转换方法 toLocaleString()、toString()和 valueOf() 栈方法 后进先出 push()、pop() 队列方法 后进先出 shift()、unshift() 重排序方法 reverse()、sort() 操作方法 concat() 连接数组、splice() 位置方法 indexOf()、lastIndexOf() 迭代方法 every() 全部 filter() 筛选 forEach() map() some() 存在 归并方法 reduce() reduceRight() Date类型 new Date()、Date.parse() 、Date.UTC() 继承的方法 日期格式化方法 toDateString()——以特定于实现的格式显示星期几、月、日和年 toTimeString()——以特定于实现的格式显示时、分、秒和时区； toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年 toLocaleTimeString()——以特定于实现的格式显示时、分、秒 toUTCString()——以特定于实现的格式完整的 UTC 日期 日期/时间组件 getTime() 返回表示日期的毫秒数；与valueOf()方法返回的值相同 setTime(毫秒) 以毫秒数设置日期，会改变整个日期 getFullYear() 取得4位数的年份（如2007而非仅07） getUTCFullYear() 返回UTC日期的4位数年份 RegExp()类型 Function类型 没有重载 函数声明与函数表达式 解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问） 至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。 作为值的函数 函数内部属性 arguments this callee 函数属性和方法 length prototype apply() call() 基本包装类型 Boolean类型 Number toFixed()方法会按照指定的小数位返回数值的字符串表示 toExponential() String trim()方法： 这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果 字符串大小写转换方法 toLowerCase() toLocaleLowerCase() toUpperCase() toLocaleUpperCase()。 字符串的模式匹配方法 localeCompare() localeCompare() fromCharCode() 单体内置对象 Global对象 Math对象 Math对象的属性 min()、max() 舍入方法 Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数 Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数 Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数 random() Math.radom() 160 创建并操作数组基本的JavaScript类型基本类型和基本包装类型面向对象的程序设计对象属性创建对象继承函数表达式BOM客户端检测DOMDOM扩展DOM2和DOM3事件表单脚本使用Canvas绘图HTML5脚本编程错误处理与调试JavaScript与XMLE4XJSONAjax与Comet高级技巧离线应用和客户端储存最佳实战新兴的API]]></content>
  </entry>
  <entry>
    <title><![CDATA[客户端渲染和服务端渲染详细执行流程]]></title>
    <url>%2F2019%2F03%2F14%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2FSSR%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[客户端渲染：CSR (client side render)在服务端放了一个html 页面，里面有//发请求，拿数据，模版引擎渲染等，$.ajax ,客户端发起请求，服务端把页面（响应的是字符串）发送过去，客户端从上到下依次解析，如果在解析的过程中，发现ajax请求，再次像服务器发送新的请求，客户端拿到ajax 响应结果，模板引擎渲染。过程至少和服务端发起两次请求 服务端渲染：SSR (server side render)sever 端页面+数据，服务端过程：1.读取index.html2.模版进行渲染，在发送给客户端之前，在服务端已经把index.html 渲染处理了。var 渲染结果 = tempeter.render(模板字符串，｛解析替换对象｝) response.end(渲染结果)，服务端响应的就是最总的结果服务端只请求一次多数网站既有服务端渲染又有客户端渲染 服务端渲染和客户端渲染的区别 客户端渲染不利于 SEO 搜索引擎优化 服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的 所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的 而是两者结合来做的 例如京东的商品列表就采用的是服务端渲染，目的了为了 SEO 搜索引擎优化 而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染]]></content>
      <categories>
        <category>前端优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件间通信&传值]]></title>
    <url>%2F2019%2F03%2F14%2FVue%2FVue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%26%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[转载： vue通信、传值的多种方式（详细） Vue.js——十分钟入门Vuex 通过路由带参数进行传值 两个组件 A和B,A组件通过query把orderId传递给B组件（触发事件可以是点击事件、钩子函数等）this.$router.push({ path: &#39;/conponentsB&#39;, query: { orderId: 123 } }) // 跳转到B 在B组件中获取A组件传递过来的参数this.$route.query.orderId 通过设置 Session Storage缓存的形式进行传递 两个组件A和B，在A组件中设置缓存orderData 123const orderData = &#123; &apos;orderId&apos;: 123, &apos;price&apos;: 88 &#125; sessionStorage.setItem(&apos;缓存名称&apos;, JSON.stringify(orderData)) B组件就可以获取在A中设置的缓存了const dataB = JSON.parse(sessionStorage.getItem(&#39;缓存名称&#39;))此时 dataB 就是数据 orderData 父子组件之间的传值父组件往子组件传值props①定义父组件，父组件传递 number这个数值给子组件，如果传递的参数很多，推荐使用json数组{}的形式 1234567891011121314# parent.vue&lt;template&gt; &lt;div class="parent"&gt; # 例如：传递数组88给子组件 &lt;children number=888&gt;&lt;/children&gt; &lt;/div&gt;&lt;/template&gt;import Children from 'components/children' # 引入子组件export default &#123; components: &#123; Children &#125;&#125; ②定义子组件，子组件通过 props方法获取父组件传递过来的值。props中可以定义能接收的数据类型，如果不符合会报错。12345678910111213# children.vue&lt;template&gt; &lt;div class="children"&gt; &#123;&#123;number&#125;&#125; # 显示父组件传递过来的值，显示88 &lt;/div&gt;&lt;/template&gt;export default &#123; props: &#123; # 限制父组件传递过来的数据类型，如果不符合就报错 'number': [Number, String, Object], 'string': [String] #可以传递多个值，逗号隔开 &#125;&#125; 当然也可以简单一点，如果不考虑数据类型，直接 props:[“number”,”string”]就可以了,中括号包裹，多个值使用，分隔。③假如接收的参数 是动态的，比如 input输入的内容 v-model的形式注意：传递的参数名称 支持驼峰命名，下面示例描述不正确（1.0是不支持的）1234567891011121314# parent.vue&lt;template&gt; &lt;div class="parent"&gt; &lt;input type="text" v-model="inputText"&gt; &lt;children :input-val = 'inputText'&gt;&lt;/children&gt; # 注意 :input-val 不支持驼峰命名，建议 - 分割 &lt;/div&gt;&lt;/template&gt;import Children from 'components/children'export default &#123; components: &#123; Children &#125;&#125; 1234567891011&lt;template&gt; &lt;div class="children"&gt; &#123;&#123;inputVal&#125;&#125; &lt;/div&gt;&lt;/template&gt;export default &#123; props: &#123; 'input-val': [String] &#125;&#125; ④父子组件传值，数据是异步请求，有可能数据渲染时报错原因：异步请求时，数据还没有获取到但是此时已经渲染节点了解决方案：可以在 父组件需要传递数据的节点加上v-if = false,异步请求获取数据后,v-if = true 子组件往父组件传值，通过emit事件123456789101112131415# children.vue&lt;template&gt; &lt;div class="children"&gt; &lt;button @click="emitToParent"&gt;按钮点击传值给父组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; methods: &#123; emitToParent() &#123; this.$emit('child-event', '我是子组件往父组件传递的内容') # child-event 不支持驼峰命名 # 子组件通过emit事件给父组件传递内容 &#125; &#125;&#125; 1234567891011121314151617181920# parent.vue&lt;template&gt; &lt;div class="parent"&gt; # 触发父组件的一个方法，然后进行相应的操作 &lt;children @child-event="parentEvent"&gt;&lt;/children&gt; # @child-event 这是子组件自定义的方法 &lt;/div&gt;&lt;/template&gt;import Children from 'components/children'export default &#123; methods: &#123; parentEvent(data) &#123; # data 就是子组件传递过来的数据 console.log(data) # 我是子组件往父组件传递的内容 &#125; &#125;, components: &#123; Children &#125;&#125; 不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用 vuex）①定义一个新的vue实例专门用于传递数据，并导出就是定义一个公共的传值用的组件进行数据的交互123# 新建文佳eventBus.jsimport Vue from 'vue'export default new Vue() ②定义传递的方法名和传输内容，点击事件或钩子函数触发eventBus.emit事件12345678910111213141516# componentA.vue&lt;template&gt; &lt;div class="componentsA"&gt; &lt;button @click="emitToB"&gt;按钮点击传递数据给兄弟组件B&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from 'common/js/eventBus.js'export default &#123; methods: &#123; emitToB() &#123; eventBus.$emit('eventFromA', '我是组件A传递给组件B的数据') &#125; &#125;&#125;&lt;/script&gt; ③接收传递过来的数据注意：enentBus是一个另一个新的Vue实例，区分两个this所代表得vue实例123456789101112131415161718192021222324252627282930componentB.vue&lt;template&gt; &lt;div class="componentsB"&gt; &#123;&#123;title&#125;&#125; # 显示传递过来的值 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from 'common/js/eventBus.js'export default &#123; data() &#123; return &#123; title: '' &#125; &#125;, mounted() &#123; this.getEventData() &#125;, methods: &#123; getEventData() &#123; const that = this #this是项目vue的实例，用that接收，与eventBus的vue区分 eventBus.$on('eventFormA', function(val) &#123; that.title = val # this.title = val # 这个this指的是eventBus的vue实例 &#125;) &#125; &#125;&#125; &lt;/script&gt; Vuex进行传值什么是Vuex Vuex是一个专门为Vue.js应用程序开发的状态管理模式, 它采用集中式存储管理所有组件的公共状态, 并以相应的规则保证状态以一种可预测的方式发生变化. 上图中绿色虚线包裹起来的部分就是Vuex的核心, state中保存的就是公共状态, 改变state的唯一方式就是通过mutations进行更改. 可能你现在看这张图有点不明白, 等经过本文的解释和案例演示, 再回来看这张图, 相信你会有更好的理解. 为什么要使用Vuex 试想这样的场景, 比如一个Vue的根实例下面有一个根组件名为App.vue, 它下面有两个子组件A.vue和B.vue, App.vue想要与A.vue或者B.vue通讯可以通过props传值的方式, 但是如果A.vue和B.vue之间的通讯就很麻烦了, 他们需要共有的父组件通过自定义事件进行实现, A组件想要和B组件通讯往往是这样的: A组件说: “报告老大, 能否帮我托个信给小弟B” =&gt; dispatch一个事件给App App老大说: “包在我身上, 它需要监听A组件的dispatch的时间, 同时需要broadcast一个事件给B组件” B小弟说: “信息已收到”, 它需要on监听App组件分发的事件 这只是一条通讯路径, 如果父组件下有多个子组件, 子组件之间通讯的路径就会变的很繁琐, 父组件需要监听大量的事件, 还需要负责分发给不同的子组件, 很显然这并不是我们想要的组件化的开发体验.Vuex就是为了解决这一问题出现的 如何引入Vuex下载vuex: npm install vuex --save 在main.js添加:12345678910111213import Vuex from 'vuex'# 使用vuexVue.use( Vuex );const store = new Vuex.Store(&#123; //待添加&#125;)new Vue(&#123; el: '#app', store, render: h =&gt; h(App)&#125;) Vuex的核心概念 在介绍Vuex的核心概念之前, 我使用vue-cli初始化了一个demo, 准备以代码的形式来说明Vuex的核心概念,这个demo分别有两个组件ProductListOne.vue和ProductListTwo.vue, 在App.vue的datat中保存着共有的商品列表, 代码和初始化的效果如下图所示:1234567891011121314151617181920212223242526272829303132333435363738//App.vue中的初始化代码&lt;template&gt;&lt;div id="app"&gt; &lt;product-list-one v-bind:products="products"&gt;&lt;/product-list-one&gt; &lt;product-list-two v-bind:products="products"&gt;&lt;/product-list-two&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ProductListOne from './components/ProductListOne.vue'import ProductListTwo from './components/ProductListTwo.vue'export default &#123; name: 'app', components: &#123; 'product-list-one': ProductListOne, 'product-list-two': ProductListTwo &#125;, data () &#123; return &#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;body&#123; font-family: Ubuntu; color: #555;&#125;&lt;/style&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//ProductListOne.vue&lt;template&gt; &lt;div id="product-list-one"&gt; &lt;h2&gt;Product List One&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="product in products"&gt; &lt;span class="name"&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class="price"&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['products'], data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;#product-list-one&#123; background: #FFF8B1; box-shadow: 1px 2px 3px rgba(0,0,0,0.2); margin-bottom: 30px; padding: 10px 20px;&#125;#product-list-one ul&#123; padding: 0;&#125;#product-list-one li&#123; display: inline-block; margin-right: 10px; margin-top: 10px; padding: 20px; background: rgba(255,255,255,0.7);&#125;.price&#123; font-weight: bold; color: #E8800C;&#125;&lt;/style&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//ProductListTwo.vue&lt;template&gt; &lt;div id="product-list-two"&gt; &lt;h2&gt;Product List Two&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="product in products"&gt; &lt;span class="name"&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class="price"&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['products'], data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;#product-list-two&#123; background: #D1E4FF; box-shadow: 1px 2px 3px rgba(0,0,0,0.2); margin-bottom: 30px; padding: 10px 20px;&#125;#product-list-two ul&#123; padding: 0; list-style-type: none;&#125;#product-list-two li&#123; margin-right: 10px; margin-top: 10px; padding: 20px; background: rgba(255,255,255,0.7);&#125;.price&#123; font-weight: bold; color: #860CE8; display: block;&#125;&lt;/style&gt; State state就是Vuex中的公共的状态, 我是将state看作是所有组件的data, 用于保存所有组件的公共数据. 此时我们就可以把App.vue中的两个组件共同使用的data抽离出来, 放到state中,代码如下:1234567891011121314151617181920212223# main.jsimport Vue from 'vue'import App from './App.vue'import Vuex from 'vuex'Vue.use( Vuex )const store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125;&#125;)new Vue(&#123; el: '#app', store, render: h =&gt; h(App)&#125;) 此时,ProductListOne.vue和ProductListTwo.vue也需要做相应的更改12345678# ProductListOne.vueexport default &#123; data () &#123; return &#123; products : this.$store.state.products //获取store中state的数据 &#125; &#125;&#125; 12345678# ProductListTwo.vueexport default &#123; data () &#123; return &#123; products: this.$store.state.products //获取store中state的数据 &#125; &#125;&#125; 此时的页面如下图所示, 可以看到, 将公共数据抽离出来后, 页面没有发生变化. Getters 我将getters属性理解为所有组件的computed属性, 也就是计算属性. vuex的官方文档也是说到可以将getter理解为store的计算属性, getters的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 此时,我们可以在main.js中添加一个getters属性, 其中的saleProducts对象将state中的价格减少一半(除以2)12345678910111213141516171819202122# main.jsconst store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125;, getters:&#123; //添加getters saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map( product =&gt; &#123; return &#123; name: product.name, price: product.price / 2 &#125; &#125;) return saleProducts; &#125; &#125; &#125;) 将productListOne.vue中的products的值更换为this.$store.getters.saleProducts1234567export default &#123; data () &#123; return &#123; products : this.$store.getters.saleProducts &#125; &#125;&#125; 现在的页面中,Product List One中的每项商品的价格都减少了一半 123456789101112131415161718192021222324252627282930313233343536```###### Mutations 我将mutaions理解为store中的methods, mutations对象中保存着更改数据的回调函数,该函数名官方规定叫type, 第一个参数是state, 第二参数是payload, 也就是自定义的参数.下面,我们在main.js中添加mutations属性,其中minusPrice这个回调函数用于将商品的价格减少payload这么多, 代码如下:```bash//main.jsconst store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125;, getters:&#123; saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map( product =&gt; &#123; return &#123; name: product.name, price: product.price / 2 &#125; &#125;) return saleProducts; &#125; &#125;, mutations:&#123; //添加mutations minusPrice (state, payload ) &#123; let newPrice = state.products.forEach( product =&gt; &#123; product.price -= payload &#125;) &#125; &#125;&#125;) 在ProductListTwo.vue中添加一个按钮,为其添加一个点击事件, 给点击事件触发minusPrice方法12345678910111213# ProductListTwo.vue&lt;template&gt; &lt;div id="product-list-two"&gt; &lt;h2&gt;Product List Two&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="product in products"&gt; &lt;span class="name"&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class="price"&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;button @click="minusPrice"&gt;减少价格&lt;/button&gt; //添加按钮 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 在ProductListTwo.vue中注册minusPrice方法, 在该方法中commitmutations中的minusPrice这个回调函数注意:调用mutaions中回调函数, 只能使用store.commit(type, payload)12345678910111213# ProductListTwo.vueexport default &#123; data () &#123; return &#123; products: this.$store.state.products &#125; &#125;, methods: &#123; minusPrice() &#123; this.$store.commit('minusPrice', 2); //提交`minusPrice,payload为2 &#125; &#125;&#125; 添加按钮, 可以发现,Product List Two中的价格减少了2, 当然你可以自定义payload,以此自定义减少对应的价格. Actionsactions 类似于 mutations，不同在于：actions提交的是mutations而不是直接变更状态actions中可以包含异步操作, mutations中绝对不允许出现异步actions中的回调函数的第一个参数是context, 是一个与store实例具有相同属性和方法的对象 此时,我们在store中添加actions属性, 其中minusPriceAsync采用setTimeout来模拟异步操作,延迟2s执行 该方法用于异步改变我们刚才在mutaions中定义的minusPrice123456789101112131415161718192021222324252627282930313233343536//main.jsconst store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125;, getters:&#123; saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map( product =&gt; &#123; return &#123; name: product.name, price: product.price / 2 &#125; &#125;) return saleProducts; &#125; &#125;, mutations:&#123; minusPrice (state, payload ) &#123; let newPrice = state.products.forEach( product =&gt; &#123; product.price -= payload &#125;) &#125; &#125;, actions:&#123; //添加actions minusPriceAsync( context, payload ) &#123; setTimeout( () =&gt; &#123; context.commit( 'minusPrice', payload ); //context提交 &#125;, 2000) &#125; &#125;&#125;) 在ProductListTwo.vue中添加一个按钮,为其添加一个点击事件, 给点击事件触发minusPriceAsync方法 12345678910111213&lt;template&gt; &lt;div id="product-list-two"&gt; &lt;h2&gt;Product List Two&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="product in products"&gt; &lt;span class="name"&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class="price"&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;button @click="minusPrice"&gt;减少价格&lt;/button&gt; &lt;button @click="minusPriceAsync"&gt;异步减少价格&lt;/button&gt; //添加按钮 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 在ProductListTwo.vue中注册minusPriceAsync方法, 在该方法中dispatchactions中的minusPriceAsync这个回调函数123456789101112131415export default &#123; data () &#123; return &#123; products: this.$store.state.products &#125; &#125;, methods: &#123; minusPrice() &#123; this.$store.commit('minusPrice', 2); &#125;, minusPriceAsync() &#123; this.$store.dispatch('minusPriceAsync', 5); //分发actions中的minusPriceAsync这个异步函数 &#125; &#125;&#125; 添加按钮, 可以发现, Product List Two中的价格延迟2s后减少了5 Modules由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 ..mapactions&amp;&amp; …mapgetters]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局]]></title>
    <url>%2F2019%2F03%2F08%2F%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[转载： 阮一峰：Flex 布局教程：语法篇 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex布局是什么？ Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。123.box&#123; display: felx;&#125; 行内元素也可以使用 Flex 布局。123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。基本概念 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性 以下6个属性设置在容器上。123456flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content flex-direction属性 flex-direction属性决定主轴的方向（即项目的排列方向）123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。1234row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。 flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性 justify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。12345flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性 align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 建立在主轴为水平方向时测试，即 flex-direction: row默认值为 stretch 即如果项目未设置高度或者设为 auto，将占满整个容器的高度。假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。12345flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。123456flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。123456orderflex-growflex-shrinkflex-basisflexalign-self order属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis属性 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: | auto; / default auto /}它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto)` 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>页面布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页从输入网址到渲染完成经历了哪些过程]]></title>
    <url>%2F2019%2F02%2F23%2FHTTP%2F%E7%BD%91%E9%A1%B5%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[过程概述 从输入域名到网页打开的简单过程如下：1. DNS域名解析 客户端输入域名后，由DNS服务器来将域名解析成对应服务器的IP地址2. 建立TCP连接 客户端得到IP地址以后,会根据所获得的IP地址以及要访问的端口号发起网络连接， 即tcp三次握手连接， 建立起TCP/IP网络连接， 具体过程如下： 第一次握手： 主机向服务器发送一个建立连接的请求（您好，我想认识您） 建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认 第二次握手： 服务器接到请求后发送同意连接的信号（好的，很高兴认识您） 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器 进入SYN_RECV状态； 第三次握手： 主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。 SYN:synchronous 建立联机ACK:acknowledgement 确认SYN_SENT:请求连接SYN_RECV:服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态。tcp在握手过程中并不携带数据，(就像你打电话给酒店订房时，在确认对方是酒店客服人员之前，你也不会马上把身份证号码报给他吧？)，而是在三次握手完成之后，才会进行数据传送。 补充说明: TCP 协议：三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号。3. 发送HTTP请求 与服务器建立连接之后，就可以向服务器发送请求了，请求需要遵循http协议4.服务器处理请求； 被请求的服务器解析用户请求的有哪些资源，通过服务器返回数据给客户端5.返回响应结果； 给客户端返回请求的状态码，通过状态码可以知道服务器端的处理是否正常6.浏览器渲染： 返回成功之后，浏览器拿到请求页面的代码，将其解析渲染出来。解析和渲染的过程主要由浏览器的渲染引擎实现。 根据域名查找 IP 地址概念解释 IP 地址：IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址； 域名(DN)：IP 地址由四个数字组成，中间用点号连接，在使用过程中难记忆且易输入错误，所以用我们熟悉的字母和数字组合来代替纯数字的 IP 地址，比如我们只会记住 www.baidu.com（百度域名） 而不是 220.181.112.244（百度的其中一个 IP 地址）； DNS： 每个域名都对应一个或多个提供相同服务服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。 知道了上面的概念，大概就知道了想要获得服务器的门牌号码，需要先将域名转换成 IP 地址。转换过程如下（以查询 www.baidu.com 的 IP 地址为例，其中2、3、4步均在上一步未查询成功的情况下进行）： 查找过程 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）； 操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求； LDNS 向 Root Name Server（根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server返回 com 域的顶级域名服务器的地址； LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com域名服务器地址； LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com的 IP 地址； LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来； 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来； 至此，浏览器已经得到了域名对应的 IP 地址。 补充说明 域名与 URL 是两个概念：域名是一台或一组服务器的名称，用来确定服务器在 Internet 上的位置；URL 是统一资源定位符，用来确定某一个文件的具体位置，例如，zhihu.com 是 知乎的域名，根据这个域名可以找到知乎的服务器，zhihu.com/people/CompileYouth 是 URL ，可以根据这个 URL 定位我的知乎主页； IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限； 网页请求与显示 当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件； 服务器将得到的 HTML 文件发送给浏览器； 在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页； 在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML 断开连接–四次挥手 主机向服务器发送一个断开连接的请求（不早了，我该走了）； 服务器接到请求后发送确认收到请求的信号（知道了）； 服务器向主机发送断开通知（我也该走了）； 主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接； URL 一个完整的URL地址由：协议、服务器地址(主机)、端口、资源路径(文件)。其中网络地址指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；协议是从 该计算机获取资源的方式，常见的是HTTP、FTP，不同协议有不同的通讯内容格式；资源路径指示从服务器上获取哪一项资源。例如：http://www.guokr.com/question/554991/超文本传输协议：http服务器地址：www.guokr.com端口： http协议的默认端口为80资源路径：是指要活的的文件的路径 -&gt;/question/554991/ 转载： 一个页面从输入url,到页面显示加载完成,这个过程中都发生了什么? 从输入 URL 到页面加载完成的过程中都发生了什么参考文章： 从键入网址到页面显示经历了那些过程]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM开发模式的理解]]></title>
    <url>%2F2019%2F02%2F23%2FVue%2FMVVM%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[MVVM MVVM（模型视图ViewModel 是一种基于MVC和MVP的架构模式，它试图更清楚地将用户界面（UI）的开发与应用程序中的业务逻辑和行为的开发分开。为此，此模式的许多实现都使用声明性数据绑定，以允许将视图上的工作与其他层分离。 Model、View、ViewModel MVVM分为Model、View、ViewModel三者。 Model 代表数据模型，数据和业务逻辑都在Model层中定义； View 代表UI视图，负责数据的展示，是用户在屏幕上看到的结构； ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作； Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom。 MVVM的实现原理：核心 响应式：vue如何监听data的属性变化 模板解析：vue的模板是如何被解析的 渲染：vue模板是如何被渲染成HTML的 响应式模板解析渲染设计模式编辑 因为WPF技术出现，从而使MVC架构模式有所改进，MVVM模式便是使用的是数据绑定基础架构。它们可以轻松构建UI的必要元素。可以参考The Composite Application Guidance for WPF(prism)View绑定到ViewModel，然后执行一些命令在向它请求一个动作。而反过来，ViewModel跟Model通讯，告诉它更新来响应UI。这样便使得为应用构建UI非常的容易。往一个应用程序上贴一个界面越容易，外观设计师就越容易使用Blend来创建一个漂亮的界面。同时，当UI和功能越来越松耦合的时候，功能的可测试性就越来越强。在MVP模式中，为了让UI层能够从逻辑层上分离下来，设计师们在UI层与逻辑层之间加了一层interface。无论是UI开发人员还是数据开发人员，都要尊重这个契约、按照它进行设计和开发。这样，理想状态下无论是Web UI还是Window UI就都可以使用同一套数据逻辑了。借鉴MVP的IView层，养成习惯。View Model听起来比Presenter要贴切得多；会把一些跟事件、命令相关的东西放在MVC的’C’,或者是MVVM的’Vm’。 优点和缺点优点 MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点: 低耦合: 视图（View）可以独立于 Model 变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可重用性: 你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 独立开发:开发人员可以专注于业务逻辑和数据的开发(ViewModel), 设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。 可测试:界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。 MVVM有助于更轻松地并行开发UI以及为其提供支持的构建块 抽象视图，从而减少其背后的代码所需的业务逻辑（或粘合剂）的数量 ViewModel比事件驱动的代码更容易进行单元测试 可以在不关心UI自动化和交互的情况下测试ViewModel（比View更多的模型） 缺点 对于更简单的UI，MVVM可能过度 虽然数据绑定可以是声明性的并且很好用，但它们比我们简单设置断点的命令式代码更难调试 非平凡应用程序中的数据绑定可以创建大量的簿记。您也不希望在绑定比绑定的对象更重的情况下结束 在较大的应用程序中，预先设计ViewModel以获得必要的泛化量可能更加困难 参考文章： 前后端分手大师——MVVM 模式 简单理解MVVM–实现Vue的MVVM模式 了解MVVM - JavaScript开发人员指南]]></content>
      <categories>
        <category>开发模式</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stylus基础]]></title>
    <url>%2F2019%2F02%2F22%2FCSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%2Fstylus%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>stylus</category>
      </categories>
      <tags>
        <tag>stylus基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis基础]]></title>
    <url>%2F2019%2F02%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fredis%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoose]]></title>
    <url>%2F2019%2F02%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmongoose%2F</url>
    <content type="text"><![CDATA[mongoosemongodb 的概念 &amp; 安装mongod mongodb 可视化工具 RoRo 3T 安装及应用mongoose 的作用mongoose 的应用]]></content>
      <categories>
        <category>mongoose</category>
      </categories>
      <tags>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa2基础]]></title>
    <url>%2F2019%2F02%2F21%2FKoa2%2FKoa2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Koa官网《Koa2进阶学习笔记》已完结 使用koa-generator生成koa2项目全局安装koa-generator: npm install -g koa-generator使用koa-generator生成koa2项目: koa2 -e koa2-learn -e 添加ejs模板引擎支持(默认是jade) koa2-learn 项目名123456789101112131415161718192021222324$ koa2 -e koa2-learning create : koa2-learning create : koa2-learning/package.json create : koa2-learning/app.js create : koa2-learning/public/javascripts create : koa2-learning/routes create : koa2-learning/routes/index.js create : koa2-learning/routes/users.js create : koa2-learning/public/images create : koa2-learning/public/stylesheets create : koa2-learning/public/stylesheets/style.css create : koa2-learning/public create : koa2-learning/views create : koa2-learning/views/index.ejs create : koa2-learning/views/error.ejs create : koa2-learning/bin create : koa2-learning/bin/www install dependencies: $ cd koa2-learning &amp;&amp; npm install run the app: $ DEBUG=koa2-learning:* npm start PS: 如果出现 npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.7: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;}) 不用担心。出现原因：fsevents 不在 package.json里，但是仍然安装了，是因为你的系统是Windows系统，fsevents是苹果系统的可选依赖,你的项目有可能是团队项目，别人在他的mac上安装了fsevents相关依赖库，所以到这边你也就安装到你的windows上边了。你可以检查你的package.json 文件中是不是有fsevents相关依赖，删除即好！如果没有，其他的npm包也会有依赖fsevents的！！！这是warning错误，是因为mac下需要fsevents，这里是在windows环境，所以可以忽略这个警告，对你没什么影响的。运行: DEBUG=koa2-learning:* npm start || npm run dev效果： 出现 node bin/www 访问 http://localhost:3000/注意： npm start 、 npm test 、 npm run dev 、 npm run prd async 和 await 语法异步概念 是指一个进程在执行某个请求的时候，如果这个请求没有执行完毕，进程不会等待，而是继续执行下面的请求。 理解async 和 awaitKoa2 中间件koa2 中间件的原理 自定义 koa2 中间件koa2 路由路由写法接口举例cookie 和 sessioncookie 和 session 的定义cookie 和 session 的作用推荐： 从头实现一个koa框架 浅析koa的洋葱模型实现]]></content>
      <categories>
        <category>Koa2</category>
      </categories>
      <tags>
        <tag>Koa2基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2019%2F02%2F15%2FVue%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Vue.js基础，模块化，单文件组件，路由，与服务器通信，状态管理，单元测试与生产发布，服务端渲染SSR与Nuxt.js，基于Vue.js企业级项目开发(Mint UI, Element UI)等132131]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局]]></title>
    <url>%2F2019%2F02%2F15%2F%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%2FCSS3%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[转载： 知乎专栏：CSS布局十八般武艺都在这里了参考：掘金：CSS 常见布局方式 常用居中方法 居中在布局中很常见，我们假设DOM文档结构如下，子元素要在父元素中居中：123&lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt;&lt;/div&gt; 水平居中 子元素为行内元素还是块状元素，宽度一定还是宽度未定，采取的布局方案不同。子元素为: 行内元素：对父元素设置text-align:center;定宽块状元素: 设置左右margin值为auto;不定宽块状元素: 设置子元素为display:inline,然后在父元素上设置text-align:center;通用方案: flex布局，对父元素设置display:flex;justify-content:center;` 例子：固定宽度 这种方式是绝对定位居中，除了使用 margin，我们还可以使用 transform（注意浏览器兼容性，只适用于 ie9+，移动开发请忽略）1234567891011121314151617.container&#123; width: 300px; height: 200px; background: pink; position: relative;&#125;.inner&#123; width: 100px; height: 50px; position: absolute; top: 50%; left: 50%; margin-top: -25px; margin-left: -50px; background: #fff; text-align: center;&#125; 1234567891011121314151617.container&#123; width: 300px; height: 200px; background: pink; position: relative;&#125;.inner&#123; width: 100px; height: 50px; position: absolute; top: 50%; left: 50%; /* transform: translate(-50%, -50%); */ transform: translate(-50px, -25px); background: #fff; text-align: center;&#125; 宽度未知 将子元素设置为行内元素，然后父元素设置 text-align: center。12345678910.container&#123; width: 300px; height: 200px; background: pink; position: relative; text-align: center;&#125;.inner&#123; display: inline-block;&#125; 多个块状元素 上面的方式即使子元素不止一个也想实现水平居中也是有效的，（宽度固定不固定都可，不固定的话就不需要设置宽度，会被自动撑开，但是要考虑到撑爆的情况）例如：12345678910111213141516.container&#123; width: 250px; height: 200px; background: pink; position: relative; text-align: center; padding: 20px;&#125;.inner&#123; display: inline-block; width: 50px; height: 150px; margin: 0 auto; background: #fff; text-align: center;&#125; 当然也可以使用我们刚刚介绍的 flex，我们只需要让子元素在主轴上的对齐方式设置为居中就可以1234567891011121314.container&#123; width: 250px; height: 200px; background: pink; display: flex; justify-content: center; padding: 20px;&#125;.inner&#123; background: #fff; width: 50px; height: 150px; margin-left: 10px;&#125; 垂直居中 垂直居中对于子元素是单行内联文本、多行内联文本以及块状元素采用的方案是不同的。父元素一定，子元素为单行内联文本:设置父元素的height等于行高line-height父元素一定，子元素为多行内联文本:设置父元素的display:table-cell或inline-block，再设置vertical-align:middle;块状元素:设置子元素position:absolute并设置top、bottom为0，父元素要设置定位为static以外的值，margin:auto;通用方案:flex布局，给父元素设置{display:flex; align-items:center;}。 单列布局 特征：定宽、水平居中常见的单列布局有两种： 一种是header、content、footer宽度都相同，其一般不会占满浏览器的最宽宽度，但当浏览器宽度缩小低于其最大宽度时，宽度会自适应。 一种是header、footer宽度为浏览器宽度，但content以及header和footer里的内容却不会占满浏览器宽度。对于第一种，对header、content、footer统一设置width或max-width，并通过margin:auto实现居中。DOM文档:12345&lt;div class="layout"&gt; &lt;div id="header"&gt;头部&lt;/div&gt; &lt;div id="content"&gt;内容&lt;/div&gt; &lt;div id="footer"&gt;尾部&lt;/div&gt;&lt;/div&gt; CSS清单:12345.layout&#123;/* width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/ max-width: 960px; margin: 0 auto;&#125; 对于第二种，header、footer的内容宽度为100%，但header、footer的内容区以及content统一设置width 或 max-width，并通过margin:auto实现居中。DOM文档:1234567&lt;div id="header"&gt; &lt;div class="layout"&gt;头部&lt;/div&gt;&lt;/div&gt;&lt;div id="content" class="layout"&gt;内容&lt;/div&gt;&lt;div id="footer"&gt; &lt;div class="layout"&gt;尾部&lt;/div&gt;&lt;/div&gt; CSS清单:12345.layout&#123;/* width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/ max-width: 960px; margin: 0 auto;&#125; 二列&amp;三列布局 二列布局的特征是侧栏固定宽度，主栏自适应宽度。三列布局的特征是两侧两列固定宽度，中间列自适应宽度。 之所以将二列布局和三列布局写在一起，是因为二列布局可以看做去掉一个侧栏的三列布局，其布局的思想有异曲同工之妙。对于传统的实现方法，主要讨论上图中前三种布局，经典的带有侧栏的二栏布局以及带有左右侧栏的三栏布局，对于flex布局，实现了上图的五种布局。 float + margin 原理说明：设置两个侧栏分别向左向右浮动，中间列通过外边距给两个侧栏腾出空间，中间列的宽度根据浏览器窗口自适应。 DOM文档:12345&lt;div id="content"&gt; &lt;div class="sub"&gt;sub&lt;/div&gt; &lt;div class="extra"&gt;extra&lt;/div&gt; &lt;div class="main"&gt;main&lt;/div&gt;&lt;/div&gt; 布局步骤: 对两边侧栏分别设置宽度，并对左侧栏添加左浮动，对右侧栏添加有浮动。对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。CSS清单:123456789101112.sub&#123; width: 100px; float: left;&#125;.extra&#123; width: 200px; float: right;&#125;.main&#123; margin-left: 100px; margin-right: 200px;&#125; 一些说明: 注意DOM文档的书写顺序，先写两侧栏，再写主面板，更换后则侧栏会被挤到下一列（圣杯布局和双飞翼布局都会用到）。 这种布局方式比较简单明了，但缺点是渲染时先渲染了侧边栏，而不是比较重要的主面板。 二列的实现方法 如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。 position + margin 原理说明：通过绝对定位将两个侧栏固定，同样通过外边距给两个侧栏腾出空间，中间列自适应。 DOM文档:123&lt;div class="sub"&gt;left&lt;/div&gt;&lt;div class="main"&gt;main&lt;/div&gt;&lt;div class="extra"&gt;right&lt;/div&gt; 布局步骤: 对两边侧栏分别设置宽度，设置定位方式为绝对定位。设置两侧栏的top值都为0，设置左侧栏的left值为0， 右侧栏的right值为0。对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。CSS清单:1234567891011121314.sub, .extra &#123; position: absolute; top: 0; width: 200px;&#125;.sub &#123; left: 0;&#125;.extra &#123; right: 0; &#125;.main &#123; margin: 0 200px;&#125; 一些说明: 本方法不限制DOM书写顺序，先写主面板会使主面板部分优先渲染（一般主面板会比侧栏内容重要）。与上一种方法相比，本种方法是通过定位来实现侧栏的位置固定。如果中间栏含有最小宽度限制，或是含有宽度的内部元素，则浏览器窗口小到一定程度，主面板与侧栏会发生重叠。二列的实现方法 如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。 圣杯布局 (float + 负margin)原理说明： 主面板设置宽度为100%，主面板与两个侧栏都设置浮动，常见为左浮动，这时两个侧栏会被主面板挤下去。通过负边距将浮动的侧栏拉上来，左侧栏的负边距为100%，刚好是窗口的宽度，因此会从主面板下面的左边跑到与主面板对齐的左边，右侧栏此时浮动在主面板下面的左边，设置负边距为负的自身宽度刚好浮动到主面板对齐的右边。为了避免侧栏遮挡主面板内容，在外层设置左右padding值为左右侧栏的宽度，给侧栏腾出空间，此时主面板的宽度减小。由于侧栏的负margin都是相对主面板的，两个侧栏并不会像我们理想中的停靠在左右两边，而是跟着缩小的主面板一起向中间靠拢。此时使用相对布局，调整两个侧栏到相应的位置。 DOM文档:12345 &lt;div id="bd"&gt; &lt;div class="main"&gt;center&lt;/div&gt; &lt;div class="sub"&gt;left&lt;/div&gt; &lt;div class="extra"&gt;right&lt;/div&gt; &lt;/div&gt; 布局步骤:三者都设置向左浮动。设置main宽度为100%，设置两侧栏的宽度。设置 负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。设置main的padding值给左右两个子面板留出空间。设置两个子面板为相对定位，sub的left值为负的sub宽度，extra的right值为负的extra宽度。CSS清单:123456789101112131415161718192021.main &#123; float: left; width: 100%; &#125; .sub &#123; float: left; width: 190px; margin-left: -100%; position: relative; left: -190px; &#125; .extra &#123; float: left; width: 230px; margin-left: -230px; position: relative; right: -230px; &#125;#bd &#123; padding: 0 230px 0 190px; &#125; 一些说明 DOM元素的书写顺序不得更改。主面板部分优先渲染（一般主面板会比侧栏内容重要）。当面板的main内容部分比两边的子面板宽度小的时候，布局就会乱掉。可以通过设置main的min-width属性或使用双飞翼布局避免问题。二列的实现方法如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的padding-right值，其他操作相同。反之亦然。 双飞翼布局 (float + 负margin) 原理说明：双飞翼布局和圣杯布局的思想有些相似，都利用了浮动和负边距，但双飞翼布局在圣杯布局上做了改进，在main元素上加了一层div, 并设置margin,由于两侧栏的负边距都是相对于main-wrap而言，main的margin值变化便不会影响两个侧栏，因此省掉了对两侧栏设置相对布局的步骤。 DOM文档:12345&lt;div class="main-wrap"&gt; &lt;div class="main"&gt;#main&lt;/div&gt;&lt;/div&gt;&lt;div class="sub"&gt;left&lt;/div&gt;&lt;div class="extra"&gt;right&lt;/div&gt; 布局步骤:三者都设置向左浮动。设置main-wrap宽度为100%，设置两个侧栏的宽度。设置负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。设置main的margin值给左右两个子面板留出空间。CSS清单:1234567891011121314151617.main-wrap &#123; float: left; width: 100%; &#125; .sub &#123; float: left; width: 190px; margin-left: -100%; &#125; .extra &#123; float: left; width: 230px; margin-left: -230px; &#125;.main &#123; margin: 0 230px 0 190px;&#125; 一些说明 主面板部分优先渲染（一般主面板会比侧栏内容重要）。圣杯采用的是padding，而双飞翼采用的margin，解决了圣杯布局main的最小宽度不能小于左侧栏的缺点。双飞翼布局不用设置相对布局，以及对应的left和right值。通过引入相对布局，可以实现三栏布局的各种组合，例如对右侧栏设置position: relative; left: 190px;,可以实现sub+extra+main的布局。二列的实现方法如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置main-wrap的margin-right值，其他操作相同。反之亦然。 flex布局 以下是五种布局的flex布局代码：DOM文档：1234567891011121314151617181920212223&lt;div class="layout"&gt; &lt;aside class="aside"&gt;侧边栏宽度固定&lt;/aside&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="aside"&gt;侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;aside class="aside"&gt;左侧边栏宽度固定&lt;/aside&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="aside"&gt;右侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;aside class="aside"&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class="aside"&gt;第2个侧边栏宽度固定&lt;/aside&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="aside"&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class="aside"&gt;第2个侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt; CSS清单123456789.layout &#123; display: flex;&#125;.main &#123; flex: 1;&#125;.aside &#123; width: 200px;&#125; 与之前所讲的几种传统布局方案相比，flex布局的代码可谓异常简洁，而且非常通用，利用简单的三行CSS即实现了常见的五种布局。 总结 传统的布局方法基于盒状模型，依赖 display属性 + position属性 + float属性，逻辑相对复杂，对于实现一些特殊效果，例如垂直居中，尤其复杂繁琐。而flex布局中的flex容器可以根据实际可用空间动态调整子元素的宽高比和顺序，使元素能够尽可能地利用可用空间，同时也能通过缩小来避免超出。flex布局提供了一套简便、完整、响应式的布局方案。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>页面布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[像素：(px、pt、em、rem、rpx)]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%83%8F%E7%B4%A0%2F%E5%83%8F%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[参考资料：px、em、rem区别介绍字体大小之px、em、rem、pt,字号详解 px: px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。 PX特点: 1. IE无法调整那些使用px作为单位的字体大小； 2. 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位； 3. Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。 pt: pt(point，磅)：是一个物理长度单位，指的是72分之一英寸。表示绝对长度。em: em是相对长度单位，相对于父元素的font-size。如当前对行内文本的字体尺寸未被人为设置，则相对浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。 em特点： 1. em的值并不是固定的； 2. em会继承父级元素的字体大小。 注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。所以我们在写CSS的时候，需要注意两点： 1. body选择器中声明Font-size=62.5%； 2. 将你的原来的px数值除以10，然后换上em作为单位； 3. 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。也就是避免1.2 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。 rem: rem（root em，根em）：是CSS3新增的一个相对单位，相对的是HTML根元素，可以只修改根元素就可以成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。兼容性IE9+都可以兼容，对于不兼容的浏览器写一个绝对单位的声明就可以了。rpx: rpx单位是微信小程序中css的尺寸单位，rpx可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。vw vh:vw,vh是css3的新单位，是相对于viewport视窗的宽高进行计算的单位。12341vw=1/100浏览器宽度1vh=1/100浏览器高度vmin：当前 vw 和 vh 中较小的一个值vmax：当前 vw 和 vh 中较大的一个值 vmin、vmax用处做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>像素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重绘(repaint)与回流(reflow)]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E9%87%8D%E7%BB%98(repaint)%E4%B8%8E%E5%9B%9E%E6%B5%81(reflow)%2F</url>
    <content type="text"><![CDATA[文章转载： 浏览器重绘和重排文章参考： 重构与回流 浏览器的重绘与重排 探讨css中repaint和reflow 前言： 页面设计中，不可避免的需要浏览器进行repaint和reflow。那到底什么是repaint和reflow呢。下面谈谈自己对repaint和reflow的理解，以及结合其他技术牛的讲解，谈谈如何优化repaint和reflow。 概述： 重排(回流), 顾名思义就是重新排版的意思; 重绘, 就是浏览器重新绘制。理解重排和重绘的含义十分重要, 因为在评审页面交互效果的时候, 重绘和重排是必须考虑的因素。并不是说交互效果实现了就可以了, 必须同时考虑到这样做会引发什么性能问题。也就是说, 浏览器在进行重绘和重排的时候是要付出高昂的性能代价的。 只有静态页面才会不存在repaint和reflow。repaint主要是针对某一个DOM元素进行的重绘，reflow则是回流，针对整个页面的重排。字面意思来说：repaint就是重绘，reflow就是回流。回流必将引起重绘，而重绘不一定会引起回流，repaint和reflow的目的是：展示一个新的页面样貌。 浏览器执行流： 浏览器每次从服务器下载完页面后就会对页面进行渲染(Render), 这里面就包含了重绘以及重排。每种浏览器虽然工作原理略有差别, 但也遵循以下流程: 览器引擎会解析HTML文档来构建DOM树。树的每个节点都是标签, 有大小边距等等的属性, 这是因为每个HTML元素都遵循盒子模型(隐藏元素不包括在文档树中, 浏览器不会将其渲染)。 渲染树构建完毕后, 浏览器就能够确定每个元素的位置并将元素放到正确的位置上, 再根据树节点的样式属性绘制出页面元素。 由于浏览器的流布局的方式, 对渲染树的计算通常只需要遍历一遍即可。但table及其内部元素除外, 可能需要执行多次计算才能确定好在渲染树中的属性,这个过程通常要耗费3倍以上的时间。 这也是我们要避免使用table标签的其中一个原因。 简言之浏览器执行顺序为： 1. 首先获取html，然后构建dom树 ，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。 2. 浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。 3. DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，render tree不包含隐藏的节点 (比如display:none的节点，还有head节点)，因为这些节点不会用于呈现。 4. 一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。 严重性： 在性能优先的前提下，性能消耗 重排(reflow)大于重绘(repaint)。 体现： repaint是某个DOM元素进行重绘；reflow是整个页面进行重排，也就是页面所有DOM元素渲染。 如何触发： style变动造成repaint和reflow。 不涉及任何DOM元素的排版问题的变动为repaint，例如元素的color/text-align/text-decoration等等属性的变动。 除上面所提到的DOM元素style的修改基本为reflow。例如元素的任何涉及长、宽、行高、边框、display等style的修改。 常见触发场景： 重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。重排(回流)是更明显的一种改变，可以理解为渲染树需要重新计算。 触发repaint： color的修改，如color=#ddd； text-align的修改，如text-align=center； a:hover也会造成重绘。 :hover引起的颜色等不导致页面回流的style变动。 触发reflow： width/height/border/margin/padding的修改，如width=778px； 动画，:hover等伪类引起的元素表现改动，display=none等造成页面回流； appendChild等DOM元素操作； font类style的修改； background的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分background的修改只触发repaint，当然IE不用考虑； scroll页面，这个不可避免； resize页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize程序窗口大小的多窗口操作系统。 读取元素的属性(这个无法理解，但是技术达人是这么说的，那就把它当做定理吧)：读取元素的某些属性(offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE)) 如何避免： 说避免那是不可能的，不然就是以前古老的静态页面了，没有交互，那在现在看来，就是一个失败的作品。所以，在我们进行网页设计的时候，就必须尽量减少页面的repaint和reflow。repaint和reflow的目的是为了展示一个新的页面，那么我们在进行页面交互时，尽量通过各种方法减少repaint和reflow但又能展示一个新的页面的目的。所以下面将结合其他技术达人的建议，通过自己的理解，给大家讲解如何避免和优化repaint和reflow： 尽可能在DOM末梢通过改变class来修改元素的style属性： 将多次改变样式属性的操作合并成一次操作，尽可能的减少受影响的DOM元素。 避免设置多项内联样式：使用常用的class的方式进行设置样式，以避免设置样式时访问DOM的低效率。 设置动画元素position属性为fixed或者absolute：由于当前元素从DOM流中独立出来，因此受影响的只有当前元素，元素repaint。 牺牲平滑度满足性能：动画精度太强，会造成更多次的repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。 避免使用table进行布局：table的每个元素的大小以及内容的改动，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以进行针对性的repaint和避免不必要的reflow。 避免在CSS中使用运算式：学习CSS的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。]]></content>
      <categories>
        <category>前端优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[转载：前端性能优化–yahoo前端性能团队总结的35条黄金定律参考文章：Web前端应该从哪些方面来优化网站? - 斯迪的回答 - 知乎WEB前端性能优化常见方法 前端是庞大的，包括 HTML、 CSS、 Javascript、Image 、Flash等等各种各样的资源。前端优化是复杂的，针对方方面面的资源都有不同的方式。那么，为什么要进行前端性能优化？ 怎么进行优化？ 优化到达的效果是什么？ 为什么需要前端性能优化[优化的好处/目的]好处： 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。 前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。 怎么进行优化 内容优化 减少Http请求次数 原因: 这条策略是最重要最有效的，因为一个完整的请求要经过DNS寻址，与服务器建立连接，发送数据，等待服务器响应，接收数据这样一个消耗时间成本和资源成本的复杂的过程。 使用方法： 从设计实现层面简化页面 合并多个CSS文件和js文件 利用CSS Sprites整合图像 Inline Images(使用 data：URL scheme在实际的页面嵌入图像数据 ) 合理设置HTTP缓存等。 使用懒加载进行图片的加载 减少DNS查询 原因: DNS查询也消耗响应时间，如果我们的网页内容来自各个不同的domain (比如嵌入了开放广告，引用了外部图片或脚本)，那么客户端首次解析这些domain也需要消耗一定的时间。DNS查询结果缓存在本地系统和浏览器中一段时间，所以DNS查询一般是对首次访问响应速度有所影响。 使用方法: 优化网站设计（九）：减少DNS查找的次数 减少DNS查找次数，最理想的方法就是将所有的内容资源都放在同一个域(Domain)下面，这样访问整个网站就只需要进行一次DNS查找，这样可以提高性能。 但理想总归是理想，上面的理想做法会带来另外一个问题，就是由于这些资源都在同一个域，而HTTP /1.1 中推荐客户端针对每个域只有一定数量的并行度（它的建议是2），那么就会出现下载资源时的排队现象，这样就会降低性能。 所以，折衷的做法是：建议在一个网站里面使用至少2个域，但不多于4个域来提供资源。我认为这条建议是很合理的，也值得我们在项目实践中去应用。 避免重定向 当客户端收到服务器的跳转回复时，客户端再次根据服务器回复中的location指定的地址再次发送请求，例如以下跳转回复: 123HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html 当客户端遇到这种回复的时候，用户只能等待客户端再次发送请求，有的网站甚至会一直跳n次，跳到他想带你去的地方…当然在这个时候用户看不到任何页面内容，只有浏览器的进度条一直在刷新。 使用Ajax缓存 Ajax可以帮助我们异步的下载网页内容，但是有些网页内容即使是异步的，用户还是在等待它的返回结果，例如ajax的返回是用户联系人的下拉列表。所以我们还是要注意尽量应用以下规则提高ajax的响应速度。 使用方法： 添加Expires 或 Cache-Control报文头使回复可以被客户端缓存 压缩回复内容 减少dns查询 精简javascript 避免跳转 配置Etags 延迟加载组件,预加载组件 延迟加载 这里讨论延迟加载需要我们知道我们的网页最初加载需要的最小内容集是什么。剩下的内容就可以推到延迟加载的集合中。 Javascript是典型的可以延迟加载内容。一个比较激进的做法是开发网页时先确保网页在没有Javascript的时候也可以基本工作，然后通过延迟加载脚本来完成一些高级的功能。 预加载 与延迟加载目的相反，提前加载的是为了提前加载接下来网页中访问的资源，下面是提前加载的类型 无条件提前加载：当前网页加载完成后，马上去下载一些其他的内容。例如google会在页面加载成功之后马上去下载一个所有结果中会用到的image sprite。 有预期的的加载：这种情况一般发生在网页重新设计时，由于用户经常访问旧网页，本地对旧的网页内容缓存充分从而显得旧网页速度很快，而新的网页内容却没有缓存，设计者可以在旧网页的内容中预先加载一些新网页中可能用到的内容，这样新的网页就会生下来一些需要下载的资源。 减少DOM元素数量: 页面中存在大量DOM元素,会导致javascript遍历DOM的效率变慢。 网页中元素过多对网页的加载和脚本的执行都是沉重的负担，500个元素和5000个元素在加载速度上会有很大差别。 想知道你的网页中有多少元素，通过在浏览器中的一条简单命令就可以算出document.getElementsByTagName(&#39;*&#39;).length 最小化iframe的数量： iframes 提供了一个简单的方式把一个网站的内容嵌入到另一个网站中。但其创建速度比其他包括JavaScript和CSS的DOM元素的创建慢了1-2个数量级。 优点 可以用来加载速度较慢的内容，例如广告。 安全沙箱保护。浏览器会对iframe中的内容进行安全控制。 脚本可以并行下载 缺点 即使iframe内容为空也消耗加载时间 会阻止页面加载 没有语义 避免404：HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。 404我们都不陌生，代表服务器没有找到资源，我们要特别要注意404的情况不要在我们提供的网页资源上，客户端发送一个请求但是服务器却返回一个无用的结果，时间浪费掉了。更糟糕的是我们网页中需要加载一个外部脚本，结果返回一个404，不仅阻塞了其他脚本下载，下载回来的内容(404)客户端还会将其当成Javascript去解析。 服务器优化 (1)使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。 再次强调第一条黄金定律，减少网页内容的下载时间。提高下载速度还可以通过CDN(内容分发网络)来提升。CDN通过部署在不同地区的服务器来提高客户的下载速度。如果你的网站上有大量的静态内容，世界各地的用户都在访问，我说的是youtube么？那CDN是必不可少的。事实上大多数互联网中的巨头们都有自己的CDN。我们自己的网站可以先通过免费的CDN供应商来分发网页资源。 添加Expires 或Cache-Control报文头(这条规则分为两个方面) 对于静态内容添加Expires，将静态内容设为永不过期，或者很长时间以后。在IIS中设置Expires可以看Configure the HTTP Expires Response Header (IIS 7)。 对于动态内容应用合适的Cache-Control，让浏览器根据条件来发送请求。关于asp.net的caching，可以看asp.net cache feature和asp.net caching best practices。 (2)GZIP压缩 Gzip通常可以减少70%网页内容的大小，包括脚本、样式表、图片等文件。Gzip比deflate更高效，主流服务器都有相应的压缩支持模块。 (3)设置ETag：ETags（Entity tags，实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。 虽然标题叫配制ETags，但是这里你要根据具体情况进行一些判断。首先Etag简单来说是通过一个文件版本标识使得服务器可以轻松判断该请求的内容是否有所更新，如果没有就回复304 (not modified)，从而避免下载整个文件。 (4)提前刷新缓冲区+ (5)对Ajax请求使用GET方法 浏览器在实现XMLHttpRequest POST的时候分成两步，先发header，然后发送数据。而GET却可以用一个TCP报文完成请求。另外GET从语义上来讲是去服务器取数据，而POST则是向服务器发送数据，所以我们使用Ajax请求数据的时候尽量通过GET来完成。 (6)避免空的图像src 空的图片src仍然会使浏览器发送请求到服务器，这样完全是浪费时间，而且浪费服务器的资源。尤其是你的网站每天被很多人访问的时候，这种空请求造成的伤害不容忽略。 Cookie优化 (1)减小Cookie大小 去除没有必要的cookie，如果网页不需要cookie就完全禁掉 将cookie的大小减到最小 注意cookie设置的domain级别，没有必要情况下不要影响到sub-domain 设置合适的过期时间，比较长的过期时间可以提高响应速度。 (2)针对Web组件使用域名无关的Cookie 大多数网站的静态资源都没必要cookie，我们可以采用不同的domain来单独存放这些静态文件，这样做不仅可以减少cookie大小从而提高响应速度，还有一个好处是有些proxy拒绝缓存带有cookie的内容，如果能将这些静态资源cookie去除，那就可以得到这些proxy的缓存支持。 常见的划分domain的方式是将静态文件放在static.example.com，动态内容放在www.example.com。 也有一些网站需要在二级域名上应用cookie，所有的子域都会继承，这种情况下一般会再购买一个专门的域名来存放cookie-free的静态资源。例如Yahoo!的yimg.com，YouTube的ytimg.com等。 CSS优化 (1)将CSS代码放在HTML页面的顶部 经样式表(css)放在网页的HEAD中会让网页显得加载速度更快，因为这样做可以使浏览器逐步加载已将下载的网页内容。这对内容比较多的网页尤其重要，用户不用一直等待在一个白屏上，而是可以先看已经下载的内容。 如果将样式表放在底部，浏览器会拒绝渲染已经下载的网页，因为大多数浏览器在实现时都努力避免重绘，样式表中的内容是绘制网页的关键信息，没有下载下来之前只好对不起观众了。 (2)避免使用CSS表达式 CSS表达式可以动态的设置CSS属性，在IE5-IE8中支持，其他浏览器中表达式会被忽略。例如下面表达式在不同时间设置不同的背景颜色。 CSS表达式的问题在于它被重新计算的次数远比我们想象的要多，不仅在网页绘制或大小改变时计算，即使我们滚动屏幕或者移动鼠标的时候也在计算，因此我们还是尽量避免使用它来防止使用不当而造成的性能损耗。 (3)使用来代替@import 避免使用@import的原因很简单，因为它相当于将css放在网页内容底部。 (4)避免使用Filters AlphaImageLoad也是IE5.5 - IE8中支持，这种滤镜的使用会导致图片在下载的时候阻塞网页绘制，另外使用这种滤镜会导致内存使用量的问题。IE9中已经不再支持。 JS优化 (1)将JavaScript脚本放在页面的底部。 HTTP/1.1 specification建议浏览器对同一个hostname不要超过两个并行下载连接， 所以当你从多个domain下载图片的时候可以提高并行下载连接数量。但是当脚本在下载的时候，即使是来自不同的hostname浏览器也不会下载其他资源，因为浏览器要在脚本下载之后依次解析和执行。 因此对于脚本提速，我们可以考虑以下方式， 把脚本置底，这样可以让网页渲染所需要的内容尽快加载显示给用户。 现在主流浏览器都支持defer关键字，可以指定脚本在文档加载后执行。 HTML5中新加了async关键字，可以让脚本异步执行。 (2)将JavaScript和CSS作为外部文件来引用： 使用外部Javascript和CSS文件可以使这些文件被浏览器缓存，从而在不同的请求内容之间重用。 同时将Javascript和CSS从inline变为external也减小了网页内容的大小。 使用外部Javascript和CSS文件的决定因素在于这些外部文件的重用率，如果用户在浏览我们的页面时会访问多次相同页面或者可以重用脚本的不同页面，那么外部文件形式可以为你带来很大的好处。但对于用户通常只会访问一次的页面，例如microsoft.com首页，那inline的javascript和css相对来说可以提供更高的效率。 (3)缩小JavaScript和CSS 精简就是将Javascript或CSS中的空格和注释全去掉， (4)删除重复的脚本 重复的脚本不仅浪费浏览器的下载时间，而且浪费解析和执行时间。一般用来避免引入重复脚本的做法是使用统一的脚本管理模块，这样不仅可以避免重复脚本引入，还可以兼顾脚本依赖管理和版本管理。 (5)最小化DOM的访问：使用JavaScript访问DOM元素比较慢。 通过Javascript访问DOM元素没有我们想象中快，元素多的网页尤其慢，对于Javascript对DOM的访问我们要注意 缓存已经访问过的元素 Offline更新节点然后再加回DOM Tree 避免通过Javascript修复layout (6)开发智能的事件处理程序 这里说智能的事件处理需要开发者对事件处理有更深入的了解，通过不同的方式尽量少去触发事件，如果必要就尽早的去处理事件。 比如一个div中10个按钮都需要事件句柄，那么我们可以将事件放在div上，在事件冒泡过程中捕获该事件然后判断事件来源。 (7)javascript代码注意： 谨慎使用with,避免使用eval Function函数,减少作用域链查找。 with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的 执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。 因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。 图像优化 (1)优化图片大小 检查GIF图片中图像颜色的数量是否和调色板规格一致。如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。可以使用imagemagick检查：identify -verbose image.gif 尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。下面这条简单的命令可以安全地把GIF格式转换为PNG格式： convert image.gif image.png 在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如： pngcrush image.png -rem alla -reduce -brute result.png 在所有的JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息 jpegtran -copy none -optimize -perfect src.jpg dest.jpg (2)通过CSS Sprites优化图片 Spirite中水平排列图片，垂直排列会增加文件大小； Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式； 不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小,但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100×100的图片为1万像素，1000×1000就是100万像素。 (3)不要在HTML中使用缩放图片 不要通过图片缩放来适应页面，如果你需要小图片，就直接使用小图片吧。 (4)favicon.ico要小而且可缓存 网站图标文件favicon.ico，不管你服务器有还是没有，浏览器都会去尝试请求这个图标。所以我们要确保这个图标 存在 文件尽量小，最好小于1k 设置一个长的过期时间 移动客户端 保持单个内容小于25KB 这限制是因为iphone，他只能缓存小于25K，注意这是解压后的大小。所以单纯gzip不一定够用，精简文件工具要用上了。 打包组建成符合文档 把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组建。当你使用这条规则时，首先要确定用户代理是否支持（iPhone不支持）。 待解决的方面 转载别人，如有错误请指出。]]></content>
      <categories>
        <category>前端优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪元素和伪类]]></title>
    <url>%2F2018%2F11%2F16%2FCSS3%2F%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[伪元素和伪类伪类包含两种：状态伪类和结构性伪类。状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。当元素处于某状态时会呈现该样式，而进入另一状态后，该样式也会失去。常见的状态伪类主要包括： :link 应用于未被访问过的链接；:hover 应用于鼠标悬停到的元素；:active 应用于被激活的元素；:visited 应用于被访问过的链接，与:link互斥。:focus 应用于拥有键盘输入焦点的元素。结构性伪类是css3新增选择器，利用dom树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少class和id属性的定义，使文档结构更简洁。常见的包括： :first-child 选择某个元素的第一个子元素；:last-child 选择某个元素的最后一个子元素；:nth-child() 选择某个元素的一个或多个特定的子元素；:nth-last-child() 选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算；:nth-of-type() 选择指定的元素；:nth-last-of-type() 选择指定的元素，从元素的最后一个开始计算；:first-of-type 选择一个上级元素下的第一个同类子元素；:last-of-type 选择一个上级元素的最后一个同类子元素；:only-child 选择的元素是它的父元素的唯一一个子元素；:only-of-type 选择一个元素是它的上级元素的唯一一个相同类型的子元素；:empty 选择的元素里面没有任何内容。 伪元素是对元素中的特定内容进行操作，而不是描述状态。它的操作层次比伪类更深一层，因此动态性比伪类低很多。实际上，伪元素就是选取某些元素前面或后面这种普通选择器无法完成的工作。控制的内容和元素是相同的，但它本身是基于元素的抽象，并不存在于文档结构中！常见的伪元素选择器包括： :first-letter 选择元素文本的第一个字（母）。:first-line 选择元素文本的第一行。:before 在元素内容的最前面添加新内容。:after 在元素内容的最后面添加新内容。 注意事项有时你会发现伪类元素使用了两个冒号 (::) 而不是一个冒号 (:)，这是 CSS3 规范中的一部分要求，目的是为了区分伪类和伪元素，大多数浏览器都支持这两种表示方式。单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。对于 CSS2 中已经有的伪元素，例如 :before，单冒号和双冒号的写法 ::before 作用是一样的。 所以，如果你的网站只需要兼容 webkit、firefox、opera 等浏览器，建议对于伪元素采用双冒号的写法，如果不得不兼容 IE 浏览器，还是用 CSS2 的单冒号写法比较安全。 参考文章： 谈谈css伪类与伪元素]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5新特性]]></title>
    <url>%2F2018%2F11%2F06%2FH5%2FHTML5%2F</url>
    <content type="text"><![CDATA[语义化标签: header footer nav section article aside 等增强型表单：HTML4: text、checkbox、password、radio、submit、reset、FileHTML5： date(从一个日期选择器选择一个日期) email(包含 e-mail 地址的输入域) number(数值的输入域) range(一定范围内数字值的输入域) search(用于搜索域) tel(定义输入电话号码字段) url、 color、 month、week等 视频和音频：audiovideoCanvas绘图SVG绘图 地理定位：Geolocation拖放API：dragweb worker：是运行在后台的JavaScript,独立于其他脚本，不会影响页面的性能web storage:localStorage sessionStorageWebSocket:HTML5开始提供的一种在单个TCP` 连接上进行全双工通讯的协议]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒子模型]]></title>
    <url>%2F2018%2F11%2F06%2FCSS3%2F%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[盒子样式介绍 width和height：内容的宽度、高度（不是盒子的宽度、高度） padding：内边距。 border：边框。 margin：外边距。 盒子模型的分类与概念 盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是IE盒子模型和标准 w3c 盒子模型。他们对盒子模型的解释各不相同: IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。 标准 W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。 ps: 1. ie8以上都是w3c标准盒模型 2. ie5极其以下都是ie盒子模型，ie6、ie7、ie8在混杂模式下ie盒模型， 3. 在标准模式下是w3c标准盒模型 4. 注意：ie6在混杂模式下一定是Ie盒模型，而ie7、ie8在混杂模式下不一定是ie盒模型 box-sizing 属性可以被用来调整这些表现: 1. content-box 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。 2. border-box 告诉浏览器去理解你设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px,那么这100px会包含其它的border和padding，内容区的实际宽度会是width减去border + padding的计算值。大多数情况下这使得我们更容易的去设定一个元素的宽高。 3. border-box定义的盒子，不会随着padding和boder的加入而增大盒子的占用空间。 border-box width 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。注意，填充和边框将在盒子内 。例如, .box {width: 350px; border: 10px solid black;} 导致在浏览器中呈现的宽度为350px的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。这里的维度计算为：width = border + padding + 内容的 width，height = border + padding + 内容的 height。 box-sizing：content-box（默认）content-box 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。border-boxborder-box 告诉浏览器去理解你设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px,那么这100px会包含其border和padding，内容区的实际宽度会是width减去(border + padding)的计算值。大多数情况下这使得我们更容易的去设定一个元素的宽高。inherit]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[块级元素行内元素]]></title>
    <url>%2F2018%2F11%2F06%2FCSS3%2F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[定义块级元素(display: block): 1. 每个块级元素都从新的一行开始，并且其后的元素也另起一行。 2. 元素的高度、宽度、行高以及顶和底边距都可设置。 3. 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致）。默认高度等于子元素高度。父子均是块级元素时，子块的高度可能冲破父级的限制 内联元素(display: inline) 1. 指的是书写完成后不会自动换行，并且元素没有宽和高。 2. 和其他内联元素都在一行上； 3. 可以通过margin、padding来改变左右的距离，但不可以改变上下的距离，导致width、height、line-height失效或。可以使用border。 4. 内联元素之间有空白区域，空白区域的形成是因为&lt;span&gt;之间有回车，在html中，空格、制表符、回车都属于空白符，多个空白符都会视为一个空格，空格的大小由父级&lt;div&gt;的font-size决定。注意：只有内联(内联块)与内联(内联块)之间的空白符才会形成一个空格，文本元素(除空白符)也是属于内联元素。常用解决方法，给&lt;div&gt;设置font-size: 0;，在&lt;span&gt;上把font-size设置回去 内联块状元素(display: inline-block) 1. 和其他元素都在一行上； 2. 元素的高度、宽度、行高以及顶和底边距都可设置。 3. 它也会有元素间出现空白区域的问题 空元素没有内容的HTML元素&lt;br&gt;、&lt;hr&gt;、&lt;img&gt;、&lt;input&gt;、&lt;link&gt;、&lt;meta&gt; 分类内联元素有：span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button（默认display：inline-block）块级元素有：div、p、h1~h6、ul、ol、dl、li、dd、table、hr、blockquote、address、menu、pre，HTML5新增的header、section、aside、footer内联块状元素： a, br, em, font, img, input, label, select, small, span, textarea]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[README]]></title>
    <url>%2F2018%2F10%2F22%2FREADME%2FREADME%2F</url>
    <content type="text"><![CDATA[It just a test music, but i like it var ap = new APlayer({ element: document.getElementById("aplayer-vzAiRJfQ"), narrow: false, autoplay: true, showlrc: false, music: { title: "起风了", author: "买辣椒也用券", url: "/assets/music/music.mp3", pic: "/assets/music/music.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深浅拷贝]]></title>
    <url>%2F2018%2F10%2F16%2FJavaScript%2F%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[转载： js 深浅拷贝 笔记总结 [JS]深拷贝与浅拷贝的区别，实现深拷贝的几种方法 JS 数据类型JavaScript的数据类型有： 数值类型(number) 、 字符串类型(string) 、 布尔类型(boolean) 、 null 、undefined 、对象(数组、正则表达式、日期、函数)大致分为两种： 基本数据类型 和 引用数据类型基本数据类型： 数字类型(number)、字符串类型(string)、布尔类型(boolean)、null、undefined引用数据类型： 常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等 深浅拷贝区别如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。 浅拷贝浅拷贝只是拷贝基本类型的数据，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，因此存在父对象被篡改的可能，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存 深拷贝深拷贝就是能够实现真正意义上的数组和对象的拷贝。递归调用”浅拷贝”。（深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象） 浅拷贝例子：12345let a=[0,1,2,3,4], b=a;console.log(a===b);a[0]=1;console.log(a,b); 运行结果：嗯？明明b复制了a，为啥修改数组a，数组b也跟着变了，这里我不禁陷入了沉思。那么这里，就得引入基本数据类型与引用数据类型的概念了。 a.基本类型–名值存储在栈内存中，例如let a=1;当你b=a复制时，栈内存会新开辟一个内存，例如这样：所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。 b.引用数据类型–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，起步就达到深拷贝的效果了 1.我们怎么去实现深拷贝呢，这里可以递归递归去复制所有层级属性。这么我们封装一个深拷贝的函数 123456789101112131415161718192021function deepClone(obj)&#123; let objClone = Array.isArray(obj)?[]:&#123;&#125;; if(obj &amp;&amp; typeof obj==="object")&#123; for(key in obj)&#123; if(obj.hasOwnProperty(key))&#123; //判断ojb子元素是否为对象，如果是，递归复制 if(obj[key]&amp;&amp;typeof obj[key] ==="object")&#123; objClone[key] = deepClone(obj[key]); &#125;else&#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125;let a=[1,2,3,4], b=deepClone(a);a[0]=2;console.log(a,b); 运行结果:跟之前想象的一样，现在b脱离了a的控制，不再受a影响了。这里再次强调，深拷贝，是拷贝对象各个层级的属性，可以看个例子。JQ里有一个extend方法也可以拷贝对象，我们来看看1234let a=[1,2,3,4], b=a.slice();a[0]=2;console.log(a,b); 运行结果：那是不是说slice方法也是深拷贝了，毕竟b也没受a的影响，上面说了，深拷贝是会拷贝所有层级的属性，还是这个例子，我们把a改改12345let a=[0,1,[2,3],4], b=a.slice();a[0]=1;a[2][0]=1;console.log(a,b); 拷贝的不彻底啊，b对象的一级属性确实不受影响了，但是二级属性还是没能拷贝成功，仍然脱离不了a的控制，说明slice根本不是真正的深拷贝。这里引用知乎问答里面的一张图 第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。 同理，concat方法与slice也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。 2.除了递归，我们还可以借用JSON对象的parse和stringify 12345678910function deepClone(obj)&#123; let _obj = JSON.stringify(obj), objClone = JSON.parse(_obj); return objClone&#125; let a=[0,1,[2,3],4], b=deepClone(a);a[0]=1;a[2][0]=1;console.log(a,b); 可以看到，这下b是完全不受a的影响了。 附带说下，JSON.stringify与JSON.parse除了实现深拷贝，还能结合localStorage实现对象数组存储 3.除了上面两种方法之外，我们还可以借用JQ的extend方法。 $.extend( [deep ], target, object1 [, objectN ] ) deep表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝 target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。 object1 objectN可选。 Object类型 第一个以及第N个被合并的对象。12345let a=[0,1,[2,3],4], b=$.extend(true,[],a);a[0]=1;a[2][0]=1;console.log(a,b); 可以看到，效果与上面方法一样，只是需要依赖JQ库。 说了这么多，了解深拷贝也不仅仅是为了应付面试题，在实际开发中也是非常有用的。例如后台返回了一堆数据，你需要对这堆数据做操作，但多人开发情况下，你是没办法明确这堆数据是否有其它功能也需要使用，直接修改可能会造成隐性问题，深拷贝能帮你更安全安心的去操作数据，根据实际情况来使用深拷贝，大概就是这个意思。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-思维]]></title>
    <url>%2F2018%2F10%2F16%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[题目： 给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值方法一：123a = a + b;b = a - b;a = a - b; 方法二：123a = a^b;b = a^b;a = a^b; 题目： 给两个杯子，一个5升，一个6升，水随便用，最后取出3升水方法： 6升装满倒入5升杯子，6升杯子里剩1升水； 6升杯子中的1升倒入5升杯子； 6升杯子装满水倒入5升杯子，6升杯子里剩2升水；把5升杯子水倒掉； 6升杯子中的2升倒入5升杯子； 6升杯子装满水倒入5升杯子，6升杯子里剩3升水，完成。 题目： 给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子方法：二分法：用天平左右各五个进行称量，10 =&gt; 5较轻的一组留下一个，继续进行分开称量，如果左右相等，则剩余的那一个为最轻的，否则剩下的两个继续进行比较5 =&gt; 1 || 5 =&gt; 2最后一次比较 2 =&gt; 1]]></content>
      <categories>
        <category>思维能力</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP和HTTPS的区别]]></title>
    <url>%2F2018%2F10%2F15%2FHTTP%2FHTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[&nbsp; &nbsp; &nbsp;超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。&nbsp; &nbsp; &nbsp;为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPHTTP的基本概念HTTP: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTP: 是超文本传输协议，信息是明文传输 HTTP的优点HTTP的缺点HTTPSHTTPS的基本概念HTTPS(Secure Hypertext Transfer Protocol)是安全超文本传输协议,HTTPS: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。https: 是具有安全性的ssl加密传输协议；HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 HTTPS的工作原理 客户端发起HTTPS请求用户在浏览器里输入一个https网址，然后连接到server的443端口。 服务端的配置采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 客户端解析证书这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 传送加密信息这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务段解密信息服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 传输加密后的信息这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 客户端解密信息客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。 HTTPS的优点 SEO方面谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 安全性 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本 HTTPS的缺点 SEO方面据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 经济方面 SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。 HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。 HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去。 HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。 HTTP和HTTPS的区别 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443； 、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全； https协议需要到ca申请证书，一般免费证书很少，需要交费。 参考文章：HTTP和HTTPS的区别、HTTP与HTTPS的区别 、HTTP详解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP连接性能优化]]></title>
    <url>%2F2018%2F10%2F14%2FHTTP%2FHTTP%E8%BF%9E%E6%8E%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[HTTP和TCP/IP的关系HTTP—&gt;(TSL/SSL)—&gt;TCP—&gt;IPHTTP处于应用层、TCP处于传输层、IP处于网络层 HTTP将所需要传输的数据以流的形式传递给TCP程序 TCP解析数据中的IP地址和端口号，将数据流分割成数据段，并添加上TCP段首部，如TCP握手（ACK、SYNC等），源端口，目的端口、TCP校验和等 TCP程序将包装好的TCP数据段叫给IP程序，IP程序在此基础上封装进去IP分组首部，如源IP地址、目的IP地址，数据报总长度、分组ID、首部长度、首部校验和等等 最后交给数据链路层去发送这个IP分组数据段 TCP性能的考虑HTTP紧挨着TCP，所以TCP的链接性能考虑直接影响的HTTP事务的性能。 HTTP事务时延一次HTTP请求可分为 DNS查询、连接、请求、事务处理、响应、关闭连接。每一步都会产生时延。其中，相对于连接、请求所消耗的时间，事务处理的时间是很短的。 对HTTP程序员产生影响的时延 TCP握手建立链接 TCP慢启动拥塞控制 数据聚集的Nagle算法 用于捎带确认的TCP延迟确认算法 TIME_WAIT 时延和端口耗尽 HTTP连接处理Connection首部真正用途HTTP允许客户端和源服务器之间存在多个代理服务器或高速缓存服务器，进行HTTP连接通信时，可以将HTTP首部逐跳的经过这些设备。这个时候，怎么在相邻的HTTP应用程序之间的连接应用一些特殊的选项呢？— Connection首部，可以承载3种不同类型的标签，这些标签不会传播到其它连接中去。a、HTTP首部字段名，列出了只与此连接有关的选项b、任意标签，用于描述此连接的非标准选项c、值close，说明操作完成之后需关闭这条持久连接由于添加Connection首部的其它首部字段，不能随着报文转发出去。因此将逐跳首部放入Connection首部，就可以达到对首部的保护。例：1234HTTP/1.1 200 OKCache-control: max-age=3600Connection: meter,close,bill-my-credit-cardMeter: max-uses=3,max-refuses=6,dont-report 实例说明：不应该转发Meter首部，要应用假想的bill-my-credit-card选项，且本次事务后应关闭持久连接。 串行事务处理延迟如果只对HTTP事务进行简单管理，TCP的性能时延可能会叠加起来，包括多次的建立连接和断开连接。 提高HTTP连接性能的四个方法：并行连接通过多条TCP连接发起并发的HTTP请求并行连接从理论上回提高页面的加载速度，因为多个请求同时发出，时延可以重叠起来。但并行连接并不是一点更快，原因可能是：客户端带宽限制、消耗更多的内存和计算资源。现代浏览器确实使用并行连接，但会限制连接数在一个较小的值（通常是4），并且服务器可以关闭来自特定客户端的超量连接。 持久连接重用TCP连接，以消除连接及关闭的时延重用连接：HTTP/1.1(HTTP/1.0增强版)允许HTTP设备在事务处理结束后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接。 持久连接+并行连接持久的连接的管理很重要，不小心会累积出大量的空闲连接 HTTP/1.0 + Keep-alive连接Connection： Keep-alive属性出现在1996年HTTP/1.0版本中，当初也是被当做实验型持久连接。 可以用通用首部Keep-Alive属性指定由逗号分隔的选项来调节keep-alive的行为。例：12Connection：Keep-aliveKeep-Alive: max=5,timeout=120 说明：服务器还会为另外5个事务保持连接的打开状态，或者将打开状态保持到连接空闲后2分钟。 Connection属于逐跳首部，只适用于单条传输链路。 现在HTTP/1.1不再需要此属性，默认开启持久连接的。 HTTP/1.1 持久连接HTTP/1.1逐渐停止了对keep-alive连接的支持，用一种名为持久连接(persistentconnection)的改进型设计取代了它。 必须显示指定Connection: close才会指定TCP连接在响应后立即关闭。当客户端发送了Connection: close请求首部之后，客户端就无法在那条连接上发送更多请求了。只有当连接上所有的报文都有正确的、自定义报文长度时，连接才能持久保持。 管道化连接通过共享的TCP连接发起并发的HTTP请求 HTTP/1.1 允许在持久连接上可选的使用请求管道。在响应到达之前，可以将多条请求放入队列，降低网络回环时间。 注：HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST），因为出错时，无法安全的重试POST这样的非幂请求。 复用的连接交替传送请求和相应报文（实验阶段） HTTP1.1 的特点持久连接每个TCP连接开始都有三次握手，要经历一次客户端与服务器间完整的往返，而开启了持久连接就不需要每次都要握手在连接中有这个属性的就是打开了持久化连接。下图展示了通过持久 TCP 连接取得 HTML 和 CSS 文件： HTTP2.0 的特点HTTP 长连接与短连接HTTP 是无状态的也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话.http1.0中默认是关闭的，需要在http头加入”Connection: Keep-Alive”，才能启用Keep-Alivehttp 1.1中默认启用Keep-Alive，如果加入”Connection: close”才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。下图是普通模式和长连接模式的请求对比： 开启Keep-Alive的优缺点优点： Keep-Alive模式更加高效，因为避免了连接建立和释放的开销缺点： 长时间的Tcp连接容易导致资源无效占用，浪费系统资源 当保持长连接时，如何判断一次请求已经完成？当保持长连接时，如何判断一次请求已经完成？ Content-LengthContent-Length表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。所以，当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置Content-Length来控制请求的结束。但当服务器并不知道请求结果的长度时，如一个动态的页面或者数据，Content-Length就无法解决上面的问题，这个时候就需要用到Transfer-Encoding字段。 Transfer-EncodingTransfer-Encoding是指传输编码，在上面的问题中，当服务端无法知道实体内容的长度时，就可以通过指定Transfer-Encoding: chunked来告知浏览器当前的编码是将数据分成一块一块传递的。当然, 还可以指定Transfer-Encoding: gzip, chunked表明实体内容不仅是gzip压缩的，还是分块传递的。最后，当浏览器接收到一个长度为0的chunked时， 知道当前请求内容已全部接收。 Keep-Alive timeout：Httpd守护进程，一般都提供了keep-alive timeout时间设置参数。比如nginx的keepalive_timeout，和Apache的KeepAliveTimeout。这个keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住keepalive_timeout秒后，才开始关闭这个连接。当httpd守护进程发送完一个响应后，理应马上主动关闭相应的tcp连接，设置 keepalive_timeout后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到浏览器发过来http请求，则关闭这个http连接。 Tcp的Keepalive：连接建立之后，如果客户端一直不发送数据，或者隔很长时间才发送一次数据，当连接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，连接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文（侦测包）给对方，如果对方回应了这个报文，说明对方还在线，连接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持连接。 tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。tcp keep-alive保鲜定时器，支持三个系统内核配置参数：net.ipv4.tcp_keepalive_intvl = 15net.ipv4.tcp_keepalive_probes = 5net.ipv4.tcp_keepalive_time = 1800keepalive是TCP保鲜定时器，当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）了tcp_keepalive_time后，服务器就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 tcp_keepalive_intvl后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试tcp_keepalive_probes,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。 参考文章： 浅谈Http长连接和Keep-Alive以及Tcp的Keepalive、http性能优化]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F10%2F12%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git 常用命令个人学习经历 从认识到使用git命令已有两年多的时间了，记得刚刚认识它的时候很是害怕，害怕那看不懂的命令，以至于每次提交代码都要用github客户端进行提交。当然了，那是的我对客户端也是晦涩难懂（现在也是），以至于要彻底放弃。有时每次提交代码都要把文件拉到网页上面进行提交，很是麻烦。后来跟着老师的课程渐渐地认识了git，才发现是如此的好用，慢慢的发现自己已经离不开它了。虽然以前已经整理过一些关于git的命令，但却凌乱不堪，以至于自己常常自惭形秽。今天我根据阮一峰老师的博客对自己的这篇文章进行重构，让自己的博客文章慢慢的有自己的思想和见解。 –2019-3-8 GIT命令1.新建代码库12345678910# 在当前目录新建一个Git代码库git init# 新建一个目录，将其初始化为Git代码库git init [project-name]# 下载一个项目和它的整个代码历史git clone [url]# 例： git clone git@github.com:aLittleLittleStar/Travel.git 2.配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置git config --list# 编辑Git配置文件git config -e [--global]# 设置提交代码时的用户信息git config [--global] user.name "[name]"git config [--global] user.email "[email address]" 3.增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 4.代码提交123456789101112131415161718192021# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -a# 提交并添加注释git commit -am "init"# 提交时显示所有diff信息git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 5.分支123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 查看本地所有分支，当前分支会被星号标示出git branch# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 可以看见每一个分支的最后一次提交git branch -v# 可以查看本地分支对应的远程分支git branch -vv# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到dev分支git checkout dev# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支git merge [branch]# 将分支dev与当前分支进行合并git merge origin/dev# 选择一个commit，合并进当前分支git cherry-pick [commit]# 给分支重命名git branch -m oldName newName# 删除分支，如果在分支中有一些未merge的提交，那么会删除分支失败git branch -d [branch-name]# 强制删除dev分支git branch -D dev# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 6.标签1234567891011121314151617181920212223242526# 列出所有taggit tag# 新建一个tag在当前commitgit tag [tag]# 新建一个tag在指定commitgit tag [tag] [commit]# 删除本地taggit tag -d [tag]# 删除远程taggit push origin :refs/tags/[tagName]# 查看tag信息git show [tag]# 提交指定taggit push [remote] [tag]# 提交所有taggit push [remote] --tags# 新建一个分支，指向某个taggit checkout -b [branch] [tag] 7.查看信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 显示有变更的文件git status# 查询repo的状态. -s表示short, -s的输出标记会有两列,# 第一列是对staging区域而言,第二列是对working目录而言.git status -s# 显示当前分支的版本历史git log# 显示commit历史，以及每次commit发生变更的文件git log --stat# 搜索提交历史，根据关键词git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]# 显示指定文件相关的每一次diffgit log -p [file]# 显示过去5次提交git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序git shortlog -sn# 显示指定文件是什么人在什么时间修改过git blame [file]# 显示暂存区和工作区的差异git diff# 显示暂存区和上一个commit的差异git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异git diff HEAD# 显示两次提交之间的差异git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码git diff --shortstat "@&#123;0 day ago&#125;"# 显示某次提交的元数据和内容变化git show [commit]# 显示某次提交发生变化的文件git show --name-only [commit]# 显示某次提交时，某个文件的内容git show [commit]:[filename]# 显示当前分支的最近几次提交git reflog 8.远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force# 推送所有分支到远程仓库git push [remote] --all 9撤销123456789101112131415161718192021222324252627282930313233343536373839# git撤销本地所有未提交的更改# 第一个命令只删除所有untracked的文件，如果文件已经被tracked,# 修改过的文件不会被回退。而第二个命令把tracked的文件revert到# 前一个版本，对于untracked的文件(比如编译的临时文件)都不会被删除。git clean -dfgit reset --hard# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop 10.其他1234567891011121314151617181920# 生成一个可供发布的压缩包git archive# 看你commit的日志git log --oneline# 查看帮助git checkout --help# 查看目录ls# 查看所有目录ls -al# 查看文件内容cat git.md# 查看git的版本信息git --version Git fetch &amp;&amp; Git pull 详解123456789101112```__git fetch__是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。__git pull__ 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。__分支的概念：__分支是用来标记特定代码的提交，每一个分支通过SHA1sum值来标识，所以对分支的操作是轻量级的，你改变的仅仅是SHA1sum值。如下图所示，当前有2个分支，A,C,E属于master分支，而A,B，D,F属于dev分支``` jsA----C----E（master） \ B---D---F(dev) 它们的head指针分别指向E和F，对上述做如下操作：12git checkout master //选择or切换到master分支git merge dev //将dev分支合并到当前分支(master)中 之后的情形是这样的：123A---C---E---G(master) \ / B---D---F（dev） 现在A，B,C,D,E,F,G属于master，G是一次合并后的结果，是将E和Ｆ的代码合并后的结果，可能会出现冲突。而A,B，D,F依然属于dev分支。可以继续在dev的分支上进行开发:123A---C---E---G---H(master) \ / B---D---F---I（dev） 理解gitfetch,关键是理解FETCH_HEAD，FETCH_HEAD指的是：某个branch在服务器上的最新状态。 git fetch 用法1git fetch &lt;远程主机名&gt; //这个命令将某个远程主机的更新全部取回本地 如果只想取回特定分支的更新，可以指定分支名：1git fetch &lt;远程主机名&gt; &lt;分支名&gt; //注意之间有空格 最常见的命令如取回origin 主机的master 分支：1git fetch origin master 取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息： 1git log -p FETCH_HEAD git pull 用法前面提到，git pull 的过程可以理解为：12git fetch origin master //从远程主机的master分支拉取最新内容 git merge FETCH_HEAD //将拉取下来的最新内容合并到当前所在的分支中 即将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为：1git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程分支是与当前分支合并，则冒号后面的部分可以省略：1git pull origin next git fetch 更新远程代码到本地仓库 理解 fetch 的关键, 是理解 FETCH_HEAD，FETCH_HEAD指的是: 某个branch在服务器上的最新状态’。 这个列表保存在 .Git/FETCH_HEAD 文件中, 其中每一行对应于远程服务器的一个分支。当前分支指向的FETCH_HEAD, 就是这个文件第一行对应的那个分支.一般来说, 存在两种情况:如果没有显式的指定远程分支, 则远程分支的master将作为默认的FETCH_HEAD.如果指定了远程分支, 就将这个远程分支作为FETCH_HEAD.git fetch origin branch1这个操作是git pull origin branch1的第一步, 而对应的pull操作,并不会在本地创建新的branch。设定当前分支的 FETCH_HEAD’ 为远程服务器的branch1分支`。 这个命令可以用来测试远程主机的远程分支branch1是否存在, 如果存在, 返回0, 如果不存在, 返回128, 抛出一个异常.git fetch origin branch1:branch2首先执行上面的fetch操作，使用远程branch1分支在本地创建branch2(但不会切换到该分支),如果本地不存在branch2分支, 则会自动创建一个新的branch2分支, 如果本地存在branch2分支, 并且是`fast forward’, 则自动合并两个分支, 否则, 会阻止以上操作.fetch更新本地仓库两种方式： 123456789101112131415//方法一$ git fetch origin master //从远程的origin仓库的master分支下载代码到本地的origin master$ git log -p master.. origin/master//比较本地的仓库和远程参考的区别$ git merge origin/master//把远程下载下来的代码合并到本地仓库，远程的和本地的合并//方法二$ git fetch origin master:temp //从远程的origin仓库的master分支下载到本地并新建一个分支temp$ git diff temp//比较master分支和temp分支的不同$ git merge temp//合并temp分支到master分支$ git branch -d temp//删除temp 1、git reset 没有push，这种情况发生在你的本地代码仓库,可能你add ,commit 以后发现代码有点问题. 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交commit_id(79f673d631b08907496ce792f429e1f00da25b73)，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard 79f673d631b08907496ce792f429e1f00da25b73。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。2、git revert已经push，对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令 git revert用一个新提交来消除一个历史提交所做的任何修改. revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题) revert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看. git revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c613、两者区别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit看似达到的效果是一样的,其实完全不同. 第一:上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突（或git push -f强制推送）.但是revert 并不会. 第二:如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里. 第三:reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的. 转载： 常用 Git 命令清单参考文章: git fetch 更新远程代码到本地仓库 Git 常用命令总结 git常用命令大全 Git常用命令解说 Git fetch &amp; pull 详解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的状态响应码]]></title>
    <url>%2F2018%2F10%2F10%2FHTTP%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码大类 状态码 说明 解释 1XX 响应中——表示请求已经接受，继续处理 消息：一般是告诉客户端请求已经收到了，正在处理，别急 2XX 成功——表示请求已经被成功接收、理解、接受。 处理成功：一般表示请求收悉、我明白你要的、请求已受理、已经处理完成等信息 3XX 重定向——要完成请求必须进行更进一步的操作 重定向到其它地方：它让客户端再发起一个请求以完成整个处理 4XX 客户端错误——请求有语法错误或请求无法实现 处理发生错误，责任在客户端：如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。 5XX 服务器端错误——服务器未能实现合法的请求。 处理发生错误，责任在服务端：如服务端抛出异常，路由出错，HTTP版本不支持等 HTTP响应状态码有很多，但是实际经常使用的大概只有14个。 状态码 200 OK //表示从客户端发来的请求在服务器端被正常处理了。 204 No Content该状态码表示服务器接收的请求已成功处理 ，但在返回的响应报文中不含实体的主体部分。 比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。 206 Partial Content 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。 301 Moved Permanently 永久性重定向。该状态码表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。 像下方给出的请求URI，当指定的资源路径的最后忘记添加斜杠”/“，就会产生301状态码 302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户(本次)能使用新的URI访问。 303 Other //我把你redirect到其它的页面，目标的URL通过响应报文头的Location告诉你。 See Other 该状态码表示由于请求对应的资源存在另外一个URI，应使用GET方法定向获取请求的资源。 303状态码和302状态码有着相同的功能，但303状态码明确表明客户端应当采用GET方法获取资源。 当301，302，303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文的主体，之后请求会自动再次发送。 301，302标准是禁止将POST方法改变成GET方法的，但实际上使用时大家都会这么做。 304 Not Modified // 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。 304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。 307 Temporary Redirect 临时重定向。该状态码与302 Found有着相同的含义。307会遵照浏览器标准，不会从POST变成GET 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 该状态码表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过1此请求，则表示用户认证失败。 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 500 Internal Server Error //该状态码表明服务器端在执行请求时发生了错误。 503 Server Unavailable //该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 参考文章 常见的HTTP响应状态码解析、常见的响应状态码]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡和捕获]]></title>
    <url>%2F2018%2F10%2F10%2FJavaScript%2F%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[事件冒泡 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是p -&gt; div -&gt; body -&gt; html -&gt; document 事件捕获捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)上面的例子在事件捕获的概念下发生click事件的顺序应该是document -&gt; html -&gt; body -&gt; div -&gt; p IE只支持事件冒泡，Chrome,Mozilla, Opera 7 和 Konqueror两种都支持，旧版本的Opera’s 和 iCab两种都不支持 。 捕获和冒泡过程图 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;event&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="obj1"&gt; welcome &lt;h5 id="obj2"&gt;hello&lt;/h5&gt; &lt;h5 id="obj3"&gt;world&lt;/h5&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var obj1=document.getElementById('obj1'); var obj2=document.getElementById('obj2'); obj1.addEventListener('click',function()&#123; alert('hello'); &#125;,false); obj2.addEventListener('click',function()&#123; alert('world'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 并且分别在obj1,obj2上绑定了一个点击事件，由于addEventListener的第三个参数为false,所以页面是在冒泡阶段处理绑定事件。此时整个页面可以有三种行为出现 点击文字welcome时，弹出hello。此时就只触发了绑定在obj1上的点击事件。具体冒泡实现过程如下：welcome 属于文本节点，点击后，开始从文本节点查找，当前文本节点没有绑定点击事件，继续向上找，找到父级（id为obj1的div），有绑定的点击事件，执行，再向上找，body，没有绑定点击事件，再到html,document,都没再有绑定的点击事件，好，整个冒泡过程结束。 点击文字hello时，先弹出world，再弹出hello 点击world时，弹出hello。 addEventListener的第三个参数1lement.addEventListener(event, function, useCapture) 第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。 我们想要在点击每个h5标签时，弹出对应的innerHTML 。常规做法是遍历每个h5,然后在每个h5上绑定一个点击事件，这种做法在h5较少的时候可以使用，但如果有一万个h5，那就会导致性能降低。这时就需要事件代理出场了。 事件代理使用事件代理的好处不仅在于将多个事件处理函数减为一个，而且对于不同的元素可以有不同的处理方法 123456obj1.addEventListener('click',function(e)&#123; var e=e||window.event; if(e.target.nodeName.toLowerCase()=='h5')&#123; alert(e.target.innerHTML); &#125;&#125;,false); 由于事件冒泡机制，点击了h5后会冒泡到div,此时就会触发绑定在div上的点击事件，再利用target找到事件实际发生的元素，就可以达到预期的效果。 问题阻止冒泡的方法，阻止默认事件的方法(兼容IE)w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true阻止事件的传播兼容 123456789101112131415function(e)&#123; var e=e||window.event; // window.event 这是IE浏览器 e.stopPropagation();//阻止事件的传播(包括捕获也包括冒泡) // 兼容处理 if (e &amp;&amp; e.stopPropagation) &#123; //这是其他浏览器 e.stopPropagation(); //阻止冒泡事件 e.preventDefault();//阻止默认事件 &#125;else&#123; // IE浏览器 e.cancelBubble=true; //阻止冒泡事件 e.returnValue=false;//阻止默认事件 &#125;&#125; 阻止冒泡事件的兼容性处理1234567function stopBubble(e) &#123; if(e &amp;&amp; e.stopPropagation) &#123; //非IE e.stopPropagation(); &#125; else &#123; //IE window.event.cancelBubble = true; &#125; &#125; 阻止默认事件w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false; 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，会执行几次事件，会先执行冒泡还是捕获？ 首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段 参考文章 终于弄懂了事件冒泡和事件捕获浅谈事件冒泡与事件捕获]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GET和POST请求]]></title>
    <url>%2F2018%2F10%2F10%2FHTTP%2FGET%E5%92%8CPOST%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[关于HTTP协议 HTTP（即超文本传输协议）是现代网络中最常见和常用的协议之一，设计它的目的是保证客户机和服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的 “请求-应答” 协议。 在HTTP中，与服务器交互的方法，最常用的有4种：即Put（增）、Delete（删）、Post（改）、Get（查）。get是获取数据，post是修改数据。 两种常见的HTTP请求：GET 和 POST在客户机和服务器之间进行请求-响应时，两种最常被用到的请求方式是：GET和 POST。GET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据 GET请求get把请求的数据放在url上，即HTTP协议头上，其格式为： 以?分割URL和传输数据，参数之间以&amp;相连。 数据如果是英文字母/数字，原样发送， 如果是空格，转换为+， 如果是中文/其他字符，则直接把字符串用BASE64加密，及“%”加上“字符串的16进制ASCII码”。特点 GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 POST 请求post把数据放在HTTP的包体内（requrest body）。特点 POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 POST 请求对数据长度没有要求 比较 GET 和 POST get提交的数据最大是2k（原则上url长度无限制，那么get提交的数据也没有限制咯？限制实际上取决于浏览器，(大多数)浏览器通常都会限制url长度在2K个字节，即使(大多数)服务器最多处理64K大小的url。也没有卵用。）。 post理论上没有限制。实际上IIS4中最大量为80KB，IIS5中为100KB。 GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 GET在浏览器回退时是无害的，POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET只接受ASCII字符的参数的数据类型，而POST没有限制那么，post那么好为什么还用get？get效率高！。 其他 HTTP 请求方法转载： HTTP 方法：GET 对比 POST参考文章: HTTP 方法：GET 对比 POST get和post的区别–面试经常被问到！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语义化标签]]></title>
    <url>%2F2018%2F10%2F10%2FH5%2F%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[H5中关于语义化的标签定义 语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。 为什么要语义化 1. 有利于SEO，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重。 2. 语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构 3. 方便其他设备解析（如移动设备、盲人阅读器等） 4. 比div标签有更加丰富的含义，便于团队开发和维护 关于语义化的标签有哪些title 简短、描述性、唯一（提升搜索引擎排名）header 页眉通常包括网站标志、主导航、全站链接以及搜索框。section 具有相似主题的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。footer 页脚，只有当父级是body时，才是整个页面的页脚。article 包含像报纸一样的内容，表示文档、页面、应用或一个独立的容器aahgroup 标签用于对网页或区段（section）的标题进行组合nav 标记导航，仅对文档中重要的链接群使用。aside 指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。address 作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）mark 突出显示文本（yellow），提醒读者。time 标记时间。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式figure 创建图（默认有40px左右margin）figcaption figure的标题，必须是figure内嵌的第一个或者最后一个元素。datailstdetailssummarydialogddprogress 完成进度。可通过js动态更新valuekeygensmall 指定细则，输入免责声明、注解、署名、版权。 H5新增的语义化标签header 是一种具有引导和导航作用的结构元素，通常用来放置整个页面或页面内的一个内容区块的标题，但也可以包含搜索表单或logo。footer footer通常包括其相关区块的脚注信息，如作者，相关阅读连接以及版权信息等。article 代表文档，页面或应用程序中独立的，完整的，可以独自被外部引用的内容，也可以嵌套使用。可以是一篇博客或者报刊中的文章，一篇论坛帖子，一段用户评论或者独立的插件，或其他任和独立的内容。aside 定义页面的侧边栏内容address 用来在文档中呈现联系信息，包括文档作者或文档维护者名字，他们的网站链接，电子邮箱，真实地址，电话号码，以及跟文档相关的联系人的所有联系信息。timedetails 用于描述文档或者文档某一部分细节，summary是details元素的标题ruby 加注释，ruby标签有两个子元素，rt注释的内容，rp是该标签不显示时显示的文字mark 定义带有几号的文本，它会给你想要突出显示的文本加个 背景色nav 是一个可以用作页面导航的链接组，其中导航元素链接到其他页面或当前页面的其他部分。progresssection 作为Html文档独立的功能。video 定义视频，属性src引入资源，controls视频的控制控件audio该标签可定义声音，及其他的音频文件，不加controls不显示音频的控制界面datalist 提示可能的值，datalist及其选项不会被显示出来，它仅仅是合法输入值的列表使用input元素的list属性来邦定datalistembed 定义插入的内容，如插件，flash，标签中间不要加内容会显现出来canvas canvas画布只是个容器，你可以通过控制坐标在canvas上绘制图形，一般配合js可以实现非常复杂的动画效果。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渐进增强和优雅降级]]></title>
    <url>%2F2018%2F10%2F10%2FCSS3%2F%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[渐进增强 一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。 123456.transition &#123; /*渐进增强写法*/ -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s;&#125; 优雅降级 一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。 123456.transition &#123; /*优雅降级写法*/ transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; 渐进增强和优雅降级的区别 渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的 常见问题 渐进增强和优雅降级如何抉择 如果你采用渐进增强的开发流程，先做一个基本功能版，然后针对各个浏览器进行渐进增加，增加各种功能。相对于优雅降级来说，开发周期长，初期投入资金大。 那采用优雅降级呢，这样可以在较短时间内开发出一个只用于一个浏览器的完整功能版，然后就可以拿给PM找客户谈呀，可以拿去测试，市场试水呀，对于功能尚未确定的 产品，优雅降级不失为一种节约成本的方法。 采用优雅降级的写法，如果一个浏览器同时支持前缀写法和正常写法，后面的旧版浏览器样式就覆盖了新版样式，出现一些奇怪的问题 ，但是用渐进增强的写法就不存在这个问题。这种属性不止border-radius一个，所以为了避免这个不必要的错误，建议大家都采用渐进增强的写法。 绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。 参考文章 渐进增强和优雅降级之间有什么不同?]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动]]></title>
    <url>%2F2018%2F10%2F10%2FCSS3%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[转载：CSS-清除浮动 为什么要清除浮动 浮动的元素是脱离文档标准流的，如果我们不清楚浮动，那么就会造成父元素高度塌陷，影响页面布局。 清除浮动的方法使用带clear属性的空元素 div、hr、br都可以123456789# html&lt;div class="clear"&gt;&lt;/div&gt;&lt;br class="clear" /&gt;&lt;hr class="clear" /&gt;#css.clear &#123; clear: both;&#125; 优点：通俗易懂，容易掌握 缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。 使用CSS的overflow属性给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发hasLayout，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。 12345678910111213141516171819.news &#123; background-color: gray; border: solid 1px black; overflow: hidden; *zoom: 1; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;&lt;div class="news"&gt;&lt;img src="news-pic.jpg" /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 优点：不存在结构和语义化问题，代码量极少 缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；04年POPO就发现overflow:hidden会导致中键失效，这是我作为一个多标签浏览控所不能接受的。所以还是不要使用. 父元素也设置浮动(给浮动的元素的容器添加浮动)优点：不存在结构和语义化问题，代码量极少缺点：给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。 使用邻接元素处理什么都不做，给浮动元素后面的元素添加clear属性。12345678910111213141516171819202122.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.content&#123; clear:both; &#125;&lt;div class="news"&gt;&lt;img src="news-pic.jpg" /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;div class="content"&gt;***&lt;/div&gt;&lt;/div&gt; 使用:after 伪元素结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。 123456789101112131415161718192021222324252627282930.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;# 清除浮动.clearfix:after&#123; content: " "; display: block; height: 0; clear: both; visibility: hidden; &#125;.clearfix &#123; /* 触发 hasLayout */ zoom: 1; &#125;&lt;div class="news clearfix"&gt;&lt;img src="news-pic.jpg" /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 清除浮动：清除对应的单词是 clear，对应CSS中的属性是 clear：left | right | both | none；闭合浮动：更确切的含义是使浮动元素闭合，从而减少浮动带来的影响。其中涉及的原理有：hasLayout 和 Block formatting contexts 。 通过上面的例子，我们不难发现清除浮动的方法可以分成两类： 一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。 二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。 在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。 最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bind、apply和call的区别]]></title>
    <url>%2F2018%2F10%2F10%2FJavaScript%2Fbind%E5%92%8Ccall%2F</url>
    <content type="text"><![CDATA[ing…bind和call的作用都是将某个函数的this指向绑定到另外一个作用域中，他们的参数调用都是相同的，第一个参数为绑定的作用域对象是什么，接下来就是可以添加不限的参数，而区别就是call在绑定的同时调用函数，bind是返回一个改变this指向的函数。apply方法和call方法有些相似，它也可以改变this的指向同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS模块化]]></title>
    <url>%2F2018%2F10%2F10%2FCSS3%2FCSS3%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[未完成ing… 设计原则 可复用能继承要完整 周期性迭代 优秀的代码是模仿/设计/重构出来的 设计方法 先整体后部分再颗粒化 布局-&gt; 页面 -&gt; 功能-&gt;业务 先抽象再具体 css模块化设计 reset.scss：浏览器不同，对默认的标签有默认的样式，为了表现统一化，要加一个这个。layout.scss:布局抽象成这个element.scss:列表、按钮 global的方式引用，比如说直接把某个模块引用进来，然后就可以写具体的样式了。scope就是用的module方法。比如说两个组件都叫做.btn，这样在之前会导致两个样式的名称一致，会被覆盖，如果想用相同的名称，样式不一样，就要用css module这样就不一致，因为编译出来的class带了一串编码。 优点： 提高代码重用率 提高开发效率、减少沟通成本 降低耦合 降低发布风险 减少Bug定位时间和Fix成本 提高页面容错 更好的实现快速迭代 更好的支持灰度发布 参考: CSS模块化如何实现？]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域的方法]]></title>
    <url>%2F2018%2F10%2F10%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端本地储存]]></title>
    <url>%2F2018%2F10%2F10%2FJavaScript%2F%E5%89%8D%E7%AB%AF%E6%9C%AC%E5%9C%B0%E5%82%A8%E5%AD%98%2F</url>
    <content type="text"><![CDATA[本地存储本地存储主要有以下几种，cookie，localStorage和sessionStorage，WebSql和IndexDB主要用在前端有大容量存储需求的页面上，例如，在线编辑浏览器或者网页邮箱。他们都可以将数据存储在浏览器，应该根据不同的场景进行使用。本文主要讲前三个。 cookiecookie机制采用的是在客户端保持状态的方案Cookie的主要内容包括：名字，值，过期时间，路径和域。可设置失效时间，没有设置的话，默认是关闭浏览器后失效。Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 优点 1. 给用户更人性化的使用体验，如记住“密码功能”、老用户登录欢迎语 2. 弥补了HTTP无连接特性 3. 站点统计访问人数的一个依据 4. 所有新旧浏览器都支持。 缺点 1. 它无法解决多人共用一台电脑的问题，带来了不安全因素 2. Cookie文件容易被误删除 3. 一人使用多台电脑 4. Cookies欺骗。修改host文件，可以非法访问目标站点的Cookie 5. 容量有限制，不能超过4kb 6. 在请求头上带着数据安全性差 为什么需要cookie 当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。Cookie 的作用就是用于解决 “如何记录客户端的用户信息”: 当用户访问 web 页面时，他的名字可以记录在 cookie 中。 在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。Cookie 以名/值对形式存储，如下所示:username=John Doe当浏览器从服务器上请求 web 页面时， 属于该页面的 cookie 会被添加到该请求中。服务端通过这种方式来获取用户的信息。 如何使用cookie12345678910# 创建Cookiedocument.cookie="username=John Doe";# 读取 Cookievar x = document.cookie;# 修改 Cookiedocument.cookie="username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/";# 删除 Cookie# 删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT"; 注意如果 cookie 被篡改了怎么办？预防 Cookie 被篡改set-cookie时加上防篡改验证码。 localStorage localStorage主要是前端开发人员，在前端设置，一旦数据保存在本地后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要地来回传递。 可以长期存储数据，没有时间限制，一天，一年，两年甚至更长，数据都可以使用。localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同 优点 1. localStorage拓展了cookie的4k限制 2. localStorage可以将第一次请求的5M大小数据直接存储到本地，相比于cookie可以节约带宽 3. localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage 缺点 1. 需要手动删除，否则长期存在 2. 浏览器大小不一，版本的支持也不一样 3. localStorage只支持string类型的存储，JSON对象需要转换 4. localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡123456789101112localStorage.setItem('x', 121313);localStorage.setItem('xxxx', 'baozhen');localStorage.getItem('x');for(let i = 0; i&lt; localStorage.length; i++) &#123; var name = localStorage.key(i); var value = localStorage.getItem(name) console.log("name:", name, "value:", value);&#125;localStorage.removeItem("x");localStorage.clear(); sessionStorage sessionStorage 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。存储上限限制：不同的浏览器存储的上限也不一样，但大多数浏览器把上限限制在5MB以下。 使用语法12345678# 保存数据语法：sessionStorage.setItem("key", "value");# 读取数据语法：var lastname = sessionStorage.getItem("key");# 删除指定键的数据语法：sessionStorage.removeItem("key");# 删除所有数据：sessionStorage.clear(); session 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session。 Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。 典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户的状态，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。 session机制采用的是在服务器端保持状态的方案。存在服务器的一种用来存放用户数据的类HashTable结构。 浏览器第一次发送请求时，服务器自动生成了一HashTable和一SessionID来唯一标识这个HashTable，并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的HashTable。 cookie 和 session 的区别 cookie数据存放在客户的浏览器上，session数据放在服务器上。 session 中保存的是对象，cookie 中保存的是字符串。 session 不能区分路径，同一个用户在访问一个网站期间，所有的session在任何地方都可以访问到。而 cookie 中如果设置了路径参数，那么同一个网站不同路径下的 cookie 互相是不可以访问的。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 localStorage 和 sessionStorage localStorage 和 sessionStorage两者的区别在于储存的有效期和作用域的不同：数据可以储存多长时间以及谁拥有数据的访问权。 名称 有效期 作用域 localStorage 永久性 同源文档 sessionStorage 当前窗口 同源文档 cookie 和 webStorage 的区别 webStorage 的优势 从容量上讲WebStorage一般浏览器提供5M的存储空间。 安全性上WebStorage 并不作为 HTTP header 发送的浏览器，所以相对安全。 从流量上讲，因为WebStorage不传送到服务器，所以不必要的流量可以节省。 Cookie和webstorage区别 数据的有效期不同 Webstorage:1.localstorage 2.sessionstorage sessionStorage：仅在当前的浏览器窗口关闭有效； localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据,除非手动删除； cookie：只在设置的cookie过期时间之前一直有效，即使窗口和浏览器关闭 作用域不同 sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面； localStorage：在所有同源窗口都是共享的； cookie：也是在所有同源窗口中共享的 webStorage支持事件通知机制，可以将数据更新的通知发生给监听者 转载： cookie和session, cookie和webStorage的区别 浏览器缓存原理以及本地存储 知乎问答]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端本地储存</tag>
      </tags>
  </entry>
</search>
