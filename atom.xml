<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>昨夜小楼又东风</title>
  
  <subtitle>纵豆蔻词工，青楼好梦，难赋深情</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-21T01:42:23.937Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LittleStar</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>reduce函数</title>
    <link href="http://yoursite.com/2019/10/21/JavaScript/reduce%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/21/JavaScript/reduce函数/</id>
    <published>2019-10-21T01:31:09.000Z</published>
    <updated>2019-10-21T01:42:23.937Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转：<br>　　<a href="https://segmentfault.com/a/1190000010731933" target="_blank" rel="noopener">JS进阶篇–JS数组reduce()方法详解及高级技巧</a><br><img src="https://files.jb51.net/file_images/article/201901/2019118104816957.png?2019018104828" alt="reduce函数"></p><p>案例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">数组求和</span><br><span class="line">var arr = [1,5,8,6,15,78,65,25,48,55]</span><br><span class="line">var sum = arr.reduce(<span class="keyword">function</span>(total,currentValue)&#123;</span><br><span class="line">  <span class="built_in">return</span> total+currentValue;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(sum);//306</span><br><span class="line">var eachSum = 0;</span><br><span class="line">arr.forEach(<span class="keyword">function</span>(currentValue)&#123;</span><br><span class="line">  eachSum += currentValue;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(eachSum);//306</span><br><span class="line"></span><br><span class="line">合并二维数组</span><br><span class="line">var twoArr = [[<span class="string">'mu'</span>,<span class="string">'zi'</span>],[<span class="string">'dig'</span>,<span class="string">'big'</span>],[<span class="string">'lucky'</span>,<span class="string">'jiji'</span>]];</span><br><span class="line">var oneArr = twoArr.reduce(<span class="keyword">function</span>(total,currentValue)&#123;</span><br><span class="line">  // console.log(total)</span><br><span class="line">  <span class="built_in">return</span> total.concat(currentValue);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(oneArr);//[<span class="string">"mu"</span>, <span class="string">"zi"</span>, <span class="string">"dig"</span>, <span class="string">"big"</span>, <span class="string">"lucky"</span>, <span class="string">"jiji"</span>]</span><br><span class="line"></span><br><span class="line">统计数组中有多少不重复的单词</span><br><span class="line">// 不用reduce时： </span><br><span class="line">var arr = [<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">"pear"</span>,<span class="string">"orange"</span>]; </span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getWordCnt</span></span>()&#123; </span><br><span class="line">  var obj = &#123;&#125;; </span><br><span class="line">  <span class="keyword">for</span>(var i= 0, l = arr.length; i&lt; l; i++)&#123; </span><br><span class="line">    var item = arr[i]; </span><br><span class="line">    obj[item] = (obj[item] +1 ) || 1; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">return</span> obj; </span><br><span class="line">&#125;</span><br><span class="line">console.log(getWordCnt());//&#123;apple: 2, orange: 3, pear: 1&#125;</span><br><span class="line">// 用reduce时： </span><br><span class="line">var arr = [<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">"pear"</span>,<span class="string">"orange"</span>]; </span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getWordCnt</span></span>()&#123; </span><br><span class="line">  <span class="built_in">return</span> arr.reduce(<span class="keyword">function</span>(prev,next)&#123; </span><br><span class="line">    prev[next] = (prev[next] + 1) || 1; </span><br><span class="line">    <span class="built_in">return</span> prev; </span><br><span class="line">  &#125;,&#123;&#125;); </span><br><span class="line">&#125; </span><br><span class="line">console.log(getWordCnt());//&#123;apple: 2, orange: 3, pear: 1&#125;</span><br></pre></td></tr></table></figure></p><h3 id="reduce的理解"><a href="#reduce的理解" class="headerlink" title="reduce的理解"></a>reduce的理解</h3><p>　　<code>reduce(callback,initiaValue)</code>会传入两个变量，回调函数<code>(callback)</code>和初始值<code>(initiaValue)</code>。<br>假设函数有个传入参数，<code>prev</code>和<code>next</code>，<code>index</code>和<code>array</code>。 <code>Prev</code>和<code>next</code>是你必须要了解的。<br>当没有传入初始值时，<code>prev</code>是从数组中第一个元素开始的，<code>next</code>是第二个函数。<br>但是当传入初始值<code>（initiaValue）</code>后,第一个<code>prev</code>将是<code>initivalValue</code>，<code>next</code>将是数组中的第一个元素。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>　　reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。<br>　　reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(callback,[initialValue])</span><br></pre></td></tr></table></figure><p><code>callback</code> （执行数组中每个值的函数，包含四个参数）<br>　　<code>previousValue</code> （上一次调用回调返回的值，或者是提供的初始值（<code>initialValue</code>））<br>　　<code>currentValue</code> （数组中当前被处理的元素）<br>　　<code>index</code> （当前元素在数组中的索引）<br>　　<code>array</code> （调用 <code>reduce</code> 的数组）<br>　　<code>initialValue</code> （作为第一次调用 <code>callback</code> 的第一个参数。）</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CORS 简单请求与非简单请求</title>
    <link href="http://yoursite.com/2019/10/17/HTTP/CORS%20%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E4%B8%8E%E9%9D%9E%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2019/10/17/HTTP/CORS 简单请求与非简单请求/</id>
    <published>2019-10-17T01:29:14.000Z</published>
    <updated>2019-10-17T01:30:08.666Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载： <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p><h3 id="跨域资源共享-CORS-详解"><a href="#跨域资源共享-CORS-详解" class="headerlink" title="跨域资源共享 CORS 详解"></a>跨域资源共享 CORS 详解</h3><p>　　CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>本文详细介绍CORS的内部机制。</p><h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p>　　CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。<br>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>　　因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p><h4 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h4><p>　　浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>只要同时满足以下两大条件，就属于简单请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（1) 请求方法是以下三种方法之一：</span><br><span class="line">  HEAD</span><br><span class="line">  GET</span><br><span class="line">  POST</span><br><span class="line">（2）HTTP的头信息不超出以下几种字段：</span><br><span class="line">  Accept</span><br><span class="line">  Accept-Language</span><br><span class="line">  Content-Language</span><br><span class="line">  Last-Event-ID</span><br><span class="line">  Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</span><br></pre></td></tr></table></figure></p><p>　　凡是不同时满足上面两个条件，就属于非简单请求。<br>　　<code>浏览器对这两种请求的处理，是不一样的。</code></p><h4 id="三、简单请求"><a href="#三、简单请求" class="headerlink" title="三、简单请求"></a>三、简单请求</h4><h5 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h5><p>　　对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。<br>　　下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0…</span><br></pre></td></tr></table></figure></p><p>　　上面的头信息中，<code>Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）</code>。<code>服务器根据这个值，决定是否同意这次请求。</code></p><p>　　如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure></p><p>　　上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。<br>（1）Access-Control-Allow-Origin<br>　　该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。<br>（2）Access-Control-Allow-Credentials<br>　　该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。<br>（3）Access-Control-Expose-Headers<br>　　该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p><h5 id="3-2-withCredentials-属性"><a href="#3-2-withCredentials-属性" class="headerlink" title="3.2 withCredentials 属性"></a>3.2 withCredentials 属性</h5><p>　　上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。<br><code>Access-Control-Allow-Credentials: true</code><br>另一方面，开发者必须在AJAX请求中打开withCredentials属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>　　否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p><p>　　但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p><p>　　需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p><h4 id="四、非简单请求"><a href="#四、非简单请求" class="headerlink" title="四、非简单请求"></a>四、非简单请求</h4><h5 id="4-1-预检请求"><a href="#4-1-预检请求" class="headerlink" title="4.1 预检请求"></a>4.1 预检请求</h5><p>　　非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。<br>　　非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<br>　　浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br>下面是一段浏览器的JavaScript脚本。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var url = ‘http://api.alice.com/cors’;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(‘PUT’, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(‘X-Custom-Header’, ‘value’);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p><p>上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。<br>　　浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0…</span><br></pre></td></tr></table></figure></p><p>　　“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p><p>　　除了Origin字段，”预检”请求的头信息包括两个特殊字段。<br>（1）Access-Control-Request-Method<br>　　该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。<br>（2）Access-Control-Request-Headers<br>　　该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p><h5 id="4-2-预检请求的回应"><a href="#4-2-预检请求的回应" class="headerlink" title="4.2 预检请求的回应"></a>4.2 预检请求的回应</h5><p>　　服务器收到”预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure></p><p>　　上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示<a href="http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。" target="_blank" rel="noopener">http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure></p><p>　　如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure></p><p>服务器回应的其他CORS相关字段如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure></p><p>（1）Access-Control-Allow-Methods<br>　　该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。<br>（2）Access-Control-Allow-Headers<br>　　如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。<br>（3）Access-Control-Allow-Credentials<br>　　该字段与简单请求时的含义相同。<br>（4）Access-Control-Max-Age<br>　　该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p><h5 id="4-3-浏览器的正常请求和回应"><a href="#4-3-浏览器的正常请求和回应" class="headerlink" title="4.3 浏览器的正常请求和回应"></a>4.3 浏览器的正常请求和回应</h5><p>　　一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。<br>下面是”预检”请求之后，浏览器的正常CORS请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0…</span><br></pre></td></tr></table></figure></p><p>上面头信息的Origin字段是浏览器自动添加的。</p><p>下面是服务器正常的回应。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure></p><p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p><h4 id="五、与JSONP的比较"><a href="#五、与JSONP的比较" class="headerlink" title="五、与JSONP的比较"></a>五、与JSONP的比较</h4><p>　　CORS与JSONP的使用目的相同，但是比JSONP更强大。<br>　　<code>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</code></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>z-index</title>
    <link href="http://yoursite.com/2019/10/16/CSS3/z-index/"/>
    <id>http://yoursite.com/2019/10/16/CSS3/z-index/</id>
    <published>2019-10-16T11:49:44.000Z</published>
    <updated>2019-10-22T01:15:00.878Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载： <a href="https://www.cnblogs.com/benbendu/p/5811534.html" target="_blank" rel="noopener">【CSS深入理解之z-index】听课总结</a><br><a id="more"></a></p><h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><h3 id="1、z-index-基础知识"><a href="#1、z-index-基础知识" class="headerlink" title="1、z-index 基础知识"></a>1、z-index 基础知识</h3><h4 id="1-1-z-index-的含义"><a href="#1-1-z-index-的含义" class="headerlink" title="1.1 z-index 的含义"></a>1.1 z-index 的含义</h4><p>　　<code>z-index</code>属性指定了元素及其子元素的【z顺序】，而【z顺序】可以决定当元素发生覆盖的时候，哪个元素在上面。通常一个较大的<code>z-index</code>值的元素会覆盖较低的那一个。</p><h4 id="1-2-属性值"><a href="#1-2-属性值" class="headerlink" title="1.2 属性值"></a>1.2 属性值</h4><p>　　<code>z-index:auto;</code> 默认值<br>　　<code>z-index:&lt;integer&gt;;</code> 整数值<br>　　<code>z-index:inherit;</code> 继承</p><h4 id="1-3-基本特性"><a href="#1-3-基本特性" class="headerlink" title="1.3 基本特性"></a>1.3 基本特性</h4><p>1&gt;支持负值；<br>2&gt;支持<code>CSS3 animation</code>动画；（并没什么实用应用场景）<br>3&gt;在<code>CSS2.1</code>时代，需要和定位元素配合使用<br>　　如果不考虑<code>CSS3</code>，只有定位元素（<code>position:relative/absolute/fixed/sticky</code>）的<code>z-index</code>才有作用！在<code>CSS3</code>中有例外</p><h3 id="2、z-index-与定位元素"><a href="#2、z-index-与定位元素" class="headerlink" title="2、z-index 与定位元素"></a>2、z-index 与定位元素</h3><p>　　z-index只对定位元素有作用。要设置非static的定位属性，z-index才会生效。<br>　　如果定位元素z-index没有发生嵌套(并列的)：</p><h4 id="2-1-gt-后来者居上的准则"><a href="#2-1-gt-后来者居上的准则" class="headerlink" title="2.1&gt;后来者居上的准则"></a>2.1&gt;后来者居上的准则</h4><p><img src="https://images2015.cnblogs.com/blog/1015026/201608/1015026-20160826163818522-890560737.jpg" alt="后来者居上的准则"></p><h4 id="2-2-gt-哪个大哪个上"><a href="#2-2-gt-哪个大哪个上" class="headerlink" title="2.2&gt;哪个大哪个上"></a>2.2&gt;哪个大哪个上</h4><p><img src="https://images2015.cnblogs.com/blog/1015026/201608/1015026-20160826163945663-1261119555.jpg" alt="哪个大哪个上"><br>　　如果定位元素<code>z-index</code>发生嵌套：<br>1&gt;祖先优先原则<br>  前提：<code>z-index是数值，不是auto</code><br><img src="https://images2015.cnblogs.com/blog/1015026/201608/1015026-20160826164602585-68770555.jpg" alt="祖先优先原则"><br>　祖先后来者居上<br><img src="https://images2015.cnblogs.com/blog/1015026/201608/1015026-20160826164910116-1216779075.jpg" alt="祖先后来者居上"><br><code>CSS2.1：（z-index：auto）</code>当前层叠上下文生成盒子层叠水平是0。盒子（除非是根元素）不会创建一个新的层叠上下文。</p><h3 id="3、层叠上下文和层叠水平"><a href="#3、层叠上下文和层叠水平" class="headerlink" title="3、层叠上下文和层叠水平"></a>3、层叠上下文和层叠水平</h3><h4 id="3-1-层叠上下文（stacking-context）"><a href="#3-1-层叠上下文（stacking-context）" class="headerlink" title="3.1 层叠上下文（stacking context）"></a>3.1 层叠上下文（stacking context）</h4><p>　　层叠上下文是HTML元素中的一个三维概念，表示元素在z轴上有了“可以高人一等”。<br>　　栗子：  皇帝（你）    当官（层叠上下文）   家族（嵌套）<br>　　· 层叠上下文表示普通老百姓HTML元素当官了，离皇帝更近了。<br>　　· 页面根元素天生具有层叠上下文，称之为“根层叠上下文” -（皇亲国戚）<br>　　· z-index值为数值的定位元素也具有层叠上下文。 -（科考入选）<br>　　· 其他属性…… -其他当官途径（见第六部分）</p><h4 id="3-2-层叠水平（stacking-level）"><a href="#3-2-层叠水平（stacking-level）" class="headerlink" title="3.2 层叠水平（stacking level）"></a>3.2 层叠水平（stacking level）</h4><p>　　层叠上下文中的每个元素都有一个层叠水平，决定了同一个层叠上下文中元素在z轴上的显示顺序。<br>　　遵循“后来居上”和“谁大谁上”的层叠准则<br>　　层叠水平和z-index不是一个东西。普通元素也有层叠水平。z-index只在定位元素上起作用。</p><h4 id="3-3-层叠上下文的几个特性："><a href="#3-3-层叠上下文的几个特性：" class="headerlink" title="3.3 层叠上下文的几个特性："></a>3.3 层叠上下文的几个特性：</h4><p>　　1&gt;层叠上下文可以嵌套，组合成一个分层次的层叠上下文。<br>　　2&gt;每个层叠上下文和兄弟元素独立：当进行层叠变化或渲染的时候，只需要考虑后代元素。<br>　　3&gt;每个层叠上下文是自称体系的：当元素的内容被层叠后，整个元素被认为是在父层的层叠顺序中。</p><h3 id="4、元素的层叠顺序-stacking-order"><a href="#4、元素的层叠顺序-stacking-order" class="headerlink" title="4、元素的层叠顺序 stacking order"></a>4、元素的层叠顺序 stacking order</h3><p>　　层叠顺序：元素发生层叠时候有着特定的垂直显示顺序<br>　　意义：规范元素重叠时候的呈现规则。<br>　　著名的7阶层叠水平（stacking level）<br>　　这样的层叠顺序更符合页面加载的功能和视觉呈现的。内容是页面最重要是实体，因此层叠水平要高。<br><img src="https://images2015.cnblogs.com/blog/1015026/201608/1015026-20160826174206944-994632417.jpg" alt="7阶层叠水平"><br><img src="https://images2015.cnblogs.com/blog/1015026/201608/1015026-20160826191045382-1289371321.jpg" alt="7阶层叠水平"><br>　　文字是内联水平<code>display:inline</code>.<br>　　上图中的层叠顺序：<br>　　　　1&gt;<code>inline-block大于block</code><br>　　　　2&gt;文字和<code>inline-block</code>方块的层叠水平一样。如果元素的层叠水平一样，没有别的因素干扰，则遵循后来者居上原则。</p><h3 id="5、z-index与层叠上下文"><a href="#5、z-index与层叠上下文" class="headerlink" title="5、z-index与层叠上下文"></a>5、z-index与层叠上下文</h3><p>　　　1.行为要点：</p><p>　　1&gt;定位元素默认z-index:auto可以看成是z-index:0（层级理解上）；</p><p>　　　定位元素会覆盖普通元素。因为：z-index只对定位元素起作用，z-index:auto的层叠顺序大于图片这个内联元素。</p><p>　　2&gt;z-index不为auto的定位元素会创建层叠上下文；</p><p>　　  z-index负值的层叠顺序在层叠上下文元素背景色之上（如图3）<br><img src="https://images2015.cnblogs.com/blog/1015026/201608/1015026-20160827114612460-564553578.jpg" alt=""><br><img src="https://images2015.cnblogs.com/blog/1015026/201608/1015026-20160827115309710-1725982560.jpg" alt=""><br><img src="https://images2015.cnblogs.com/blog/1015026/201608/1015026-20160827115408460-995084292.jpg" alt=""><br>从层叠顺序上讲，z-index:auto 可以看成z-index:0;</p><p>　　　 但是从层叠上下文来讲，两者却有着本质差异。</p><p>　　　 但是在IE7之下有bug，z-index:auto 也会创建层叠上下文。</p><p>　　3&gt;z-index层叠顺序的比较止步于父级层叠上下文；<br><img src="https://images2015.cnblogs.com/blog/1015026/201608/1015026-20160827120655757-451676150.jpg" alt=""></p><h3 id="6、其他CSS属性与层叠上下文（不只是z-index）"><a href="#6、其他CSS属性与层叠上下文（不只是z-index）" class="headerlink" title="6、其他CSS属性与层叠上下文（不只是z-index）"></a>6、其他CSS属性与层叠上下文（不只是z-index）</h3><p><img src="https://images2015.cnblogs.com/blog/1015026/201608/1015026-20160827121701241-1329607728.jpg" alt=""></p><h3 id="7、z-index与其他CSS属性层叠上下文——非定位元素层叠上下文和z-index的关系"><a href="#7、z-index与其他CSS属性层叠上下文——非定位元素层叠上下文和z-index的关系" class="headerlink" title="7、z-index与其他CSS属性层叠上下文——非定位元素层叠上下文和z-index的关系"></a>7、z-index与其他CSS属性层叠上下文——非定位元素层叠上下文和z-index的关系</h3><p>　　1.不支持z-index的层叠上下文元素的层叠顺序均是z-index:auto级别<br><img src="https://images2015.cnblogs.com/blog/1015026/201608/1015026-20160827150900288-1967455897.jpg" alt=""><br>举个例子：<br><img src="https://images2015.cnblogs.com/blog/1015026/201608/1015026-20160827151059835-1303346271.jpg" alt="举个例子："></p><h3 id="8、z-index相关实践"><a href="#8、z-index相关实践" class="headerlink" title="8、z-index相关实践"></a>8、z-index相关实践</h3><h4 id="8-1最小化影响原则"><a href="#8-1最小化影响原则" class="headerlink" title="8.1最小化影响原则"></a>8.1最小化影响原则</h4><p>　　　　目的：避免z-index嵌套层级关系混乱<br>　　　　原因：1&gt;元素的层叠水平主要由所在的层叠上下文决定；<br>　　　　　　　2&gt;IE7  z-index:auto也会新建层叠上下文；<br>　　　　做法：1&gt;避免使用定位属性<br>　　　　　　　2&gt;定位属性从大容器平级分离为私有小容器；</p><h4 id="8-2不犯二准则"><a href="#8-2不犯二准则" class="headerlink" title="8.2不犯二准则"></a>8.2不犯二准则</h4><p>　　　　目的：避免z-index混乱，一山比一山高的样式问题<br>　　　　原因：多人协作以及后期维护；<br>　　　　做法：对于非浮层元素，避免设置z-index值，z-index值没有任何道理需要超过2——不犯二准则；</p><h4 id="8-3组件层级计数器"><a href="#8-3组件层级计数器" class="headerlink" title="8.3组件层级计数器"></a>8.3组件层级计数器</h4><p>　　　　目的：避免浮层组件因z-index被覆盖的问题<br>　　　　原因：1&gt;总会遇到意想不到的高层级元素；<br>　　　　　　　2.组件的覆盖规则具有动态性；<br>　　　　做法：通过JS获得body下子元素的最大z-index值</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;转载： &lt;a href=&quot;https://www.cnblogs.com/benbendu/p/5811534.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【CSS深入理解之z-index】听课总结&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>Vue diff</title>
    <link href="http://yoursite.com/2019/10/10/Vue/vue%E4%B9%8Bdiff/"/>
    <id>http://yoursite.com/2019/10/10/Vue/vue之diff/</id>
    <published>2019-10-10T01:19:01.000Z</published>
    <updated>2019-10-10T01:24:53.269Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><ol><li>Virtual DOM不快，只是避免了重大性能损失，Model和View的分离导致Diff本身都不能达到最高效率，Virtual DOM的根本目的只是希望以声明式设计简化乱七八糟的浏览器环境，简化开发。</li><li>响应式的核心是响应Model，所以Model（数据源）更新应该精确更新View。</li></ol><p>v-dom的卖点从来都不是性能，而是以可接受的性能提升开发体验。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>New干了什么</title>
    <link href="http://yoursite.com/2019/09/29/JavaScript/New%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2019/09/29/JavaScript/New干了什么/</id>
    <published>2019-09-29T05:03:16.000Z</published>
    <updated>2019-09-29T05:03:36.202Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转：<br>　　<a href="https://blog.csdn.net/weixin_41910848/article/details/81983740" target="_blank" rel="noopener">js中的new做了什么？</a><br><a href="https://www.jianshu.com/p/35414c2063e8" target="_blank" rel="noopener">new 操作符干了什么</a></p><h4 id="1-案例"><a href="#1-案例" class="headerlink" title="1. 案例"></a>1. 案例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span> () &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sex = sex</span><br><span class="line"> </span><br><span class="line">    this.sayName = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> this.name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var person = new Person(<span class="string">"tom"</span>, 21, <span class="string">"famle"</span>);</span><br><span class="line"> </span><br><span class="line">console.log(person.name);</span><br></pre></td></tr></table></figure><p>　　使用关键字new创建新实例对象经过了以下几步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 创建一个新对象</span><br><span class="line">2. 将新对象的_proto_指向构造函数的prototype对象</span><br><span class="line">3. 将构造函数的作用域赋值给新对象 （也就是this指向新对象）</span><br><span class="line">4. 执行构造函数中的代码（为这个新对象添加属性）</span><br><span class="line">5. 返回新的对象</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var Obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Obj._proto_ =  Person.prototype();</span><br><span class="line">Person.call(Obj);</span><br></pre></td></tr></table></figure><h4 id="2-案例"><a href="#2-案例" class="headerlink" title="2. 案例"></a>2. 案例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person1(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> Person2(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    <span class="built_in">return</span> this.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> Person3(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    <span class="built_in">return</span> new String(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> Person4 (name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> Person5(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    <span class="built_in">return</span> new Array();</span><br><span class="line">&#125;</span><br><span class="line">const person1 = new Person1(<span class="string">"yuer"</span>);//Person1 &#123;name: <span class="string">"yuer"</span>&#125;</span><br><span class="line"></span><br><span class="line">const person2 = new Person2(<span class="string">"yuer"</span>);//Person2 &#123;name: <span class="string">"yuer"</span>&#125;</span><br><span class="line"></span><br><span class="line">const person3 = new Person3(<span class="string">"yuer"</span>);//String &#123;0: <span class="string">"y"</span>, 1: <span class="string">"u"</span>, 2: <span class="string">"e"</span>, 3: <span class="string">"r"</span>, length: 4, [[PrimitiveValue]]: <span class="string">"yuer"</span>&#125;</span><br><span class="line"></span><br><span class="line">const person4 = new Person4(<span class="string">"yuer"</span>);//<span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">const person5 = new Person5(<span class="string">"yuer"</span>);//[]</span><br></pre></td></tr></table></figure><p>这里给出了5个例子，其实new操作符干了以下三步:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.先创建了一个新的空对象</span><br><span class="line">2.然后让这个空对象的__proto__指向函数的原型prototype</span><br><span class="line">3.将对象作为函数的this传进去，如果<span class="built_in">return</span> 出来东西是对象的话就</span><br><span class="line">直接返回 <span class="built_in">return</span> 的内容，没有的话就返回创建的这个对象</span><br></pre></td></tr></table></figure></p><p>对应伪代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于const a = new Foo();，new干了以下事情</span><br><span class="line"></span><br><span class="line">const o = new Object();//创建了一个新的空对象o</span><br><span class="line">o.__proto__ = Foo.prototype;//让这个o对象的` __proto__`指向函数的原型`prototype`</span><br><span class="line">Foo.call(o);//this指向o对象</span><br><span class="line">a = o;//将o对象赋给a对象</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue 之 Mixin理解与使用</title>
    <link href="http://yoursite.com/2019/09/29/Vue/Vue%20%E4%B9%8B%20Mixin%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/09/29/Vue/Vue 之 Mixin理解与使用/</id>
    <published>2019-09-29T01:17:02.000Z</published>
    <updated>2019-09-29T01:40:58.768Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转：<br><a href="https://blog.csdn.net/qq_27460969/article/details/88688073" target="_blank" rel="noopener">【Vue原理】Mixin - 白话版</a><br><a href="https://blog.csdn.net/qq_36838191/article/details/81004590" target="_blank" rel="noopener">Vue 中mixin 的用法详解</a></p><h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>　　说下我对vue中mixin的一点理解<br>　　vue中提供了一种混合机制–<code>mixins</code>，用来更高效的实现组件内容的复用。最开始我一度认为这个和组件好像没啥区别。。后来发现错了。下面我们来看看mixins和普通情况下引入组件有什么区别？<br>　　组件在引用之后相当于在父组件内开辟了一块单独的空间，来根据父组件props过来的值进行相应的操作，单本质上两者还是泾渭分明，相对独立。<br>　　而<code>mixins</code>则是在引入组件之后，则是<code>将组件内部的内容如data等方法、method等属性与父组件相应内容进行合并</code>。相当于在引入后，父组件的各种属性方法都被扩充了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单纯组件引用：</span><br><span class="line">　　父组件 + 子组件 &gt;&gt;&gt; 父组件 + 子组件</span><br><span class="line">mixins：</span><br><span class="line">　　父组件 + 子组件 &gt;&gt;&gt; new父组件</span><br></pre></td></tr></table></figure><p>　　作用：<code>多个组件可以共享数据和方法，在使用mixin的组件中引入后，mixin中的方法和属性也就并入到该组件中，可以直接使用。钩子函数会两个都被调用，mixin中的钩子首先执行</code>。</p><h4 id="什么时候合并"><a href="#什么时候合并" class="headerlink" title="什么时候合并"></a>什么时候合并</h4><p>　　什么是全局选项？ 就是 全局组件，全局过滤器，全局指令，全局mixin<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、Vue.component 注册的 【全局组件】</span><br><span class="line">2、Vue.filter 注册的 【全局过滤器】</span><br><span class="line">3、Vue.directive 注册的 【全局指令】</span><br><span class="line">4、Vue.mixin 注册的 【全局mixin】</span><br></pre></td></tr></table></figure></p><p>　　也就是说，你全局注册的选项，其实会被传递引用到你的每个组件中，这样，全局选项 和 组件选项 就会合并起来，之后组件便能访问到全局选项，然后你就可以在组件内使用全局注册的选项，比如使用 全局过滤器<br>　　其实就是像你在 自己的组件声明 components 一样，只是全局注册的话，Vue 背后偷偷给你的每个组件 都合并多一个全局选项的引用<br>　　但是为了保证全局选项不被污染，又不可能每个组件都深度克隆一份全局选项导致开销过大，所以会根据不同的选项，做不同的处理。下面会详细讲解</p><h4 id="怎么合并"><a href="#怎么合并" class="headerlink" title="怎么合并"></a>怎么合并</h4><h5 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h5><p>1、组件选项</p><p>2、组件 - mixin</p><p>3、组件 - mixin - mixin</p><p>4、…省略无数可能存在的嵌套 mixin</p><p>x、全局 选项</p><p>权重 从 1 到最后 依次减少</p><p>其实没有权重这个东西，但是结果是一样的，是我觉得这样好理解，加上的一个概念</p><p>下面的讲解，会使用 四种选项代号 作为例子</p><p>　　<code>mixin</code> 里面嵌套<code>mixin</code> 太深 很少见，而且也 难以维护，所以就只嵌套一层为例</p><p>1、组件选项：代号为 A</p><p>2、组件-mixin：代号为 B</p><p>3、组件-mixin-mixin ：代号为 C</p><p>4、全局选项 ：代号为 D</p><h6 id="1、函数合并叠加"><a href="#1、函数合并叠加" class="headerlink" title="1、函数合并叠加"></a>1、函数合并叠加</h6><p>包括选项：<code>data，provide</code></p><p>把两个函数合并加到一个新函数中，并返回这个函数。在函数里面，会执行 那两个方法。</p><p>按照这个流程，使用代号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、D 和 C 合并成一个函数 (CD)，函数执行时，会执行 C ，再执行 D</span><br><span class="line"></span><br><span class="line">2、(CD) 和 B 合并成 一个函数 (B(CD))，函数执行时，会执行 B ，再执行 (CD)</span><br><span class="line"></span><br><span class="line">3、(B(CD)) 和 A 合并成一个函数，函数执行时，会执行 B ，再执行 (B(CD))</span><br><span class="line"></span><br><span class="line">有点绕，简化执行流程是： A-&gt;B-&gt;C-&gt;D</span><br></pre></td></tr></table></figure></p><p>　　data 中数据有重复的，权重大的优先，比如下面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var test_mixins=&#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span>()&#123;        </span><br><span class="line">        <span class="built_in">return</span> &#123;name:34&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a=new Vue(&#123;    </span><br><span class="line">    mixins:[test_mixins],</span><br><span class="line">    <span class="function"><span class="title">data</span></span>()&#123;        </span><br><span class="line">        <span class="built_in">return</span> &#123;name:12&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>　　可以看到，mixin 和 组件本身 的 data 都有 name 这个数据，很显然会以组件本身的为主，因为组件本身权重大</p><h6 id="2、数组叠加"><a href="#2、数组叠加" class="headerlink" title="2、数组叠加"></a>2、数组叠加</h6><p>生命周期函数</p><p>权重越大的越放后面，会合并成一个数组，比如created</p><p>[<br>    全局 mixin - created，<br>    组件 mixin-mixin - created，<br>    组件 mixin - created，<br>    组件 options - created<br>]</p><p>执行流程是 </p><blockquote><p>全局mixin-created -&gt; 组件mixin-mixin-created -&gt; 组件mixin-created -&gt; 组件options-created</p></blockquote><p>生命周期，权重小的 先执行</p><p>watch<br>合并成一个下面这样的数组，权重越大的越放后面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ </span><br><span class="line">    全局 mixin - watch，</span><br><span class="line">    组件 mixin-mixin - watch，</span><br><span class="line">    组件 mixin - watch，</span><br><span class="line">    组件 options - watch </span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>执行流程是</p><blockquote><p>全局mixin-watch -&gt;组件mixin-mixin-watch -&gt; 组件mixin-watch -&gt; 组件options-watch</p></blockquote><p>监听回调，权重小的 先执行</p><h6 id="3、原型叠加"><a href="#3、原型叠加" class="headerlink" title="3、原型叠加"></a>3、原型叠加</h6><p>包括选项：<code>components，filters，directives</code></p><p>两个对象合并的时候，不会相互覆盖，而是 权重小的 被放到 权重大 的 的原型上</p><p>这样权重大的，访问快些，因为作用域链短了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.__proto__ = B  </span><br><span class="line">B.__proto__ = C  </span><br><span class="line">C.__proto__ = D</span><br></pre></td></tr></table></figure></p><p>两个对象合并的时候，不会</p><p>以 filter 为例，下面是四种 filter 合并<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 全局 filter</span><br><span class="line">Vue.filter(<span class="string">"global_filter"</span>,<span class="keyword">function</span> (params) &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// mixin 的 mixin</span><br><span class="line">var mixin_mixin=&#123;    </span><br><span class="line">    filters:&#123;</span><br><span class="line">        <span class="function"><span class="title">mixin_mixin_filter</span></span>()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// mixin filter</span><br><span class="line">var test_mixins=&#123;    </span><br><span class="line">    filters:&#123;</span><br><span class="line">        <span class="function"><span class="title">mixin_filter</span></span>()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 组件 filter</span><br><span class="line">var a=new Vue(&#123;    </span><br><span class="line">    mixins:[test_mixins],    </span><br><span class="line">    filters:&#123;</span><br><span class="line">        <span class="function"><span class="title">self_filter</span></span>()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>结果就系这样…</p><p>4、覆盖叠加<br>包括选项：<code>props，methods，computed，inject</code></p><p>两个对象合并，如果有重复key，权重大的覆盖权重小的</p><p>比如<br>　　组件的 <code>props：{ name:&quot;&quot;}</code><br>　　组件mixin 的 <code>props：{ name:&quot;&quot;, age: “” }</code><br>那么 把两个对象合并，有相同属性，以 权重大的为主，组件的 name 会替换 mixin 的name</p><p>5、直接替换<br>　　这是默认的处理方式，当选项不属于上面的处理方式的时候，就会像这样处理，包含选项：el，template，propData 等<br>　　两个数据只替换，不合并，权重大的，会一直替换 权重小的，因为这些属于只允许存在一个，所有只使用权重大的选项<br>　　组件 设置 template，mixin 也设置 template，不用怕，组件的肯定优先<br>　　这个好像跟 覆盖叠加 很像，其实不一样，覆盖叠加会把两个数据合并，重复的才覆盖。而这个不会合并，直接替换掉整个选项</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序和H5区别</title>
    <link href="http://yoursite.com/2019/09/29/H5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8CH5%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/09/29/H5/微信小程序和H5区别/</id>
    <published>2019-09-29T00:30:01.000Z</published>
    <updated>2019-09-29T01:08:35.346Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转：<br><a href="https://www.cnblogs.com/wxcbg/p/10538997.html" target="_blank" rel="noopener">微信小程序开发和h5的区别</a><br><a href="https://blog.csdn.net/freekiteyu/article/details/84316183" target="_blank" rel="noopener">小程序 与 App 与 H5 之间的区别</a></p><h2 id="微信小程序和H5区别"><a href="#微信小程序和H5区别" class="headerlink" title="微信小程序和H5区别"></a>微信小程序和H5区别</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><table><thead><tr><th style="text-align:left">HTML</th><th style="text-align:left">微信小程序</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;div&gt;&lt;/div&gt;</code></td><td style="text-align:left"><code>&lt;view&gt;&lt;/view&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;h1&gt;&lt;/h1&gt;...&lt;h6&gt;&lt;/h6&gt;  &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt;</code></td><td style="text-align:left"><code>&lt;view&gt;&lt;/view&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;i class=&quot;icon&quot;&gt;&lt;/i&gt;</code></td><td style="text-align:left"><code>&lt;icon&gt;&lt;/icon&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;input type=&quot;text&quot;&gt;</code></td><td style="text-align:left"><code>&lt;input/&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;input type=&quot;checkbox&quot;&gt;</code></td><td style="text-align:left"><code>&lt;checkbox/&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;input type=&quot;radio&quot;&gt;</code></td><td style="text-align:left"><code>&lt;radio/&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;input type=&quot;file&quot;&gt;</code></td><td style="text-align:left"><code>&lt;view bindtab=&quot;chooseImage&quot;&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code></td><td style="text-align:left"><code>&lt;navigator url=&quot;#&quot; redirect&gt;&lt;/navigator&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;img src=&quot;&quot;&gt;</code></td><td style="text-align:left"><code>&lt;image src=&quot;&quot;&gt;&lt;/image&gt;</code></td></tr></tbody></table><h3 id="开发注意"><a href="#开发注意" class="headerlink" title="开发注意"></a>开发注意</h3><ol><li>开发小程序时，每个页面一定要在app.json文件中注册，页面文件夹和其包含的四个文件的名字要保持一致。</li><li>小程序发起的都是HTTPS网络请求，在开发调试的过程中可以不校验协议和TLS版本，但在实际上线后必须进行HTTPS协议通信。</li><li>小程序可以进行组件化开发以及数据绑定，所有对于DOM的操作都是基于数据驱动的，并没有直接进行DOM操作的做法，换言之，小程序内没有document对象，原生js和jQuery里的DOM操作思维要舍弃掉。</li><li>小程序的网络请求wx.request()是不自带Cookies的，这和浏览器上的网络请求不同，因此基于Cookies实现的会话管理不适用于小程序。</li><li>小程序的脚本文件中，内置对象是page，而非传统浏览器里的window，因此所有基于window对象来写的库(例如jQuery)都不适用于小程序。</li><li>小程序提供模板功能，模板拥有自己的作用域，它只能使用从data属性传入的数据。</li><li>每一个页面文件夹下的.json文件是用来写配置项的，如果该页面无需添加相关配置，.json文件也要写上一对大括号（“{ }”），否则会报错。</li><li>在同一个tab里的页面可以跳转，并且允许携带参数。不同tab的页面之间无法跳转，使用wx.navigateTo()接口会报错。同时，tab之间的跳转可以用wx.switchTab()实现，但是路径后不能带参数。</li><li>脚本文件里data的数据，在更新的时候要通过this.setData()方法来更新，而不能直接用“=”来做。</li><li>在组件标签里，可以通过“data-属性值”的方式绑定我们需要的数据，然后在事件内置event对象里进行获取。</li><li>小程序里也存在事件的冒泡，具体的冒泡事件可以参考官方文档，如果希望事件向上冒泡，则使用bind来绑定事件，若希望阻止事件冒泡，就使用catch来进行事件绑定。</li><li>小程序支持文件引用，有import和include两种方式，import有作用域，也就是引入的目标文件里import的模板不会被引入；而include等于是将目标文件除<template>以外的整个代码进行引入。</template></li><li>wx.login()和wx.getUserInfo()是两个独立的接口，前者可以实现用户登录，这个过程是悄无声息的，不需要用户授权，登录后可以拿到用户的openid和session_key；而wx.getUserInfo()可以拿到用户的具体信息，这个过程需要获得用户的授权，开发时也必须考虑用户拒绝授权的场景。</li><li>目前小程序可以分享给微信好友和微信群，但小程序默认是没有这个功能的，只有在Page里定义了onShareAppMessage事件处理函数，点击小程序右上角才可以看到分享按钮。</li><li>微信小程序还在不断的成长中，定期会有相关的API修改和增加、以及废弃，开发者需要及时关注每一次重大的版本更新，同时对于一些新出的API要进行兼容处理，考虑兼容的场景，因为某些API只在高版本的微信app里有效。</li></ol><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p>　　微信小程序就是微信支持的一种第三方插件，微信向这种第三方插件开放了更多的功能接口，从丰富的界面控制到多种框架，特别合适提供了更多的对移动设备的访问能力。　</p><h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><p>　　原生 App 直接运行在操作系统的单独进程中（在 Android 中还可以开启多进程），而小程序只能运行在微信的进程中。<br>开发成本<br>　　原生 App 的开发涉及到 Android/iOS 多个平台、开发工具、开发语言、不同设备的适配等问题；而小程序只需要开发一个就可以在 Android/iOS 等不同平台不同设备上运行。<br>　　原生 App 需要在商店上架（Android 需要上架各种商店）；小程序只能在微信平台发布。</p><h4 id="系统权限"><a href="#系统权限" class="headerlink" title="系统权限"></a>系统权限</h4><p>　　原生 App 调用的是系统资源，也就是说系统提供给开发的的 API 都可以使用；而小程序是基于微信的，小程序所有的功能都受限于微信，也就是说微信给开发者提供 API 才可以使用，不能绕过微信直接使用系统提供的 API。<br>　　原生 App 可以给用户推送消息；小程序不允许主动给用户发送消息，只能回复模版消息 。<br>　　原生 App 有独立的数据库，可以做离线存储；小程序只能存储到 LocalStorage，无法做离线存储。<br>　　原生 App 需要下载，安装包比较大；小程序无需下载，可以通过小程序码等方式通过微信直接打开。</p><h4 id="运行流畅度"><a href="#运行流畅度" class="headerlink" title="运行流畅度"></a>运行流畅度</h4><p>　　原生 App 运行在操作系统中，所有的原生组件可以直接调用 GPU 进行渲染；而小程序运行在微信的进程中，只能通过 WebView 进行渲染。<br>小程序与 H5 的区别</p><h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><p>　　H5是由W3C做的一个开放标准规范，小程序是腾讯自己的封闭规范。</p><h4 id="运行环境-1"><a href="#运行环境-1" class="headerlink" title="运行环境"></a>运行环境</h4><p>　　简单来说，小程序是一种应用，运行的环境是微信（App）；H5 是一种技术，依附的外壳是是浏览器。<br>H5 的运行环境是浏览器，包括 WebView，而微信小程序的运行环境并非完整的浏览器，因为小程序的开发过程中只用到一部分H5 技术。<br>小程序的运行环境是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对性做了优化，配合自己定义的开发语言标准，提升了小程序的性能。<br>　　小程序中无法使用浏览器中常用的 window 对象和 document 对象，H5 可以随意使用。</p><h4 id="开发成本"><a href="#开发成本" class="headerlink" title="开发成本"></a>开发成本</h4><p>　　H5 的开发，涉及开发工具（vscode、Atom等）、前端框架（Angular、react等）、模块管理工具（Webpack 、Browserify 等）、任务管理工具（Grunt、Gulp等），还有 UI 库选择、接口调用工具（ajax、Fetch Api等）、浏览器兼容性等等。<br>尽管这些工具可定制化非常高，大部分开发者也有自己的配置模板，但对于项目中各种外部库的版本迭代、版本升级，这些成本加在一起那就是个不小数目了。<br>　　而开发一个微信小程序，由于微信团队提供了开发者工具，并且规范了开发标准，则简单得多。前端常见的 HTML、CSS 变成了微信自定义的 WXML、WXSS，官方文档中都有明确的使用介绍，开发者按照说明专注写程序就可以了。<br>需要调用后端接口时，调用发起请求API；需要上传下载时，调用上传下载API；需要数据缓存时，调用本地存储API；引入地图、使用罗盘、调用支付、调用扫码等等功能都可以直接使用；UI 库方面，框架带有自家 weui 库加成。<br>并且在使用这些 API 时，不用考虑浏览器兼容性，不用担心出现 BUG，显而易见微信小程序的开发成本相对低很多。</p><h4 id="系统权限-1"><a href="#系统权限-1" class="headerlink" title="系统权限"></a>系统权限</h4><p>　　获取到的权限不一样，H5作为一个网页，被封闭在浏览器这个沙箱内。但是微信可以赋予微信小程序更多特殊权限，比如录音，视频，罗盘，扫一扫，模板消息，客服消息，分享等，这些都是和微信无缝衔接的。在微信里，微信小程序毫无疑问要比H5的体验好很多，除了不能支持长按识别二维码外。<br>而这一点恰巧是 H5 被诟病的地方，这也是 H5 的大多应用场景被定位在业务逻辑简单、功能单一的原因。</p><h4 id="运行流畅度-1"><a href="#运行流畅度-1" class="headerlink" title="运行流畅度"></a>运行流畅度</h4><p>　　这条无论对于用户还是开发者来说，都是最直观的感受。长久以来，当HTML5应用面对复杂的业务逻辑或者丰富的页面交互时，它的体验总是不尽人意，需要不断的对项目优化来提升用户体验。但是由于微信小程序运行环境独立，尽管同样用 HTML +CSS + JS 去开发，但配合微信的解析器最终渲染出来的是原生组件的效果，自然体验上将会更进一步。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>vue-router 使用方法及实现原理</title>
    <link href="http://yoursite.com/2019/09/27/Vue/vue-router%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/27/Vue/vue-router使用及实现原理/</id>
    <published>2019-09-27T10:40:21.000Z</published>
    <updated>2019-10-08T01:37:45.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载： <a href="https://segmentfault.com/a/1190000018584560" target="_blank" rel="noopener">vue-router实现原理</a><br><a href="https://www.cnblogs.com/tiedaweishao/p/9144531.html" target="_blank" rel="noopener">前端路由简介以及vue-router实现原理</a><br><a href="https://www.cnblogs.com/JRliu/p/9025290.html" target="_blank" rel="noopener">前端路由的两种模式： hash 模式和 history 模式</a></p><h3 id="路由简介"><a href="#路由简介" class="headerlink" title="路由简介"></a>路由简介</h3><h4 id="后端路由简介"><a href="#后端路由简介" class="headerlink" title="后端路由简介"></a>后端路由简介</h4><p>　　路由这个概念最先是后端出现的。在以前用模板引擎开发页面时，经常会看到这样</p><blockquote><p><a href="http://www.xxx.com/login" target="_blank" rel="noopener">http://www.xxx.com/login</a></p></blockquote><p>大致流程可以看成这样：<br>　　浏览器发出请求<br>　　服务器监听到80端口（或443）有请求过来，并解析url路径<br>　　根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）<br>　　浏览器根据数据包的 Content-Type 来决定如何解析数据</p><p>　　简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。</p><h4 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h4><h4 id="前端路由的主要功能"><a href="#前端路由的主要功能" class="headerlink" title="前端路由的主要功能"></a>前端路由的主要功能</h4><h5 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h5><ol><li>记录当前页面的状态（保存或分享当前页的url，再次打开该url时，网页还是保存（分享）时的状态）；</li><li>可以使用浏览器的前进后退功能（如点击后退按钮，可以使页面回到使用ajax更新页面之前的状态，url也回到之前的状态）；</li></ol><h5 id="开发者"><a href="#开发者" class="headerlink" title="开发者"></a>开发者</h5><ol><li>改变url且不让浏览器向服务器发出请求；</li><li>监测 url 的变化；</li><li>截获 url 地址，并解析出需要的信息来匹配路由规则。</li></ol><h4 id="1-hash-模式"><a href="#1-hash-模式" class="headerlink" title="1. hash 模式"></a>1. hash 模式</h4><p>　　随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。<br>　　类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。但是这样存在一个问题，就是 url 每次变化的时候，都会造成页面的刷新。那解决问题的思路便是在改变 url 的情况下，保证页面的不刷新。在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：</p><blockquote><p><a href="http://www.xxx.com/#/login" target="_blank" rel="noopener">http://www.xxx.com/#/login</a></p></blockquote><p>　　这种<code>#</code>。后面<code>hash</code>值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 <code>hash</code> 值的变化，还会触发<code>hashchange</code> 这个事件，通过这个事件我们就可以知道 <code>hash</code> 值发生了哪些变化。然后我们便可以监听 <code>hashchange</code> 来实现更新页面部分内容的操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">matchAndUpdate</span></span> () &#123;</span><br><span class="line">   // todo 匹配 <span class="built_in">hash</span> 做 dom 更新操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">'hashchange'</span>, matchAndUpdate)</span><br></pre></td></tr></table></figure></p><p>使用到的api：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.location.hash = <span class="string">'qq'</span> // 设置 url 的 <span class="built_in">hash</span>，会在当前url后加上 <span class="string">'#qq'</span></span><br><span class="line"></span><br><span class="line">var <span class="built_in">hash</span> = window.location.hash // <span class="string">'#qq'</span>  </span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">'hashchange'</span>, <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">    // 监听<span class="built_in">hash</span>变化，点击浏览器的前进后退会触发</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>　　vue-router默认hash模式，使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</p><h4 id="2-history-模式"><a href="#2-history-模式" class="headerlink" title="2. history 模式"></a>2. history 模式</h4><p>　　14年后，因为 <code>HTML5</code> 准发布。多了两个 <code>API</code>，<code>pushState</code> 和 <code>replaceState</code>，通过这两个 <code>API</code> 可以改变 <code>url</code> 地址且不会发送请求。同时还有 <code>popstate</code> 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 <code>HTML5</code> 的实现，单页路由的 url 就不会多出一个<code>#</code>，变得更加美观。<code>但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求</code>。<code>为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。</code><br>　　已经有 hash 模式了，而且 hash 能兼容到IE8， history 只能兼容到 IE10，为什么还要搞个 history 呢？<br>首先，<code>hash 本来是拿来做页面定位的，如果拿来做路由的话，原来的锚点功能就不能用了</code>。其次，<code>hash 的传参是基于 url 的，如果要传递复杂的数据，会有体积的限制，而 history 模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">matchAndUpdate</span></span> () &#123;</span><br><span class="line">   // todo 匹配路径 做 dom 更新操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">'popstate'</span>, matchAndUpdate)</span><br></pre></td></tr></table></figure><p>相关API：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(state, title, url) </span><br><span class="line">// state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取</span><br><span class="line">// title：标题，基本没用，一般传 null</span><br><span class="line">// url：设定新的历史记录的 url。新的 url 与当前 url 的 origin 必须是一樣的，否则会抛出错误。url可以是绝对路径，也可以是相对路径。</span><br><span class="line">//如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, <span class="string">'./qq/'</span>)，则变成 https://www.baidu.com/a/qq/，</span><br><span class="line">//执行history.pushState(null, null, <span class="string">'/qq/'</span>)，则变成 https://www.baidu.com/qq/</span><br><span class="line"></span><br><span class="line">window.history.replaceState(state, title, url)</span><br><span class="line">// 与 pushState 基本相同，但她是修改当前历史记录，而 pushState 是创建新的历史记录</span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">"popstate"</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    // 监听浏览器前进后退事件，pushState 与 replaceState 方法不会触发              </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">window.history.back() // 后退</span><br><span class="line">window.history.forward() // 前进</span><br><span class="line">window.history.go(1) // 前进一步，-2为后退两步，window.history.lengthk可以查看当前历史堆栈中页面的数量</span><br></pre></td></tr></table></figure></p><p>　　<code>history</code> 模式改变 <code>url</code> 的方式会导致浏览器向服务器发送请求，这不是我们想看到的，我们需要在服务器端做处理：<code>如果匹配不到任何静态资源，则应该始终返回同一个 html 页面</code>。</p><h3 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h5><h6 id="使用router的name属性也就是params来传递参数"><a href="#使用router的name属性也就是params来传递参数" class="headerlink" title="使用router的name属性也就是params来传递参数"></a>使用router的name属性也就是params来传递参数</h6><p>这个方法有一个bug就是当你传参过去的时候，再次刷新页面时参数就会丢失。解决方法下边会说到。</p><p>　　step:1,首先需要在router/index.js里边配置每个页面的路径，name属性，看例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import Router from <span class="string">'vue-router'</span></span><br><span class="line">const _import = require(<span class="string">'./_import_'</span> + process.env.NODE_ENV)</span><br><span class="line">Vue.use(Router)</span><br><span class="line"><span class="built_in">export</span> const constantRouterMap = [&#123;</span><br><span class="line">        path: <span class="string">'/login/:userId/:id'</span>,</span><br><span class="line">        name:<span class="string">'Message'</span>,    //就是要在路由配置里边配置这个属性，用来知道你要跳转到那个页面的名字</span><br><span class="line">    /***</span><br><span class="line">     * 如果想做到页面刷新，参数不丢失，就必须在path后面加上这个参数</span><br><span class="line">     * 但是这样做的话就会导致参数显示在url的后面，（在这一点上）跟query没什么区别了。</span><br><span class="line">    *  多个参数也可以一直往后边追加</span><br><span class="line">     */</span><br><span class="line">        component: _import(<span class="string">'login/index'</span>),</span><br><span class="line">        hidden: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">''</span>,</span><br><span class="line">        component: Layout,</span><br><span class="line">        redirect: <span class="string">'dashboard'</span>,</span><br><span class="line">        icon: <span class="string">'dashboard'</span>,</span><br><span class="line">        hidden: <span class="literal">true</span>,</span><br><span class="line">        noDropDown: <span class="literal">true</span>,</span><br><span class="line">        children: [&#123;</span><br><span class="line">            path: <span class="string">'dashboard'</span>,</span><br><span class="line">            name: <span class="string">'首页'</span>,</span><br><span class="line">            component: _import(<span class="string">'main/index'</span>),</span><br><span class="line">            meta: &#123;</span><br><span class="line">                title: <span class="string">'dashboard'</span>,</span><br><span class="line">                icon: <span class="string">'dashboard'</span>,</span><br><span class="line">                noCache: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default new Router(&#123;</span><br><span class="line">    routes: constantRouterMap</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>　　step:2,在传值页面的写法：<br>//用这种方法传参，必须这么些，不能写path,否则你在取参数的时候this.$router.params.userId就是undefined.这是因为，params只能用name来引入路由，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="variable">$router</span>.push(&#123;</span><br><span class="line">    name:<span class="string">"'Message'"</span>,//这个name就是你刚刚配置在router里边的name</span><br><span class="line">    params:&#123;</span><br><span class="line">          userId:<span class="string">"10011"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>　　step:3,在取值页面的写法：<br>切记，再取参数的时候一定是this.route 不是 this.router，切记。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$route.params.userId</span><br></pre></td></tr></table></figure></p><h6 id="使用query来传递参数"><a href="#使用query来传递参数" class="headerlink" title="使用query来传递参数"></a>使用query来传递参数</h6><p>　　step:1,在传值页面的写法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="variable">$router</span>.push(&#123;</span><br><span class="line">    path:<span class="string">"/login"</span>,//这个path就是你在router/index.js里边配置的路径</span><br><span class="line">    query:&#123;</span><br><span class="line">          userId:<span class="string">"10011"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>　　step:2,在取值页面的写法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">this.<span class="variable">$router</span>.currentRoute.query.userId</span><br><span class="line">第二种：</span><br><span class="line">这种方法再取参数的时候一定是this.<span class="variable">$route</span>   不是   this.<span class="variable">$router</span>，切记。</span><br><span class="line">this.<span class="variable">$route</span>.query.userId</span><br></pre></td></tr></table></figure></p><h6 id="使用vue里的标签来传递参数"><a href="#使用vue里的标签来传递参数" class="headerlink" title="使用vue里的标签来传递参数"></a>使用vue里的<router-link>标签来传递参数</router-link></h6><p>　　step:1,在传值页面的写法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link target=<span class="string">"_blank"</span></span><br><span class="line">   :to=<span class="string">"&#123;path:'/login',query:&#123;userId: "</span>33333<span class="string">"&#125;&#125;"</span>&gt;</span><br><span class="line"> &lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p><p>　　step:2,在取值页面的写法：同第二种。<br>其实，router-link也可以使用name的方法传参<br>　　同样，这种方法也需要在<code>router/index.js</code>里边配置每个页面的路径，name属性<br><code>name:&#39;Message&#39;</code>,    //就是要在路由配置里边配置这个属性，用来知道你要跳转到那个页面的名字<br><code>&lt;router-link :to=&quot;{name:&#39;&#39;Message&#39;&#39;,params:{userId:&#39;1234&#39;}}&quot;&gt;Hi页面1&lt;/router-link&gt;</code><br>取参方法：<br><code>this.$route.params.userId</code></p><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><p><code>更新视图但不重新请求页面</code><br>　　vue-router实现单页面路由跳转，提供了三种方式：hash模式、history模式、abstract模式，根据mode参数来决定采用哪一种方式。</p><h5 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h5><p>vue-router 提供了三种运行模式：<br>　　● hash: 使用 URL hash 值来作路由。默认模式。<br>　　● history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。<br>　　● abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端</p><h6 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h6><p>　　hash即浏览器url中#后面的内容，包含#。hash是URL中的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会加载相应位置的内容，不会重新加载页面。<br>也就是说<br>　　1. 即#是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中，不包含#。<br>　　2.每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置。</p><p>所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。</p><h6 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h6><p>　　<code>HTML5 History API</code>提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 <code>history.pushState API</code> 来完成 URL 跳转而无须重新加载页面；<br>　　由于hash模式会在url中自带#，如果不想要很丑的 <code>hash</code>，我们可以用路由的 <code>history</code> 模式，只需要在配置路由规则时，加入”<code>mode</code>: ‘<code>history</code>‘“,这种模式充分利用 <code>history.pushState API</code> 来完成 <code>URL</code> 跳转而无须重新加载页面。<br>　　有时，history模式下也会出问题：<br>eg:<br>hash模式下：<code>xxx.com/#/id=5</code> 请求地址为 <code>xxx.com</code>,没有问题。<br>history模式下：<code>xxx.com/id=5</code> 请求地址为 <code>xxx.com/id=5</code>，如果后端没有对应的路由处理，就会返回404错误；<br>　　为了应对这种情况，需要后台配置支持：<br>在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 <code>index.html</code> 页面，这个页面就是你 app 依赖的页面。</p><h6 id="abstract模式"><a href="#abstract模式" class="headerlink" title="abstract模式"></a>abstract模式</h6><p>　　abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。<br>根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 （当然，你也可以明确指定在所有情况下都使用 abstract 模式）。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>我们来看一下<code>vue-router</code>是如何定义的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from <span class="string">'vue-router'</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>　　可以看出来vue-router是通过 Vue.use的方法被注入进 Vue 实例中，在使用的时候我们需要全局用到 vue-router的router-view和router-link组件，以及this.$router/$route这样的实例对象。那么是如何实现这些操作的呢？下面我会分几个章节详细的带你进入vue-router的世界。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vue-router 实现 -- install</span><br><span class="line">vue-router 实现 -- new VueRouter(options)</span><br><span class="line">vue-router 实现 -- HashHistory</span><br><span class="line">vue-router 实现 -- HTML5History</span><br><span class="line">vue-router 实现 -- 路由变更监听</span><br></pre></td></tr></table></figure></p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>　　经过上面的阐述，相信您已经对前端路由以及vue-router有了一些大致的了解。那么这里我们为了贯彻无解肥，我们来手把手撸一个下面这样的数据驱动的 router：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">new Router(&#123;</span><br><span class="line">  id: <span class="string">'router-view'</span>, // 容器视图</span><br><span class="line">  mode: <span class="string">'hash'</span>, // 模式</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'home'</span>,</span><br><span class="line">      component: <span class="string">'&lt;div&gt;Home&lt;/div&gt;'</span>,</span><br><span class="line">      beforeEnter: (next) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'before enter home'</span>)</span><br><span class="line">        next()</span><br><span class="line">      &#125;,</span><br><span class="line">      afterEnter: (next) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'enter home'</span>)</span><br><span class="line">        next()</span><br><span class="line">      &#125;,</span><br><span class="line">      beforeLeave: (next) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'start leave home'</span>)</span><br><span class="line">        next()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/bar'</span>,</span><br><span class="line">      name: <span class="string">'bar'</span>,</span><br><span class="line">      component: <span class="string">'&lt;div&gt;Bar&lt;/div&gt;'</span>,</span><br><span class="line">      beforeEnter: (next) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'before enter bar'</span>)</span><br><span class="line">        next()</span><br><span class="line">      &#125;,</span><br><span class="line">      afterEnter: (next) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'enter bar'</span>)</span><br><span class="line">        next()</span><br><span class="line">      &#125;,</span><br><span class="line">      beforeLeave: (next) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'start leave bar'</span>)</span><br><span class="line">        next()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      name: <span class="string">'foo'</span>,</span><br><span class="line">      component: <span class="string">'&lt;div&gt;Foo&lt;/div&gt;'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h6 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h6><p>　　首先是数据驱动，所以我们可以通过一个route对象来表述当前路由状态，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">current = &#123;</span><br><span class="line">    path: <span class="string">'/'</span>, // 路径</span><br><span class="line">    query: &#123;&#125;, // query</span><br><span class="line">    params: &#123;&#125;, // params</span><br><span class="line">    name: <span class="string">''</span>, // 路由名</span><br><span class="line">    fullPath: <span class="string">'/'</span>, // 完整路径</span><br><span class="line">    route: &#123;&#125; // 记录当前路由属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　current.route内存放当前路由的配置信息，所以我们只需要监听current.route的变化来动态render页面便可。<br>接着我么需要监听不同的路由变化，做相应的处理。以及实现hash和history模式。</p><h6 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h6><p>　　这里我们延用vue数据驱动模型，实现一个简单的数据劫持，并更新视图。首先定义我们的observer<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">class Observer &#123;</span><br><span class="line">  constructor (value) &#123;</span><br><span class="line">    this.walk(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk (obj) &#123;</span><br><span class="line">    Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class="line">      // 如果是对象，则递归调用walk，保证每个属性都可以被defineReactive</span><br><span class="line">      <span class="keyword">if</span> (typeof obj[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">        this.walk(obj[key])</span><br><span class="line">      &#125;</span><br><span class="line">      defineReactive(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> defineReactive(obj, key, value) &#123;</span><br><span class="line">  <span class="built_in">let</span> dep = new Dep()</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    get: () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        // 依赖收集</span><br><span class="line">        dep.add()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: (newValue) =&gt; &#123;</span><br><span class="line">      value = newValue</span><br><span class="line">      // 通知更新，对应的更新视图</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> observer(value) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Observer(value)</span><br><span class="line">&#125;</span><br><span class="line">再接着，我们需要定义Dep和Watcher:</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> class Dep &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span> () &#123;</span><br><span class="line">    this.deppend = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">add</span></span> () &#123;</span><br><span class="line">    // 收集watcher</span><br><span class="line">    this.deppend.push(Dep.target)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span></span> () &#123;</span><br><span class="line">    this.deppend.forEach((target) =&gt; &#123;</span><br><span class="line">      // 调用watcher的更新函数</span><br><span class="line">      target.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.target = null</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> setTarget (target) &#123;</span><br><span class="line">  Dep.target = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">cleanTarget</span></span>() &#123;</span><br><span class="line">  Dep.target = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Watcher</span><br><span class="line"><span class="built_in">export</span> class Watcher &#123;</span><br><span class="line">  constructor (vm, expression, callback) &#123;</span><br><span class="line">    this.vm = vm</span><br><span class="line">    this.callbacks = []</span><br><span class="line">    this.expression = expression</span><br><span class="line">    this.callbacks.push(callback)</span><br><span class="line">    this.value = this.getVal()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getVal</span></span> () &#123;</span><br><span class="line">    setTarget(this)</span><br><span class="line">    // 触发 get 方法，完成对 watcher 的收集</span><br><span class="line">    <span class="built_in">let</span> val = this.vm</span><br><span class="line">    this.expression.split(<span class="string">'.'</span>).forEach((key) =&gt; &#123;</span><br><span class="line">      val = val[key]</span><br><span class="line">    &#125;)</span><br><span class="line">    cleanTarget()</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更新动作</span><br><span class="line">  <span class="function"><span class="title">update</span></span> () &#123;</span><br><span class="line">    this.callbacks.forEach((cb) =&gt; &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　到这里我们实现了一个简单的订阅-发布器，所以我们需要对<code>current.route</code>做数据劫持。一旦<code>current.route</code>更新，我们可以及时的更新当前页面：</p><p>  // 响应式数据劫持<br>  <code>observer(this.current)</code></p><p>  // 对 current.route 对象进行依赖收集，变化时通过 render 来更新<br>  <code>new Watcher(this.current, &#39;route&#39;, this.render.bind(this))</code><br>恩….到这里，我们似乎已经完成了一个简单的响应式数据更新。其实render也就是动态的为页面指定区域渲染对应内容，这里只做一个简化版的render:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> i</span><br><span class="line">  <span class="keyword">if</span> ((i = this.history.current) &amp;&amp; (i = i.route) &amp;&amp; (i = i.component)) &#123;</span><br><span class="line">    document.getElementById(this.container).innerHTML = i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="hash-和-history"><a href="#hash-和-history" class="headerlink" title="hash 和 history"></a>hash 和 history</h6><p>　　接下来是hash和history模式的实现，这里我们可以沿用vue-router的思想，建立不同的处理模型便可。来看一下我实现的核心代码：<br><code>this.history = this.mode === &#39;history&#39; ? new HTML5History(this) : new HashHistory(this)</code><br>当页面变化时，我们只需要监听hashchange和popstate事件，做路由转换transitionTo:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 路由转换</span><br><span class="line">   * @param target 目标路径</span><br><span class="line">   * @param cb 成功后的回调</span><br><span class="line">   */</span><br><span class="line">  transitionTo(target, cb) &#123;</span><br><span class="line">    // 通过对比传入的 routes 获取匹配到的 targetRoute 对象</span><br><span class="line">    const targetRoute = match(target, this.router.routes)</span><br><span class="line">    this.confirmTransition(targetRoute, () =&gt; &#123;</span><br><span class="line">      // 这里会触发视图更新</span><br><span class="line">      this.current.route = targetRoute</span><br><span class="line">      this.current.name = targetRoute.name</span><br><span class="line">      this.current.path = targetRoute.path</span><br><span class="line">      this.current.query = targetRoute.query || getQuery()</span><br><span class="line">      this.current.fullPath = getFullPath(this.current)</span><br><span class="line">      cb &amp;&amp; cb()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 确认跳转</span><br><span class="line">   * @param route</span><br><span class="line">   * @param cb</span><br><span class="line">   */</span><br><span class="line">  confirmTransition (route, cb) &#123;</span><br><span class="line">    // 钩子函数执行队列</span><br><span class="line">    <span class="built_in">let</span> queue = [].concat(</span><br><span class="line">      this.router.beforeEach,</span><br><span class="line">      this.current.route.beforeLeave,</span><br><span class="line">      route.beforeEnter,</span><br><span class="line">      route.afterEnter</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    // 通过 step 调度执行</span><br><span class="line">    <span class="built_in">let</span> i = -1</span><br><span class="line">    const step = () =&gt; &#123;</span><br><span class="line">      i ++</span><br><span class="line">      <span class="keyword">if</span> (i &gt; queue.length) &#123;</span><br><span class="line">        cb()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue[i]) &#123;</span><br><span class="line">        queue[i](step)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        step()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    step(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这样我们一方面通过<code>this.current.route = targetRoute</code>达到了对之前劫持数据的更新，来达到视图更新。另一方面我们又通过任务队列的调度，实现了基本的钩子函数<code>beforeEach、beforeLeave、beforeEnter、afterEnter</code>。<br>到这里其实也就差不多了，接下来我们顺带着实现几个API吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 跳转，添加历史记录</span><br><span class="line"> * @param location </span><br><span class="line"> * @example this.push(&#123;name: <span class="string">'home'</span>&#125;)</span><br><span class="line"> * @example this.push(<span class="string">'/'</span>)</span><br><span class="line"> */</span><br><span class="line">push (location) &#123;</span><br><span class="line">  const targetRoute = match(location, this.router.routes)</span><br><span class="line"></span><br><span class="line">  this.transitionTo(targetRoute, () =&gt; &#123;</span><br><span class="line">    changeUrl(this.router.base, this.current.fullPath)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 跳转，添加历史记录</span><br><span class="line"> * @param location</span><br><span class="line"> * @example this.replaceState(&#123;name: <span class="string">'home'</span>&#125;)</span><br><span class="line"> * @example this.replaceState(<span class="string">'/'</span>)</span><br><span class="line"> */</span><br><span class="line">replaceState(location) &#123;</span><br><span class="line">  const targetRoute = match(location, this.router.routes)</span><br><span class="line"></span><br><span class="line">  this.transitionTo(targetRoute, () =&gt; &#123;</span><br><span class="line">    changeUrl(this.router.base, this.current.fullPath, <span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go (n) &#123;</span><br><span class="line">  window.history.go(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> changeUrl(path, replace) &#123;</span><br><span class="line">  const href = window.location.href</span><br><span class="line">  const i = href.indexOf(<span class="string">'#'</span>)</span><br><span class="line">  const base = i &gt;= 0 ? href.slice(0, i) : href</span><br><span class="line">  <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">    window.history.replaceState(&#123;&#125;, <span class="string">''</span>, `<span class="variable">$&#123;base&#125;</span><span class="comment">#/$&#123;path&#125;`)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    window.history.pushState(&#123;&#125;, <span class="string">''</span>, `<span class="variable">$&#123;base&#125;</span><span class="comment">#/$&#123;path&#125;`)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里也就基本上结束了</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="vue-router" scheme="http://yoursite.com/categories/vue-router/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue图片懒加载原理及实现</title>
    <link href="http://yoursite.com/2019/09/25/JavaScript/Vue%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/09/25/JavaScript/Vue图片懒加载原理及实现/</id>
    <published>2019-09-25T01:22:32.000Z</published>
    <updated>2019-09-25T01:32:33.599Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转：<br>　　<a href="https://www.jianshu.com/p/57e1055cc3fb" target="_blank" rel="noopener">Vue图片懒加载原理和实现</a><br>　　<a href="https://blog.csdn.net/Tom__cy/article/details/90299757" target="_blank" rel="noopener">Vue 中实现图片预加载 + 懒加载原理实现</a></p><h3 id="Vue图片懒加载原理及实现"><a href="#Vue图片懒加载原理及实现" class="headerlink" title="Vue图片懒加载原理及实现"></a>Vue图片懒加载原理及实现</h3><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>　　<code>先将img标签的src链接设为同一张图片(默认图片)，当js监听到该图片进入可视窗口时，再将实际地址应用。</code></p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><h5 id="1-判断元素是否在可视范围"><a href="#1-判断元素是否在可视范围" class="headerlink" title="1.判断元素是否在可视范围"></a>1.判断元素是否在可视范围</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断元素是否在可视范围</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> isVisible(ele)&#123;</span><br><span class="line">  <span class="built_in">let</span> windowHeight = window.innerHeight</span><br><span class="line">  <span class="built_in">let</span> position = ele.getBoundingClientRect()</span><br><span class="line">  // 当元素的top偏移量小于页面大小并且大于高度的负数</span><br><span class="line">  <span class="keyword">if</span>(position.top&lt;windowHeight &amp;&amp; position.top&gt;-position.height)&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-对图片实现懒加载"><a href="#2-对图片实现懒加载" class="headerlink" title="2.对图片实现懒加载"></a>2.对图片实现懒加载</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 对图片进行懒加载</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> lazyLoad(img, src)&#123;</span><br><span class="line">  <span class="keyword">if</span>(img &amp;&amp; src &amp;&amp; isVisible(img))&#123; // 元素存在，元素未被加载，元素可见</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">      img.setAttribute(<span class="string">'src'</span>, src)</span><br><span class="line">    &#125;, 1000) // 模拟网络请求</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-添加滚动监听"><a href="#3-添加滚动监听" class="headerlink" title="3.添加滚动监听"></a>3.添加滚动监听</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 窗口滚动</span><br><span class="line">window.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  lazyLoad(img, src)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Vue插件实现代码"><a href="#Vue插件实现代码" class="headerlink" title="Vue插件实现代码"></a>Vue插件实现代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断元素可见</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> isVisible(el)&#123;</span><br><span class="line">  <span class="built_in">let</span> windowHeight = window.innerHeight</span><br><span class="line">  <span class="built_in">let</span> position = el.getBoundingClientRect()</span><br><span class="line">  // 当元素的top偏移量小于页面大小并且大于高度的负数</span><br><span class="line">  <span class="keyword">if</span>(position.top&lt;windowHeight &amp;&amp; position.top&gt;-position.height)&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对图片进行懒加载</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> lazyLoad(img, src)&#123;</span><br><span class="line">  <span class="keyword">if</span>(img &amp;&amp; src &amp;&amp; isVisible(img))&#123; // 元素存在，元素未被加载，元素可见</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">      img.setAttribute(<span class="string">'src'</span>, src)</span><br><span class="line">    &#125;, 1000) // 模拟网络请求慢的情况</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  install(Vue, options)&#123;</span><br><span class="line">    Vue.directive(<span class="string">'lazy'</span>, &#123;</span><br><span class="line">      <span class="built_in">bind</span>: <span class="keyword">function</span>(el, binding, vnode)&#123;</span><br><span class="line">        el.setAttribute(<span class="string">'src'</span>, options.loading)</span><br><span class="line">        window.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">          lazyLoad(el, binding.value)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      inserted: <span class="keyword">function</span>(el, binding, vnode)&#123;</span><br><span class="line">        lazyLoad(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　main.js<br><code>Vue.use(myPlugin, {loading: defaultImg})</code></p><h4 id="在Vue中使用-vue-lazyload插件"><a href="#在Vue中使用-vue-lazyload插件" class="headerlink" title="在Vue中使用 vue-lazyload插件"></a>在Vue中使用 vue-lazyload插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.安装插件</span><br><span class="line">npm install vue-lazyload --save-dev</span><br><span class="line"></span><br><span class="line">2.在入口文件main.js中引入并使用</span><br><span class="line">import VueLazyload from <span class="string">'vue-lazyload'</span></span><br><span class="line"></span><br><span class="line">直接使用</span><br><span class="line">Vue.use(VueLazyload)</span><br><span class="line"></span><br><span class="line">或者添加自定义选项</span><br><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">  preLoad: 1.3,</span><br><span class="line">  error: <span class="string">'dist/error.png'</span>,</span><br><span class="line">  loading: <span class="string">'dist/loading.gif'</span>,</span><br><span class="line">  attempt: 1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">3.修改图片显示方式为懒加载（将 :src 属性直接改为v-lazy）</span><br><span class="line">&lt;a href=<span class="string">"javascript:;"</span>&gt;</span><br><span class="line">  &lt;img v-lazy=<span class="string">"'/static/img/' + item.productImage"</span>&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配</title>
    <link href="http://yoursite.com/2019/09/23/JavaScript/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    <id>http://yoursite.com/2019/09/23/JavaScript/移动端适配/</id>
    <published>2019-09-23T12:04:23.000Z</published>
    <updated>2019-09-23T12:06:22.848Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p><a href="https://juejin.im/post/5b6cfcffe51d453a1d27080b" target="_blank" rel="noopener">移动端常见兼容性问题解决方案</a><br><a href="https://juejin.im/post/5add7a44f265da0b886d05f8#heading-0" target="_blank" rel="noopener">移动端适配问题解决方案</a><br><a href="https://www.jianshu.com/p/2a091bd289ba" target="_blank" rel="noopener">解决vue移动端适配问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>AJAX</title>
    <link href="http://yoursite.com/2019/09/23/Ajax/AJAX/"/>
    <id>http://yoursite.com/2019/09/23/Ajax/AJAX/</id>
    <published>2019-09-23T11:47:04.000Z</published>
    <updated>2019-09-23T11:51:26.266Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h3 id="AJAX简介"><a href="#AJAX简介" class="headerlink" title="AJAX简介"></a>AJAX简介</h3><p>　　AJAX全称为“Asynchronous Javascript And XML”， 即“异步JavaScript和XML”的意思。通过AJAX我们可以向服务器发送请求，在不阻塞页面的情况下进行数据交互，也可以理解为异步数据传输。在AJAX的帮助下我们的网页只需局部刷新即可更新数据的显示，减少了不必要的数据量，大大提高了用户体验，缩短了用户等待的时间，使得web应用程序更小、更快，更友好。<a id="more"></a></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>　　页面无刷新，用户体验好。<br>　　异步通信，更加快的响应能力。<br>　　减少冗余请求，减轻了服务器负担<br>　　基于标准化的并被广泛支持的技术，不需要下载插件或者小程序</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>　　ajax干掉了back按钮，即对浏览器后退机制的破坏。<br>　　存在一定的安全问题。<br>　　对搜索引擎的支持比较弱。<br>　　破坏了程序的异常机制。<br>　　无法用URL直接访问</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>　　场景 1. 数据验证<br>　　场景 2. 按需取数据<br>　　场景 3. 自动更新页面</p><h3 id="AJAX的核心-XMLHttpRequest对象"><a href="#AJAX的核心-XMLHttpRequest对象" class="headerlink" title="AJAX的核心 XMLHttpRequest对象"></a>AJAX的核心 XMLHttpRequest对象</h3><p>创建XML对象的实例：<code>const xhr = new XMLHttpRequest()</code></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备启动一个AJAX请求</span></span><br><span class="line">.open()</span><br><span class="line"><span class="comment"># 设置请求头部信息</span></span><br><span class="line">.setRequestHeader()</span><br><span class="line"><span class="comment"># 发送AJAX请求</span></span><br><span class="line">.send()</span><br><span class="line"><span class="comment"># 获得响应头部信息</span></span><br><span class="line">.getResponseHeader()</span><br><span class="line"><span class="comment"># 获得一个包含所有头部信息的长字符串</span></span><br><span class="line">.getAllResponseHeader()</span><br><span class="line"><span class="comment"># 取消异步请求</span></span><br><span class="line">.abort()</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个JavaScript函数对象，当readyState属性改变时会调用它。</span></span><br><span class="line"><span class="comment"># 回调函数会在user interface线程中调用。</span></span><br><span class="line">onreadystatechange</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示“请求”/“响应”过程的当前活动阶段</span></span><br><span class="line"><span class="comment"># HTTP 请求的状态.当一个 XMLHttpRequest 初次创建时，</span></span><br><span class="line"><span class="comment"># 这个属性的值从 0 开始，直到接收到完整的 HTTP 响应，这个值增加到 4。</span></span><br><span class="line"><span class="comment"># 0 Uninitialized 初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。</span></span><br><span class="line"><span class="comment"># 1 Open open() 方法已调用，但是 send() 方法未调用。请求还没有被发送。</span></span><br><span class="line"><span class="comment"># 2 Sent Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。</span></span><br><span class="line"><span class="comment"># 3 Receiving   所有响应头部都已经接收到。响应体开始接收但未完成。</span></span><br><span class="line"><span class="comment"># 4 Loaded      HTTP 响应已经完全接收。</span></span><br><span class="line"><span class="comment"># readyState 的值不会递减，除非当一个请求在处理过程中的时候调用了</span></span><br><span class="line"><span class="comment">#  abort() 或 open() 方法。每次这个属性的值增加的时候，都会触发 </span></span><br><span class="line"><span class="comment"># onreadystatechange 事件句柄。</span></span><br><span class="line">.readyState</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前为止为服务器接收到的响应体（不包括头部），或者如果还没有接收到数据的话，</span></span><br><span class="line"><span class="comment"># 就是空字符串。</span></span><br><span class="line"><span class="comment"># 如果 readyState 小于 3，这个属性就是一个空字符串。当 readyState 为 3，</span></span><br><span class="line"><span class="comment"># 这个属性返回目前已经接收的响应部分。如果 readyState 为 4，这个属性保存</span></span><br><span class="line"><span class="comment"># 了完整的响应体。</span></span><br><span class="line">.responseText</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果响应的内容类型时text/xml或application/xml，</span></span><br><span class="line"><span class="comment"># 该属性将保存包含着相应数据的XML DOM文档</span></span><br><span class="line">.responseXML</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应的HTTP状态</span></span><br><span class="line">.status</span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP状态的说明</span></span><br><span class="line">.statusText</span><br></pre></td></tr></table></figure><h5 id="XMLHttpRequest-方法"><a href="#XMLHttpRequest-方法" class="headerlink" title="XMLHttpRequest 方法"></a>XMLHttpRequest 方法</h5><h6 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h6><p>取消当前响应，关闭连接并且结束任何未决的网络活动。<br>　　这个方法把 <code>XMLHttpRequest</code> 对象重置为 <code>readyState</code>为 0 的状态，并且取消所有未决的网络活动。例如，如果请求用了太长时间，而且响应不再必要的时候，可以调用这个方法。</p><h6 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders()"></a>getAllResponseHeaders()</h6><p>把 HTTP 响应头部作为未解析的字符串返回。<br>　　如果 <code>readyState</code> 小于 3，这个方法返回 null。否则，它返回服务器发送的所有 HTTP 响应的头部。头部作为单个的字符串返回，一行一个头部。每行用换行符 <code>&quot;\r\n&quot;</code> 隔开。</p><h6 id="getResponseHeader"><a href="#getResponseHeader" class="headerlink" title="getResponseHeader()"></a>getResponseHeader()</h6><p>　　返回指定的 HTTP 响应头部的值。其参数是要返回的 <code>HTTP</code> 响应头部的名称。可以使用任何大小写来制定这个头部名字，和响应头部的比较是不区分大小写的。<br>　　该方法的返回值是指定的 HTTP 响应头部的值，如果没有接收到这个头部或者 readyState 小于 3 则为空字符串。如果接收到多个有指定名称的头部，这个头部的值被连接起来并返回，使用逗号和空格分隔开各个头部的值。</p><h6 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h6><p>初始化一个请求. 该方法用于JavaScript代码中;如果是本地代码, 使用 openRequest())方法代替.</p><blockquote><p>注意: 在一个已经激活的request下（已经调用open()或者openRequest()方法的request）再次调用这个方法相当于调用了abort（）方法。</p></blockquote><p>参数：<br><code>method</code><br>　　请求所使用的HTTP方法; 例如 “GET”, “POST”, “PUT”, “DELETE”等. 如果下个参数是非HTTP(S)的URL,则忽略该参数.<br><code>url</code><br>　　该请求所要访问的URL<br><code>async</code><br>　　一个可选的布尔值参数，默认为true,意味着是否执行异步操作，如果值为false,则send()方法不会返回任何东西，直到接受到了服务器的返回数据。如果为值为true，一个对开发者透明的通知会发送到相关的事件监听者。这个值必须是true,如果multipart 属性是true，否则将会出现一个意外。<br><code>user</code><br>　　用户名,可选参数,为授权使用;默认参数为空string.<br><code>password</code><br>　　密码,可选参数,为授权使用;默认参数为空string.</p><h6 id="sned"><a href="#sned" class="headerlink" title="sned()"></a>sned()</h6><p>发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体。</p><h6 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader()"></a>setRequestHeader()</h6><p>向一个打开但未发送的请求设置或添加一个 HTTP 请求(设置请求头)。<br>参数：<br><code>header</code><br>　　将要被赋值的请求头名称<br><code>value</code><br>　　给指定的请求头赋的值</p><h3 id="发送AJAX请求"><a href="#发送AJAX请求" class="headerlink" title="发送AJAX请求"></a>发送AJAX请求</h3><h4 id="设置请求头部信息"><a href="#设置请求头部信息" class="headerlink" title="设置请求头部信息"></a>设置请求头部信息</h4><p>　　每个HTTP请求和响应都会带有相应的头部信息，包含一些与数据，收发者网络环境与状态等相关信息。XMLHttpRequest对象提供的.setRequestHeader()方法为开发者提供了一个操作这两种头部信息的方法，并允许开发者自定义请求头的头部信息。<br>默认情况下，当发送AJAX请求时，会附带以下头部信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浏览器能够处理的内容类型</span></span><br><span class="line">Accept</span><br><span class="line"><span class="comment"># 浏览器能够显示的字符集</span></span><br><span class="line">Accept-Charset</span><br><span class="line"><span class="comment"># 浏览器能够处理的压缩编码</span></span><br><span class="line">Accept-Encoding</span><br><span class="line"><span class="comment"># 浏览器当前设置的语言</span></span><br><span class="line">Accept-Language</span><br><span class="line"><span class="comment"># 浏览器与服务器之间连接的类型</span></span><br><span class="line">Connection</span><br><span class="line"><span class="comment"># 当前页面设置的任何Cookie</span></span><br><span class="line">Cookie</span><br><span class="line"><span class="comment"># 发出请求的页面所在的域</span></span><br><span class="line">Host</span><br><span class="line"><span class="comment"># 发出请求的页面URI</span></span><br><span class="line">Referer</span><br><span class="line"><span class="comment"># 浏览器的用户代理字符串</span></span><br><span class="line">User-Agent</span><br></pre></td></tr></table></figure></p><p><strong>注意:</strong><br>　　部分浏览器不允许使用<code>.setRequestHeader()</code>方法重写默认请求头信息，因此自定义请求头信息是更加安全的方法：<br><code># 自定义请求头</code><br><code>xhr.setRequestHeader(&quot;myHeader&quot;, &quot;MyValue&quot;)</code></p><h4 id="发送AJAX请求-1"><a href="#发送AJAX请求-1" class="headerlink" title="发送AJAX请求"></a>发送AJAX请求</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送AJAX请求</span></span><br><span class="line"><span class="comment"># 使用get方法发送同步请求(false)</span></span><br><span class="line"><span class="built_in">let</span> xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.php'</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">'myHeader'</span>, <span class="string">'goodHeader'</span>)</span><br><span class="line">xhr.send(null)</span><br><span class="line"></span><br><span class="line"><span class="comment"># POST请求</span></span><br><span class="line"><span class="built_in">let</span> xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'example.php'</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">'myHeader'</span>, <span class="string">'goodHeader'</span>)</span><br><span class="line">shr.send(some_data)</span><br></pre></td></tr></table></figure><h4 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h4><p>同步的GET请求响应：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"example.php"</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">"myHeader"</span>, <span class="string">"goodHeader"</span>)</span><br><span class="line">xhr.send(null)</span><br><span class="line"><span class="comment"># 由于是同步的AJAX请求，因此只有当服务器响应后才会继续执行下面的代码</span></span><br><span class="line"><span class="comment"># 因此xhr.status的值一定不为默认值</span></span><br><span class="line"><span class="keyword">if</span>((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;</span><br><span class="line">  console.log(<span class="string">"xhr.responseText:"</span>, xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  console.log(<span class="string">"Request was unsuccessful:"</span>, xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　上面的代码不难理解，我们通过之前提到的<code>xhr.status</code>属性（如果你忘记了，它存储着响应的HTTP状态）判断请求是否成功，如果成功的话，我们将读取<code>xhr.responseText</code>属性中存储的返回值。但是，当我们的请求为异步时，问题就稍微变得复杂了，由于是异步的请求，在<code>xhr.send(null)</code>语句被执行后，<code>JavaScript</code>引擎会紧接着执行下面的判断语句，而这时由于尚未来得及响应，我们注定会得到一个默认的<code>xhr.status</code>值，因此，我们永远都不可能获取请求的资源了。<br>如何解决这个问题？答案是通过为<code>XMLHTTPRequest</code>实例添加<code>onreadystatechange</code>事件处理程序（当然你也可以直接使用DOM2级规范规定的<code>.addEventListener()</code>方法，但是注意，IE8是不支持该方法的）。<br>　　xhr实例的<code>readystatechange</code>事件会监听<code>xhr.readyState</code>属性的变化，你可以将这个属性想象为一个计数器，随着AJAX流程的推进而不断累加，其可取的值如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　0：未初始化 -- 尚未调用.open()方法</span><br><span class="line">　　1：启动 -- 已经调用.open()方法，但尚未调用.send()方法</span><br><span class="line">　　2：发送 -- 已经调用.send()方法，但尚未接收到响应</span><br><span class="line">　　3：接收 -- 已经接收到部分响应数据</span><br><span class="line">　　4：完成 -- 已经接收到全部响应数据，而且已经可以在客户端使用了</span><br></pre></td></tr></table></figure></p><p>有了这个时间处理程序对AJAX进程做监听，剩下的事就简单多了，一个<code>异步</code>的<code>GET</code>请求代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest()</span><br><span class="line"><span class="comment"># 等价于 xhr.onreadystatechange = function()&#123;&#125;</span></span><br><span class="line"><span class="comment"># 利用onreadystatechange监测状态</span></span><br><span class="line">xhr.onreadystatechange = () =&gt; &#123;</span><br><span class="line">  <span class="comment"># readyState为4表示请求响应完成</span></span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState == 4) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;</span><br><span class="line">      console.log(<span class="string">"xhr.responseText:"</span>, xhr.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      console.log(<span class="string">"Request was unsuccessful:"</span>, xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'example.php'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(null)</span><br></pre></td></tr></table></figure></p><h3 id="其他库框架中的AJAX"><a href="#其他库框架中的AJAX" class="headerlink" title="其他库框架中的AJAX"></a>其他库框架中的AJAX</h3><h4 id="jQuery中的AJAX"><a href="#jQuery中的AJAX" class="headerlink" title="jQuery中的AJAX"></a>jQuery中的AJAX</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    method: <span class="string">'GET'</span>, <span class="comment"># 1.9.0本版前用'type'</span></span><br><span class="line">    url: <span class="string">"/test/"</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">done</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'执行成功'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.fail(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'执行出错'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Vue-js中的AJAX"><a href="#Vue-js中的AJAX" class="headerlink" title="Vue.js中的AJAX"></a>Vue.js中的AJAX</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.get(<span class="string">'/test/'</span>).<span class="keyword">then</span>((response) =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'执行成功'</span>);</span><br><span class="line">&#125;, (response) =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'执行出错'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="状态值和状态码"><a href="#状态值和状态码" class="headerlink" title="状态值和状态码"></a>状态值和状态码</h3><h4 id="状态值于状态码："><a href="#状态值于状态码：" class="headerlink" title="状态值于状态码："></a>状态值于状态码：</h4><blockquote><p>在ajax时间运行过程中，对于访问XMLHttpRequest不是一次就完成的，而是经历多种状态后获取的结果。<br>对于这种状态在ajax中分为5中状态：<br>0: (未初始化)还没有调用send()方法。<br>1: (载入)已经调用send()方法，正在派发请求。<br>2: (载入完成)send()已经执行完成，已经接收到全部的响应内容。<br>3: (交互)正在解析响应内容。<br>4: (完成)响应内容已经解析完成，用户可以调用。</p></blockquote><blockquote><p>ajax状态值和状态码的区别：<br>ajax的状态值指，运行ajax时运行的几种状态，无论是成功还是失败都要响应的步骤。如：正在派发，正在响应等，由ajax对象和<br>服务器之间交互是所得。使用ajax.readyState获得（0~4）<br>ajax状态码是值，ajax无论请求是否成功，根据http所提及的用户信息，用服务器返回http头信息代码，使用ajax.state来获得</p></blockquote><blockquote><p>这就是我们在使用AJAX时为什么采用下面的方式判断所获得的信息是否正确的原因。<br>if(ajax.readyState == 4 &amp;&amp; ajax.status == 200) {<br>    putData(ajax.responseText);<br>}</p></blockquote><h4 id="ajax状态码："><a href="#ajax状态码：" class="headerlink" title="ajax状态码："></a>ajax状态码：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">AJAX状态码说明</span><br><span class="line"></span><br><span class="line">1**：请求收到，继续处理</span><br><span class="line">2**：操作成功收到，分析、接受</span><br><span class="line">3**：完成此请求必须进一步处理</span><br><span class="line">4**：请求包含一个错误语法或不能完成</span><br><span class="line">5**：服务器执行一个完全有效请求失败</span><br><span class="line">100——客户必须继续发出请求</span><br><span class="line">101——客户要求服务器根据请求转换HTTP协议版本</span><br><span class="line">200——交易成功</span><br><span class="line">201——提示知道新文件的URL</span><br><span class="line">202——接受和处理、但处理未完成</span><br><span class="line">203——返回信息不确定或不完整</span><br><span class="line">204——请求收到，但返回信息为空</span><br><span class="line">205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</span><br><span class="line">206——服务器已经完成了部分用户的GET请求</span><br><span class="line">300——请求的资源可在多处得到</span><br><span class="line">301——删除请求数据</span><br><span class="line">302——在其他地址发现了请求数据</span><br><span class="line">303——建议客户访问其他URL或访问方式</span><br><span class="line">304——客户端已经执行了GET，但文件未变化</span><br><span class="line">305——请求的资源必须从服务器指定的地址得到</span><br><span class="line">306——前一版本HTTP中使用的代码，现行版本中不再使用</span><br><span class="line">307——申明请求的资源临时性删除</span><br><span class="line">400——错误请求，如语法错误</span><br><span class="line">401——请求授权失败</span><br><span class="line">402——保留有效ChargeTo头响应</span><br><span class="line">403——请求不允许</span><br><span class="line">404——没有发现文件、查询或URl</span><br><span class="line">405——用户在Request-Line字段定义的方法不允许</span><br><span class="line">406——根据用户发送的Accept拖，请求资源不可访问</span><br><span class="line">407——类似401，用户必须首先在代理服务器上得到授权</span><br><span class="line">408——客户端没有在用户指定的饿时间内完成请求</span><br><span class="line">409——对当前资源状态，请求不能完成</span><br><span class="line">410——服务器上不再有此资源且无进一步的参考地址</span><br><span class="line">411——服务器拒绝用户定义的Content-Length属性请求</span><br><span class="line">412——一个或多个请求头字段在当前请求中错误</span><br><span class="line">413——请求的资源大于服务器允许的大小</span><br><span class="line">414——请求的资源URL长于服务器允许的长度</span><br><span class="line">415——请求资源不支持请求项目格式</span><br><span class="line">416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</span><br><span class="line">417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求</span><br><span class="line">500——服务器产生内部错误</span><br><span class="line">501——服务器不支持请求的函数</span><br><span class="line">502——服务器暂时不可用，有时是为了防止发生系统过载</span><br><span class="line">503——服务器过载或暂停维修</span><br><span class="line">504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长</span><br><span class="line">505——服务器不支持或拒绝支请求头中指定的HTTP版本</span><br></pre></td></tr></table></figure><h4 id="ajax类库"><a href="#ajax类库" class="headerlink" title="ajax类库"></a>ajax类库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">function</span> ajax(value)&#123;</span><br><span class="line">        var url = value.url;</span><br><span class="line">        var <span class="built_in">type</span> = value.type || <span class="string">"get"</span>;</span><br><span class="line">        var data = value.data || <span class="string">""</span>;</span><br><span class="line">        var success = value.success;</span><br><span class="line">        var error = value.error || <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        //1、创建AJAX对象</span><br><span class="line">        var oAjax;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            //Firefox,Opera 8.0+, Safari</span><br><span class="line">            oAjax = new XMLHttpRequest();</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            //Internet Explorer</span><br><span class="line">            try&#123;</span><br><span class="line">                oAjax = new ActiveXObject(<span class="string">"Msxml2.XMLHTTP"</span>);</span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    oAjax = new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">                &#125;catch(e)&#123;</span><br><span class="line">                    alert(<span class="string">"浏览器不支持ajax"</span>);</span><br><span class="line">                    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //链接服务器</span><br><span class="line">        oAjax.open(<span class="built_in">type</span>, url, <span class="literal">true</span>);</span><br><span class="line">        //发送请求</span><br><span class="line">        oAjax.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded;charset=UTF-8"</span>);</span><br><span class="line">        oAjax.send(data);</span><br><span class="line">        //数据接收</span><br><span class="line">        oAjax.onreadystatechange = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            <span class="keyword">if</span>(oAjax.readyState == 4)&#123;</span><br><span class="line">                <span class="keyword">if</span>(oAjax.stack == 200)&#123;</span><br><span class="line">                    var data = oAjax.responseText;</span><br><span class="line">                    success(data);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(error)&#123;</span><br><span class="line">                        error();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>转载：<br>　　<a href="https://juejin.im/post/5a20b1f1f265da432529179c" target="_blank" rel="noopener">使用AJAX</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h3 id=&quot;AJAX简介&quot;&gt;&lt;a href=&quot;#AJAX简介&quot; class=&quot;headerlink&quot; title=&quot;AJAX简介&quot;&gt;&lt;/a&gt;AJAX简介&lt;/h3&gt;&lt;p&gt;　　AJAX全称为“Asynchronous Javascript And XML”， 即“异步JavaScript和XML”的意思。通过AJAX我们可以向服务器发送请求，在不阻塞页面的情况下进行数据交互，也可以理解为异步数据传输。在AJAX的帮助下我们的网页只需局部刷新即可更新数据的显示，减少了不必要的数据量，大大提高了用户体验，缩短了用户等待的时间，使得web应用程序更小、更快，更友好。&lt;/p&gt;
    
    </summary>
    
      <category term="AJAX" scheme="http://yoursite.com/categories/AJAX/"/>
    
    
      <category term="AJAX" scheme="http://yoursite.com/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>数据埋点</title>
    <link href="http://yoursite.com/2019/09/23/JavaScript/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9/"/>
    <id>http://yoursite.com/2019/09/23/JavaScript/数据埋点/</id>
    <published>2019-09-23T11:28:09.000Z</published>
    <updated>2019-09-23T12:04:03.028Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h2 id="数据埋点"><a href="#数据埋点" class="headerlink" title="数据埋点"></a>数据埋点</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>　　所谓埋点就是在应用中特定的流程收集一些信息，用来跟踪应用使用的状况，后续用来进一步优化产品或是提供运营的数据支撑，包括访问数（<code>Visits</code>），访客数（<code>Visitor</code>），停留时长（<code>Time On Site</code>），页面浏览数（<code>Page Views</code>）和跳出率（<code>Bounce Rate</code>）。这样的信息收集可以大致分为两种：页面统计（<code>track this virtual page view</code>），统计操作行为（<code>track this button by an event</code>）</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>现在埋点的主流有两种方式：<br>　　第一种：自己公司研发在产品中注入代码统计，并搭建起相应的后台查询。<br>　　第二种：第三方统计工具，如友盟、神策、<code>Talkingdata</code>、<code>GrowingIO</code>等。</p><h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标<a id="more"></a></h3><h4 id="访问与访客"><a href="#访问与访客" class="headerlink" title="访问与访客"></a>访问与访客</h4><p>　　访问次数（Visits）与访问人数（Vistors）是几乎所有应用都需要统计的指标，这也是最基础的指标。<br>　　对于应用的统计来说，经常看到的DAU，MAU，UV等指标都是指统计访客（Vistors）。访问（Visits）是指会话层，用户打开应用花一段时间浏览又离开，从指标定义（访问次数）来说这被称之为统计会话（Session）数。<br>　　一次会话（Session 或 Visit）是打开应用的第一个请求（打开应用）和最后一个请求决定的。如果用户打开应用然后放下手机或是离开电脑，并在接下来30分钟内没有任何动作，此次会话自动结束，通常也算作一次访问或会话期（30分钟是早起网页版应用约定俗成的会话数定义，目前用户停留在应用的时长变长，30分钟的限定也可能随之不同，总之是能代表一次用户访问的时长）。<br>　　在计算访问人数（Vistors）时，埋点上报的数据是尽可能接近真实访客的人数。对于有需要统计独立访客这个指标的场景，这里还是需要强调一下，访问人数（Vistors）并不是真实独立的人，因此收集数据时必须知道访问人数虽然能够很好的反映使用应用的真实访问者的数量，但不等于使用应用的真实人数。（原因是，重复安装的应用，或是手机参数被修改都会使得独立访客的指标收到影响。计算访问人数的埋点都是依赖Cookie，用户打开应用，应用都会在此人的终端创建一个独立Cookie, Cookie会被保留，但还是难免会被用户手动清理或是Cookie被禁用导致同一用户使用应用Cookie不一致，所以独立访客只能高度接近于使用应用的真实人数。）</p><h4 id="停留时长"><a href="#停留时长" class="headerlink" title="停留时长"></a>停留时长</h4><p>　　停留时长用来衡量用户在应用的某一个页面或是一次访问（会话）所停留的时间。<br>　　页面停留时长，表示在每个页面所花费的时间；例如：首页就是进入首页（10：00）到离开首页进入下一个页面(10:01)的时长，首页停留时长计算为1分钟。页面A是2分钟。停留时长的数据并不都是一定采集得到的，比如页面B进入时间（10：03），离开出现异常或是退出时间没有记录，这时候计算就是0 （所以指标计算时需要了解埋点的状况，剔除这样的无效数据）。<br>　　应用的停留时长，表示一次访问（会话）所停留的时间，计算起来就是所有页面的访问时长，同样是上一个流程，应用的停留时长就是4分钟。</p><h4 id="跳出率"><a href="#跳出率" class="headerlink" title="跳出率"></a>跳出率</h4><p>　　跳出率的计算方法现在在各个公司还是很多种，最经常被使用的是：用户只访问了一个页面所占的会话比例（原因是：假设这种场景，用户来了访问了一个页面就离开了，想想用户使用的心里画面应该是：打开应用，心想什么鬼，然后关闭应用甚至卸载了。这个场景多可怕，这也是为什么跳出率指标被如此关注）<br>　　跳出率可以分解到两个层次：<code>一是整个应用的跳出率</code>，<code>二是重点的着陆页的跳出率</code>，甚至是搜索关键词的跳出率。跳出率的指标可操作性非常强，通过统计跳出率可以直接发现页面的问题发现关键词的问题。</p><h4 id="退出率"><a href="#退出率" class="headerlink" title="退出率"></a>退出率</h4><p>　　退出率是针对页面的，这个指标的目标很简单，就是在针对某个页面有多少用户离开了应用，主要用户反映用户从应用离开的情况。哪些页面需要被改进最快的方式被发掘。（注意：退出率高不一定是坏事。例如：预测流程的最终节点的退出率就应该是高的）</p><h4 id="转化率"><a href="#转化率" class="headerlink" title="转化率"></a>转化率</h4><p>　　我们在产品上投入这么多，不就是为了衡量产出么？所以对于电商类应用，还有比转化率更值得关注的指标吗？转化率的计算方法是某种产出除以独立访客或是访问量，对于电商产品来说，就是提交订单用户数除以独立访客。<br>　　转化率的计算看起来想到那简单，但却是埋点中最贴近业务的数据收集。这也是最体现埋点技巧的指标，需要结合业务特点制定计算方法。提交订单量/访客数是最基本的转化率，转化率还可以分层次，指定用户路径的，如：完成某条路径的提交订单数/访客数。<br>　　试着找一条路径，想想转化率的数据怎么得来的吧，埋点都收集了什么样的数据吧？参与度参与度并不是一个指标，而是一系列的指标的统称，例如访问深度，访问频次，针对电商的下单次数，针对内容服务商的播放次数，及用户行为序列这些都可以是衡量参与度的指标。之所以把参与度列为一个指标，是希望大家明白把指标结合业务，产生化学反应，活学活用去发现事物的本质。</p><h4 id="埋点的内容"><a href="#埋点的内容" class="headerlink" title="埋点的内容"></a>埋点的内容</h4><p>　　看完关键的这些指标后，其实埋点大致分为两部分，一部分是统计应用页面访问情况，即页面统计，随页面访问动作发生时进行上报；另外一部分是统计应用内的操作行为，在页面中操作时进行上报（例如：组件曝光时，组件点击时，上滑，下滑时）。<br>　　为了统计到所需要的指标，应用中的所有页面，事件都被唯一标记，用户的信息，设备的信息，时间参数以及符合业务需要的参数具体内容被附加上报，就是埋点。</p><h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><h4 id="1、提高网站的转化率"><a href="#1、提高网站的转化率" class="headerlink" title="1、提高网站的转化率"></a>1、提高网站的转化率</h4><p>　　根据页面埋点可得到一些重要信息，它告诉你用户对网站的反应，以及如何<code>提高网站流量</code>、<code>改进网站性能</code>，<code>了解用户访问网站的行为</code>，<code>为更好地满足用户需求提供支持</code>。 </p><h4 id="2、反应用户黏度"><a href="#2、反应用户黏度" class="headerlink" title="2、反应用户黏度"></a>2、反应用户黏度</h4><p>　　即使网站吸引了很多用户访问，但是通过流量分析发现，用户停留的时间非常短，重复访问用户不多，用户平均浏览的页面也少，这样的网站用户黏度不够，有流量但是没有忠实的用户，一旦有其它可替代网站，用户随时可能流失。这样的网站，如果不采取有效的运营措施，很难有长期发展的后劲。</p><h4 id="3、为网站内容管理和网站的产品策划提供方向"><a href="#3、为网站内容管理和网站的产品策划提供方向" class="headerlink" title="3、为网站内容管理和网站的产品策划提供方向"></a>3、为网站内容管理和网站的产品策划提供方向</h4><p>　　通过流量分析，可以挖掘出整个网站哪个频道最有人气，频道之间的流量比例是多少，每个页面的流量是多少，哪个页面最受欢迎，每个页面中具体的哪个栏目点击 量最高，这样通过对频道、栏目、页面的具体流量分析和对比，可以挖掘出用户的需求，发现用户最关心什么内容，这对评估网站频道、内容、页面的价值有重要的 参考作用，也对网站内容下一步的优化有直接的参考意义。</p><blockquote><p>转载：<br><a href="https://zhuanlan.zhihu.com/p/25195217" target="_blank" rel="noopener">数据埋点是什么？设置埋点的意义是什么？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;数据埋点&quot;&gt;&lt;a href=&quot;#数据埋点&quot; class=&quot;headerlink&quot; title=&quot;数据埋点&quot;&gt;&lt;/a&gt;数据埋点&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;　　所谓埋点就是在应用中特定的流程收集一些信息，用来跟踪应用使用的状况，后续用来进一步优化产品或是提供运营的数据支撑，包括访问数（&lt;code&gt;Visits&lt;/code&gt;），访客数（&lt;code&gt;Visitor&lt;/code&gt;），停留时长（&lt;code&gt;Time On Site&lt;/code&gt;），页面浏览数（&lt;code&gt;Page Views&lt;/code&gt;）和跳出率（&lt;code&gt;Bounce Rate&lt;/code&gt;）。这样的信息收集可以大致分为两种：页面统计（&lt;code&gt;track this virtual page view&lt;/code&gt;），统计操作行为（&lt;code&gt;track this button by an event&lt;/code&gt;）&lt;/p&gt;
&lt;h3 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h3&gt;&lt;p&gt;现在埋点的主流有两种方式：&lt;br&gt;　　第一种：自己公司研发在产品中注入代码统计，并搭建起相应的后台查询。&lt;br&gt;　　第二种：第三方统计工具，如友盟、神策、&lt;code&gt;Talkingdata&lt;/code&gt;、&lt;code&gt;GrowingIO&lt;/code&gt;等。&lt;/p&gt;
&lt;h3 id=&quot;指标&quot;&gt;&lt;a href=&quot;#指标&quot; class=&quot;headerlink&quot; title=&quot;指标&quot;&gt;&lt;/a&gt;指标&lt;/h3&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/07/21/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/%E5%87%86%E5%A4%87/"/>
    <id>http://yoursite.com/2019/07/21/面试题-思维/准备/</id>
    <published>2019-07-21T15:13:17.822Z</published>
    <updated>2019-07-21T15:49:55.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">【百度-母婴业务部-前端】校招提前批内推</span><br><span class="line">lanjianguo@baidu.com</span><br><span class="line">1.姓名2.邮箱3.手机号4.简历5.推荐词（选填）</span><br><span class="line">坑位有限，先到先得，截止到8月14日。</span><br><span class="line">百度招聘官网：https://talent.baidu.com/external/baidu/campus.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">旷视科技</span><br><span class="line">sihaiyang@megvii.com</span><br><span class="line">发邮件时请注明岗位和工作地点，默认北京，正文请备注自己的姓名、邮箱、手机号。附件为简历，简历建议命名为：姓名-学校-手机号。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">陌陌</span><br><span class="line">https://uploadfiles.nowcoder.com/images/20190715/340047502_1563204023495_E4050D8294A27655000FDBF912B1FD08</span><br><span class="line">1.打开下方二维码（用微信扫描）</span><br><span class="line">2.选择自己对应的岗位</span><br><span class="line">3.扔简历</span><br><span class="line">4.内推完成</span><br><span class="line">https://app.mokahr.com/recommendation-apply/immomo/2050/?recommenderId=192152&amp;<span class="built_in">hash</span>=%23%2Fjobs%3Fkeyword%3D2020%26page%3D1%26isCampusJob%3D1%26_k%3D4v9ivu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">快手</span><br><span class="line">867326226@qq.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">贝壳找房</span><br><span class="line">23107689内推人:莫健锋</span><br><span class="line">http://campus.ke.com/Campus</span><br><span class="line">岗位 下划线 姓名 下划线 学校.pdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">拼多多</span><br><span class="line">xulongxiang@pinduoduo.com</span><br><span class="line">2020届学霸批+姓名+学校+岗位.pdf</span><br><span class="line">上海 web前端研发工程师</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">商汤研究院招前端-cv实习生</span><br><span class="line">sunjiaming@sensetime.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">阿里巴巴[秋招]</span><br><span class="line">qijin.hq@alibaba-inc.com</span><br><span class="line">【秋招内推】 姓名_学校_专业_L7GT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QQ音乐提前批来啦招聘web前端工程师</span><br><span class="line">坐标深圳，qqmusic_fe@outlook.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">星环科技</span><br><span class="line">前端开发工程师（实习生）</span><br><span class="line">扫描二维码，关注“星环科技招聘”，选择“星招聘”，进入校园招聘页面，</span><br><span class="line">选择你心仪的岗位进行投递</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端-面试题</title>
    <link href="http://yoursite.com/2019/07/21/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/vue%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/07/21/面试题-思维/vue面试题/</id>
    <published>2019-07-21T09:53:08.000Z</published>
    <updated>2019-07-21T15:03:15.681Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单自我介绍, 做过哪些项目, 使用哪些技术栈 ?<br>如何看待前端框架选型 ?<br>vue的如何实现双向绑定的 ？<br>react 虚拟DOM 是什么? 如何实现? 说一下diff算法 ?<br>工作中最出色的点, 和你最头疼的问题 如何解决的 ?<br>平时如何学习, 最近接触了解了哪些新的知识 ?<br>技术一面<br>简单自我介绍, 介绍一下你的项目, 技术栈 ?<br>react和vue的比较 ?<br>React Diff 算法 ?<br>观察者模式实现 ?<br>http报文头部有哪些字段? 有什么意义 ?<br>移动端高清方案如何解决 ?<br>webpack的原理, loader 和 plugin 是干什么的? 有自己手写过么 ?<br>简述从网页输入url到网页展示的过程发生了哪些事情 ?<br>SSR 和 客户端渲染有什么区别 , vue是如何实现绑定事件的 ?<br>简述公司node架构中容灾的实现 ?<br>浏览器事件有哪些过程? 为什么一般在冒泡阶段, 而不是在捕获阶段注册监听? addEventListener 参数分别是什么 ?<br>面向对象如何实现? 需要复用的变量 怎么处理 ?<br>移动端300ms延时的原因? 如何处理?<br>主流框架的数据单向/双向绑定实现原理 ?<br>简述转行经历, 如何学习 ?<br>你觉得自己在前端工作的最大的优点是什么 拿实际工作的内容举例?<br>技术二面<br>和一面前3问基本一致,简述项目,React vue区别 virsualDOM实现<br>DIFF算法为什么是O(n)复杂度而不是O(n^3)<br>http code码?<br>移动端rem布局如何实现? 简述原理?<br>JSbridge原理, js和native是如何通信的?<br>Rollup和webpack区别, treeshaking是什么?<br>TCP三次握手的过程, get post请求的区别 ?<br>静态文件的浏览器缓存如何实现?<br>前端跨域方案<br>http 请求包含哪些字段 分别是什么意思<br>js 有哪些数据类型 如何判断? null 和 undefined区别 应用场景?<br>new String(‘a’) 和 ‘a’ 是一样的么?<br>移动端如何实现下拉到底部 跟随移动 结束后回弹的动画?<br>移动端如何优化首页白屏时间过长 ?<br>ES6 generator函数简述<br>数组去重实现?<br>js浮点数运算不精确 如何解决?<br>工作中最得意和出色的点, 头疼的点, 问题如何解决的<br>为何换工作?<br>聊了下阿里的压力,文化<br>技术三面<br>公司的前端工程化实践<br>转行之后是如何自学前端的, 学习途径 有没有一些自己的代码<br>DOM基础知识,添加元素,删除元素等等…<br>DOM节点类型<br>正则表达式如何匹配一段url ?在正则表达式中有哪几种作用?<br>移动端优化方式? 离线包是如何实现的?</p><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">https://ustbhuangyi.github.io/vue-analysis/</a></p><p>我的手机 2019/3/14 10:04:34<br><a href="https://www.jianshu.com/p/a804606ad8e9" target="_blank" rel="noopener">https://www.jianshu.com/p/a804606ad8e9</a></p><p>我的手机 2019/3/14 10:04:50<br><a href="https://www.cnblogs.com/chinabin1993/p/9115396.html" target="_blank" rel="noopener">https://www.cnblogs.com/chinabin1993/p/9115396.html</a></p><p>我的手机 2019/3/14 10:05:03<br><a href="https://segmentfault.com/a/1190000012996217" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012996217</a></p><p>我的手机 2019/3/14 10:05:20<br><a href="https://blog.csdn.net/qq_35430000/article/details/79291287" target="_blank" rel="noopener">https://blog.csdn.net/qq_35430000/article/details/79291287</a></p><p>我的手机 2019/3/14 10:05:37<br><a href="https://m.jb51.net/article/140581.htm" target="_blank" rel="noopener">https://m.jb51.net/article/140581.htm</a></p><p><a href="https://yukwan.cn/fronttech/front-end/" target="_blank" rel="noopener">https://yukwan.cn/fronttech/front-end/</a><br>2019/3/8 16:31:10<br>我的手机 2019/3/8 16:31:10<br><a href="https://mp.weixin.qq.com/s/L8P0RIXym4myfknzM5Nsog" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/L8P0RIXym4myfknzM5Nsog</a><br>2019/3/9 16:28:42<br>我的手机 2019/3/9 16:28:42<br><a href="https://campushr.hikvision.com/JobDetails.html?id=057c01652bb444b597345337c7b8c14f&amp;type=0" target="_blank" rel="noopener">https://campushr.hikvision.com/JobDetails.html?id=057c01652bb444b597345337c7b8c14f&amp;type=0</a></p><p><a href="https://wx2.sinaimg.cn/mw690/005NaMhPly1g0nayy8lbij30hs59p7wh.jpg?from=singlemessage" target="_blank" rel="noopener">https://wx2.sinaimg.cn/mw690/005NaMhPly1g0nayy8lbij30hs59p7wh.jpg?from=singlemessage</a></p><h3 id="2019-07-21"><a href="#2019-07-21" class="headerlink" title="2019-07-21"></a>2019-07-21</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">1. 说一下CSS盒模型</span><br><span class="line">标准盒模型和IE怪异盒模型，然后提到了设置 box-sizing 可以转换及一些常见应用场景（这题过）</span><br><span class="line">2. 怎样让一个元素水平垂直居中</span><br><span class="line">3. 知道什么是同源策略吗</span><br><span class="line">4. 那怎么解决跨域问题</span><br><span class="line">5. 知道 JSONP 原理吗</span><br><span class="line">6. 怎么检测浏览器中的内存泄漏</span><br><span class="line">7. 如果要让你给 chrome 写一个插件检测内存泄漏说一下你的思路</span><br><span class="line">8. 重绘和重排的区别</span><br><span class="line">9. 知道浏览器事件机制吗</span><br><span class="line">10. 从输入一个URL到页面加载完成发生了什么</span><br><span class="line">11. 计算机网络了解吗？OSI七层模型？选择一个比较熟悉的层，介绍一下有哪些协议</span><br><span class="line">12. DNS的运行过程，DNS性能优化有哪些方法</span><br><span class="line">13. 写代码：给一个淘宝的页面，写一下大概如何布局</span><br><span class="line">14. 写代码，DOM操作将所有页面元素存为一个&#123;key:count&#125;的结构，即统计在页面中每种元素的数量，将元素根据count进行排序。</span><br><span class="line">15. 垃圾回收机制</span><br><span class="line">16. https和http区别，对称加密和非对称加密区别</span><br><span class="line">17. http1.0和http1.1和http2.0</span><br><span class="line">18. CSS盒模型（box-sizing属性）</span><br><span class="line">19. 写代码：多维数组展为一维数组（如：[[1,2],3,[4,5,6],[7,8]]-&gt;[1,2,3,4,5,6,7,8]）</span><br><span class="line">20. 写代码：自己实现一个instanceof</span><br><span class="line">21. 对于原型链的理解，new的过程中发生了什么，写代码：自己实现一个new</span><br><span class="line">22. Vue双向绑定的原理</span><br><span class="line">23. Vue双向绑定的原理</span><br><span class="line">24. Vue组件间的通信</span><br><span class="line">25. CSS雪碧图是什么</span><br><span class="line">26. 重绘和重排，哪些属性会触发重绘，哪些属性会触发重排</span><br><span class="line">27. ES6中<span class="built_in">let</span>,const,var的区别</span><br><span class="line">28. map,forEach的区别</span><br><span class="line">29. 跨域有哪些方法</span><br><span class="line">30. 写代码：多维数组展开成一维数组，分析算法的时间复杂度，用es6的什么方法可以实现（flat）</span><br><span class="line">31. 写代码：数组去重有哪些方法</span><br><span class="line">32. 写代码：用闭包实现add()函数，第n次调用的时候输出n</span><br><span class="line">33. this的指向问题：</span><br><span class="line">var a=2; var obj=&#123; a:1, b:this.a, fun:<span class="function"><span class="title">function</span></span>()&#123; console.log(this.b); &#125; &#125;</span><br><span class="line">输出结果为2，分析原因</span><br><span class="line">34. 写代码：实现call函数</span><br><span class="line">35. TCP三次握手，为什么是三次</span><br><span class="line">36. http请求包括什么，http应答包括什么</span><br><span class="line">37. 了解哪些状态码</span><br><span class="line">38. 输入url到页面出现发生了什么</span><br><span class="line">39. 浏览器渲染机制</span><br><span class="line">40. 什么是同源策略（如何判断是否同源），CORS策略</span><br><span class="line">41. CSS实现三角形，箭头</span><br><span class="line">42. CSS垂直居中的方法</span><br><span class="line">43. CSRF和XSS是什么，如何预防</span><br><span class="line">44. localStorage和sessionStorage区别，localStorage最大存储量</span><br><span class="line">45. CORS机制</span><br><span class="line">46. Chrome调试断点如何设置</span><br><span class="line">47. TCP三次握手，为什么不是四次，为什么不是两次</span><br><span class="line">48. 浏览器渲染机制，js阻塞加载</span><br><span class="line">49. js动态加载，<span class="built_in">eval</span>()方法</span><br><span class="line">50. 写代码：请求一个require.js文件，并统计文件中<span class="string">'require'</span>的数量，分析时间复杂度，如何优化</span><br><span class="line">51. 为什么想做前端，平时如何学习前端，知不知道社区里有哪些大神，讲讲最近看的一些前端相关的知识</span><br><span class="line">52. 自己对前端未来发展方向是什么</span><br><span class="line">53. 如何实现一个轮播图效果</span><br><span class="line">54. CSS3新特性了解哪些</span><br><span class="line">55. js数组的方法、对象的方法</span><br><span class="line">56. Flex布局</span><br><span class="line">57. js闭包</span><br><span class="line">58. json是什么，为什么要用json</span><br><span class="line">59. ajax元素操作的步骤</span><br><span class="line">60. 数组排序的方法有哪些？说一下归并</span><br><span class="line">61. 数组深拷贝</span><br><span class="line">62. 从后端返回一个很大的数组，如何实现分页显示（通过数组下标进行对应）</span><br><span class="line">63. 如何实现一个下划线（和text-decoration里的underline不一样），答案：用box-shadow</span><br><span class="line">64. 单页应用有什么好处</span><br><span class="line">65. 如何判断一个链表是否有环</span><br><span class="line">66. 一个二叉树中找到两个节点的最小公共父节点</span><br><span class="line">67. js闭包是什么，什么是内存泄漏，如何解决内存泄漏问题</span><br><span class="line">68. js垃圾回收机制</span><br><span class="line">69. 原生ajax原理，ajax和fetch的区别，fetch支持http的哪些方法</span><br><span class="line">70. option方法可以发送那些内容</span><br><span class="line">71. CSS的display有哪些取值</span><br><span class="line">72. iso七层模型，每一层模型的经典协议</span><br><span class="line">73. es6新增的数组方法</span><br><span class="line">74. 数组的reduce方法</span><br><span class="line">75. js中找到一个数组最大值的方法，分析复杂度</span><br><span class="line">76. MVC和MVVM的区别，MVVM的优点</span><br><span class="line">77. flex布局用在哪些场景下</span><br><span class="line">78. 如何适配不同的屏幕</span><br><span class="line">79. HTTP状态码有哪些</span><br><span class="line">80. cookie,localStorage,sessionStorage的区别</span><br><span class="line">81. es6的<span class="built_in">let</span>,const和var区别，const绑定的对象能不能修改属性值</span><br><span class="line">82. Vue数组双向绑定的原理，数组中没有get和<span class="built_in">set</span>方法，应该如何实现数据劫持</span><br><span class="line">83. event-loop原理，宏任务，微任务有哪些</span><br><span class="line">84. 如何实现水平垂直居中（元素定长和不定长）</span><br><span class="line">85. position有哪些属性，有什么区别，除了定位上的不同还有什么区别</span><br><span class="line">86. Vue组件中的data为什么是函数</span><br><span class="line">87. Vue双向数据绑定的原理</span><br><span class="line">88. webpack怎么用，实现机制</span><br><span class="line">89. Vuex相关</span><br><span class="line">90. 一个网站图片很多，加载很慢，应该如何优化：DOMContentLoad,图片懒加载，CDN</span><br><span class="line">91. Vue的watch和computed区别</span><br><span class="line">92. CSS选择器优先级</span><br><span class="line">93. es5实现继承</span><br><span class="line">94. 一个页面加载不出来可能是那些方面的原因</span><br><span class="line">95. setTimeout和Promise的区别，如何实现Promise</span><br><span class="line">96. HTTP持续连接实现原理</span><br><span class="line">97. 了解哪些设计模式</span><br><span class="line">98. jQ选择器的实现原理</span><br><span class="line">99. Vue中虚拟DOM解决什么问题，原理？</span><br><span class="line">100. http协议是什么，请求和响应的构成，如何区分一个请求的头部和实体（中间有一个空行）</span><br><span class="line">101. http有哪些方法，为什么要有这些方法（语义化）</span><br><span class="line">102. 状态码3开头的有哪些，浏览器收到301和302怎么做，304用在哪些场景</span><br><span class="line">103. cookie相关，cookie用在什么场景，cookie有哪些性质</span><br><span class="line">104.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/07/10/%E5%89%8D%E7%AB%AF%E8%A7%84%E5%88%99/%E4%BB%A3%E7%A0%81%E8%A7%84%E5%88%99/"/>
    <id>http://yoursite.com/2019/07/10/前端规则/代码规则/</id>
    <published>2019-07-10T00:59:31.939Z</published>
    <updated>2019-07-10T01:58:05.076Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前端代码命名规则"><a href="#前端代码命名规则" class="headerlink" title="前端代码命名规则"></a>前端代码命名规则</h3><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><ul><li>项目命名</li><li>目录/文件夹命名</li><li>JavaScript文件命名</li><li>css (scss、less、stylus)文件命名</li><li>html文件命名</li></ul><h4 id="HTML文件代码规范"><a href="#HTML文件代码规范" class="headerlink" title="HTML文件代码规范"></a>HTML文件代码规范</h4><ul><li>语法 （缩进，dom属性命名规范，单双引号的运用）</li><li>lang 属性</li><li>字符串编码</li><li>IE兼容模式</li><li>CSS 引入方式</li><li>JavaScript 文件引入顺序</li><li>避免 dom 标签嵌套的层级过多</li></ul><h4 id="CSS-文件代码规范"><a href="#CSS-文件代码规范" class="headerlink" title="CSS 文件代码规范"></a>CSS 文件代码规范</h4><ul><li>缩进</li><li>分号</li><li>空格</li><li>换行</li><li>注释方案</li><li>命名</li><li>媒体查询</li><li>….</li></ul><h4 id="JavaScript-文件代码规范"><a href="#JavaScript-文件代码规范" class="headerlink" title="JavaScript 文件代码规范"></a>JavaScript 文件代码规范</h4><ul><li>缩进、空格、换行、注释…</li><li>变量命名</li><li>函数引用</li><li>数组对象</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件循环与任务队列</title>
    <link href="http://yoursite.com/2019/04/22/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/04/22/JavaScript/事件循环与任务队列/</id>
    <published>2019-04-22T02:52:17.000Z</published>
    <updated>2019-04-22T03:05:43.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p><a href="https://juejin.im/post/5c8a024d51882546be0a3082" target="_blank" rel="noopener">从面试题看 JS 事件循环与 macro micro 任务队列</a></p><h3 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a>事件轮询</h3><p><strong>同步任务</strong> 指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<br><strong>异步任务</strong> 指的是，不进入主线程、而进入”任务队列”（<code>task queue</code>）的任务，等待同步任务执行完毕之后，轮询执行异步任务队列中的任务<br><strong>macrotask队列</strong> 等同于我们常说的任务队列，macrotask是由宿主环境分发的异步任务，事件轮询的时候总是一个一个任务队列去查看执行的，”任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。<br><strong>microtask</strong> 即<code>微任务</code>，是由js引擎分发的任务，总是添加到当前任务队列末尾执行。另外在处理<code>microtask</code>期间，如果有新添加的<code>microtasks</code>，也会被添加到队列的末尾并执行。注意与<code>setTimeout(fn,0)</code>的区别：<br>　　<code>setTimeOut(fn(),0)</code> 指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。<br><strong>所以我们可以得到js执行顺序是：</strong></p><blockquote><p>开始 -&gt; 取第一个task queue里的任务执行(可以认为同步任务队列是第一个task queue) -&gt; 取 microtask 全部任务依次执行 -&gt; 取下一个task queue里的任务执行 -&gt; 再次取出microtask全部任务执行 -&gt; … 这样循环往复</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CommonJS&amp;&amp;AMD&amp;&amp;CMD</title>
    <link href="http://yoursite.com/2019/04/21/JavaScript/CommonJS&amp;&amp;AMD&amp;&amp;CMD/"/>
    <id>http://yoursite.com/2019/04/21/JavaScript/CommonJS&amp;&amp;AMD&amp;&amp;CMD/</id>
    <published>2019-04-21T12:57:06.000Z</published>
    <updated>2019-09-30T01:00:05.187Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p><a href="https://juejin.im/post/5aaa37c8f265da23945f365c" target="_blank" rel="noopener">前端模块化：CommonJS,AMD,CMD,ES6</a><br><a href="https://juejin.im/post/5c17ad756fb9a049ff4e0a62#heading-2" target="_blank" rel="noopener">前端模块化详解(完整版)</a><br><a href="https://blog.csdn.net/jackwen110200/article/details/52105493" target="_blank" rel="noopener">前端模块化，AMD与CMD的区别</a></p><h2 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h2><h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h3><p>　　将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。<br>　　块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。</p><h3 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h3><p>　　避免命名冲突(减少命名空间污染)<br>　　更好的分离, 按需加载<br>　　更高复用性<br>　　高可维护性<br>目前这些规范的实现都能达成<code>浏览器端模块化开发的目的</code>。</p><h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>　　Node 应用由模块组成，采用 <code>CommonJS</code> 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>　　所有代码都运行在模块作用域，不会污染全局作用域。<br>　　模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。<br>　　模块加载的顺序，按照其在代码中出现的顺序。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>　　暴露模块：<code>module.exports = value</code>或<code>exports.xxx = value</code><br>　　引入模块：<code>require(xxx)</code>,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</p><p>　　此处我们有个疑问：<strong>CommonJS暴露的模块到底是什么?</strong> CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。<strong>加载某个模块，其实是加载该模块的module.exports属性。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var x = 5;</span><br><span class="line">var addX = <span class="keyword">function</span> (value) &#123;</span><br><span class="line">  <span class="built_in">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.x = x;</span><br><span class="line">module.exports.addX = addX;</span><br></pre></td></tr></table></figure></p><p>上面代码通过<code>module.exports</code>输出变量x和函数addX。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span><br><span class="line">var example = require(<span class="string">'./example.js'</span>);</span><br><span class="line">console.log(example.x); // 5</span><br><span class="line">console.log(example.addX(1)); // 6</span><br></pre></td></tr></table></figure></p><p>　　require命令用于加载模块文件。<strong>require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</strong></p><blockquote><p>CommonJS规范—是通过module.exports定义的，在前端浏览器里面并不支持module.exports,通过node.js后端使用的。Nodejs端是使用CommonJS规范的，前端浏览器一般使用AMD、CMD、ES6等定义模块化开发的<br>输出方式有2种：默认输出—module export  和带有名字的输出—exports.area</p></blockquote><h4 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h4><p>　　<strong>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</strong>。这点与ES6模块化有重大差异（下文会介绍），请看下面这个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line">var counter = 3;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">incCounter</span></span>() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">var counter = require(<span class="string">'./lib'</span>).counter;</span><br><span class="line">var incCounter = require(<span class="string">'./lib'</span>).incCounter;</span><br><span class="line"></span><br><span class="line">console.log(counter);  // 3</span><br><span class="line">incCounter();</span><br><span class="line">console.log(counter); // 3</span><br></pre></td></tr></table></figure></p><p>　　上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。<strong>这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</strong></p><h3 id="AMD和require-js"><a href="#AMD和require-js" class="headerlink" title="AMD和require.js"></a>AMD和require.js</h3><p>　　AMD规范采用<code>异步方式加载模块</code>，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用<code>require.js</code>实现<code>AMD</code>规范的模块化：用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。<br>　　首先我们需要引入<code>require.js</code>文件和一个入口文件<code>main.js</code>。<code>main.js</code>中配置<code>require.config()</code>并规定项目中用到的基础模块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/** 网页中引入require.js及main.js **/</span><br><span class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/main"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">/** main.js 入口文件/主模块 **/</span><br><span class="line">// 首先用config()指定各模块路径和引用名</span><br><span class="line">require.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">"js/lib"</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,  //实际路径为js/lib/jquery.min.js</span><br><span class="line">    <span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 执行基本操作</span><br><span class="line">require([<span class="string">"jquery"</span>,<span class="string">"underscore"</span>],<span class="keyword">function</span>($,_)&#123;</span><br><span class="line">  // some code here</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>　　引用模块的时候，我们将模块名放在<code>[]</code>中作为<code>reqiure()</code>的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在<code>[]</code>中作为<code>define()</code>的第一参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 定义math.js模块</span><br><span class="line">define(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var basicNum = 0;</span><br><span class="line">    var add = <span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">        <span class="built_in">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        add: add,</span><br><span class="line">        basicNum :basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">// 定义一个依赖underscore.js的模块</span><br><span class="line">define([<span class="string">'underscore'</span>],<span class="keyword">function</span>(_)&#123;</span><br><span class="line">  var classify = <span class="keyword">function</span>(list)&#123;</span><br><span class="line">    _.countBy(list,<span class="keyword">function</span>(num)&#123;</span><br><span class="line">      <span class="built_in">return</span> num &gt; 30 ? <span class="string">'old'</span> : <span class="string">'young'</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    classify :classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 引用模块，将模块放在[]内</span><br><span class="line">require([<span class="string">'jquery'</span>, <span class="string">'math'</span>],<span class="keyword">function</span>($, math)&#123;</span><br><span class="line">  var sum = math.add(10,20);</span><br><span class="line">  $(<span class="string">"#sum"</span>).html(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>RequireJS：是一个AMD框架，可以异步加载JS文件，按照模块加载方法，通过define()函数定义，第一个参数是一个数组，里面定义一些需要依赖的包，第二个参数是一个回调函数，通过变量来引用模块里面的方法，最后通过return来输出。<br>是一个依赖前置、异步定义的AMD框架（在参数里面引入js文件），在定义的同时如果需要用到别的模块，在最前面定义好即在参数数组里面进行引入，在回调里面加载</p></blockquote><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>　　CMD规范专门用于浏览器端，<code>模块的加载是异步的</code>，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。</p><h4 id="CMD规范基本语法"><a href="#CMD规范基本语法" class="headerlink" title="CMD规范基本语法"></a>CMD规范基本语法</h4><p>　　定义暴露模块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义没有依赖的模块</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module)&#123;</span><br><span class="line">  exports.xxx = value</span><br><span class="line">  module.exports = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义有依赖的模块</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module)&#123;</span><br><span class="line">  //引入依赖模块(同步)</span><br><span class="line">  var module2 = require(<span class="string">'./module2'</span>)</span><br><span class="line">  //引入依赖模块(异步)</span><br><span class="line">    require.async(<span class="string">'./module3'</span>, <span class="keyword">function</span> (m3) &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  //暴露模块</span><br><span class="line">  exports.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>引入使用模块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span> (require) &#123;</span><br><span class="line">  var m1 = require(<span class="string">'./module1'</span>)</span><br><span class="line">  var m4 = require(<span class="string">'./module4'</span>)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="CMD和sea-js"><a href="#CMD和sea-js" class="headerlink" title="CMD和sea.js"></a>CMD和sea.js</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>　　Sea.js 推崇一个模块一个文件，遵循统一的写法<br>　　　　define(id?, deps?, factory)<br>　　因为CMD推崇<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个文件一个模块，所以经常就用文件名作为模块id</span><br><span class="line">CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写</span><br></pre></td></tr></table></figure></p><p>　　<code>factory</code>是一个函数，有三个参数，<code>function(require, exports, module)</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口：require(id)</span><br><span class="line">exports 是一个对象，用来向外提供模块接口</span><br><span class="line">module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</span><br></pre></td></tr></table></figure></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>　　require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>], <span class="keyword">function</span>(a, b, c, d, e, f) &#123; </span><br><span class="line">    // 等于在最前面声明并初始化了要用到的所有模块</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">      // 即便没用到某个模块 b，但 b 还是提前执行了</span><br><span class="line">      b.foo()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>　　CMD是另一种js模块化方案，它与AMD很类似，不同点在于：<strong>AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/** AMD写法 **/</span><br><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>], <span class="keyword">function</span>(a, b, c, d, e, f) &#123; </span><br><span class="line">     // 等于在最前面声明并初始化了要用到的所有模块</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        // 即便没用到某个模块 b，但 b 还是提前执行了</span><br><span class="line">        b.doSomething()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/** CMD写法 **/</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var a = require(<span class="string">'./a'</span>); //在需要时申明</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        var b = require(<span class="string">'./b'</span>);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/** sea.js **/</span><br><span class="line">// 定义模块 math.js</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var $ = require(<span class="string">'jquery.js'</span>);</span><br><span class="line">    var add = <span class="keyword">function</span>(a,b)&#123;</span><br><span class="line">        <span class="built_in">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    exports.add = add;</span><br><span class="line">&#125;);</span><br><span class="line">// 加载模块</span><br><span class="line">seajs.use([<span class="string">'math.js'</span>], <span class="keyword">function</span>(math)&#123;</span><br><span class="line">    var sum = math.add(1+2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>　　ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：<code>export和import</code>。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/** 定义模块 math.js **/</span><br><span class="line">var basicNum = 0;</span><br><span class="line">var add = <span class="keyword">function</span> (a, b) &#123;</span><br><span class="line">    <span class="built_in">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">export</span> &#123; basicNum, add &#125;;</span><br><span class="line"></span><br><span class="line">/** 引用模块 **/</span><br><span class="line">import &#123; basicNum, add &#125; from <span class="string">'./math'</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(ele) &#123;</span><br><span class="line">    ele.textContent = add(99 + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　如上例所示，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名。其实<code>ES6</code>还提供了<code>exportdefault</code>命令，为模块指定默认输出，对应的<code>import</code>语句不需要使用大括号。这也更趋近于<code>ADM</code>的引用写法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** <span class="built_in">export</span> default **/</span><br><span class="line">//定义输出</span><br><span class="line"><span class="built_in">export</span> default &#123; basicNum, add &#125;;</span><br><span class="line">//引入</span><br><span class="line">import math from <span class="string">'./math'</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(ele) &#123;</span><br><span class="line">    ele.textContent = math.add(99 + math.basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p><h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><h4 id="CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h4><p>　　CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。<br>　　ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> counter = 3;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">incCounter</span></span>() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">// main.js</span><br><span class="line">import &#123; counter, incCounter &#125; from <span class="string">'./lib'</span>;</span><br><span class="line">console.log(counter); // 3</span><br><span class="line">incCounter();</span><br><span class="line">console.log(counter); // 4</span><br></pre></td></tr></table></figure></p><h4 id="CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h4><p>　　运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。<br>　　编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。<br>　　CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><h3 id="AMD与CMD区别"><a href="#AMD与CMD区别" class="headerlink" title="AMD与CMD区别"></a>AMD与CMD区别</h3><p>最明显的区别就是在模块定义时对依赖的处理不同<br>　　1、<code>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</code><br>　　2、<code>CMD推崇就近依赖，只有在用到某个模块的时候再去require</code><br>　　3、<code>AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹</code>。<br>这种区别各有优劣，只是语法上的差距，而且<code>requireJS</code>和<code>SeaJS</code>都支持对方的写法<br>　　AMD和CMD最大的区别是对依赖模块的<code>执行时机处理不同</code>，注意<code>不是加载的时机或者方式不同</code><br>　　很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略<br>　　为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）<br>　　同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行<br>　　CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的<br>　　这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。<br>　　AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。<br>　　CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重<br>　　ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>项目的总结</title>
    <link href="http://yoursite.com/2019/04/21/Project/Backstage/"/>
    <id>http://yoursite.com/2019/04/21/Project/Backstage/</id>
    <published>2019-04-21T10:50:06.000Z</published>
    <updated>2019-04-21T12:37:25.921Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>项目名： 森尚宅配全屋定制流程控制系统<br>项目地址： <a href="https://github.com/aLittleLittleStar/Backstage" target="_blank" rel="noopener">https://github.com/aLittleLittleStar/Backstage</a><br>项目技术：<br>Asp.net<br>MySQL8.0.13<br>JQuery2.2.4<br>BootStarp3.3.7<br>负责功能：<br>前端页面的设计与编写<br>登录交互功能的编写<br>（如何根据不同的用户权限对内容页面的展示进行修改。解决方法使用localStrong把用户类别放到本地前端读取之后进行相对应页面的显示和隐藏），<br>时间组件bootstrap-datetimepicker的使用<br>页面的布局 flex布局<br>iframe 的使用： 点击侧边栏菜单内容页面进行相应的切换<br>项目的难点：<br>登录功能的实现</p><p>Travel去哪儿网<br>项目地址： <a href="https://github.com/aLittleLittleStar/Travel" target="_blank" rel="noopener">https://github.com/aLittleLittleStar/Travel</a><br>项目技术：<br>node10.5.0<br>npm 3.0.0<br>axios 0.18.0<br>better-scroll 6.26.0<br>faskclick 1.0.6<br>stylus 0.54.5<br>vue 2.5.2<br>vue-router 3.0.1<br>vuex 3.0.1<br>ESLint 4.15.0<br>webpack 3.6.0</p><p>负责功能：页面的设计，功能分析，编译打包<br>数据的传递共享（vuex）<br>项目的难点：<br>解决一像素边框问题 fastclick<br>使用ajax获取数据</p><p>刷新页面是轮播图无法显示第一页<br>解决方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;swiper :options=&quot;swiperOption&quot; v-if=&quot;showSwiper&quot;&gt;</span><br><span class="line">&lt;!-- 计算属性：计算list数组长度，刚开始没有加载数据所以数组长度为0，v-if为false页面不显示 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        showSwiper () &#123;</span><br><span class="line">            return this.list.length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="项目总结" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>编程风格</title>
    <link href="http://yoursite.com/2019/04/17/JavaScript/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
    <id>http://yoursite.com/2019/04/17/JavaScript/编程风格/</id>
    <published>2019-04-17T12:42:01.000Z</published>
    <updated>2019-04-19T11:13:42.566Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>块级作用域<br>字符串<br>解构赋值<br>对象<br>数组<br>函数<br>Map函数<br>Class<br>模板<br>ESLint 使用</p><h3 id="正则："><a href="#正则：" class="headerlink" title="正则："></a>正则：</h3><h4 id="两种模糊匹配"><a href="#两种模糊匹配" class="headerlink" title="两种模糊匹配"></a>两种模糊匹配</h4><h5 id="横向模糊匹配"><a href="#横向模糊匹配" class="headerlink" title="横向模糊匹配"></a>横向模糊匹配</h5><p>横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。<br>{m,n}，表示连续出现最少m次，最多n次。<br>比如/ab{2,5}c/表示匹配这样一个字符串：第一个字符是“a”，接下来是2到5个字符“b”，最后是字符“c”。</p><h5 id="纵向模糊匹配"><a href="#纵向模糊匹配" class="headerlink" title="纵向模糊匹配"></a>纵向模糊匹配</h5><p>纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>蘑菇街面试准备</title>
    <link href="http://yoursite.com/2019/04/15/JavaScript/%E8%98%91%E8%8F%87%E8%A1%97%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/04/15/JavaScript/蘑菇街面试题详解/</id>
    <published>2019-04-15T11:05:41.000Z</published>
    <updated>2019-04-22T13:03:58.545Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>const<br>let  var 之间的区别<br>4、es6中的const解释解释<br>9.em和rem区别<br>3.js部分，const，let和 var 的区别。<br>4.js部分，数组遍历map和forEach的区别。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">能用forEach()做到的，map()同样可以。反过来也是如此。</span><br><span class="line">map()会分配内存空间存储新数组并返回，forEach()不会返回数据。</span><br><span class="line">forEach()允许callback更改原始数组的元素。map()返回新的数组。</span><br></pre></td></tr></table></figure></p><p>5.css部分，em和rem怎么做自适应。<br>8.函数提升和变量提升优先级<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">函数提升 优于变量</span><br><span class="line">解析器在向执行环境中加载数据时会率先读取函数声明，并使其在执行任何代码之前可用(可访问)，即函数声明提升、JavaScript上卷中第40页提到函数声明是优于变量提升的。可见代码</span><br><span class="line">console.log(getName)</span><br><span class="line">var getName = 1;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">// 输出为函数getName</span><br><span class="line">注意:不要学了一点就忘记别的了啊，如果两个函数名一样，后面的会覆盖前面的(认为是在函数解析的时候覆盖，即提升的时候就覆盖了)</span><br></pre></td></tr></table></figure></p><p>JS深拷贝的用处，哪里会用到？</p><blockquote><p>浅拷贝<br>深拷贝 </p></blockquote><p>7、闭包以及带来问题<br>闭包知道吗？它可能出现的问题呢<br>10、css有哪些布局（一开始理解错了说了一大堆，后来面试官带回来了，是关于position、float）<br>11、flex实现水平垂直居中<br>12、align-items:center是不是只针对垂直<br>css布局都用过啥，flex布局，想让我说flex布局的原理的。。。想想还是算了，感觉面试官对原理情有独钟<br>CSS布局技巧<br>跨域的几种方式，有答jsonp，然后又问了 jsonp 的原理是啥？<br>6.跨域问题<br>6.常用的跨域方式。<br>项目有没跨域问题<br>5.作用域链<br><a href="https://juejin.im/post/58ed9c0ea0bb9f006a4c28cd" target="_blank" rel="noopener">JavaScript深入之作用域链</a><br><a href="https://juejin.im/post/5c8290455188257e5d0ec64f" target="_blank" rel="noopener">深入理解JavaScript作用域和作用域链</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">作用域链，是由当前环境与上层环境的一系列变量对象组成，</span><br><span class="line">它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</span><br><span class="line"></span><br><span class="line">当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，</span><br><span class="line">就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到</span><br><span class="line">全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对</span><br><span class="line">象构成的链表就叫做作用域链。</span><br></pre></td></tr></table></figure></p><p>第一个问题是讲一下原型链，这个我先推了一下，讲了个小插曲，promise的状态和蘑菇街面试的状态吻合，只有pending、resolved、rejected三种状态，算是个破冰吧，今天看promise想到的。<br>然后继续回答原型链。</p><p>2、Promise了解多少<br><a href="https://juejin.im/post/5b32f552f265da59991155f0" target="_blank" rel="noopener"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Promise 是异步编程的一种解决方案：</span><br><span class="line">从语法上讲，promise是一个对象，从它可以获取异步操作的消息；</span><br><span class="line">从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</span><br><span class="line">promise有三种状态：pending(等待态)，fulfiled(成功态)，rejected(失败态)；</span><br><span class="line">状态一旦改变，就不会再变。创造promise实例后，它会立即执行。</span><br><span class="line"></span><br><span class="line">pending，异步任务正在进行。</span><br><span class="line">resolved (也可以叫fulfilled)，异步任务执行成功。</span><br><span class="line">rejected，异步任务执行失败。</span><br><span class="line"></span><br><span class="line">回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</span><br><span class="line">promise可以支持多个并发的请求，获取并发请求中的数据</span><br><span class="line">这个promise可以解决异步的问题，本身不能说promise是异步的</span><br><span class="line"></span><br><span class="line">Promise.resolve(value)</span><br><span class="line">类方法，该方法返回一个以 value 值解析后的 Promise 对象</span><br><span class="line">1、如果这个值是个 thenable（即带有 <span class="keyword">then</span> 方法），返回的 Promise </span><br><span class="line">对象会“跟随”这个 thenable 的对象，采用它的最终状态</span><br><span class="line">（指 resolved/rejected/pending/settled）</span><br><span class="line">2、如果传入的 value 本身就是 Promise 对象，</span><br><span class="line">  则该对象作为 Promise.resolve 方法的返回值返回。</span><br><span class="line">3、其他情况以该值为成功状态返回一个 Promise 对象。</span><br><span class="line"></span><br><span class="line">Promise.all的用法：谁跑的慢，以谁为准执行回调。</span><br><span class="line">  all接收一个数组参数，里面的值最终都算返回Promise对象</span><br><span class="line">  all方法可以说是Promise中很常用的方法了，它的作用就是将一个数组的Promise对象放在其中，当全部resolve的时候就会执行<span class="keyword">then</span>方法，当有一个reject的时候就会执行catch，并且他们的结果也是按着数组中的顺序来排放的，那么我们来实现一下。</span><br><span class="line">Promise.race的用法：谁跑的快，以谁为准执行回调</span><br><span class="line">它的作用是将一个Promise数组放入race中，哪个先执行完，race就直接执行完，并从<span class="keyword">then</span>中取值。</span><br><span class="line">Promise.prototype.catch</span><br><span class="line">  实例方法，捕获异常，函数形式：fn(err)&#123;&#125;, err 是 catch 注册 之前的回调抛出的异常信息。</span><br><span class="line">Promise.prototype.then</span><br><span class="line">  实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue)&#123;&#125;，value 是上一个任务的返回结果，<span class="keyword">then</span> 中的函数一定要 <span class="built_in">return</span> 一个结果或者一个新的 Promise 对象，才可以让之后的<span class="keyword">then</span> 回调接收。</span><br><span class="line">Promise.reject</span><br><span class="line">类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。</span><br><span class="line"></span><br><span class="line">Promise的立即执行性</span><br><span class="line">Promise 三种状态</span><br><span class="line">Promise 状态的不可逆性</span><br><span class="line"><span class="keyword">then</span>方法链式调用</span><br><span class="line"></span><br><span class="line">async/await</span><br></pre></td></tr></table></figure></p><p>promise有了解吗<br>Promise.all promise.race 有了解吗（当时一直听成Promise.out ，我就纳闷了说哪儿来的这个方法。。）</p><p>3.React 生命周期，如果要合并 props 和 state 在哪进行<br>4.React 组件想用函数调用的方式使用，怎么设计<br>react如果更新了父组件，子组件没有更新，会都重新渲染吗？<br>react的原理，他的内部是怎么构建DOM的，比如p标签的子元素放在哪个属性里。。。没看过源码着实不知道<br>react相关的redux的原理？<br>7.你印象比较深的项目或者代码<br>我觉得是像 antd 里面的 message 模块，使用 ReactDOM.render<br>挂载组件到指定节点，然后通过更新 props 使用<br>html css js擅长哪部分？<br>我回答擅长js，但他居然没有继续问下去了</p><p>3、es5和es6了解多少<br>es5,es6哪个用的多点？<br>3、es5和es6了解多少<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">变量声明：<span class="built_in">let</span> const</span><br><span class="line">字符串模板</span><br><span class="line">解构赋值 对象对对象 数组对数组</span><br><span class="line">扩展运算符</span><br><span class="line">箭头函数</span><br><span class="line">  不需要 <span class="keyword">function</span> 关键字来创建函数</span><br><span class="line">  省略 <span class="built_in">return</span> 关键字</span><br><span class="line">  继承当前上下文的 this 关键字</span><br><span class="line">import导入模块、<span class="built_in">export</span>导出模块</span><br><span class="line">Promise</span><br><span class="line">数组常用方法：</span><br><span class="line">Array.isArray</span><br><span class="line">map</span><br><span class="line">filter</span><br><span class="line">forEach</span><br><span class="line">every</span><br><span class="line">reduce</span><br><span class="line">splice</span><br><span class="line">indexOf</span><br><span class="line">slice</span><br><span class="line">concat</span><br><span class="line">reverse()</span><br><span class="line">join()</span><br><span class="line"></span><br><span class="line">Array.from()</span><br><span class="line">Array.of()</span><br><span class="line">copyWitch</span><br><span class="line">find</span><br><span class="line">findIndex</span><br><span class="line">keys()</span><br><span class="line">values()</span><br><span class="line">class 静态、私有、共有</span><br><span class="line"></span><br><span class="line">生成器（ generator）是能返回一个迭代器的函数。</span><br><span class="line">生成器函数也是一种函数，最直观的表现就是比普通的<span class="keyword">function</span>多了个星号*，</span><br><span class="line">在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。</span><br><span class="line"></span><br><span class="line">可以暂停并重新开始执行的函数</span><br><span class="line"></span><br><span class="line">generators 可以扮演三种角色</span><br><span class="line">  迭代器(数据生产者)</span><br><span class="line">  观察者(数据消费者)</span><br><span class="line">  协作程序(数据生产者和消费者)</span><br></pre></td></tr></table></figure></p><p><a href="https://segmentfault.com/a/1190000012358863" target="_blank" rel="noopener">es6 Generators详解</a></p><p>2.CSS sprite(雪碧图或者精灵图)<br><a href="https://www.cnblogs.com/evenyao/p/9262371.html" target="_blank" rel="noopener">CSS Sprite “精灵图”</a><br><a href="https://blog.csdn.net/CamilleZJ/article/details/80406645" target="_blank" rel="noopener">CSS Sprite雪碧图</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用CSS的<span class="string">"background-image"</span>，<span class="string">"background-repeat"</span>，<span class="string">"background-position"</span></span><br><span class="line">的组合进行背景定位，background-position可以用数字精确的定位出背景图片的位置。</span><br><span class="line">CSS Sprites 的优点：</span><br><span class="line">减少图片字节</span><br><span class="line">减少网页HTTP请求，提高网页性能</span><br><span class="line">减少命名难的问题</span><br><span class="line">缺点</span><br><span class="line">图片合并的时候要把图片合理的合并成一张图片，防止板块内出现不必要的背景</span><br><span class="line">在高分辨率下的自适应如果图片宽度不够，容易造成背景断裂</span><br><span class="line">维护的时候比较困难，如果背景图有少许改动，需要改动合并图片。</span><br></pre></td></tr></table></figure></p><p>事件节流？刚看过，没印象了，哭。<br>情景题，往下滚动，加载更多，有什么优化方案，图片懒加载？提示了可以滚轮事件是个比较频繁的操作，但是还是没想出来。防抖</p><p>vue和react差别，<br>8、问了vue有没有做过项目，然后就没有了<br>1.vue生命周期，没有问详细的，就是顺着生命周期说了一遍。英文捉急。<br>2.vue源码部分，几个重要的部分，compile，数据劫持，依赖收集，虚拟DOM。<br>问了一个异步加载组件，不用标签引入的方法。<br>让你实现vue你怎么实现……<br>说说vue的双向绑定（顺带把响应式说了）<br>说说Vue的diff过程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">如果不了解virtual dom，要理解diff的过程是比较困难的。虚拟dom对应的是真实dom， 使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点。</span><br><span class="line"></span><br><span class="line">我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。</span><br><span class="line">diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。</span><br><span class="line"></span><br><span class="line">在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。</span><br><span class="line">diff流程图</span><br><span class="line">当数据发生改变时，<span class="built_in">set</span>方法会让调用Dep.notify通知所有订阅者Watcher，</span><br><span class="line">订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。</span><br><span class="line"></span><br><span class="line">patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点</span><br><span class="line">判断两节点是否值得比较，值得比较则执行patchVnode</span><br><span class="line">不值得比较则用Vnode替换oldVnode</span><br><span class="line">如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。</span><br><span class="line"></span><br><span class="line">当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法</span><br><span class="line">这个函数做了以下事情：</span><br><span class="line">  找到对应的真实dom，称为el</span><br><span class="line">  判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接<span class="built_in">return</span></span><br><span class="line">  如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。</span><br><span class="line">  如果oldVnode有子节点而Vnode没有，则删除el的子节点</span><br><span class="line">  如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el</span><br><span class="line">  如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要</span><br><span class="line">updateChildren</span><br><span class="line">先说一下这个函数做了什么</span><br><span class="line">  将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来</span><br><span class="line">  oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。</span><br></pre></td></tr></table></figure></p><p>v-model，v-bind 和v-click<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">v-bind  动态地绑定一个或多个特性、或一个组件 prop 到表达式。</span><br><span class="line">1:v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，</span><br><span class="line">在为了能够动态的给这些属性添加值，可以使用v-bind:你要动态变化的值=<span class="string">"表达式"</span></span><br><span class="line"></span><br><span class="line">v-model 在表单控件或者组件上创建双向绑定。</span><br><span class="line">v-on 指令用于监听DOM事件 形式如：v-on:click  缩写为 @click;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[VUE中的v-if与v-show](http://www.cnblogs.com/wmhuang/p/5420344.html)</span><br><span class="line">手段：v-if是动态的向DOM树内添加或者删除DOM元素；</span><br><span class="line">v-show是通过设置DOM元素的display样式属性控制显隐；</span><br><span class="line">编译过程</span><br><span class="line">：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；</span><br><span class="line">v-show只是简单的基于css切换；</span><br><span class="line">编译条件：</span><br><span class="line">v-if是惰性的，如果初始条件为假，则什么也不做；</span><br><span class="line">只有在条件第一次变为真时才开始局部编译(编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载)</span><br><span class="line">v-if是动态的向DOM树内添加或者删除DOM元素；</span><br><span class="line">v-show是通过设置DOM元素的display样式属性控制显隐；</span><br><span class="line">v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；</span><br><span class="line">性能消耗：</span><br><span class="line">v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</span><br><span class="line">使用场景：</span><br><span class="line">v-if适合运营条件不大可能改变；v-show适合频繁切换。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</span><br><span class="line">v-if 也是惰性的：</span><br><span class="line">如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</span><br><span class="line">相比之下，v-show 就简单得多——不管初始条件是什么，</span><br><span class="line">元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</span><br><span class="line">一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；</span><br><span class="line">如果在运行时条件不太可能改变，则使用 v-if 较好。</span><br></pre></td></tr></table></figure></p><p>function a(){}，a的<strong>proto</strong> 指向哪，Function呢？Object呢？<br>js异步都有哪些？答了onclick之类的、setTimeout/setInterval/requestAnimation、Generator、promise、async/await，讲了promise和async/await的优缺点。</p><p>1.就我这次面试表现而言，有哪方面需要提升或者欠缺的<br>3.团队技术栈？<br>然后项目……照着你简历上的问，<br>技术选型，遇到的困难，解决思路，</p><p>面试中印象最深的问题<br>场面试官自己先介绍了三分钟..然后让我也介绍一下基本情况，项目经历难点之类的。<br>然后开始面试，很少技术问题<br>项目难点，如何解决的<br>有没有想过进入一个团队实习之后会有哪些压力大的事情？<br>有没有了解前端的新技术<br>有没有参加线下前端活动<br>会去看哪些博客或者社区<br>CSS动画和JS动画。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> (1)浏览器可以对动画进行优化。</span><br><span class="line">  1、 浏览器使用与 requestAnimationFrame 类似的机制，requestAnimationFrame比起setTimeout，setInterval设置动画的优势主要是:1)requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成,并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率,一般来说,这个频率为每秒60帧。2)在隐藏或不可见的元素中requestAnimationFrame不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。</span><br><span class="line">  2、强制使用硬件加速 （通过 GPU 来提高动画性能）</span><br><span class="line">  (2)代码相对简单,性能调优方向固定</span><br><span class="line">  (3)对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码</span><br><span class="line">缺点：</span><br><span class="line">　　1、 运行过程控制较弱,无法附加事件绑定回调函数。CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件,无进度报告</span><br><span class="line"> 　  2、  代码冗长。想用 CSS 实现稍微复杂一点动画,最后CSS代码都会变得非常笨重。</span><br><span class="line"></span><br><span class="line">JavaScript</span><br><span class="line">  (1)JavaScript动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。</span><br><span class="line">  (2)动画效果比css3动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成</span><br><span class="line">  (3)CSS3有兼容性问题，而JS大多时候没有兼容性问题</span><br><span class="line">缺点：</span><br><span class="line">　　　(1)JavaScript在浏览器的主线程中运行，而主线程中还有其它需要运行的JavaScript脚本、样式计算、布局、绘制任务等,对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。</span><br><span class="line">  (2)代码的复杂度高于CSS动画</span><br></pre></td></tr></table></figure></p><p>后来说问点有难度的问题的吧。直接怼了好多原理。。。卡了好几下<br>webpack的打包目录为啥是这样的，知道原理吗？<br>大概目前只能想到这些了，最后问了面试官几个问题，面试官说有结果，顿了一下，通过或者不通过hr都会通知你的emmm，感觉有点凉，主要是原理着实卡了好几个地方，不过自我感觉面试官人还是很nice的，没有太难为我，看面相是个忠厚老实的小哥哥emmm，求offer啊啊啊啊啊啊啊啊啊啊啊啊<br>7.项目印象深刻的部分和难点。<br>二面我就不写面经了，就是问了些项目上的问题，解决问题的思路，技术栈，基本情况<br>自我介绍<br>项目介绍<br>你说的你的项目里有个首屏加载特别慢的问题对吧？能说说怎么优化的吗？<br>一个骰子，5个面，你怎么实现它（一个面你怎么布局）<br>说说事件循环<br>假如有个项目加载最开始特别快，后面越来越慢你知道是为什么吗？以及如何第一时间定位（内存泄漏）<br>1、自我介绍 + 项目介绍（难点）<br>5、事件委托<br>6、任务队列<br>9、一个场景题（关于使用调试工具的）<br>13、bootstrap中的栅格式<br>一面我上来就说的微信小程序，然后后边面试官几乎都没问别的（倒是考我几个问题啊，js css啥都不问，得嘞，白准备了），然后说到Vue，说了个v-model感觉不是很满意，自己也觉得虽然自己懂原理，但是没讲清楚。。。整个流程10来分钟，估计gg了</p><p>重绘&amp;&amp;回流<br>vue differ<br>vue 生命周期<br>跨域<br>自我介绍</p><p>JavaScript 怎么实现 OOP<br>原型继承与类继承的区别<br>闭包的应用场景<br>关系完整性约束</p><p>Cookie &amp; Session 的区别<br>Session 的实现原理<br>HTTP 请求方法中哪些是幂等性的<br>跨域处理方案<br>JSONP 的缺点以及安全隐患<br>为什么要做单元测试<br>黑盒测试与白盒测试的区别<br>怎样实现测试覆盖率<br>Async &amp; Await 的使用</p><p>块级元素、行内元素、inline-block 的区别<br>水平居中的方法<br>String、Array 常用的方法<br>输入一个 URL 到呈现页面的过程<br>Vue.js 组件的生命周期<br>Git 怎么合并提交记录<br>Linux 常用的命令<br>HTTP2 新特性</p><p>常见的 Web 攻击手段以及防范措施<br>对 Ajax 的理解<br>对闭包的理解<br>对事件机制的理解<br>对 HTTP 的理解<br>GET &amp; POST 的区别<br>HTTP2 和 HTTP1 有什么不同<br>对 JavaScript 各大框架的理解<br>对 jQuery 的理解<br>页面性能优化<br>计算机网络分层<br>输入 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 到呈现页面的过程<br>事件机制（W3C 标准）<br>事件代理<br>XSS、CSRF 的防范<br>token 的实现原理<br>熟练使用JS实现Json、XML格式的数据发送与数据解析；<br>3、熟悉各种web标准，了解各主流浏览器特性，使页面兼容主浏览器；</p><p>自我介绍<br>事件流<br>vue nextTick原理<br>vue react区别<br>web优化<br>移动端的优化有特别了解过吗<br>css flex了解过吗<br>如何前端监控错误，<br>koa有学过吗<br>事件循环说一说<br>web新技术了解过哪些，最近有去学习哪些东西<br>PWA你能详细说说吗<br>service worker<br>h5 worker<br>非受控组件 与受控组件<br>const let var区别<br>三道题<br>有自己写过webpack插件吗<br>webpack loader 和plugin区别<br>实现promise<br>大数相加<br>纯js写一个动画，5s由快到慢，速度自定义<br>（这里特别感谢以前发过面筋的同学，前两道题因为碰到过，自己下去做了一下 10多分钟给做完了 然后又让我补了一道= =）<br>自我介绍，说一下怎么学习前端的，以及做的项目的亮点<br>web优化<br>缓存（协商，强制说一说）<br>CDN<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CDN的全称是Content Delivery Network，即内容分发网络。</span><br><span class="line">其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，</span><br><span class="line">使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联</span><br><span class="line">网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、</span><br><span class="line">负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近</span><br><span class="line">的服务节点上。</span><br><span class="line"></span><br><span class="line">其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，</span><br><span class="line">提高用户访问网站的响应速度。</span><br><span class="line">降低核心系统负载 加速用户访问</span><br><span class="line">CDN做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源</span><br></pre></td></tr></table></figure></p><p>DNS如何查询域名的<br>node中间件原理<br>跨域<br>作用域<br>一个页面白屏，分析原因<br>数据结构链表<br>怎么判断链表有环（当时还问我是不是刷了很多题，我们都笑了笑）<br>cookie了解吗<br>cookie的属性，怎么存储<br>web安全，xss csrf<br>css响应式布局<br>token生成过程<br>前端新技术<br>PWA讲一讲<br>serviceworker<br>h5 worker<br>智商题<br>3.45分夹角<br>两个火车相对而行，知道彼此的速度，中间有一个小鸟来回飞 知道小鸟的速度 求相撞的时候的 小鸟飞行的距离<br>10瓶药，每瓶药有10颗药片，每片10克，其中一瓶药里的所有药片是坏的 每片重量为11克，现在给你一个秤，如何一次性称出来</p><p>三面<br>自我介绍<br>web优化<br>css动画<br>csrf如何防御<br>如何生成token<br>Vue的diff能详细说一说吗<br>Vue子组件你的子组件方法是放在哪里的<br>Vue自定义指令<br>微信小程序接触过吗<br>微信小程序原理<br>TCP三次握手第三次失败了 客户端和服务端是如何处理的<br>301，302状态码区别，以及什么时候会返回这些状态。<br>node如何升级到webSoket<br>如何添加header头<br>DNS迭代和递归区别<br>前端怎么设置cookie过期<br>有看过源码吗<br>看过哪些书<br>能来实习的时间<br>智商题<br>一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球 求同时喜欢足球和篮球的<br>算法 最大的回文字符<br>北森<br>一面<br>面试官非常nice，善于引导<br>自我介绍<br>你的项目<br>能说下vue如何收集依赖双向绑定的吗<br>能说下vue如何更新节点的吗<br>node如何打印时间与错误<br>webpack构建流程<br>webpack如何找到依赖关系的<br>webpack如何配置<br>vue和react区别<br>react生命周期<br>函数式组件，如何给状态（hook）<br>原型链，原型知道多少<br>es6了解哪些<br>promise.resolve()<br>http状态码<br>post请求之前先发送Option条件<br>get,post,put,delete区别（冥等）<br>二面<br>面试官是个女架构师，感觉非常好，还因为迟到了几分钟说道歉之类的<br>vue,react，你更倾向于哪一个，为什么<br>es6模块cmd amd 区别<br>跨域<br>深拷贝，浅拷贝<br>post发送Option的条件<br>输入URL到浏览器会发生什么<br>TCP为什么三次握手<br>TCP为什么四次挥手<br>HTTP为什么基于TCP协议<br>vue diff过程<br>vue如果同一个数据，很短的时间内连续更新 会怎么样。<br>算法题<br>[0,0,1,1,1,2,3,4,5]，不借用辅助空间找到不重复项[2，3，4，5]</p><p>三面<br>面试官是技术总监，问的问题都是基于场景来说的，面试体验还可以<br>有这样一个数组，你如何扁平化<br>如果用字符串形式会出现什么问题<br>跨域你如何处理的<br>能说说同源策略吗，那如果是直接请求ip会有同源策略吗，如果一个域名对应多个ip的情况呢。<br>你以前做的项目，如果让你去完善你能说一说完善的细节吗，说三点 （我提到模块化，规范化，可扩展性）<br>能具体一点说说吗，说一点就可以<br>你觉得你相比其他实习生的优点和缺点在哪里</p><p>前天过了一面。问的有基础的知识和CSS、JS应用的知识，还问了OSI七层网络。其实自我感觉回答的不太好，面试官也说框架知识和项目经验不太足够，没想到过了。<br>了项目难点，然后还考了osi网络层级，怎么用css实现表格奇偶行不同颜色，怎么根据表格行的颜色拿到行数，还问了vue的生命周期钩子函数，vue-cli不过我没答上来</p><p>007bcc9b9629c19abe2d66d4ceb0c0006f9fd8e8</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
