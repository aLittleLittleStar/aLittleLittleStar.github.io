<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>昨夜小楼又东风</title>
  
  <subtitle>纵豆蔻词工，青楼好梦，难赋深情</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-25T12:24:21.080Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LittleStar</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网页从输入网址到渲染完成经历了哪些过程</title>
    <link href="http://yoursite.com/2019/02/23/HTTP/%E7%BD%91%E9%A1%B5%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/23/HTTP/网页从输入网址到渲染完成经历了哪些过程/</id>
    <published>2019-02-23T14:45:31.000Z</published>
    <updated>2019-02-25T12:24:21.080Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="过程概述"><a href="#过程概述" class="headerlink" title="过程概述"></a>过程概述</h4><p>　　从输入域名到网页打开的简单过程如下：<br><strong>1. DNS域名解析</strong><br>　　客户端输入域名后，由DNS服务器来将域名解析成对应服务器的IP地址<br><strong>2. 建立TCP连接</strong><br>　　客户端得到IP地址以后,会根据所获得的IP地址以及要访问的端口号发起网络连接， 即<font color="blue"><strong>tcp三次握手</strong></font>连接， 建立起TCP/IP网络连接， 具体过程如下：<a id="more"></a><br>　　第一次握手：<br>　　　　<font color="orange">主机向服务器发送一个建立连接的请求（您好，我想认识您）</font><br>　　　　<font color="red">建立连接时，客户端发送syn包(syn=j)到服务器，并进入<strong><em>SYN_SEND</em></strong>状态，等待服务器确认</font><br>　　第二次握手：<br>　　　　<font color="orange">服务器接到请求后发送同意连接的信号（好的，很高兴认识您）</font><br>　　　　<font color="red">服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器 进入SYN_RECV状态；</font><br>　　第三次握手：<br>　　　　<font color="orange">主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接</font><br>　　　　<font color="red">客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。<br>通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。</font><br><strong>补充说明:</strong><br>　　　　TCP 协议：三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号。<br><strong>3. 发送HTTP请求</strong><br>　　与服务器建立连接之后，就可以向服务器发送请求了，请求需要遵循http协议<br><strong>4.服务器处理请求；</strong><br>　　被请求的服务器解析用户请求的有哪些资源，通过服务器返回数据给客户端<br><strong>5.返回响应结果；</strong><br>　　给客户端返回请求的状态码，通过状态码可以知道服务器端的处理是否正常<br><strong>6.浏览器渲染：</strong><br>　　返回成功之后，浏览器拿到请求页面的代码，将其解析渲染出来。解析和渲染的过程主要由浏览器的渲染引擎实现。</p><h5 id="根据域名查找-IP-地址"><a href="#根据域名查找-IP-地址" class="headerlink" title="根据域名查找 IP 地址"></a>根据域名查找 IP 地址</h5><h6 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h6><p>　　<strong>IP 地址</strong>：IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址；<br>　　<strong>域名(DN)</strong>：IP 地址由四个数字组成，中间用点号连接，在使用过程中难记忆且易输入错误，所以用我们熟悉的字母和数字组合来代替纯数字的 IP 地址，比如我们只会记住 <code>www.baidu.com</code>（百度域名） 而不是 <code>220.181.112.244</code>（百度的其中一个 IP 地址）；<br>　　<strong>DNS</strong>： 每个域名都对应一个或多个提供相同服务服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。</p><p>　　知道了上面的概念，大概就知道了想要获得服务器的门牌号码，需要先将域名转换成 IP 地址。转换过程如下（以查询 <code>www.baidu.com</code> 的 IP 地址为例，其中2、3、4步均在上一步未查询成功的情况下进行）：</p><h6 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h6><ol><li>浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；</li><li>搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；</li><li>搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；</li><li>操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；<ol><li>LDNS 向 <code>Root Name Server</code>（根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，<code>Root Name Server</code>返回 com 域的顶级域名服务器的地址；</li><li>LDNS 向 com 域的顶级域名服务器发起请求，返回 <code>baidu.com</code>域名服务器地址；</li><li>LDNS 向 baidu.com 域名服务器发起请求，得到 <code>www.baidu.com</code>的 IP 地址；</li></ol></li><li>LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；</li><li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；</li><li>至此，浏览器已经得到了域名对应的 IP 地址。</li></ol><p><strong>补充说明</strong><br>　　域名与 URL 是两个概念：域名是一台或一组服务器的名称，用来确定服务器在 Internet 上的位置；URL 是统一资源定位符，用来确定某一个文件的具体位置，例如，<code>zhihu.com</code> 是 知乎的域名，根据这个域名可以找到知乎的服务器，<code>zhihu.com/people/CompileYouth</code> 是 URL ，可以根据这个 URL 定位我的知乎主页；<br>　　IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限；</p><h5 id="网页请求与显示"><a href="#网页请求与显示" class="headerlink" title="网页请求与显示"></a>网页请求与显示</h5><p>　　当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。</p><ol><li>服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；</li><li>服务器将得到的 HTML 文件发送给浏览器；</li><li>在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；</li><li>在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML </li></ol><h4 id="断开连接–四次挥手"><a href="#断开连接–四次挥手" class="headerlink" title="断开连接–四次挥手"></a>断开连接–四次挥手</h4><ol><li>主机向服务器发送一个断开连接的请求（不早了，我该走了）；</li><li>服务器接到请求后发送确认收到请求的信号（知道了）；</li><li>服务器向主机发送断开通知（我也该走了）；</li><li>主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；</li></ol><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>　　一个完整的URL地址由：<strong>协议</strong>、<strong>服务器地址(主机)</strong>、<strong>端口</strong>、<strong>资源路径(文件)</strong>。其中网络地址指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；协议是从 该计算机获取资源的方式，常见的是HTTP、FTP，不同协议有不同的通讯内容格式；资源路径指示从服务器上获取哪一项资源。<br>例如：<code>http://www.guokr.com/question/554991/</code><br>超文本传输协议：<code>http</code><br>服务器地址：<code>www.guokr.com</code><br>端口： http协议的默认<strong>端口</strong>为80<br>资源路径：是指要活的的文件的路径 -&gt;<code>/question/554991/</code></p><p>转载：<br>　　<a href="https://www.cnblogs.com/ishuanghe/p/5200775.html" target="_blank" rel="noopener">一个页面从输入url,到页面显示加载完成,这个过程中都发生了什么?</a><br>　　<a href="https://zhuanlan.zhihu.com/p/23155051" target="_blank" rel="noopener">从输入 URL 到页面加载完成的过程中都发生了什么</a><br>参考文章：<br>　　<a href="http://www.cnblogs.com/beyond-Acm/p/4309983.html" target="_blank" rel="noopener">从键入网址到页面显示经历了那些过程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h4 id=&quot;过程概述&quot;&gt;&lt;a href=&quot;#过程概述&quot; class=&quot;headerlink&quot; title=&quot;过程概述&quot;&gt;&lt;/a&gt;过程概述&lt;/h4&gt;&lt;p&gt;　　从输入域名到网页打开的简单过程如下：&lt;br&gt;&lt;strong&gt;1. DNS域名解析&lt;/strong&gt;&lt;br&gt;　　客户端输入域名后，由DNS服务器来将域名解析成对应服务器的IP地址&lt;br&gt;&lt;strong&gt;2. 建立TCP连接&lt;/strong&gt;&lt;br&gt;　　客户端得到IP地址以后,会根据所获得的IP地址以及要访问的端口号发起网络连接， 即&lt;font color=&quot;blue&quot;&gt;&lt;strong&gt;tcp三次握手&lt;/strong&gt;&lt;/font&gt;连接， 建立起TCP/IP网络连接， 具体过程如下：&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="网页从输入网址到渲染完成经历了哪些过程" scheme="http://yoursite.com/tags/%E7%BD%91%E9%A1%B5%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MVVM开发模式的理解</title>
    <link href="http://yoursite.com/2019/02/23/Vue/MVVM%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/23/Vue/MVVM开发模式的理解/</id>
    <published>2019-02-23T06:28:24.000Z</published>
    <updated>2019-02-23T14:15:49.508Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- 目录 --><!-- toc --><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>　　MVVM（模型视图ViewModel 是一种基于MVC和MVP的架构模式，<font color="FF0000">它试图更清楚地将用户界面（UI）的开发与应用程序中的业务逻辑和行为的开发分开</font>。为此，此模式的许多实现都使用声明性数据绑定，以允许将视图上的工作与其他层分离。<a id="more"></a></p><h4 id="Model、View、ViewModel"><a href="#Model、View、ViewModel" class="headerlink" title="Model、View、ViewModel"></a>Model、View、ViewModel</h4><p>　　MVVM分为Model、View、ViewModel三者。</p><ul><li>Model 代表数据模型，数据和业务逻辑都在Model层中定义；</li><li>View 代表UI视图，负责数据的展示，是用户在屏幕上看到的结构；</li><li>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；<br>　　Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。<br>这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom。<br><img src="/assets/images/mvvm2.png" alt="mvvm"><br><img src="/assets/images/mvvm.png" alt="mvvm"></li></ul><h3 id="设计模式编辑"><a href="#设计模式编辑" class="headerlink" title="设计模式编辑"></a>设计模式编辑</h3><p>　　因为WPF技术出现，从而使MVC架构模式有所改进，MVVM 模式便是使用的是数据绑定基础架构。它们可以轻松构建UI的必要元素。<br>可以参考The Composite Application Guidance for WPF(prism)<br>View绑定到ViewModel，然后执行一些命令在向它请求一个动作。而反过来，ViewModel跟Model通讯，告诉它更新来响应UI。这样便使得为应用构建UI非常的容易。往一个应用程序上贴一个界面越容易，外观设计师就越容易使用Blend来创建一个漂亮的界面。同时，当UI和功能越来越松耦合的时候，功能的可测试性就越来越强。<br>在MVP模式中，为了让UI层能够从逻辑层上分离下来，设计师们在UI层与逻辑层之间加了一层interface。无论是UI开发人员还是数据开发人员，都要尊重这个契约、按照它进行设计和开发。这样，理想状态下无论是Web UI还是Window UI就都可以使用同一套数据逻辑了。借鉴MVP的IView层，养成习惯。View Model听起来比Presenter要贴切得多；会把一些跟事件、命令相关的东西放在MVC的’C’,或者是MVVM的’Vm’。</p><h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>　　MVVM模式和MVC模式一样，主要目的是<font color="#FF0000">分离视图（View）</font>和<font color="#FF0000">模型（Model）</font>，有几大优点:</p><ol><li><strong>低耦合</strong>: <strong>视图（View）</strong>可以独立于 <strong>Model</strong> 变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li><li><strong>可重用性</strong>: 你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li><li><strong>独立开发</strong>:开发人员可以专注于业务逻辑和数据的开发(ViewModel), 设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。</li><li><strong>可测试</strong>:界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</li><li>MVVM有助于更轻松地并行开发UI以及为其提供支持的构建块</li><li>抽象视图，从而减少其背后的代码所需的业务逻辑（或粘合剂）的数量</li><li>ViewModel比事件驱动的代码更容易进行单元测试</li><li>可以在不关心UI自动化和交互的情况下测试ViewModel（比View更多的模型）</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>对于更简单的UI，MVVM可能过度</li><li>虽然数据绑定可以是声明性的并且很好用，但它们比我们简单设置断点的命令式代码更难调试</li><li>非平凡应用程序中的数据绑定可以创建大量的簿记。您也不希望在绑定比绑定的对象更重的情况下结束</li><li>在较大的应用程序中，预先设计ViewModel以获得必要的泛化量可能更加困难</li></ol><p>参考文章：<br>　　<a href="https://www.cnblogs.com/iovec/p/7840228.html" target="_blank" rel="noopener">前后端分手大师——MVVM 模式</a><br>　　<a href="https://zhuanlan.zhihu.com/p/38296857" target="_blank" rel="noopener">简单理解MVVM–实现Vue的MVVM模式</a><br>　　<a href="https://addyosmani.com/blog/understanding-mvvm-a-guide-for-javascript-developers/" target="_blank" rel="noopener">了解MVVM - JavaScript开发人员指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- 目录 --&gt;
&lt;!-- toc --&gt;
&lt;h3 id=&quot;MVVM&quot;&gt;&lt;a href=&quot;#MVVM&quot; class=&quot;headerlink&quot; title=&quot;MVVM&quot;&gt;&lt;/a&gt;MVVM&lt;/h3&gt;&lt;p&gt;　　MVVM（模型视图ViewModel 是一种基于MVC和MVP的架构模式，&lt;font color=&quot;FF0000&quot;&gt;它试图更清楚地将用户界面（UI）的开发与应用程序中的业务逻辑和行为的开发分开&lt;/font&gt;。为此，此模式的许多实现都使用声明性数据绑定，以允许将视图上的工作与其他层分离。&lt;/p&gt;
    
    </summary>
    
      <category term="开发模式" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>redis基础</title>
    <link href="http://yoursite.com/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    <id>http://yoursite.com/2019/02/22/数据库/redis/</id>
    <published>2019-02-22T13:47:36.000Z</published>
    <updated>2019-02-22T13:29:06.914Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis基础" scheme="http://yoursite.com/tags/redis%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>stylus基础</title>
    <link href="http://yoursite.com/2019/02/22/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/stylus%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/22/CSS预处理器/stylus基础语法/</id>
    <published>2019-02-22T13:47:36.000Z</published>
    <updated>2019-02-22T13:46:25.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="stylus" scheme="http://yoursite.com/categories/stylus/"/>
    
    
      <category term="stylus基础" scheme="http://yoursite.com/tags/stylus%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>mongoose</title>
    <link href="http://yoursite.com/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/mongoose/"/>
    <id>http://yoursite.com/2019/02/22/数据库/mongoose/</id>
    <published>2019-02-22T13:27:12.000Z</published>
    <updated>2019-02-22T13:44:54.750Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h4><h5 id="mongodb-的概念-amp-安装"><a href="#mongodb-的概念-amp-安装" class="headerlink" title="mongodb 的概念 &amp; 安装"></a>mongodb 的概念 &amp; 安装</h5><p>mongod</p><h5 id="mongodb-可视化工具-RoRo-3T-安装及应用"><a href="#mongodb-可视化工具-RoRo-3T-安装及应用" class="headerlink" title="mongodb 可视化工具 RoRo 3T 安装及应用"></a>mongodb 可视化工具 RoRo 3T 安装及应用</h5><h5 id="mongoose-的作用"><a href="#mongoose-的作用" class="headerlink" title="mongoose 的作用"></a>mongoose 的作用</h5><h5 id="mongoose-的应用"><a href="#mongoose-的应用" class="headerlink" title="mongoose 的应用"></a>mongoose 的应用</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="mongoose" scheme="http://yoursite.com/categories/mongoose/"/>
    
    
      <category term="mongoose" scheme="http://yoursite.com/tags/mongoose/"/>
    
  </entry>
  
  <entry>
    <title>Koa2基础</title>
    <link href="http://yoursite.com/2019/02/21/Koa2/Koa2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/02/21/Koa2/Koa2基础知识/</id>
    <published>2019-02-21T15:54:01.000Z</published>
    <updated>2019-02-22T13:25:17.236Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p><a href="https://koa.bootcss.com" target="_blank" rel="noopener">Koa官网</a><br><a href="https://chenshenhai.github.io/koa2-note/" target="_blank" rel="noopener">《Koa2进阶学习笔记》已完结</a></p><h3 id="使用koa-generator生成koa2项目"><a href="#使用koa-generator生成koa2项目" class="headerlink" title="使用koa-generator生成koa2项目"></a>使用koa-generator生成koa2项目</h3><p>全局安装koa-generator: <code>npm install -g koa-generator</code><br>使用koa-generator生成koa2项目: <code>koa2 -e koa2-learn</code><br>　　　　　　　　　　　　　　　　　<strong>-e 添加ejs模板引擎支持(默认是jade)</strong><br>　　　　　　　　　　　　　　　　　koa2-learn 项目名<a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ koa2 -e koa2-learning</span><br><span class="line"></span><br><span class="line">   create : koa2-learning</span><br><span class="line">   create : koa2-learning/package.json</span><br><span class="line">   create : koa2-learning/app.js</span><br><span class="line">   create : koa2-learning/public/javascripts</span><br><span class="line">   create : koa2-learning/routes</span><br><span class="line">   create : koa2-learning/routes/index.js</span><br><span class="line">   create : koa2-learning/routes/users.js</span><br><span class="line">   create : koa2-learning/public/images</span><br><span class="line">   create : koa2-learning/public/stylesheets</span><br><span class="line">   create : koa2-learning/public/stylesheets/style.css</span><br><span class="line">   create : koa2-learning/public</span><br><span class="line">   create : koa2-learning/views</span><br><span class="line">   create : koa2-learning/views/index.ejs</span><br><span class="line">   create : koa2-learning/views/error.ejs</span><br><span class="line">   create : koa2-learning/bin</span><br><span class="line">   create : koa2-learning/bin/www</span><br><span class="line"></span><br><span class="line">   install dependencies:</span><br><span class="line">     $ cd koa2-learning &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">   run the app:</span><br><span class="line">     $ DEBUG=koa2-learning:* npm start</span><br></pre></td></tr></table></figure></p><p>PS: 如果出现 <code>npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.7: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})</code>  不用担心。出现原因：<br><code>fsevents</code> 不在 <code>package.json</code>里，但是仍然安装了，是因为你的系统是Windows系统，fsevents是苹果系统的可选依赖,你的项目有可能是团队项目，别人在他的mac上安装了fsevents相关依赖库，所以到这边你也就安装到你的windows上边了。你可以检查你的package.json 文件中是不是有fsevents相关依赖，删除即好！<br>如果没有，其他的npm包也会有依赖fsevents的！！！<br><strong>这是warning错误，是因为mac下需要fsevents，这里是在windows环境，所以可以忽略这个警告，对你没什么影响的。</strong><br>运行: <code>DEBUG=koa2-learning:* npm start</code> || <code>npm run dev</code><br>效果： 出现 <strong>node bin/www</strong> 访问 <code>http://localhost:3000/</code><br>注意： npm start 、 npm test 、 npm run dev 、 npm run prd</p><h3 id="async-和-await-语法"><a href="#async-和-await-语法" class="headerlink" title="async 和 await 语法"></a>async 和 await 语法</h3><h4 id="异步概念"><a href="#异步概念" class="headerlink" title="异步概念"></a>异步概念</h4><blockquote><p>是指一个进程在执行某个请求的时候，如果这个请求没有执行完毕，进程不会等待，而是继续执行下面的请求。</p></blockquote><h4 id="理解async-和-await"><a href="#理解async-和-await" class="headerlink" title="理解async 和 await"></a>理解async 和 await</h4><h3 id="Koa2-中间件"><a href="#Koa2-中间件" class="headerlink" title="Koa2 中间件"></a>Koa2 中间件</h3><h4 id="koa2-中间件的原理"><a href="#koa2-中间件的原理" class="headerlink" title="koa2 中间件的原理"></a>koa2 中间件的原理</h4><p><img src="/assets/images/koa2.png" alt="koa2"><br><img src="/assets/images/koa2中间件.png" alt="koa2"></p><h4 id="自定义-koa2-中间件"><a href="#自定义-koa2-中间件" class="headerlink" title="自定义 koa2 中间件"></a>自定义 koa2 中间件</h4><h3 id="koa2-路由"><a href="#koa2-路由" class="headerlink" title="koa2 路由"></a>koa2 路由</h3><h4 id="路由写法"><a href="#路由写法" class="headerlink" title="路由写法"></a>路由写法</h4><h4 id="接口举例"><a href="#接口举例" class="headerlink" title="接口举例"></a>接口举例</h4><h3 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h3><h4 id="cookie-和-session-的定义"><a href="#cookie-和-session-的定义" class="headerlink" title="cookie 和 session 的定义"></a>cookie 和 session 的定义</h4><h4 id="cookie-和-session-的作用"><a href="#cookie-和-session-的作用" class="headerlink" title="cookie 和 session 的作用"></a>cookie 和 session 的作用</h4><p>推荐：<br>　　<a href="https://zhuanlan.zhihu.com/p/35040744" target="_blank" rel="noopener">从头实现一个koa框架</a><br>　　<a href="https://segmentfault.com/a/1190000013981513" target="_blank" rel="noopener">浅析koa的洋葱模型实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;&lt;a href=&quot;https://koa.bootcss.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Koa官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://chenshenhai.github.io/koa2-note/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Koa2进阶学习笔记》已完结&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用koa-generator生成koa2项目&quot;&gt;&lt;a href=&quot;#使用koa-generator生成koa2项目&quot; class=&quot;headerlink&quot; title=&quot;使用koa-generator生成koa2项目&quot;&gt;&lt;/a&gt;使用koa-generator生成koa2项目&lt;/h3&gt;&lt;p&gt;全局安装koa-generator: &lt;code&gt;npm install -g koa-generator&lt;/code&gt;&lt;br&gt;使用koa-generator生成koa2项目: &lt;code&gt;koa2 -e koa2-learn&lt;/code&gt;&lt;br&gt;　　　　　　　　　　　　　　　　　&lt;strong&gt;-e 添加ejs模板引擎支持(默认是jade)&lt;/strong&gt;&lt;br&gt;　　　　　　　　　　　　　　　　　koa2-learn 项目名&lt;/p&gt;
    
    </summary>
    
      <category term="Koa2" scheme="http://yoursite.com/categories/Koa2/"/>
    
    
      <category term="Koa2基础" scheme="http://yoursite.com/tags/Koa2%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js基础</title>
    <link href="http://yoursite.com/2019/02/15/Vue/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2019/02/15/Vue/基础知识点/</id>
    <published>2019-02-15T09:32:51.000Z</published>
    <updated>2019-02-20T14:18:20.035Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- 目录 --><!-- toc --><p>Vue.js基础，模块化，单文件组件，路由，与服务器通信，状态管理，单元测试与生产发布，服务端渲染SSR与Nuxt.js，基于Vue.js企业级项目开发(Mint UI, Element UI)等<br>132131</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue基础" scheme="http://yoursite.com/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>css布局</title>
    <link href="http://yoursite.com/2019/02/15/CSS3/css%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2019/02/15/CSS3/css布局/</id>
    <published>2019-02-15T08:27:32.000Z</published>
    <updated>2019-02-15T08:44:17.868Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="页面布局" scheme="http://yoursite.com/tags/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>像素：(px、pt、em、rem、rpx)</title>
    <link href="http://yoursite.com/2019/02/14/%E5%83%8F%E7%B4%A0/%E5%83%8F%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/02/14/像素/像素/</id>
    <published>2019-02-14T12:04:32.000Z</published>
    <updated>2019-02-14T16:16:19.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考资料：<br><a href="http://www.runoob.com/w3cnote/px-em-rem-different.html" target="_blank" rel="noopener">px、em、rem区别介绍</a><br><a href="https://www.cnblogs.com/zhaowy/p/8400271.html" target="_blank" rel="noopener">字体大小之px、em、rem、pt,字号详解</a></p><p><strong>px:</strong><br>　　px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。<br>　　PX特点:<br>　　　　1. IE无法调整那些使用px作为单位的字体大小；<br>　　　　2. 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位；<br>　　　　3. Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。<a id="more"></a><br><strong>pt:</strong><br>　　pt(point，磅)：是一个物理长度单位，指的是72分之一英寸。表示绝对长度。<br><strong>em:</strong><br>　　em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。<br>　　em特点：<br>　　　　1. em的值并不是固定的；<br>　　　　2. em会继承父级元素的字体大小。<br>　　注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px<em>62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。<br>所以我们在写CSS的时候，需要注意两点：<br>　　　　1. body选择器中声明Font-size=62.5%；<br>　　　　2. 将你的原来的px数值除以10，然后换上em作为单位；<br>　　　　3. 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。也就是避免1.2 </em> 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。<br>　　　　<br><strong>rem:</strong><br>　　rem（root em，根em）：是CSS3新增的一个相对单位，相对的只是HTML根元素，可以只修改根元素就可以成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。兼容性IE9+都可以兼容，对于不兼容的浏览器写一个绝对单位的声明就可以了。<br><strong>rpx:</strong><br>　　rpx单位是微信小程序中css的尺寸单位，rpx可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：&lt;br&gt;&lt;a href=&quot;http://www.runoob.com/w3cnote/px-em-rem-different.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;px、em、rem区别介绍&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/zhaowy/p/8400271.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;字体大小之px、em、rem、pt,字号详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;px:&lt;/strong&gt;&lt;br&gt;　　px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。&lt;br&gt;　　PX特点:&lt;br&gt;　　　　1. IE无法调整那些使用px作为单位的字体大小；&lt;br&gt;　　　　2. 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位；&lt;br&gt;　　　　3. Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="像素" scheme="http://yoursite.com/tags/%E5%83%8F%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>重绘(repaint)与回流(reflow)</title>
    <link href="http://yoursite.com/2019/02/14/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%87%8D%E7%BB%98(repaint)%E4%B8%8E%E5%9B%9E%E6%B5%81(reflow)/"/>
    <id>http://yoursite.com/2019/02/14/前端性能优化/重绘(repaint)与回流(reflow)/</id>
    <published>2019-02-14T07:07:34.000Z</published>
    <updated>2019-02-14T11:43:43.818Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>文章转载：<br>　<a href="http://www.cnblogs.com/blackmanba/p/browser-repaint-reflow.html" target="_blank" rel="noopener">浏览器重绘和重排</a><br>文章参考：<br>　<a href="https://www.cnblogs.com/jiayuexuan/p/7490140.html" target="_blank" rel="noopener">重构与回流</a><br>　<a href="https://kb.cnblogs.com/page/169820/" target="_blank" rel="noopener">浏览器的重绘与重排</a><br>　<a href="http://www.cnblogs.com/shenqi0920/p/3545820.html" target="_blank" rel="noopener">探讨css中repaint和reflow</a></p><h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言：</strong></h5><p>　　页面设计中，不可避免的需要浏览器进行repaint和reflow。那到底什么是repaint和reflow呢。下面谈谈自己对repaint和reflow的理解，以及结合其他技术牛的讲解，谈谈如何优化repaint和reflow。</p><h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述：</strong></h5><p>　　<strong>重排(回流)</strong>, 顾名思义就是重新排版的意思; <strong>重绘</strong>, 就是浏览器重新绘制。理解重排和重绘的含义十分重要, 因为在评审页面交互效果的时候, 重绘和重排是必须考虑的因素。并不是说交互效果实现了就可以了, 必须同时考虑到这样做会引发什么性能问题。也就是说, 浏览器在进行重绘和重排的时候是要付出高昂的性能代价的。<br>　　只有静态页面才会不存在repaint和reflow。repaint主要是针对某一个DOM元素进行的重绘，reflow则是回流，针对整个页面的重排。字面意思来说：repaint就是重绘，reflow就是回流。<strong>回流必将引起重绘，而重绘不一定会引起回流</strong>，repaint和reflow的目的是：展示一个新的页面样貌。<a id="more"></a></p><h5 id="浏览器执行流："><a href="#浏览器执行流：" class="headerlink" title="浏览器执行流："></a><strong>浏览器执行流：</strong></h5><p>　　浏览器每次从服务器下载完页面后就会对页面进行渲染(Render), 这里面就包含了重绘以及重排。每种浏览器虽然工作原理略有差别, 但也遵循以下流程:<br>　　览器引擎会解析HTML文档来构建DOM树。树的每个节点都是标签, 有大小边距等等的属性, 这是因为每个HTML元素都遵循<strong>盒子模型</strong>(隐藏元素不包括在文档树中, 浏览器不会将其渲染)。<br>　　渲染树构建完毕后, 浏览器就能够确定每个元素的位置并将元素放到正确的位置上, 再根据<strong><em>树节点的样式属性</em></strong>绘制出页面元素。<br>　　由于浏览器的流布局的方式, 对渲染树的计算通常只需要遍历一遍即可。但table及其内部元素除外, 可能需要执行多次计算才能确定好在渲染树中的属性,这个过程通常要耗费3倍以上的时间。<br>　　这也是我们要避免使用table标签的其中一个原因。<br>　　简言之浏览器执行顺序为：<br>  　　1. 首先获取html，然后构建dom树 ，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。<br>  　　2. 浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。<br>  　　3. DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，render tree不包含隐藏的节点 (比如display:none的节点，还有head节点)，因为这些节点不会用于呈现。<br>  　　4. 一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。　　</p><h5 id="严重性："><a href="#严重性：" class="headerlink" title="严重性："></a><strong>严重性：</strong></h5><p>　在性能优先的前提下，性能消耗 reflow大于repaint。</p><h5 id="体现："><a href="#体现：" class="headerlink" title="体现："></a><strong>体现：</strong></h5><p>　repaint是某个DOM元素进行重绘；reflow是整个页面进行重排，也就是页面所有DOM元素渲染。</p><h5 id="如何触发："><a href="#如何触发：" class="headerlink" title="如何触发："></a><strong>如何触发：</strong></h5><p>　style变动造成repaint和reflow。<br>　不涉及任何DOM元素的排版问题的变动为repaint，例如元素的color/text-align/text-decoration等等属性的变动。<br>　除上面所提到的DOM元素style的修改基本为reflow。例如元素的任何涉及长、宽、行高、边框、display等style的修改。</p><h5 id="常见触发场景："><a href="#常见触发场景：" class="headerlink" title="常见触发场景："></a><strong>常见触发场景：</strong></h5><p>　　重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。重排(回流)是更明显的一种改变，可以理解为渲染树需要重新计算。</p><ol><li>触发repaint：<ol><li>color的修改，如color=#ddd；</li><li>text-align的修改，如text-align=center；</li><li>a:hover也会造成重绘。</li><li>:hover引起的颜色等不导致页面回流的style变动。</li></ol></li><li>触发reflow：<ol><li>width/height/border/margin/padding的修改，如width=778px；</li><li>动画，:hover等伪类引起的元素表现改动，display=none等造成页面回流；</li><li>appendChild等DOM元素操作；</li><li>font类style的修改；</li><li>background的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分background的修改只触发repaint，当然IE不用考虑；</li><li>scroll页面，这个不可避免；</li><li>resize页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize程序窗口大小的多窗口操作系统。</li><li>读取元素的属性(这个无法理解，但是技术达人是这么说的，那就把它当做定理吧)：读取元素的某些属性(offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE))</li></ol></li></ol><p><strong>如何避免：</strong><br>　　说避免那是不可能的，不然就是以前古老的静态页面了，没有交互，那在现在看来，就是一个失败的作品。所以，在我们进行网页设计的时候，就必须尽量减少页面的repaint和reflow。repaint和reflow的目的是为了展示一个新的页面，那么我们在进行页面交互时，尽量通过各种方法减少repaint和reflow但又能展示一个新的页面的目的。所以下面将结合其他技术达人的建议，通过自己的理解，给大家讲解如何避免和优化repaint和reflow：</p><ol><li>尽可能在DOM末梢通过改变class来修改元素的style属性： 将多次改变样式属性的操作合并成一次操作，尽可能的减少受影响的DOM元素。</li><li>避免设置多项内联样式：使用常用的class的方式进行设置样式，以避免设置样式时访问DOM的低效率。</li><li>设置动画元素position属性为fixed或者absolute：由于当前元素从DOM流中独立出来，因此受影响的只有当前元素，元素repaint。</li><li>牺牲平滑度满足性能：动画精度太强，会造成更多次的repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。</li><li>避免使用table进行布局：table的每个元素的大小以及内容的改动，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以进行针对性的repaint和避免不必要的reflow。</li><li>避免在CSS中使用运算式：学习CSS的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;文章转载：&lt;br&gt;　&lt;a href=&quot;http://www.cnblogs.com/blackmanba/p/browser-repaint-reflow.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浏览器重绘和重排&lt;/a&gt;&lt;br&gt;文章参考：&lt;br&gt;　&lt;a href=&quot;https://www.cnblogs.com/jiayuexuan/p/7490140.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;重构与回流&lt;/a&gt;&lt;br&gt;　&lt;a href=&quot;https://kb.cnblogs.com/page/169820/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浏览器的重绘与重排&lt;/a&gt;&lt;br&gt;　&lt;a href=&quot;http://www.cnblogs.com/shenqi0920/p/3545820.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;探讨css中repaint和reflow&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;　　页面设计中，不可避免的需要浏览器进行repaint和reflow。那到底什么是repaint和reflow呢。下面谈谈自己对repaint和reflow的理解，以及结合其他技术牛的讲解，谈谈如何优化repaint和reflow。&lt;/p&gt;
&lt;h5 id=&quot;概述：&quot;&gt;&lt;a href=&quot;#概述：&quot; class=&quot;headerlink&quot; title=&quot;概述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;概述：&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;　　&lt;strong&gt;重排(回流)&lt;/strong&gt;, 顾名思义就是重新排版的意思; &lt;strong&gt;重绘&lt;/strong&gt;, 就是浏览器重新绘制。理解重排和重绘的含义十分重要, 因为在评审页面交互效果的时候, 重绘和重排是必须考虑的因素。并不是说交互效果实现了就可以了, 必须同时考虑到这样做会引发什么性能问题。也就是说, 浏览器在进行重绘和重排的时候是要付出高昂的性能代价的。&lt;br&gt;　　只有静态页面才会不存在repaint和reflow。repaint主要是针对某一个DOM元素进行的重绘，reflow则是回流，针对整个页面的重排。字面意思来说：repaint就是重绘，reflow就是回流。&lt;strong&gt;回流必将引起重绘，而重绘不一定会引起回流&lt;/strong&gt;，repaint和reflow的目的是：展示一个新的页面样貌。&lt;/p&gt;
    
    </summary>
    
      <category term="前端优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端性能优化" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化</title>
    <link href="http://yoursite.com/2019/02/13/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/02/13/前端性能优化/前端性能优化/</id>
    <published>2019-02-13T12:37:12.000Z</published>
    <updated>2019-02-13T19:02:24.742Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- 目录 --><!-- toc --><p>转载：<br><a href="http://www.cnblogs.com/lei2007/archive/2013/08/16/3262897.html" target="_blank" rel="noopener">前端性能优化–yahoo前端性能团队总结的35条黄金定律</a><br>参考文章：<br><a href="https://www.zhihu.com/question/21658448/answer/18903129" target="_blank" rel="noopener">Web前端应该从哪些方面来优化网站? - 斯迪的回答 - 知乎</a><br><a href="https://segmentfault.com/a/1190000008829958" target="_blank" rel="noopener">WEB前端性能优化常见方法</a><br>　　前端是庞大的，包括 HTML、 CSS、 Javascript、Image 、Flash等等各种各样的资源。前端优化是复杂的，针对方方面面的资源都有不同的方式。那么，为什么要进行前端性能优化？ 怎么进行优化？ 优化到达的效果是什么？<br><a id="more"></a></p><h3 id="为什么需要前端性能优化-优化的好处-目的"><a href="#为什么需要前端性能优化-优化的好处-目的" class="headerlink" title="为什么需要前端性能优化[优化的好处/目的]"></a>为什么需要前端性能优化[优化的好处/目的]</h3><p>好处： </p><ol><li>从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。</li><li>从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。</li></ol><p>前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。</p><h3 id="怎么进行优化"><a href="#怎么进行优化" class="headerlink" title="怎么进行优化"></a>怎么进行优化</h3><ul><li><p>内容优化</p><ol><li>减少Http请求次数<ul><li>原因: 这条策略是最重要最有效的，因为一个完整的请求要经过DNS寻址，与服务器建立连接，发送数据，等待服务器响应，接收数据这样一个消耗时间成本和资源成本的复杂的过程。</li><li>使用方法：<ol><li>从设计实现层面简化页面</li><li>合并多个CSS文件和js文件</li><li>利用CSS Sprites整合图像</li><li>Inline Images(使用 data：URL scheme在实际的页面嵌入图像数据 )</li><li>合理设置HTTP缓存等。</li><li>使用懒加载进行图片的加载</li></ol></li></ul></li><li>减少DNS查询<ul><li>原因: DNS查询也消耗响应时间，如果我们的网页内容来自各个不同的domain (比如嵌入了开放广告，引用了外部图片或脚本)，那么客户端首次解析这些domain也需要消耗一定的时间。DNS查询结果缓存在本地系统和浏览器中一段时间，所以DNS查询一般是对首次访问响应速度有所影响。</li><li>使用方法: <a href="https://www.cnblogs.com/chenxizhang/archive/2013/05/02/3053996.html" target="_blank" rel="noopener">优化网站设计（九）：减少DNS查找的次数</a><ol><li>减少DNS查找次数，最理想的方法就是将所有的内容资源都放在同一个域(Domain)下面，这样访问整个网站就只需要进行一次DNS查找，这样可以提高性能。</li><li>但理想总归是理想，上面的理想做法会带来另外一个问题，就是由于这些资源都在同一个域，而HTTP /1.1 中推荐客户端针对每个域只有一定数量的并行度（它的建议是2），那么就会出现下载资源时的排队现象，这样就会降低性能。</li><li>所以，折衷的做法是：建议在一个网站里面使用至少2个域，但不多于4个域来提供资源。我认为这条建议是很合理的，也值得我们在项目实践中去应用。</li></ol></li></ul></li><li><p>避免重定向</p><ul><li><p>当客户端收到服务器的跳转回复时，客户端再次根据服务器回复中的location指定的地址再次发送请求，例如以下跳转回复:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Location: http://example.com/newuri</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure></li><li><p>当客户端遇到这种回复的时候，用户只能等待客户端再次发送请求，有的网站甚至会一直跳n次，跳到他想带你去的地方…当然在这个时候用户看不到任何页面内容，只有浏览器的进度条一直在刷新。</p></li></ul></li><li>使用Ajax缓存<ul><li>Ajax可以帮助我们异步的下载网页内容，但是有些网页内容即使是异步的，用户还是在等待它的返回结果，例如ajax的返回是用户联系人的下拉列表。所以我们还是要注意尽量应用以下规则提高ajax的响应速度。</li><li>使用方法：<ul><li>添加Expires 或 Cache-Control报文头使回复可以被客户端缓存</li><li>压缩回复内容</li><li>减少dns查询</li><li>精简javascript</li><li>避免跳转</li><li>配置Etags</li></ul></li></ul></li><li>延迟加载组件,预加载组件<ul><li>延迟加载<ul><li>这里讨论延迟加载需要我们知道我们的网页最初加载需要的最小内容集是什么。剩下的内容就可以推到延迟加载的集合中。</li><li>Javascript是典型的可以延迟加载内容。一个比较激进的做法是开发网页时先确保网页在没有Javascript的时候也可以基本工作，然后通过延迟加载脚本来完成一些高级的功能。</li></ul></li><li>预加载<ul><li>与延迟加载目的相反，提前加载的是为了提前加载接下来网页中访问的资源，下面是提前加载的类型</li><li>无条件提前加载：当前网页加载完成后，马上去下载一些其他的内容。例如google会在页面加载成功之后马上去下载一个所有结果中会用到的image sprite。</li><li>有预期的的加载：这种情况一般发生在网页重新设计时，由于用户经常访问旧网页，本地对旧的网页内容缓存充分从而显得旧网页速度很快，而新的网页内容却没有缓存，设计者可以在旧网页的内容中预先加载一些新网页中可能用到的内容，这样新的网页就会生下来一些需要下载的资源。</li></ul></li></ul></li><li>减少DOM元素数量:<ul><li>页面中存在大量DOM元素,会导致javascript遍历DOM的效率变慢。</li><li>网页中元素过多对网页的加载和脚本的执行都是沉重的负担，500个元素和5000个元素在加载速度上会有很大差别。</li><li>想知道你的网页中有多少元素，通过在浏览器中的一条简单命令就可以算出<code>document.getElementsByTagName(&#39;*&#39;).length</code></li></ul></li><li>最小化iframe的数量：<ul><li>iframes 提供了一个简单的方式把一个网站的内容嵌入到另一个网站中。但其创建速度比其他包括JavaScript和CSS的DOM元素的创建慢了1-2个数量级。</li><li>优点<ol><li>可以用来加载速度较慢的内容，例如广告。</li><li>安全沙箱保护。浏览器会对iframe中的内容进行安全控制。</li><li>脚本可以并行下载</li></ol></li><li>缺点<ol><li>即使iframe内容为空也消耗加载时间</li><li>会阻止页面加载</li><li>没有语义</li></ol></li></ul></li><li>避免404：HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。<ul><li>404我们都不陌生，代表服务器没有找到资源，我们要特别要注意404的情况不要在我们提供的网页资源上，客户端发送一个请求但是服务器却返回一个无用的结果，时间浪费掉了。更糟糕的是我们网页中需要加载一个外部脚本，结果返回一个404，不仅阻塞了其他脚本下载，下载回来的内容(404)客户端还会将其当成Javascript去解析。</li></ul></li></ol></li><li>服务器优化<ul><li>(1)使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。<ul><li>再次强调第一条黄金定律，减少网页内容的下载时间。提高下载速度还可以通过CDN(内容分发网络)来提升。CDN通过部署在不同地区的服务器来提高客户的下载速度。如果你的网站上有大量的静态内容，世界各地的用户都在访问，我说的是youtube么？那CDN是必不可少的。事实上大多数互联网中的巨头们都有自己的CDN。我们自己的网站可以先通过免费的CDN供应商来分发网页资源。</li><li>添加Expires 或Cache-Control报文头(这条规则分为两个方面)<ol><li>对于静态内容添加Expires，将静态内容设为永不过期，或者很长时间以后。在IIS中设置Expires可以看Configure the HTTP Expires Response Header (IIS 7)。</li><li>对于动态内容应用合适的Cache-Control，让浏览器根据条件来发送请求。关于asp.net的caching，可以看asp.net cache feature和asp.net caching best practices。</li></ol></li></ul></li><li>(2)GZIP压缩<ul><li>Gzip通常可以减少70%网页内容的大小，包括脚本、样式表、图片等文件。Gzip比deflate更高效，主流服务器都有相应的压缩支持模块。</li></ul></li><li>(3)设置ETag：ETags（Entity tags，实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。<ul><li>虽然标题叫配制ETags，但是这里你要根据具体情况进行一些判断。首先Etag简单来说是通过一个文件版本标识使得服务器可以轻松判断该请求的内容是否有所更新，如果没有就回复304 (not modified)，从而避免下载整个文件。</li></ul></li><li>(4)提前刷新缓冲区<br>+ </li><li>(5)对Ajax请求使用GET方法<ul><li>浏览器在实现XMLHttpRequest POST的时候分成两步，先发header，然后发送数据。而GET却可以用一个TCP报文完成请求。另外GET从语义上来讲是去服务器取数据，而POST则是向服务器发送数据，所以我们使用Ajax请求数据的时候尽量通过GET来完成。</li></ul></li><li>(6)避免空的图像src<ul><li>空的图片src仍然会使浏览器发送请求到服务器，这样完全是浪费时间，而且浪费服务器的资源。尤其是你的网站每天被很多人访问的时候，这种空请求造成的伤害不容忽略。</li></ul></li></ul></li><li>Cookie优化<ul><li>(1)减小Cookie大小<ul><li>去除没有必要的cookie，如果网页不需要cookie就完全禁掉</li><li>将cookie的大小减到最小</li><li>注意cookie设置的domain级别，没有必要情况下不要影响到sub-domain</li><li>设置合适的过期时间，比较长的过期时间可以提高响应速度。</li></ul></li><li>(2)针对Web组件使用域名无关的Cookie<ul><li>大多数网站的静态资源都没必要cookie，我们可以采用不同的domain来单独存放这些静态文件，这样做不仅可以减少cookie大小从而提高响应速度，还有一个好处是有些proxy拒绝缓存带有cookie的内容，如果能将这些静态资源cookie去除，那就可以得到这些proxy的缓存支持。</li><li>常见的划分domain的方式是将静态文件放在static.example.com，动态内容放在<a href="http://www.example.com。" target="_blank" rel="noopener">www.example.com。</a></li><li>也有一些网站需要在二级域名上应用cookie，所有的子域都会继承，这种情况下一般会再购买一个专门的域名来存放cookie-free的静态资源。例如Yahoo!的yimg.com，YouTube的ytimg.com等。</li></ul></li></ul></li><li>CSS优化<ul><li>(1)将CSS代码放在HTML页面的顶部<ul><li>经样式表(css)放在网页的HEAD中会让网页显得加载速度更快，因为这样做可以使浏览器逐步加载已将下载的网页内容。这对内容比较多的网页尤其重要，用户不用一直等待在一个白屏上，而是可以先看已经下载的内容。</li><li>如果将样式表放在底部，浏览器会拒绝渲染已经下载的网页，因为大多数浏览器在实现时都努力避免重绘，样式表中的内容是绘制网页的关键信息，没有下载下来之前只好对不起观众了。</li></ul></li><li>(2)避免使用CSS表达式<ul><li>CSS表达式可以动态的设置CSS属性，在IE5-IE8中支持，其他浏览器中表达式会被忽略。例如下面表达式在不同时间设置不同的背景颜色。</li><li>CSS表达式的问题在于它被重新计算的次数远比我们想象的要多，不仅在网页绘制或大小改变时计算，即使我们滚动屏幕或者移动鼠标的时候也在计算，因此我们还是尽量避免使用它来防止使用不当而造成的性能损耗。</li></ul></li><li>(3)使用<link>来代替@import<ul><li>避免使用@import的原因很简单，因为它相当于将css放在网页内容底部。</li></ul></li><li>(4)避免使用Filters<ul><li>AlphaImageLoad也是IE5.5 - IE8中支持，这种滤镜的使用会导致图片在下载的时候阻塞网页绘制，另外使用这种滤镜会导致内存使用量的问题。IE9中已经不再支持。</li></ul></li></ul></li><li>JS优化<ul><li>(1)将JavaScript脚本放在页面的底部。<ul><li>HTTP/1.1 specification建议浏览器对同一个hostname不要超过两个并行下载连接， 所以当你从多个domain下载图片的时候可以提高并行下载连接数量。但是当脚本在下载的时候，即使是来自不同的hostname浏览器也不会下载其他资源，因为浏览器要在脚本下载之后依次解析和执行。</li><li>因此对于脚本提速，我们可以考虑以下方式，<ul><li>把脚本置底，这样可以让网页渲染所需要的内容尽快加载显示给用户。</li><li>现在主流浏览器都支持defer关键字，可以指定脚本在文档加载后执行。</li><li>HTML5中新加了async关键字，可以让脚本异步执行。</li></ul></li></ul></li><li>(2)将JavaScript和CSS作为外部文件来引用：<ul><li>使用外部Javascript和CSS文件可以使这些文件被浏览器缓存，从而在不同的请求内容之间重用。</li><li>同时将Javascript和CSS从inline变为external也减小了网页内容的大小。</li><li>使用外部Javascript和CSS文件的决定因素在于这些外部文件的重用率，如果用户在浏览我们的页面时会访问多次相同页面或者可以重用脚本的不同页面，那么外部文件形式可以为你带来很大的好处。但对于用户通常只会访问一次的页面，例如microsoft.com首页，那inline的javascript和css相对来说可以提供更高的效率。</li></ul></li><li>(3)缩小JavaScript和CSS<ul><li>精简就是将Javascript或CSS中的空格和注释全去掉，</li></ul></li><li>(4)删除重复的脚本<ul><li>重复的脚本不仅浪费浏览器的下载时间，而且浪费解析和执行时间。一般用来避免引入重复脚本的做法是使用统一的脚本管理模块，这样不仅可以避免重复脚本引入，还可以兼顾脚本依赖管理和版本管理。</li></ul></li><li>(5)最小化DOM的访问：使用JavaScript访问DOM元素比较慢。<ul><li>通过Javascript访问DOM元素没有我们想象中快，元素多的网页尤其慢，对于Javascript对DOM的访问我们要注意<ul><li>缓存已经访问过的元素</li><li>Offline更新节点然后再加回DOM Tree</li><li>避免通过Javascript修复layout</li></ul></li></ul></li><li>(6)开发智能的事件处理程序<ul><li>这里说智能的事件处理需要开发者对事件处理有更深入的了解，通过不同的方式尽量少去触发事件，如果必要就尽早的去处理事件。</li><li>比如一个div中10个按钮都需要事件句柄，那么我们可以将事件放在div上，在事件冒泡过程中捕获该事件然后判断事件来源。</li></ul></li><li>(7)javascript代码注意：<ul><li>谨慎使用with,避免使用eval Function函数,减少作用域链查找。<ul><li>with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的 执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。</li><li>因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。</li></ul></li></ul></li></ul></li><li>图像优化<ul><li>(1)优化图片大小<ul><li>检查GIF图片中图像颜色的数量是否和调色板规格一致。如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。可以使用imagemagick检查：identify -verbose image.gif</li><li>尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。下面这条简单的命令可以安全地把GIF格式转换为PNG格式： convert image.gif image.png</li><li>在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如： pngcrush image.png -rem alla -reduce -brute result.png</li><li>在所有的JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息 jpegtran -copy none -optimize -perfect src.jpg dest.jpg</li></ul></li><li>(2)通过CSS Sprites优化图片<ul><li>Spirite中水平排列图片，垂直排列会增加文件大小；</li><li>Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；</li><li>不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小,但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100×100的图片为1万像素，1000×1000就是100万像素。</li></ul></li><li>(3)不要在HTML中使用缩放图片<ul><li>不要通过图片缩放来适应页面，如果你需要小图片，就直接使用小图片吧。</li></ul></li><li>(4)favicon.ico要小而且可缓存<ul><li>网站图标文件favicon.ico，不管你服务器有还是没有，浏览器都会去尝试请求这个图标。所以我们要确保这个图标<ol><li>存在</li><li>文件尽量小，最好小于1k</li><li>设置一个长的过期时间</li></ol></li></ul></li></ul></li><li>移动客户端<ul><li>保持单个内容小于25KB<ul><li>这限制是因为iphone，他只能缓存小于25K，注意这是解压后的大小。所以单纯gzip不一定够用，精简文件工具要用上了。</li></ul></li><li>打包组建成符合文档<ul><li>把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组建。当你使用这条规则时，首先要确定用户代理是否支持（iPhone不支持）。</li></ul></li></ul></li></ul><h3 id="待解决的方面"><a href="#待解决的方面" class="headerlink" title="待解决的方面"></a>待解决的方面</h3><blockquote><p>转载别人，如有错误请指出。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- 目录 --&gt;
&lt;!-- toc --&gt;
&lt;p&gt;转载：&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/lei2007/archive/2013/08/16/3262897.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端性能优化–yahoo前端性能团队总结的35条黄金定律&lt;/a&gt;&lt;br&gt;参考文章：&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/21658448/answer/18903129&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Web前端应该从哪些方面来优化网站? - 斯迪的回答 - 知乎&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008829958&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WEB前端性能优化常见方法&lt;/a&gt;&lt;br&gt;　　前端是庞大的，包括 HTML、 CSS、 Javascript、Image 、Flash等等各种各样的资源。前端优化是复杂的，针对方方面面的资源都有不同的方式。那么，为什么要进行前端性能优化？ 怎么进行优化？ 优化到达的效果是什么？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端性能优化" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>伪元素和伪类</title>
    <link href="http://yoursite.com/2018/11/16/CSS3/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/11/16/CSS3/伪元素和伪类/</id>
    <published>2018-11-16T11:34:19.000Z</published>
    <updated>2018-11-06T11:50:25.251Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>伪类</strong>包含两种：<strong>状态伪类</strong>和<strong>结构性伪类</strong>。<br><strong>状态伪类</strong>是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。<br>当元素处于某状态时会呈现该样式，而进入另一状态后，该样式也会失去。常见的状态伪类主要包括：</p><p>:link 应用于未被访问过的链接；<br>:hover 应用于鼠标悬停到的元素；<br>:active 应用于被激活的元素；<br>:visited 应用于被访问过的链接，与:link互斥。<br>:focus 应用于拥有键盘输入焦点的元素。<br><strong>结构性伪类</strong>是css3新增选择器，利用dom树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少class和id属性的定义，使文档结构更简洁。常见的包括：</p><p>:first-child 选择某个元素的第一个子元素；<br>:last-child 选择某个元素的最后一个子元素；<br>:nth-child() 选择某个元素的一个或多个特定的子元素；<br>:nth-last-child() 选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算；<br>:nth-of-type() 选择指定的元素；<br>:nth-last-of-type() 选择指定的元素，从元素的最后一个开始计算；<br>:first-of-type 选择一个上级元素下的第一个同类子元素；<br>:last-of-type 选择一个上级元素的最后一个同类子元素；<br>:only-child 选择的元素是它的父元素的唯一一个子元素；<br>:only-of-type 选择一个元素是它的上级元素的唯一一个相同类型的子元素；<br>:empty 选择的元素里面没有任何内容。</p><p><strong>伪元素</strong>是对元素中的特定内容进行操作，而不是描述状态。它的操作层次比伪类更深一层，因此动态性比伪类低很多。实际上，伪元素就是选取某些元素前面或后面这种普通选择器无法完成的工作。控制的内容和元素是相同的，但它本身是基于元素的抽象，并不存在于文档结构中！常见的伪元素选择器包括：</p><p>:first-letter 选择元素文本的第一个字（母）。<br>:first-line 选择元素文本的第一行。<br>:before 在元素内容的最前面添加新内容。<br>:after 在元素内容的最后面添加新内容。</p><p>注意事项<br>有时你会发现伪类元素使用了两个冒号 (::) 而不是一个冒号 (:)，这是 CSS3 规范中的一部分要求，目的是为了区分伪类和伪元素，大多数浏览器都支持这两种表示方式。单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。对于 CSS2 中已经有的伪元素，例如 :before，单冒号和双冒号的写法 ::before 作用是一样的。</p><p>所以，如果你的网站只需要兼容 webkit、firefox、opera 等浏览器，建议对于伪元素采用双冒号的写法，如果不得不兼容 IE 浏览器，还是用 CSS2 的单冒号写法比较安全。</p><p>参考文章： <a href="https://segmentfault.com/a/1190000012156828" target="_blank" rel="noopener">谈谈css伪类与伪元素</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>盒子模型</title>
    <link href="http://yoursite.com/2018/11/06/CSS3/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/11/06/CSS3/盒子模型/</id>
    <published>2018-11-06T12:10:06.000Z</published>
    <updated>2019-02-12T13:42:40.476Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="盒子样式介绍"><a href="#盒子样式介绍" class="headerlink" title="盒子样式介绍"></a>盒子样式介绍</h4><ul><li>width和height：内容的宽度、高度（不是盒子的宽度、高度）</li><li>padding：内边距。</li><li>border：边框。</li><li>margin：外边距。</li></ul><hr><h4 id="盒子模型的分类与概念"><a href="#盒子模型的分类与概念" class="headerlink" title="盒子模型的分类与概念"></a>盒子模型的分类与概念</h4><p>　　盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是<strong><em>IE盒子模型</em></strong>和<strong><em>标准 w3c 盒子模型</em></strong>。<br>他们对盒子模型的解释各不相同:<br>　　IE 盒子模型的范围也包括 <strong><em>margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading</em></strong>。<br><img src="/assets/images/盒子模型-IE.jpg" alt="IE盒子模型"><br>　　标准 W3C 盒子模型的范围包括 <strong><em>margin、border、padding、content，并且 content 部分不包含其他部分</em></strong>。<br><img src="/assets/images/盒子模型-标准.jpg" alt="标准盒子模型"></p><p><strong>ps</strong>:<br>　　1. ie8以上都是w3c标准盒模型 　　<br>　　2. ie5极其以下都是ie盒子模型，ie6、ie7、ie8在混杂模式下ie盒模型，<br>　　3. 在标准模式下是w3c标准盒模型<br>　　4. 注意：ie6在混杂模式下一定是Ie盒模型，而ie7、ie8在混杂模式下不一定是ie盒模型</p><p>box-sizing 属性可以被用来调整这些表现:<br>　　1. content-box 是默认值。<br>如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。<br>　　2. border-box 告诉浏览器去理解你设置的边框和内边距的值是包含在width内的。<br>也就是说，如果你将一个元素的width设为100px,那么这100px会包含其它的border和padding，内容区的实际宽度会是width减去border + padding的计算值。大多数情况下这使得我们更容易的去设定一个元素的宽高。<br>　　3. border-box定义的盒子，不会随着padding和boder的加入而增大盒子的占用空间</p><blockquote><p>border-box  width 和 height 属性包括内容，内边距和边框，但不包括外边距。<br>这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。注意，填充和边框将在盒子内 。<br>例如, .box {width: 350px; border: 10px solid black;} 导致在浏览器中呈现的宽度为350px<br>的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。<br>这里的维度计算为：<br>width = border + padding + 内容的  width，<br>height = border + padding + 内容的 height。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/11/06/H5/H5/"/>
    <id>http://yoursite.com/2018/11/06/H5/H5/</id>
    <published>2018-11-06T12:10:06.000Z</published>
    <updated>2018-11-06T12:14:21.186Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>H5语义化标签</title>
    <link href="http://yoursite.com/2018/11/06/CSS3/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2018/11/06/CSS3/语义化标签/</id>
    <published>2018-11-06T10:30:06.000Z</published>
    <updated>2018-11-06T11:05:30.466Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><h3>H5中关于语义化的标签有哪些，语义化标签有什么作用？为什么要使用语义化标签?</h3><p></p><h4>1. H5中关于语义化的标签有哪些</h4><p>title  简短、描述性、唯一（提升搜索引擎排名）<br>header 页眉通常包括网站标志、主导航、全站链接以及搜索框。<br>section 具有相似主题的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。<br><a id="more"></a><br>footer 页脚，只有当父级是body时，才是整个页面的页脚。<br>article 包含像报纸一样的内容= =||是这么理解的，表示文档、页面、应用或一个独立的容器<br>a<br>hgroup 标签用于对网页或区段（section）的标题进行组合<br>nav 标记导航，仅对文档中重要的链接群使用。<br>aside 指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。<br>address 作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）<br>mark 突出显示文本（yellow），提醒读者。<br>time 标记时间。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式<br>figure 创建图（默认有40px左右margin）<br>figcaption figure的标题，必须是figure内嵌的第一个或者最后一个元素。<br>datailst<br>details<br>summary<br>dialog<br>dd<br>progress 完成进度。可通过js动态更新value<br>keygen<br>small 指定细则，输入免责声明、注解、署名、版权。</p><h4>2. 语义化标签有什么作用？为什么要使用语义化标签？</h4><p></p><p>在HTML5出现之前，我们一般采用div+css布局我们的页面。但是这样的布局方式不仅<br>使我们的文档结构不够清晰，而且不利于搜索引擎爬虫对我们页面的爬取。为了解决上述缺点，<br>HTML5新增了很多新的语义化标签。</p><p></p><ul><li>引入语义化标签的好处主要有<ul><li>比div标签有更加丰富的含义，方便开发与维护</li><li>搜索引擎能更方便的识别页面的每个部分</li><li>方便其他设备解析（如移动设备、盲人阅读器等）</li></ul></li></ul><p></p><h4>H5新增的语义化标签</h4><br>header<br>footer<br>article<br>aside  定义页面的侧边栏内容<br>time<br>details 用于描述文档或者文档某一部分细节，summary是details元素的标题<br>ruby 加注释，ruby标签有两个子元素，rt注释的内容，rp是该标签不显示时显示的文字<br>mark 定义带有几号的文本，它会给你想要突出显示的文本加个 背景色<br>nav<br>progress<br>section<br>video 定义视频，属性src引入资源，controls视频的控制控件<br>audio 该标签可定义声音，及其他的音频文件，不加controls不显示音频的控制界面<br>datalist 提示可能的值，datalist及其选项不会被显示出来，它仅仅是合法输入值的列表使用input元素的list属性来邦定datalist<br>embed 定义插入的内容，如插件，flash，标签中间不要加内容会显现出来<br>canvas canvas画布只是个容器，你可以通过控制坐标在canvas上绘制图形，一般配合js可以实现非常复杂的动画效果<p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h3&gt;H5中关于语义化的标签有哪些，语义化标签有什么作用？为什么要使用语义化标签?&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;h4&gt;1. H5中关于语义化的标签有哪些&lt;/h4&gt;

&lt;p&gt;title  简短、描述性、唯一（提升搜索引擎排名）&lt;br&gt;header 页眉通常包括网站标志、主导航、全站链接以及搜索框。&lt;br&gt;section 具有相似主题的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>块级元素行内元素</title>
    <link href="http://yoursite.com/2018/11/06/CSS3/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2018/11/06/CSS3/块级元素行内元素/</id>
    <published>2018-11-06T10:21:49.000Z</published>
    <updated>2018-11-06T12:09:27.625Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>行内元素指的是书写完成后不会自动换行，并且元素没有宽和高。<br>块级元素写完后会自动换行，有宽高可以修改。<br>还有一种特殊的元素叫做行内联元素。</p><p>行内元素有：span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、<br>u（下划线）、button（默认display：inline-block<br>块级元素有：div、p、h1~h6、ul、ol、dl、li、dd、table、hr、blockquote、address、table、menu、pre，HTML5新增的header、section、aside、footer<br>内联元素： a , b , br , em , font , img , input , label , select , small , span , textarea </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>README</title>
    <link href="http://yoursite.com/2018/10/22/README/README/"/>
    <id>http://yoursite.com/2018/10/22/README/README/</id>
    <published>2018-10-22T11:23:46.000Z</published>
    <updated>2018-10-22T13:28:38.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>It just a test music, but i like it </p>        <div id="aplayer-gfKIeZyv" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-gfKIeZyv"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "起风了",              author: "买辣椒也用券",              url: "/assets/music/music.mp3",              pic: "/assets/music/music.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="情感" scheme="http://yoursite.com/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>深浅拷贝</title>
    <link href="http://yoursite.com/2018/10/16/JS/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2018/10/16/JS/深浅拷贝/</id>
    <published>2018-10-16T10:12:26.000Z</published>
    <updated>2018-10-18T12:04:28.680Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载： <a href="https://www.cnblogs.com/136asdxxl/p/8645750.html" target="_blank" rel="noopener">js 深浅拷贝 笔记总结</a>、<a href="https://www.cnblogs.com/echolun/p/7889848.html" target="_blank" rel="noopener">[JS]深拷贝与浅拷贝的区别，实现深拷贝的几种方法</a></p><h5 id="JS-数据类型"><a href="#JS-数据类型" class="headerlink" title="JS 数据类型"></a>JS 数据类型</h5><p>JavaScript的数据类型有： <strong>数值类型</strong>(number) 、 <strong>字符串类型</strong>(string) 、 <strong>布尔类型</strong>(boolean) 、 <strong>null</strong> 、<strong>undefined</strong> 、<strong>对象(数组、正则表达式、日期、函数)</strong><br>大致分为两种： <strong>基本数据类型</strong> 和 <strong>引用数据类型</strong><br>基本数据类型： 数字类型(number)、字符串类型(string)、布尔类型(boolean)、null、undefined<br>引用数据类型： 常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等</p><h5 id="深浅拷贝区别"><a href="#深浅拷贝区别" class="headerlink" title="深浅拷贝区别"></a>深浅拷贝区别</h5><p>如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。</p><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>浅拷贝只是拷贝基本类型的数据，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，因此存在父对象被篡改的可能，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存<br><a id="more"></a></p><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>深拷贝就是能够实现真正意义上的数组和对象的拷贝。递归调用”浅拷贝”。（深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象）</p><p>浅拷贝例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    b=a;</span><br><span class="line"><span class="built_in">console</span>.log(a===b);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/assets/images/浅拷贝1.png" alt="浅拷贝例子结果"><br>嗯？明明b复制了a，为啥修改数组a，数组b也跟着变了，这里我不禁陷入了沉思。<br>那么这里，就得引入基本数据类型与引用数据类型的概念了。</p><p>a.<strong>基本类型</strong>–名值存储在栈内存中，例如let a=1;<br><img src="/assets/images/拷贝2.jpg" alt="基本类型"><br>当你b=a复制时，栈内存会新开辟一个内存，例如这样：<br><img src="/assets/images/拷贝3.jpg" alt="基本类型"><br>所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。</p><p>b.<strong>引用数据类型</strong>–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：<br><img src="/assets/images/拷贝4.jpg" alt="引用数据类型"><br>当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。<br><img src="/assets/images/拷贝5.jpg" alt="引用数据类型"><br>而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。<br><img src="/assets/images/拷贝6.jpg" alt="引用数据类型"><br>那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，起步就达到深拷贝的效果了<br><img src="/assets/images/拷贝7.jpg" alt="引用数据类型"></p><p>1.我们怎么去实现深拷贝呢，这里可以递归递归去复制所有层级属性。<br>这么我们封装一个深拷贝的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> objClone = <span class="built_in">Array</span>.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj===<span class="string">"object"</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">                <span class="comment">//判断ojb子元素是否为对象，如果是，递归复制</span></span><br><span class="line">                <span class="keyword">if</span>(obj[key]&amp;&amp;<span class="keyword">typeof</span> obj[key] ===<span class="string">"object"</span>)&#123;</span><br><span class="line">                    objClone[key] = deepClone(obj[key]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果不是，简单复制</span></span><br><span class="line">                    objClone[key] = obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="/assets/images/深拷贝1.png" alt="深拷贝例子结果"><br>跟之前想象的一样，现在b脱离了a的控制，不再受a影响了。<br>这里再次强调，深拷贝，是拷贝对象各个层级的属性，可以看个例子。JQ里有一个extend方法也可以拷贝对象，我们来看看<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    b=a.slice();</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/assets/images/深拷贝2.png" alt="深拷贝例子2结果"><br>那是不是说slice方法也是深拷贝了，毕竟b也没受a的影响，上面说了，深拷贝是会拷贝所有层级的属性，还是这个例子，我们把a改改<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">        b=a.slice();</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/深拷贝3.png" alt="深拷贝例子3结果"><br>拷贝的不彻底啊，b对象的一级属性确实不受影响了，但是二级属性还是没能拷贝成功，仍然脱离不了a的控制，说明slice根本不是真正的深拷贝。<br>这里引用知乎问答里面的一张图</p><p><img src="/assets/images/拷贝知乎.jpg" alt="深拷贝知乎"></p><p>第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。</p><p>同理，concat方法与slice也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。</p><p>2.除了递归，我们还可以借用JSON对象的parse和stringify</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _obj = <span class="built_in">JSON</span>.stringify(obj),</span><br><span class="line">        objClone = <span class="built_in">JSON</span>.parse(_obj);</span><br><span class="line">    <span class="keyword">return</span> objClone</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure><p><img src="/assets/images/json深拷贝.png" alt="深拷贝例子4结果"><br>可以看到，这下b是完全不受a的影响了。</p><p>附带说下，JSON.stringify与JSON.parse除了实现深拷贝，还能结合localStorage实现对象数组存储</p><p>3.除了上面两种方法之外，我们还可以借用JQ的extend方法。</p><p>$.extend( [deep ], target, object1 [, objectN ] )</p><p>deep表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝</p><p>target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。</p><p>object1  objectN可选。 Object类型 第一个以及第N个被合并的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">    b=$.extend(<span class="literal">true</span>,[],a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure></p><p>可以看到，效果与上面方法一样，只是需要依赖JQ库。<br><img src="/assets/images/深拷贝jquery.png" alt="深拷贝jquery方法"></p><p>说了这么多，了解深拷贝也不仅仅是为了应付面试题，在实际开发中也是非常有用的。例如后台返回了一堆数据，你需要对这堆数据做操作，但多人开发情况下，你是没办法明确这堆数据是否有其它功能也需要使用，直接修改可能会造成隐性问题，深拷贝能帮你更安全安心的去操作数据，根据实际情况来使用深拷贝，大概就是这个意思。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载： &lt;a href=&quot;https://www.cnblogs.com/136asdxxl/p/8645750.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;js 深浅拷贝 笔记总结&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/echolun/p/7889848.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[JS]深拷贝与浅拷贝的区别，实现深拷贝的几种方法&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;JS-数据类型&quot;&gt;&lt;a href=&quot;#JS-数据类型&quot; class=&quot;headerlink&quot; title=&quot;JS 数据类型&quot;&gt;&lt;/a&gt;JS 数据类型&lt;/h5&gt;&lt;p&gt;JavaScript的数据类型有： &lt;strong&gt;数值类型&lt;/strong&gt;(number) 、 &lt;strong&gt;字符串类型&lt;/strong&gt;(string) 、 &lt;strong&gt;布尔类型&lt;/strong&gt;(boolean) 、 &lt;strong&gt;null&lt;/strong&gt; 、&lt;strong&gt;undefined&lt;/strong&gt; 、&lt;strong&gt;对象(数组、正则表达式、日期、函数)&lt;/strong&gt;&lt;br&gt;大致分为两种： &lt;strong&gt;基本数据类型&lt;/strong&gt; 和 &lt;strong&gt;引用数据类型&lt;/strong&gt;&lt;br&gt;基本数据类型： 数字类型(number)、字符串类型(string)、布尔类型(boolean)、null、undefined&lt;br&gt;引用数据类型： 常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等&lt;/p&gt;
&lt;h5 id=&quot;深浅拷贝区别&quot;&gt;&lt;a href=&quot;#深浅拷贝区别&quot; class=&quot;headerlink&quot; title=&quot;深浅拷贝区别&quot;&gt;&lt;/a&gt;深浅拷贝区别&lt;/h5&gt;&lt;p&gt;如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。&lt;/p&gt;
&lt;h5 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h5&gt;&lt;p&gt;浅拷贝只是拷贝基本类型的数据，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，因此存在父对象被篡改的可能，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>面试题-思维</title>
    <link href="http://yoursite.com/2018/10/16/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/"/>
    <id>http://yoursite.com/2018/10/16/面试题-思维/面试题-思维/</id>
    <published>2018-10-16T09:53:08.000Z</published>
    <updated>2018-10-16T10:11:32.528Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="题目：-给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值"><a href="#题目：-给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值" class="headerlink" title="题目： 给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值"></a>题目： 给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值</h4><p>方法一：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a^b;</span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br></pre></td></tr></table></figure></p><h4 id="题目：-给两个杯子，一个5升，一个6升，水随便用，最后取出3升水"><a href="#题目：-给两个杯子，一个5升，一个6升，水随便用，最后取出3升水" class="headerlink" title="题目： 给两个杯子，一个5升，一个6升，水随便用，最后取出3升水"></a>题目： 给两个杯子，一个5升，一个6升，水随便用，最后取出3升水</h4><p>方法：</p><ol><li>6升装满倒入5升杯子，6升杯子里剩1升水；</li><li>6升杯子中的1升倒入5升杯子；</li><li>6升杯子装满水倒入5升杯子，6升杯子里剩2升水；把5升杯子水倒掉；</li><li>6升杯子中的2升倒入5升杯子；</li><li>6升杯子装满水倒入5升杯子，6升杯子里剩3升水，完成。</li></ol><h4 id="题目：-给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子"><a href="#题目：-给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子" class="headerlink" title="题目： 给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子"></a>题目： 给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子</h4><p>方法：<br>二分法：<br>用天平左右各五个进行称量，10 =&gt; 5<br>较轻的一组留下一个，继续进行分开称量，如果左右相等，则剩余的那一个为最轻的，否则剩下的两个继续进行比较5 =&gt; 1 || 5 =&gt; 2<br>最后一次比较 2 =&gt; 1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="思维能力" scheme="http://yoursite.com/categories/%E6%80%9D%E7%BB%B4%E8%83%BD%E5%8A%9B/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HTTP和HTTPS的区别</title>
    <link href="http://yoursite.com/2018/10/15/HTTP/HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/10/15/HTTP/HTTP和HTTPS的区别/</id>
    <published>2018-10-15T01:04:39.000Z</published>
    <updated>2018-11-06T12:31:32.992Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>&nbsp; &nbsp; &nbsp;超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，<strong>HTTP协议以明文方式发送内容</strong>，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。<br>&nbsp; &nbsp; &nbsp;为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，<strong>HTTPS在HTTP的基础上加入了SSL协议</strong>，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。<br><a id="more"></a></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP的基本概念"><a href="#HTTP的基本概念" class="headerlink" title="HTTP的基本概念"></a>HTTP的基本概念</h4><p>HTTP: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br>HTTP: 是超文本传输协议，信息是明文传输</p><h4 id="HTTP的优点"><a href="#HTTP的优点" class="headerlink" title="HTTP的优点"></a>HTTP的优点</h4><h4 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h4><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="HTTPS的基本概念"><a href="#HTTPS的基本概念" class="headerlink" title="HTTPS的基本概念"></a>HTTPS的基本概念</h4><p>HTTPS(Secure Hypertext Transfer Protocol)是安全超文本传输协议,<br>HTTPS: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，<strong>即HTTP下加入SSL层</strong>，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br>https: 是具有安全性的ssl加密传输协议；<br>HTTPS协议的主要作用可以分为两种：一种是建立一个<strong><em>信息安全通道</em></strong>，来保证数据传输的安全；另一种就是<strong><em>确认网站的真实性</em></strong>。</p><h4 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h4><ol><li>客户端发起HTTPS请求<br>用户在浏览器里输入一个https网址，然后连接到server的443端口。</li><li>服务端的配置<br>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。<br>这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li><li>传送证书<br>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</li><li>客户端解析证书<br>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。<br>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</li><li>传送加密信息<br>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li><li>服务段解密信息<br>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li><li>传输加密后的信息<br>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</li><li>客户端解密信息<br>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</li></ol><h4 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h4><ol><li>SEO方面<br>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li><li>安全性</li></ol><ul><li><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></li><li><p>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p></li><li><p>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本</p></li></ul><h4 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h4><ol><li>SEO方面<br>据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。<br>而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。<br>最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li><li>经济方面</li></ol><ul><li><p>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p></li><li><p>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。</p></li><li><p>HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。</p></li><li><p>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去。</p></li><li><p>HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。</p></li></ul><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ul><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443；</li><li>、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全；</li><li>https协议需要到ca申请证书，一般免费证书很少，需要交费。 </li><li></li></ul><p>参考文章：<a href="http://www.mahaixiang.cn/internet/1233.html" target="_blank" rel="noopener">HTTP和HTTPS的区别</a>、<a href="https://www.cnblogs.com/wudaoyongchang/p/6253451.html" target="_blank" rel="noopener">HTTP与HTTPS的区别</a> 、<a href="http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/" target="_blank" rel="noopener">HTTP详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，&lt;strong&gt;HTTP协议以明文方式发送内容&lt;/strong&gt;，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，&lt;strong&gt;HTTPS在HTTP的基础上加入了SSL协议&lt;/strong&gt;，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
</feed>
