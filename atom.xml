<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>昨夜小楼又东风</title>
  
  <subtitle>纵豆蔻词工，青楼好梦，难赋深情</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-22T03:05:43.051Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LittleStar</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>事件循环与任务队列</title>
    <link href="http://yoursite.com/2019/04/22/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/04/22/JavaScript/事件循环与任务队列/</id>
    <published>2019-04-22T02:52:17.000Z</published>
    <updated>2019-04-22T03:05:43.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p><a href="https://juejin.im/post/5c8a024d51882546be0a3082" target="_blank" rel="noopener">从面试题看 JS 事件循环与 macro micro 任务队列</a></p><h3 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a>事件轮询</h3><p><strong>同步任务</strong> 指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<br><strong>异步任务</strong> 指的是，不进入主线程、而进入”任务队列”（<code>task queue</code>）的任务，等待同步任务执行完毕之后，轮询执行异步任务队列中的任务<br><strong>macrotask队列</strong> 等同于我们常说的任务队列，macrotask是由宿主环境分发的异步任务，事件轮询的时候总是一个一个任务队列去查看执行的，”任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。<br><strong>microtask</strong> 即<code>微任务</code>，是由js引擎分发的任务，总是添加到当前任务队列末尾执行。另外在处理<code>microtask</code>期间，如果有新添加的<code>microtasks</code>，也会被添加到队列的末尾并执行。注意与<code>setTimeout(fn,0)</code>的区别：<br>　　<code>setTimeOut(fn(),0)</code> 指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。<br><strong>所以我们可以得到js执行顺序是：</strong></p><blockquote><p>开始 -&gt; 取第一个task queue里的任务执行(可以认为同步任务队列是第一个task queue) -&gt; 取 microtask 全部任务依次执行 -&gt; 取下一个task queue里的任务执行 -&gt; 再次取出microtask全部任务执行 -&gt; … 这样循环往复</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CommonJS&amp;&amp;AMD&amp;&amp;CMD</title>
    <link href="http://yoursite.com/2019/04/21/JavaScript/CommonJS&amp;&amp;AMD&amp;&amp;CMD/"/>
    <id>http://yoursite.com/2019/04/21/JavaScript/CommonJS&amp;&amp;AMD&amp;&amp;CMD/</id>
    <published>2019-04-21T12:57:06.000Z</published>
    <updated>2019-04-22T00:35:40.169Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p><a href="https://juejin.im/post/5aaa37c8f265da23945f365c" target="_blank" rel="noopener">前端模块化：CommonJS,AMD,CMD,ES6</a><br><a href="https://juejin.im/post/5c17ad756fb9a049ff4e0a62#heading-2" target="_blank" rel="noopener">前端模块化详解(完整版)</a></p><h2 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h2><h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h3><p>　　将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。<br>　　块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。</p><h3 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h3><p>　　避免命名冲突(减少命名空间污染)<br>　　更好的分离, 按需加载<br>　　更高复用性<br>　　高可维护性</p><h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>　　Node 应用由模块组成，采用 <code>CommonJS</code> 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>　　所有代码都运行在模块作用域，不会污染全局作用域。<br>　　模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。<br>　　模块加载的顺序，按照其在代码中出现的顺序。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>　　暴露模块：<code>module.exports = value</code>或<code>exports.xxx = value</code><br>　　引入模块：<code>require(xxx)</code>,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</p><p>　　此处我们有个疑问：<strong>CommonJS暴露的模块到底是什么?</strong> CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。<strong>加载某个模块，其实是加载该模块的module.exports属性。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var x = 5;</span><br><span class="line">var addX = <span class="keyword">function</span> (value) &#123;</span><br><span class="line">  <span class="built_in">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.x = x;</span><br><span class="line">module.exports.addX = addX;</span><br></pre></td></tr></table></figure></p><p>上面代码通过<code>module.exports</code>输出变量x和函数addX。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span><br><span class="line">var example = require(<span class="string">'./example.js'</span>);</span><br><span class="line">console.log(example.x); // 5</span><br><span class="line">console.log(example.addX(1)); // 6</span><br></pre></td></tr></table></figure></p><p>　　require命令用于加载模块文件。<strong>require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</strong></p><h4 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h4><p>　　<strong>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</strong>。这点与ES6模块化有重大差异（下文会介绍），请看下面这个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line">var counter = 3;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">incCounter</span></span>() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">var counter = require(<span class="string">'./lib'</span>).counter;</span><br><span class="line">var incCounter = require(<span class="string">'./lib'</span>).incCounter;</span><br><span class="line"></span><br><span class="line">console.log(counter);  // 3</span><br><span class="line">incCounter();</span><br><span class="line">console.log(counter); // 3</span><br></pre></td></tr></table></figure></p><p>　　上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。<strong>这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</strong></p><h3 id="AMD和require-js"><a href="#AMD和require-js" class="headerlink" title="AMD和require.js"></a>AMD和require.js</h3><p>　　AMD规范采用<code>异步方式加载模块</code>，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用<code>require.js</code>实现<code>AMD</code>规范的模块化：用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。<br>　　首先我们需要引入<code>require.js</code>文件和一个入口文件<code>main.js</code>。<code>main.js</code>中配置<code>require.config()</code>并规定项目中用到的基础模块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/** 网页中引入require.js及main.js **/</span><br><span class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/main"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">/** main.js 入口文件/主模块 **/</span><br><span class="line">// 首先用config()指定各模块路径和引用名</span><br><span class="line">require.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">"js/lib"</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,  //实际路径为js/lib/jquery.min.js</span><br><span class="line">    <span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 执行基本操作</span><br><span class="line">require([<span class="string">"jquery"</span>,<span class="string">"underscore"</span>],<span class="keyword">function</span>($,_)&#123;</span><br><span class="line">  // some code here</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>　　引用模块的时候，我们将模块名放在<code>[]</code>中作为<code>reqiure()</code>的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在<code>[]</code>中作为<code>define()</code>的第一参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 定义math.js模块</span><br><span class="line">define(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var basicNum = 0;</span><br><span class="line">    var add = <span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">        <span class="built_in">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        add: add,</span><br><span class="line">        basicNum :basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">// 定义一个依赖underscore.js的模块</span><br><span class="line">define([<span class="string">'underscore'</span>],<span class="keyword">function</span>(_)&#123;</span><br><span class="line">  var classify = <span class="keyword">function</span>(list)&#123;</span><br><span class="line">    _.countBy(list,<span class="keyword">function</span>(num)&#123;</span><br><span class="line">      <span class="built_in">return</span> num &gt; 30 ? <span class="string">'old'</span> : <span class="string">'young'</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    classify :classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 引用模块，将模块放在[]内</span><br><span class="line">require([<span class="string">'jquery'</span>, <span class="string">'math'</span>],<span class="keyword">function</span>($, math)&#123;</span><br><span class="line">  var sum = math.add(10,20);</span><br><span class="line">  $(<span class="string">"#sum"</span>).html(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>　　CMD规范专门用于浏览器端，<code>模块的加载是异步的</code>，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。</p><h4 id="CMD规范基本语法"><a href="#CMD规范基本语法" class="headerlink" title="CMD规范基本语法"></a>CMD规范基本语法</h4><p>定义暴露模块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义没有依赖的模块</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module)&#123;</span><br><span class="line">  exports.xxx = value</span><br><span class="line">  module.exports = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义有依赖的模块</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module)&#123;</span><br><span class="line">  //引入依赖模块(同步)</span><br><span class="line">  var module2 = require(<span class="string">'./module2'</span>)</span><br><span class="line">  //引入依赖模块(异步)</span><br><span class="line">    require.async(<span class="string">'./module3'</span>, <span class="keyword">function</span> (m3) &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  //暴露模块</span><br><span class="line">  exports.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>引入使用模块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span> (require) &#123;</span><br><span class="line">  var m1 = require(<span class="string">'./module1'</span>)</span><br><span class="line">  var m4 = require(<span class="string">'./module4'</span>)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="CMD和sea-js"><a href="#CMD和sea-js" class="headerlink" title="CMD和sea.js"></a>CMD和sea.js</h3><p>　　require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>], <span class="keyword">function</span>(a, b, c, d, e, f) &#123; </span><br><span class="line">    // 等于在最前面声明并初始化了要用到的所有模块</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">      // 即便没用到某个模块 b，但 b 还是提前执行了</span><br><span class="line">      b.foo()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>　　CMD是另一种js模块化方案，它与AMD很类似，不同点在于：<strong>AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/** AMD写法 **/</span><br><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>], <span class="keyword">function</span>(a, b, c, d, e, f) &#123; </span><br><span class="line">     // 等于在最前面声明并初始化了要用到的所有模块</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        // 即便没用到某个模块 b，但 b 还是提前执行了</span><br><span class="line">        b.doSomething()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/** CMD写法 **/</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var a = require(<span class="string">'./a'</span>); //在需要时申明</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        var b = require(<span class="string">'./b'</span>);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/** sea.js **/</span><br><span class="line">// 定义模块 math.js</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var $ = require(<span class="string">'jquery.js'</span>);</span><br><span class="line">    var add = <span class="keyword">function</span>(a,b)&#123;</span><br><span class="line">        <span class="built_in">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    exports.add = add;</span><br><span class="line">&#125;);</span><br><span class="line">// 加载模块</span><br><span class="line">seajs.use([<span class="string">'math.js'</span>], <span class="keyword">function</span>(math)&#123;</span><br><span class="line">    var sum = math.add(1+2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>　　ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/** 定义模块 math.js **/</span><br><span class="line">var basicNum = 0;</span><br><span class="line">var add = <span class="keyword">function</span> (a, b) &#123;</span><br><span class="line">    <span class="built_in">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">export</span> &#123; basicNum, add &#125;;</span><br><span class="line"></span><br><span class="line">/** 引用模块 **/</span><br><span class="line">import &#123; basicNum, add &#125; from <span class="string">'./math'</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(ele) &#123;</span><br><span class="line">    ele.textContent = add(99 + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　如上例所示，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名。其实<code>ES6</code>还提供了<code>exportdefault</code>命令，为模块指定默认输出，对应的<code>import</code>语句不需要使用大括号。这也更趋近于<code>ADM</code>的引用写法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** <span class="built_in">export</span> default **/</span><br><span class="line">//定义输出</span><br><span class="line"><span class="built_in">export</span> default &#123; basicNum, add &#125;;</span><br><span class="line">//引入</span><br><span class="line">import math from <span class="string">'./math'</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(ele) &#123;</span><br><span class="line">    ele.textContent = math.add(99 + math.basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p><h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><h4 id="CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h4><p>　　CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。<br>　　ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> counter = 3;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">incCounter</span></span>() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">// main.js</span><br><span class="line">import &#123; counter, incCounter &#125; from <span class="string">'./lib'</span>;</span><br><span class="line">console.log(counter); // 3</span><br><span class="line">incCounter();</span><br><span class="line">console.log(counter); // 4</span><br></pre></td></tr></table></figure></p><h4 id="CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h4><p>　　运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。<br>　　编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。<br>　　CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。<br>　　AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。<br>　　CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重<br>　　ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>项目的总结</title>
    <link href="http://yoursite.com/2019/04/21/Project/Backstage/"/>
    <id>http://yoursite.com/2019/04/21/Project/Backstage/</id>
    <published>2019-04-21T10:50:06.000Z</published>
    <updated>2019-04-21T12:37:25.921Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>项目名： 森尚宅配全屋定制流程控制系统<br>项目地址： <a href="https://github.com/aLittleLittleStar/Backstage" target="_blank" rel="noopener">https://github.com/aLittleLittleStar/Backstage</a><br>项目技术：<br>Asp.net<br>MySQL8.0.13<br>JQuery2.2.4<br>BootStarp3.3.7<br>负责功能：<br>前端页面的设计与编写<br>登录交互功能的编写<br>（如何根据不同的用户权限对内容页面的展示进行修改。解决方法使用localStrong把用户类别放到本地前端读取之后进行相对应页面的显示和隐藏），<br>时间组件bootstrap-datetimepicker的使用<br>页面的布局 flex布局<br>iframe 的使用： 点击侧边栏菜单内容页面进行相应的切换<br>项目的难点：<br>登录功能的实现</p><p>Travel去哪儿网<br>项目地址： <a href="https://github.com/aLittleLittleStar/Travel" target="_blank" rel="noopener">https://github.com/aLittleLittleStar/Travel</a><br>项目技术：<br>node10.5.0<br>npm 3.0.0<br>axios 0.18.0<br>better-scroll 6.26.0<br>faskclick 1.0.6<br>stylus 0.54.5<br>vue 2.5.2<br>vue-router 3.0.1<br>vuex 3.0.1<br>ESLint 4.15.0<br>webpack 3.6.0</p><p>负责功能：页面的设计，功能分析，编译打包<br>数据的传递共享（vuex）<br>项目的难点：<br>解决一像素边框问题 fastclick<br>使用ajax获取数据</p><p>刷新页面是轮播图无法显示第一页<br>解决方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;swiper :options=&quot;swiperOption&quot; v-if=&quot;showSwiper&quot;&gt;</span><br><span class="line">&lt;!-- 计算属性：计算list数组长度，刚开始没有加载数据所以数组长度为0，v-if为false页面不显示 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        showSwiper () &#123;</span><br><span class="line">            return this.list.length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="项目总结" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>编程风格</title>
    <link href="http://yoursite.com/2019/04/17/JavaScript/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
    <id>http://yoursite.com/2019/04/17/JavaScript/编程风格/</id>
    <published>2019-04-17T12:42:01.000Z</published>
    <updated>2019-04-19T11:13:42.566Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>块级作用域<br>字符串<br>解构赋值<br>对象<br>数组<br>函数<br>Map函数<br>Class<br>模板<br>ESLint 使用</p><h3 id="正则："><a href="#正则：" class="headerlink" title="正则："></a>正则：</h3><h4 id="两种模糊匹配"><a href="#两种模糊匹配" class="headerlink" title="两种模糊匹配"></a>两种模糊匹配</h4><h5 id="横向模糊匹配"><a href="#横向模糊匹配" class="headerlink" title="横向模糊匹配"></a>横向模糊匹配</h5><p>横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。<br>{m,n}，表示连续出现最少m次，最多n次。<br>比如/ab{2,5}c/表示匹配这样一个字符串：第一个字符是“a”，接下来是2到5个字符“b”，最后是字符“c”。</p><h5 id="纵向模糊匹配"><a href="#纵向模糊匹配" class="headerlink" title="纵向模糊匹配"></a>纵向模糊匹配</h5><p>纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>蘑菇街面试准备</title>
    <link href="http://yoursite.com/2019/04/15/JavaScript/%E8%98%91%E8%8F%87%E8%A1%97%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/04/15/JavaScript/蘑菇街面试题详解/</id>
    <published>2019-04-15T11:05:41.000Z</published>
    <updated>2019-04-22T13:03:58.545Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>const<br>let  var 之间的区别<br>4、es6中的const解释解释<br>9.em和rem区别<br>3.js部分，const，let和 var 的区别。<br>4.js部分，数组遍历map和forEach的区别。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">能用forEach()做到的，map()同样可以。反过来也是如此。</span><br><span class="line">map()会分配内存空间存储新数组并返回，forEach()不会返回数据。</span><br><span class="line">forEach()允许callback更改原始数组的元素。map()返回新的数组。</span><br></pre></td></tr></table></figure></p><p>5.css部分，em和rem怎么做自适应。<br>8.函数提升和变量提升优先级<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">函数提升 优于变量</span><br><span class="line">解析器在向执行环境中加载数据时会率先读取函数声明，并使其在执行任何代码之前可用(可访问)，即函数声明提升、JavaScript上卷中第40页提到函数声明是优于变量提升的。可见代码</span><br><span class="line">console.log(getName)</span><br><span class="line">var getName = 1;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">// 输出为函数getName</span><br><span class="line">注意:不要学了一点就忘记别的了啊，如果两个函数名一样，后面的会覆盖前面的(认为是在函数解析的时候覆盖，即提升的时候就覆盖了)</span><br></pre></td></tr></table></figure></p><p>JS深拷贝的用处，哪里会用到？</p><blockquote><p>浅拷贝<br>深拷贝 </p></blockquote><p>7、闭包以及带来问题<br>闭包知道吗？它可能出现的问题呢<br>10、css有哪些布局（一开始理解错了说了一大堆，后来面试官带回来了，是关于position、float）<br>11、flex实现水平垂直居中<br>12、align-items:center是不是只针对垂直<br>css布局都用过啥，flex布局，想让我说flex布局的原理的。。。想想还是算了，感觉面试官对原理情有独钟<br>CSS布局技巧<br>跨域的几种方式，有答jsonp，然后又问了 jsonp 的原理是啥？<br>6.跨域问题<br>6.常用的跨域方式。<br>项目有没跨域问题<br>5.作用域链<br><a href="https://juejin.im/post/58ed9c0ea0bb9f006a4c28cd" target="_blank" rel="noopener">JavaScript深入之作用域链</a><br><a href="https://juejin.im/post/5c8290455188257e5d0ec64f" target="_blank" rel="noopener">深入理解JavaScript作用域和作用域链</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">作用域链，是由当前环境与上层环境的一系列变量对象组成，</span><br><span class="line">它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</span><br><span class="line"></span><br><span class="line">当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，</span><br><span class="line">就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到</span><br><span class="line">全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对</span><br><span class="line">象构成的链表就叫做作用域链。</span><br></pre></td></tr></table></figure></p><p>第一个问题是讲一下原型链，这个我先推了一下，讲了个小插曲，promise的状态和蘑菇街面试的状态吻合，只有pending、resolved、rejected三种状态，算是个破冰吧，今天看promise想到的。<br>然后继续回答原型链。</p><p>2、Promise了解多少<br><a href="https://juejin.im/post/5b32f552f265da59991155f0" target="_blank" rel="noopener"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Promise 是异步编程的一种解决方案：</span><br><span class="line">从语法上讲，promise是一个对象，从它可以获取异步操作的消息；</span><br><span class="line">从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</span><br><span class="line">promise有三种状态：pending(等待态)，fulfiled(成功态)，rejected(失败态)；</span><br><span class="line">状态一旦改变，就不会再变。创造promise实例后，它会立即执行。</span><br><span class="line"></span><br><span class="line">pending，异步任务正在进行。</span><br><span class="line">resolved (也可以叫fulfilled)，异步任务执行成功。</span><br><span class="line">rejected，异步任务执行失败。</span><br><span class="line"></span><br><span class="line">回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</span><br><span class="line">promise可以支持多个并发的请求，获取并发请求中的数据</span><br><span class="line">这个promise可以解决异步的问题，本身不能说promise是异步的</span><br><span class="line"></span><br><span class="line">Promise.resolve(value)</span><br><span class="line">类方法，该方法返回一个以 value 值解析后的 Promise 对象</span><br><span class="line">1、如果这个值是个 thenable（即带有 <span class="keyword">then</span> 方法），返回的 Promise </span><br><span class="line">对象会“跟随”这个 thenable 的对象，采用它的最终状态</span><br><span class="line">（指 resolved/rejected/pending/settled）</span><br><span class="line">2、如果传入的 value 本身就是 Promise 对象，</span><br><span class="line">  则该对象作为 Promise.resolve 方法的返回值返回。</span><br><span class="line">3、其他情况以该值为成功状态返回一个 Promise 对象。</span><br><span class="line"></span><br><span class="line">Promise.all的用法：谁跑的慢，以谁为准执行回调。</span><br><span class="line">  all接收一个数组参数，里面的值最终都算返回Promise对象</span><br><span class="line">  all方法可以说是Promise中很常用的方法了，它的作用就是将一个数组的Promise对象放在其中，当全部resolve的时候就会执行<span class="keyword">then</span>方法，当有一个reject的时候就会执行catch，并且他们的结果也是按着数组中的顺序来排放的，那么我们来实现一下。</span><br><span class="line">Promise.race的用法：谁跑的快，以谁为准执行回调</span><br><span class="line">它的作用是将一个Promise数组放入race中，哪个先执行完，race就直接执行完，并从<span class="keyword">then</span>中取值。</span><br><span class="line">Promise.prototype.catch</span><br><span class="line">  实例方法，捕获异常，函数形式：fn(err)&#123;&#125;, err 是 catch 注册 之前的回调抛出的异常信息。</span><br><span class="line">Promise.prototype.then</span><br><span class="line">  实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue)&#123;&#125;，value 是上一个任务的返回结果，<span class="keyword">then</span> 中的函数一定要 <span class="built_in">return</span> 一个结果或者一个新的 Promise 对象，才可以让之后的<span class="keyword">then</span> 回调接收。</span><br><span class="line">Promise.reject</span><br><span class="line">类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。</span><br><span class="line"></span><br><span class="line">Promise的立即执行性</span><br><span class="line">Promise 三种状态</span><br><span class="line">Promise 状态的不可逆性</span><br><span class="line"><span class="keyword">then</span>方法链式调用</span><br><span class="line"></span><br><span class="line">async/await</span><br></pre></td></tr></table></figure></p><p>promise有了解吗<br>Promise.all promise.race 有了解吗（当时一直听成Promise.out ，我就纳闷了说哪儿来的这个方法。。）</p><p>3.React 生命周期，如果要合并 props 和 state 在哪进行<br>4.React 组件想用函数调用的方式使用，怎么设计<br>react如果更新了父组件，子组件没有更新，会都重新渲染吗？<br>react的原理，他的内部是怎么构建DOM的，比如p标签的子元素放在哪个属性里。。。没看过源码着实不知道<br>react相关的redux的原理？<br>7.你印象比较深的项目或者代码<br>我觉得是像 antd 里面的 message 模块，使用 ReactDOM.render<br>挂载组件到指定节点，然后通过更新 props 使用<br>html css js擅长哪部分？<br>我回答擅长js，但他居然没有继续问下去了</p><p>3、es5和es6了解多少<br>es5,es6哪个用的多点？<br>3、es5和es6了解多少<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">变量声明：<span class="built_in">let</span> const</span><br><span class="line">字符串模板</span><br><span class="line">解构赋值 对象对对象 数组对数组</span><br><span class="line">扩展运算符</span><br><span class="line">箭头函数</span><br><span class="line">  不需要 <span class="keyword">function</span> 关键字来创建函数</span><br><span class="line">  省略 <span class="built_in">return</span> 关键字</span><br><span class="line">  继承当前上下文的 this 关键字</span><br><span class="line">import导入模块、<span class="built_in">export</span>导出模块</span><br><span class="line">Promise</span><br><span class="line">数组常用方法：</span><br><span class="line">Array.isArray</span><br><span class="line">map</span><br><span class="line">filter</span><br><span class="line">forEach</span><br><span class="line">every</span><br><span class="line">reduce</span><br><span class="line">splice</span><br><span class="line">indexOf</span><br><span class="line">slice</span><br><span class="line">concat</span><br><span class="line">reverse()</span><br><span class="line">join()</span><br><span class="line"></span><br><span class="line">Array.from()</span><br><span class="line">Array.of()</span><br><span class="line">copyWitch</span><br><span class="line">find</span><br><span class="line">findIndex</span><br><span class="line">keys()</span><br><span class="line">values()</span><br><span class="line">class 静态、私有、共有</span><br><span class="line"></span><br><span class="line">生成器（ generator）是能返回一个迭代器的函数。</span><br><span class="line">生成器函数也是一种函数，最直观的表现就是比普通的<span class="keyword">function</span>多了个星号*，</span><br><span class="line">在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。</span><br><span class="line"></span><br><span class="line">可以暂停并重新开始执行的函数</span><br><span class="line"></span><br><span class="line">generators 可以扮演三种角色</span><br><span class="line">  迭代器(数据生产者)</span><br><span class="line">  观察者(数据消费者)</span><br><span class="line">  协作程序(数据生产者和消费者)</span><br></pre></td></tr></table></figure></p><p><a href="https://segmentfault.com/a/1190000012358863" target="_blank" rel="noopener">es6 Generators详解</a></p><p>2.CSS sprite(雪碧图或者精灵图)<br><a href="https://www.cnblogs.com/evenyao/p/9262371.html" target="_blank" rel="noopener">CSS Sprite “精灵图”</a><br><a href="https://blog.csdn.net/CamilleZJ/article/details/80406645" target="_blank" rel="noopener">CSS Sprite雪碧图</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用CSS的<span class="string">"background-image"</span>，<span class="string">"background-repeat"</span>，<span class="string">"background-position"</span></span><br><span class="line">的组合进行背景定位，background-position可以用数字精确的定位出背景图片的位置。</span><br><span class="line">CSS Sprites 的优点：</span><br><span class="line">减少图片字节</span><br><span class="line">减少网页HTTP请求，提高网页性能</span><br><span class="line">减少命名难的问题</span><br><span class="line">缺点</span><br><span class="line">图片合并的时候要把图片合理的合并成一张图片，防止板块内出现不必要的背景</span><br><span class="line">在高分辨率下的自适应如果图片宽度不够，容易造成背景断裂</span><br><span class="line">维护的时候比较困难，如果背景图有少许改动，需要改动合并图片。</span><br></pre></td></tr></table></figure></p><p>事件节流？刚看过，没印象了，哭。<br>情景题，往下滚动，加载更多，有什么优化方案，图片懒加载？提示了可以滚轮事件是个比较频繁的操作，但是还是没想出来。防抖</p><p>vue和react差别，<br>8、问了vue有没有做过项目，然后就没有了<br>1.vue生命周期，没有问详细的，就是顺着生命周期说了一遍。英文捉急。<br>2.vue源码部分，几个重要的部分，compile，数据劫持，依赖收集，虚拟DOM。<br>问了一个异步加载组件，不用标签引入的方法。<br>让你实现vue你怎么实现……<br>说说vue的双向绑定（顺带把响应式说了）<br>说说Vue的diff过程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">如果不了解virtual dom，要理解diff的过程是比较困难的。虚拟dom对应的是真实dom， 使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点。</span><br><span class="line"></span><br><span class="line">我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。</span><br><span class="line">diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。</span><br><span class="line"></span><br><span class="line">在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。</span><br><span class="line">diff流程图</span><br><span class="line">当数据发生改变时，<span class="built_in">set</span>方法会让调用Dep.notify通知所有订阅者Watcher，</span><br><span class="line">订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。</span><br><span class="line"></span><br><span class="line">patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点</span><br><span class="line">判断两节点是否值得比较，值得比较则执行patchVnode</span><br><span class="line">不值得比较则用Vnode替换oldVnode</span><br><span class="line">如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。</span><br><span class="line"></span><br><span class="line">当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法</span><br><span class="line">这个函数做了以下事情：</span><br><span class="line">  找到对应的真实dom，称为el</span><br><span class="line">  判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接<span class="built_in">return</span></span><br><span class="line">  如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。</span><br><span class="line">  如果oldVnode有子节点而Vnode没有，则删除el的子节点</span><br><span class="line">  如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el</span><br><span class="line">  如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要</span><br><span class="line">updateChildren</span><br><span class="line">先说一下这个函数做了什么</span><br><span class="line">  将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来</span><br><span class="line">  oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。</span><br></pre></td></tr></table></figure></p><p>v-model，v-bind 和v-click<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">v-bind  动态地绑定一个或多个特性、或一个组件 prop 到表达式。</span><br><span class="line">1:v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，</span><br><span class="line">在为了能够动态的给这些属性添加值，可以使用v-bind:你要动态变化的值=<span class="string">"表达式"</span></span><br><span class="line"></span><br><span class="line">v-model 在表单控件或者组件上创建双向绑定。</span><br><span class="line">v-on 指令用于监听DOM事件 形式如：v-on:click  缩写为 @click;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[VUE中的v-if与v-show](http://www.cnblogs.com/wmhuang/p/5420344.html)</span><br><span class="line">手段：v-if是动态的向DOM树内添加或者删除DOM元素；</span><br><span class="line">v-show是通过设置DOM元素的display样式属性控制显隐；</span><br><span class="line">编译过程</span><br><span class="line">：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；</span><br><span class="line">v-show只是简单的基于css切换；</span><br><span class="line">编译条件：</span><br><span class="line">v-if是惰性的，如果初始条件为假，则什么也不做；</span><br><span class="line">只有在条件第一次变为真时才开始局部编译(编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载)</span><br><span class="line">v-if是动态的向DOM树内添加或者删除DOM元素；</span><br><span class="line">v-show是通过设置DOM元素的display样式属性控制显隐；</span><br><span class="line">v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；</span><br><span class="line">性能消耗：</span><br><span class="line">v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</span><br><span class="line">使用场景：</span><br><span class="line">v-if适合运营条件不大可能改变；v-show适合频繁切换。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</span><br><span class="line">v-if 也是惰性的：</span><br><span class="line">如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</span><br><span class="line">相比之下，v-show 就简单得多——不管初始条件是什么，</span><br><span class="line">元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</span><br><span class="line">一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；</span><br><span class="line">如果在运行时条件不太可能改变，则使用 v-if 较好。</span><br></pre></td></tr></table></figure></p><p>function a(){}，a的<strong>proto</strong> 指向哪，Function呢？Object呢？<br>js异步都有哪些？答了onclick之类的、setTimeout/setInterval/requestAnimation、Generator、promise、async/await，讲了promise和async/await的优缺点。</p><p>1.就我这次面试表现而言，有哪方面需要提升或者欠缺的<br>3.团队技术栈？<br>然后项目……照着你简历上的问，<br>技术选型，遇到的困难，解决思路，</p><p>面试中印象最深的问题<br>场面试官自己先介绍了三分钟..然后让我也介绍一下基本情况，项目经历难点之类的。<br>然后开始面试，很少技术问题<br>项目难点，如何解决的<br>有没有想过进入一个团队实习之后会有哪些压力大的事情？<br>有没有了解前端的新技术<br>有没有参加线下前端活动<br>会去看哪些博客或者社区<br>CSS动画和JS动画。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> (1)浏览器可以对动画进行优化。</span><br><span class="line">  1、 浏览器使用与 requestAnimationFrame 类似的机制，requestAnimationFrame比起setTimeout，setInterval设置动画的优势主要是:1)requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成,并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率,一般来说,这个频率为每秒60帧。2)在隐藏或不可见的元素中requestAnimationFrame不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。</span><br><span class="line">  2、强制使用硬件加速 （通过 GPU 来提高动画性能）</span><br><span class="line">  (2)代码相对简单,性能调优方向固定</span><br><span class="line">  (3)对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码</span><br><span class="line">缺点：</span><br><span class="line">　　1、 运行过程控制较弱,无法附加事件绑定回调函数。CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件,无进度报告</span><br><span class="line"> 　  2、  代码冗长。想用 CSS 实现稍微复杂一点动画,最后CSS代码都会变得非常笨重。</span><br><span class="line"></span><br><span class="line">JavaScript</span><br><span class="line">  (1)JavaScript动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。</span><br><span class="line">  (2)动画效果比css3动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成</span><br><span class="line">  (3)CSS3有兼容性问题，而JS大多时候没有兼容性问题</span><br><span class="line">缺点：</span><br><span class="line">　　　(1)JavaScript在浏览器的主线程中运行，而主线程中还有其它需要运行的JavaScript脚本、样式计算、布局、绘制任务等,对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。</span><br><span class="line">  (2)代码的复杂度高于CSS动画</span><br></pre></td></tr></table></figure></p><p>后来说问点有难度的问题的吧。直接怼了好多原理。。。卡了好几下<br>webpack的打包目录为啥是这样的，知道原理吗？<br>大概目前只能想到这些了，最后问了面试官几个问题，面试官说有结果，顿了一下，通过或者不通过hr都会通知你的emmm，感觉有点凉，主要是原理着实卡了好几个地方，不过自我感觉面试官人还是很nice的，没有太难为我，看面相是个忠厚老实的小哥哥emmm，求offer啊啊啊啊啊啊啊啊啊啊啊啊<br>7.项目印象深刻的部分和难点。<br>二面我就不写面经了，就是问了些项目上的问题，解决问题的思路，技术栈，基本情况<br>自我介绍<br>项目介绍<br>你说的你的项目里有个首屏加载特别慢的问题对吧？能说说怎么优化的吗？<br>一个骰子，5个面，你怎么实现它（一个面你怎么布局）<br>说说事件循环<br>假如有个项目加载最开始特别快，后面越来越慢你知道是为什么吗？以及如何第一时间定位（内存泄漏）<br>1、自我介绍 + 项目介绍（难点）<br>5、事件委托<br>6、任务队列<br>9、一个场景题（关于使用调试工具的）<br>13、bootstrap中的栅格式<br>一面我上来就说的微信小程序，然后后边面试官几乎都没问别的（倒是考我几个问题啊，js css啥都不问，得嘞，白准备了），然后说到Vue，说了个v-model感觉不是很满意，自己也觉得虽然自己懂原理，但是没讲清楚。。。整个流程10来分钟，估计gg了</p><p>重绘&amp;&amp;回流<br>vue differ<br>vue 生命周期<br>跨域<br>自我介绍</p><p>JavaScript 怎么实现 OOP<br>原型继承与类继承的区别<br>闭包的应用场景<br>关系完整性约束</p><p>Cookie &amp; Session 的区别<br>Session 的实现原理<br>HTTP 请求方法中哪些是幂等性的<br>跨域处理方案<br>JSONP 的缺点以及安全隐患<br>为什么要做单元测试<br>黑盒测试与白盒测试的区别<br>怎样实现测试覆盖率<br>Async &amp; Await 的使用</p><p>块级元素、行内元素、inline-block 的区别<br>水平居中的方法<br>String、Array 常用的方法<br>输入一个 URL 到呈现页面的过程<br>Vue.js 组件的生命周期<br>Git 怎么合并提交记录<br>Linux 常用的命令<br>HTTP2 新特性</p><p>常见的 Web 攻击手段以及防范措施<br>对 Ajax 的理解<br>对闭包的理解<br>对事件机制的理解<br>对 HTTP 的理解<br>GET &amp; POST 的区别<br>HTTP2 和 HTTP1 有什么不同<br>对 JavaScript 各大框架的理解<br>对 jQuery 的理解<br>页面性能优化<br>计算机网络分层<br>输入 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 到呈现页面的过程<br>事件机制（W3C 标准）<br>事件代理<br>XSS、CSRF 的防范<br>token 的实现原理<br>熟练使用JS实现Json、XML格式的数据发送与数据解析；<br>3、熟悉各种web标准，了解各主流浏览器特性，使页面兼容主浏览器；</p><p>自我介绍<br>事件流<br>vue nextTick原理<br>vue react区别<br>web优化<br>移动端的优化有特别了解过吗<br>css flex了解过吗<br>如何前端监控错误，<br>koa有学过吗<br>事件循环说一说<br>web新技术了解过哪些，最近有去学习哪些东西<br>PWA你能详细说说吗<br>service worker<br>h5 worker<br>非受控组件 与受控组件<br>const let var区别<br>三道题<br>有自己写过webpack插件吗<br>webpack loader 和plugin区别<br>实现promise<br>大数相加<br>纯js写一个动画，5s由快到慢，速度自定义<br>（这里特别感谢以前发过面筋的同学，前两道题因为碰到过，自己下去做了一下 10多分钟给做完了 然后又让我补了一道= =）<br>自我介绍，说一下怎么学习前端的，以及做的项目的亮点<br>web优化<br>缓存（协商，强制说一说）<br>CDN<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CDN的全称是Content Delivery Network，即内容分发网络。</span><br><span class="line">其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，</span><br><span class="line">使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联</span><br><span class="line">网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、</span><br><span class="line">负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近</span><br><span class="line">的服务节点上。</span><br><span class="line"></span><br><span class="line">其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，</span><br><span class="line">提高用户访问网站的响应速度。</span><br><span class="line">降低核心系统负载 加速用户访问</span><br><span class="line">CDN做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源</span><br></pre></td></tr></table></figure></p><p>DNS如何查询域名的<br>node中间件原理<br>跨域<br>作用域<br>一个页面白屏，分析原因<br>数据结构链表<br>怎么判断链表有环（当时还问我是不是刷了很多题，我们都笑了笑）<br>cookie了解吗<br>cookie的属性，怎么存储<br>web安全，xss csrf<br>css响应式布局<br>token生成过程<br>前端新技术<br>PWA讲一讲<br>serviceworker<br>h5 worker<br>智商题<br>3.45分夹角<br>两个火车相对而行，知道彼此的速度，中间有一个小鸟来回飞 知道小鸟的速度 求相撞的时候的 小鸟飞行的距离<br>10瓶药，每瓶药有10颗药片，每片10克，其中一瓶药里的所有药片是坏的 每片重量为11克，现在给你一个秤，如何一次性称出来</p><p>三面<br>自我介绍<br>web优化<br>css动画<br>csrf如何防御<br>如何生成token<br>Vue的diff能详细说一说吗<br>Vue子组件你的子组件方法是放在哪里的<br>Vue自定义指令<br>微信小程序接触过吗<br>微信小程序原理<br>TCP三次握手第三次失败了 客户端和服务端是如何处理的<br>301，302状态码区别，以及什么时候会返回这些状态。<br>node如何升级到webSoket<br>如何添加header头<br>DNS迭代和递归区别<br>前端怎么设置cookie过期<br>有看过源码吗<br>看过哪些书<br>能来实习的时间<br>智商题<br>一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球 求同时喜欢足球和篮球的<br>算法 最大的回文字符<br>北森<br>一面<br>面试官非常nice，善于引导<br>自我介绍<br>你的项目<br>能说下vue如何收集依赖双向绑定的吗<br>能说下vue如何更新节点的吗<br>node如何打印时间与错误<br>webpack构建流程<br>webpack如何找到依赖关系的<br>webpack如何配置<br>vue和react区别<br>react生命周期<br>函数式组件，如何给状态（hook）<br>原型链，原型知道多少<br>es6了解哪些<br>promise.resolve()<br>http状态码<br>post请求之前先发送Option条件<br>get,post,put,delete区别（冥等）<br>二面<br>面试官是个女架构师，感觉非常好，还因为迟到了几分钟说道歉之类的<br>vue,react，你更倾向于哪一个，为什么<br>es6模块cmd amd 区别<br>跨域<br>深拷贝，浅拷贝<br>post发送Option的条件<br>输入URL到浏览器会发生什么<br>TCP为什么三次握手<br>TCP为什么四次挥手<br>HTTP为什么基于TCP协议<br>vue diff过程<br>vue如果同一个数据，很短的时间内连续更新 会怎么样。<br>算法题<br>[0,0,1,1,1,2,3,4,5]，不借用辅助空间找到不重复项[2，3，4，5]</p><p>三面<br>面试官是技术总监，问的问题都是基于场景来说的，面试体验还可以<br>有这样一个数组，你如何扁平化<br>如果用字符串形式会出现什么问题<br>跨域你如何处理的<br>能说说同源策略吗，那如果是直接请求ip会有同源策略吗，如果一个域名对应多个ip的情况呢。<br>你以前做的项目，如果让你去完善你能说一说完善的细节吗，说三点 （我提到模块化，规范化，可扩展性）<br>能具体一点说说吗，说一点就可以<br>你觉得你相比其他实习生的优点和缺点在哪里</p><p>前天过了一面。问的有基础的知识和CSS、JS应用的知识，还问了OSI七层网络。其实自我感觉回答的不太好，面试官也说框架知识和项目经验不太足够，没想到过了。<br>了项目难点，然后还考了osi网络层级，怎么用css实现表格奇偶行不同颜色，怎么根据表格行的颜色拿到行数，还问了vue的生命周期钩子函数，vue-cli不过我没答上来</p><p>007bcc9b9629c19abe2d66d4ceb0c0006f9fd8e8</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue双向绑定原理及实现</title>
    <link href="http://yoursite.com/2019/04/15/Vue/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/04/15/Vue/Vue双向绑定原理及实现/</id>
    <published>2019-04-15T06:33:31.000Z</published>
    <updated>2019-04-16T03:21:51.713Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h4 id="双向绑定方法"><a href="#双向绑定方法" class="headerlink" title="双向绑定方法"></a>双向绑定方法</h4><p>发布者-订阅者模式（<code>backbone.js</code>）<br>脏值检查（<code>angular.js</code>）<br>数据劫持（<code>vue.js</code>）<br>发布者-订阅者模式: 一般通过<code>sub, pub</code>的方式实现数据和视图的绑定监听，更新数据方式通常做法是 <code>vm.set(&#39;property&#39;, value)</code><br>脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 <code>setInterval()</code> 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：<br>　　DOM事件，譬如用户输入文本，点击按钮等。( <code>ng-click</code> )<br>　　XHR响应事件 ( <code>$http</code> )<br>　　浏览器<code>Location</code>变更事件 ( <code>$location</code> )<br>　　Timer事件( <code>$timeout</code> , <code>$interval</code> )<br>　　执行 <code>$digest()</code> 或 <code>$apply()</code><br>数据劫持:<br>　　<code>vue.js</code> 则是采用<code>数据劫持结合发布者-订阅者模式</code>的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>　　<code>Vue</code> 响应系统，其核心有三点：<code>observe</code>、<code>watcher</code>、<code>dep</code>：<br>　　　　<code>observe</code>：遍历 <code>data</code> 中的属性，使用 <code>Object.defineProperty</code> 的 <code>get/set</code> 方法对其进行数据劫持；<br>　　　　<code>dep</code>：每个属性拥有自己的消息订阅器 <code>dep</code>，用于存放所有订阅了该属性的观察者对象；<br>　　　　<code>watcher</code>：观察者（对象），通过 <code>dep</code> 实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。<br>实现虚拟DOM包含以下三个步骤：<br>　　用JS对象模拟DOM树<br>　　比较两棵虚拟DOM树的差异, Diff算法<br>　　映射成真实DOM</p><h4 id="Vue-双向数据绑定的原理"><a href="#Vue-双向数据绑定的原理" class="headerlink" title="Vue 双向数据绑定的原理"></a>Vue 双向数据绑定的原理</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object​.define​Property()</a><br>属性描述符有两种主要形式：<code>数据描述符</code>和<code>存取描述符</code>。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。<br><code>Object.defineProperty</code>是<code>ES5</code>新增的一个<code>API</code>，其作用是给对象的属性增加更多的控制<br><code>Object.defineProperty(obj, prop, descriptor)</code><br>参数 :<br>　　<code>obj</code>: 需要定义属性的对象（目标对象）<br>　　<code>prop</code>: 需被定义或修改的属性名（对象上的属性或者方法）<br>对于<code>setter</code>和<code>getter</code>，我的理解是它们是一对勾子（<code>hook</code>）函数，当你对一个对象的某个属性赋值时，则会自动调用相应的<code>setter</code>函数；而当获取属性时，则调用<code>getter</code>函数。这也是实现双向数据绑定的关键。<br>　　<code>descriptor</code>: 将被定义或修改的属性描述符。<br>描述:<br>　　该方法允许精确添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，能够在属性枚举期间呈现出来（<code>for...in</code> 或 <code>Object.keys</code> 方法）， 这些属性的值可以被改变，也可以被删除。这个方法允许修改默认的额外选项（或配置）。<code>默认情况下</code>，使用 <code>Object.defineProperty()</code> 添加的属性值是<code>不可修改</code>的。</p><p>整理思路<br>实现mvvm的双向绑定，就必须要实现以下几点：<br>1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者<br>2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数<br>3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br>4、mvvm入口函数，整合以上三者<br>observer用来实现对每个vue中的data中定义的属性循环用<code>Object.defineProperty()</code>实现数据劫持，以便利用其中的setter和getter，然后通知订阅者，订阅者会触发它的update方法，对视图进行更新。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们介绍为什么要订阅者，在`vue`中`v-model`，`v-name`，`&#123;&#123;&#125;&#125;`等都可以</span><br><span class="line">对数据进行显示，也就是说假如一个属性都通过这三个指令了，那么每当这个属性</span><br><span class="line">改变的时候，相应的这个三个指令的html视图也必须改变，于是vue中就是每当有</span><br><span class="line">这样的可能用到双向绑定的指令，就在一个Dep中增加一个订阅者，其订阅者只是</span><br><span class="line">更新自己的指令对应的数据，也就是`v-model=<span class="string">'name'</span>`和`&#123;&#123;name&#125;&#125;`有两个对</span><br><span class="line">应的订阅者，各自管理自己的地方。每当属性的<span class="built_in">set</span>方法触发，就循环更新Dep中</span><br><span class="line">的订阅者。</span><br></pre></td></tr></table></figure></p><p><code>Object.defineProperty</code>缺陷：<br>只能对属性进行数据劫持，对于JS对象劫持需要深度遍历；<br>对于数组不能监听到数据的变化，而是通过一些hack办法来实现，如<code>push、pop、shift、unshift、splice、sort、reverse</code></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>函数节流与防抖</title>
    <link href="http://yoursite.com/2019/04/15/JavaScript/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
    <id>http://yoursite.com/2019/04/15/JavaScript/函数节流与防抖/</id>
    <published>2019-04-15T00:09:39.000Z</published>
    <updated>2019-04-15T10:37:54.194Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;防抖和节流&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        button &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 50px;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="built_in">log</span> &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 30px;</span><br><span class="line">            border: 1px solid <span class="comment">#ccc;</span></span><br><span class="line">            margin-top: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=<span class="string">"debounced"</span>&gt;Debounced&lt;/button&gt;</span><br><span class="line">    &lt;button id=<span class="string">"throttled"</span>&gt;Throttled&lt;/button&gt;</span><br><span class="line">    &lt;div id=<span class="string">"log1"</span> class=<span class="string">"log"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">"log2"</span> class=<span class="string">"log"</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        /*</span><br><span class="line">          节流说白了就是每ms执行一次函数，</span><br><span class="line">          防抖就是 我最后一次触发后ms后执行一次回调函数</span><br><span class="line">        */</span><br><span class="line">        /*debounced（防抖动）函数，该函数会从上一次被调用后，延迟 <span class="built_in">wait</span> 毫秒后调用 fn 方法。*/</span><br><span class="line">        <span class="keyword">function</span> debounce(fn, <span class="built_in">wait</span>, options) &#123;</span><br><span class="line">            // 等待时间</span><br><span class="line">            <span class="built_in">wait</span> = <span class="built_in">wait</span> || 0</span><br><span class="line">            // 点击次数</span><br><span class="line">            <span class="built_in">let</span> timerId;</span><br><span class="line">            console.log(<span class="string">"timerId:"</span>, timerId);</span><br><span class="line">            // 这个函数的功能是：</span><br><span class="line">            // </span><br><span class="line">            <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> (timerId) &#123;</span><br><span class="line">                    clearTimeout(timerId);</span><br><span class="line">                    timerId = null;</span><br><span class="line">                &#125;</span><br><span class="line">                timerId = setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                    fn();</span><br><span class="line">                &#125;, <span class="built_in">wait</span>);</span><br><span class="line">                console.log(<span class="string">"timerId:"</span>, timerId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 节流函数，在 <span class="built_in">wait</span> 秒内最多执行 fn 一次的函数。</span><br><span class="line">        <span class="keyword">function</span> throttle(fn, <span class="built_in">wait</span>, options) &#123;</span><br><span class="line">            <span class="built_in">wait</span> = <span class="built_in">wait</span> || 0;</span><br><span class="line">            <span class="built_in">let</span> timerId;</span><br><span class="line">            <span class="built_in">let</span> lastTime = 0;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                <span class="built_in">let</span> currentTime = new Date();</span><br><span class="line">                <span class="keyword">if</span> (currentTime &gt;= lastTime + <span class="built_in">wait</span>) &#123;</span><br><span class="line">                    fn();</span><br><span class="line">                    lastTime = currentTime;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (timerId) &#123;</span><br><span class="line">                        clearTimeout(timerId);</span><br><span class="line">                        timerId = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    timerId = setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                        fn();</span><br><span class="line">                    &#125;, <span class="built_in">wait</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">let</span> debouncedBtn = document.getElementById(<span class="string">'debounced'</span>);</span><br><span class="line">        <span class="built_in">let</span> throttledBtn = document.getElementById(<span class="string">'throttled'</span>);</span><br><span class="line">        <span class="built_in">let</span> log1 = document.getElementById(<span class="string">'log1'</span>);</span><br><span class="line">        <span class="built_in">let</span> log2 = document.getElementById(<span class="string">'log2'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">handleDebounce</span></span>() &#123;</span><br><span class="line">            log1.innerHTML += <span class="string">'debounced'</span>;</span><br><span class="line">            console.log(<span class="string">"debounced"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">handleThrottle</span></span>() &#123;</span><br><span class="line">            log2.innerHTML += <span class="string">'throttle'</span>;</span><br><span class="line">            console.log(<span class="string">"throttle"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        debouncedBtn.addEventListener(<span class="string">'click'</span>, debounce(handleDebounce, 2000));</span><br><span class="line">        throttledBtn.addEventListener(<span class="string">'click'</span>, throttle(handleThrottle, 2000));</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="http://yoursite.com/2019/04/11/Ajax/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/04/11/Ajax/跨域/</id>
    <published>2019-04-11T07:36:13.000Z</published>
    <updated>2019-04-11T08:58:37.980Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p><a href="https://juejin.im/post/5a2f92c65188253e2470f16d" target="_blank" rel="noopener">正确面对跨域，别慌</a><br><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="AJAX" scheme="http://yoursite.com/categories/AJAX/"/>
    
    
      <category term="AJAX" scheme="http://yoursite.com/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>CSS3选择器</title>
    <link href="http://yoursite.com/2019/04/11/CSS3/CSS3%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/04/11/CSS3/CSS3选择器/</id>
    <published>2019-04-11T02:13:51.000Z</published>
    <updated>2019-04-11T03:13:05.791Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br><a href="https://segmentfault.com/a/1190000003064142" target="_blank" rel="noopener">CSS &gt; 选择器优先级与效率优化</a></p><h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><p>　　important声明 1,0,0,0<br>　　ID选择器      0,1,0,0<br>　　类选择器      0,0,1,0<br>　　伪类选择器    0,0,1,0<br>　　属性选择器    0,0,1,0<br>　　标签选择器    0,0,0,1<br>　　伪元素选择器  0,0,0,1<br>　　通配符选择器  0,0,0,0<br>important &gt; 行内样式</p><h3 id="选择器效率"><a href="#选择器效率" class="headerlink" title="选择器效率"></a>选择器效率</h3><p>　　读取选择器的原则是<code>从右到左</code>。因此，我们书写的右边的最后一个选择器，被称作<code>关键选择器</code>，对于效率有决定性影响。<br>选择器效率：<br>　　ID选择器<br>　　类选择器<br>　　标签选择器<br>　　相邻选择器<br>　　子选择器<br>　　后代选择器<br>　　通配符选择器<br>　　属性选择器<br>　　伪类选择器<br><strong>优先级高的不一定效率高</strong><br>举个例子：<code>#id .class</code> 与 <code>div#id p.class</code><br>前者效率高于后者，而后者优先级高于前者。我们需要在效率与优先级之间平衡取舍。</p><h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><p>扼要摘其精要总结如下：<br>　　避免使用通配符<br>　　不使用标签名或类名修饰ID规则：如果规则使用ID选择器作为关键选择器，不要给规则添加标签名。因为ID本身就是唯一的，添加标签名会不必要地降低匹配效率。<br>　　不使用标签名修饰类：相较于标签，类更具独特性。<br>　　尽量选择最具体的方式：造成低效的最简单粗暴的原因就是在标签上使用太多规则。给元素添加类可以更快细分到类方式，可以减少规则去匹配标签的时间。<br>　　关于后代选择器和子选择器：避免使用后代选择器，非要用的话建议用子选择器代替，但子选择器也要慎用，标签规则永远不要包含子选择器。<br>　　利用可继承性：没必要在一般内容上声明样式。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>数组操作</title>
    <link href="http://yoursite.com/2019/04/11/JavaScript/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/04/11/JavaScript/数组操作/</id>
    <published>2019-04-11T00:49:01.000Z</published>
    <updated>2019-04-14T12:43:47.375Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><h4 id="改变原始数组的操作方法"><a href="#改变原始数组的操作方法" class="headerlink" title="改变原始数组的操作方法"></a>改变原始数组的操作方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向数组末尾添加元素，并返回新的长度</span></span><br><span class="line">push</span><br><span class="line"><span class="comment"># 删除最后一个并返回删除的元素</span></span><br><span class="line">pop</span><br><span class="line"><span class="comment"># 向数组开头添加元素，并返回新的长度</span></span><br><span class="line">unshift</span><br><span class="line"><span class="comment"># 将第一个元素删除并且返回删除元素，空即为undefined</span></span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="comment"># 颠倒数组顺序</span></span><br><span class="line">reverse</span><br><span class="line"><span class="comment"># 对数组排序</span></span><br><span class="line">sort</span><br><span class="line"><span class="comment"># 删，增，替换数组元素，返回被删除数组，无删除则不返回</span></span><br><span class="line">splice</span><br><span class="line"><span class="comment"># 用于从数组的指定位置拷贝元素到数组的另一个指定位置中。</span></span><br><span class="line">copyWithin</span><br><span class="line"><span class="comment"># 用于将一个固定值替换数组的元素。</span></span><br><span class="line">fill</span><br></pre></td></tr></table></figure><h5 id="splice-添加-删除数组元素"><a href="#splice-添加-删除数组元素" class="headerlink" title="splice() 添加/删除数组元素"></a>splice() 添加/删除数组元素</h5><p>定义： <code>splice()</code> 方法向/从数组中添加/删除项目，然后返回被删除的项目<br><code>array.splice(index,howmany,item1,.....,itemX)</code><br>参数:<br>　　<code>index</code>：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。<br>　　<code>howmany</code>：可选。要删除的项目数量。如果设置为 0，则不会删除项目。<br>　　<code>item1, ..., itemX</code>： 可选。向数组添加的新项目。<br><strong>删除元素</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line"><span class="built_in">let</span> item = a.splice(0, 3); // [1,2,3]</span><br><span class="line">console.log(a); // [4,5,6,7]</span><br><span class="line">// 从数组下标0开始，删除3个元素</span><br><span class="line"><span class="built_in">let</span> item = a.splice(-1, 3); // [7]</span><br><span class="line">// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span><br></pre></td></tr></table></figure></p><p><strong>删除并添加</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line"><span class="built_in">let</span> item = a.splice(0,3,<span class="string">'添加'</span>); // [1,2,3]</span><br><span class="line">console.log(a); // [<span class="string">'添加'</span>,4,5,6,7]</span><br><span class="line">// 从数组下标0开始，删除3个元素，并添加元素<span class="string">'添加'</span></span><br><span class="line"><span class="built_in">let</span> b = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line"><span class="built_in">let</span> item = b.splice(-2,3,<span class="string">'添加1'</span>,<span class="string">'添加2'</span>); // [6,7]</span><br><span class="line">console.log(b); // [1,2,3,4,5,<span class="string">'添加1'</span>,<span class="string">'添加2'</span>]</span><br><span class="line">// 从数组最后第二个元素开始，删除3个元素，并添加两个元素<span class="string">'添加1'</span>、<span class="string">'添加2'</span></span><br></pre></td></tr></table></figure></p><p><strong>添加元素</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">// [] 没有删除元素，返回空数组</span><br><span class="line"><span class="built_in">let</span> item = a.splice(0,0,<span class="string">'添加1'</span>,<span class="string">'添加2'</span>); </span><br><span class="line">console.log(a); // [<span class="string">'添加1'</span>,<span class="string">'添加2'</span>,1,2,3,4,5,6,7]</span><br><span class="line"><span class="built_in">let</span> b = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">// [] 没有删除元素，返回空数组</span><br><span class="line"><span class="built_in">let</span> item = b.splice(-1,0,<span class="string">'添加1'</span>,<span class="string">'添加2'</span>); </span><br><span class="line">// [1,2,3,4,5,6,<span class="string">'添加1'</span>,<span class="string">'添加2'</span>,7] 在最后一个元素的前面添加两个元素</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure></p><p>　　数组如果元素不够，会删除到最后一个元素为止<br>　　操作的元素，包括开始的那个元素<br>　　可以添加很多个元素<br>　　添加是在开始的元素前面添加的</p><h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h5><h5 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h5><h5 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h5><h5 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h5><h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h5><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h5><h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h5><h5 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h5><h4 id="不改变原始数组的操作方法"><a href="#不改变原始数组的操作方法" class="headerlink" title="不改变原始数组的操作方法"></a>不改变原始数组的操作方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接多个数组，返回新的数组</span></span><br><span class="line">concat</span><br><span class="line"><span class="comment"># 将数组中所有元素以参数作为分隔符放入一个字符</span></span><br><span class="line">join</span><br><span class="line"><span class="comment"># 返回选定元素</span></span><br><span class="line">slice</span><br><span class="line"><span class="comment"># 数组映射为新的数组</span></span><br><span class="line">map(es6)</span><br><span class="line"><span class="comment"># 数组过滤，返回所有通过方法判断后(判断为true时)生成的新数组</span></span><br><span class="line">filter(es6)</span><br><span class="line"><span class="comment"># 数组遍历，没有返回值</span></span><br><span class="line">forEach</span><br><span class="line"><span class="comment"># 对数组中的每一项运行给定函数，如每一项均为true时返回true，否则返回false</span></span><br><span class="line">every(es6)</span><br><span class="line"><span class="comment"># 数组中的的元素运行给定函数，如其中有一项为true时返回true，</span></span><br><span class="line"><span class="comment"># 此时剩余的元素不会再执行检测，如果所以都为false则返回false</span></span><br><span class="line">some(es6)</span><br><span class="line"><span class="comment"># 寻找数组中符合测试方法（函数）条件的第一个元素，并且返回该元素</span></span><br><span class="line">find(es6)</span><br><span class="line"><span class="comment"># 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</span></span><br><span class="line">reduce(es6)</span><br><span class="line"><span class="comment"># 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</span></span><br><span class="line">indexOf</span><br><span class="line"><span class="comment"># 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true，否则返回false。</span></span><br><span class="line">includes(es7)</span><br></pre></td></tr></table></figure><h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><h4 id="toLocaleString-数组转字符串"><a href="#toLocaleString-数组转字符串" class="headerlink" title="toLocaleString() 数组转字符串"></a>toLocaleString() 数组转字符串</h4><h4 id="toString-数组转字符串-不推荐"><a href="#toString-数组转字符串-不推荐" class="headerlink" title="toString() 数组转字符串 不推荐"></a>toString() 数组转字符串 不推荐</h4><h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><h4 id="ES6扩展运算符…合并数组"><a href="#ES6扩展运算符…合并数组" class="headerlink" title="ES6扩展运算符…合并数组"></a>ES6扩展运算符…合并数组</h4><h4 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h4><h4 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h4><h4 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7 includes() 查找数组是否包含某个元素 返回布尔"></a>ES7 includes() 查找数组是否包含某个元素 返回布尔</h4><h3 id="遍历方法-12个"><a href="#遍历方法-12个" class="headerlink" title="遍历方法(12个):"></a>遍历方法(12个):</h3><h4 id="关于forEach-你要知道："><a href="#关于forEach-你要知道：" class="headerlink" title="关于forEach()你要知道："></a>关于forEach()你要知道：</h4><h4 id="every-检测数组所有元素是否都符合判断条件"><a href="#every-检测数组所有元素是否都符合判断条件" class="headerlink" title="every 检测数组所有元素是否都符合判断条件"></a>every 检测数组所有元素是否都符合判断条件</h4><h4 id="some-数组中的是否有满足判断条件的元素"><a href="#some-数组中的是否有满足判断条件的元素" class="headerlink" title="some 数组中的是否有满足判断条件的元素"></a>some 数组中的是否有满足判断条件的元素</h4><h4 id="filter-过滤原始数组，返回新数组"><a href="#filter-过滤原始数组，返回新数组" class="headerlink" title="filter 过滤原始数组，返回新数组"></a>filter 过滤原始数组，返回新数组</h4><h4 id="map-对数组中的每个元素进行处理，返回新的数组"><a href="#map-对数组中的每个元素进行处理，返回新的数组" class="headerlink" title="map 对数组中的每个元素进行处理，返回新的数组"></a>map 对数组中的每个元素进行处理，返回新的数组</h4><h4 id="reduce-为数组提供累加器，合并为一个值"><a href="#reduce-为数组提供累加器，合并为一个值" class="headerlink" title="reduce 为数组提供累加器，合并为一个值"></a>reduce 为数组提供累加器，合并为一个值</h4><h4 id="reduceRight-从右至左累加"><a href="#reduceRight-从右至左累加" class="headerlink" title="reduceRight 从右至左累加"></a>reduceRight 从右至左累加</h4><h4 id="ES6-find-amp-findIndex-根据条件找到数组成员"><a href="#ES6-find-amp-findIndex-根据条件找到数组成员" class="headerlink" title="ES6 find()&amp; findIndex() 根据条件找到数组成员"></a>ES6 find()&amp; findIndex() 根据条件找到数组成员</h4><h4 id="ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值"><a href="#ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值" class="headerlink" title="ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值"></a>ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[【干货】js 数组详细操作方法及解析合集](https://juejin.im/post/5b0903b26fb9a07a9d70c7e0)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>原型&amp;&amp;原型链</title>
    <link href="http://yoursite.com/2019/04/10/JavaScript/%E5%8E%9F%E5%9E%8B&amp;&amp;%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2019/04/10/JavaScript/原型&amp;&amp;原型链/</id>
    <published>2019-04-10T07:34:11.000Z</published>
    <updated>2019-04-22T01:14:52.133Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>摘自JavaScript高级程序设计:<br>　　继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: <code>接口继承</code> 和 <code>实现继承</code> .<code>接口继承只继承方法签名</code>,而<code>实现继承则继承实际的方法</code>.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 实现继承 主要是依靠<code>原型链</code>来实现的.<br>　　在 JavaScript 中，是一种面向对象的程序设计语言，但是 JS 本身是没有 “类” 的概念，JS 是靠原型和原型链实现对象属性的继承。<br>　　在理解原型前，需要先知道对象的构造函数是什么，构造函数都有什么特点？</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数 Person()</span><br><span class="line"><span class="keyword">function</span> Person(name, gender) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(<span class="string">"周杰伦"</span>, <span class="string">"男"</span>);</span><br><span class="line">// 最后创建出来的对象实例 person</span><br><span class="line">person</span><br><span class="line">&#123;</span><br><span class="line">  name: <span class="string">"周杰伦"</span>,</span><br><span class="line">  gender: <span class="string">"男"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，普通函数 <code>Person()</code>，加上 <code>new</code> 关键字后，就构造了一个对象 <code>person</code><br>所以构造函数的定义就是普通函数加上 <code>new</code> 关键字，并总会返回一个对象。</p><h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><p>　　同时，JS 中的对象分为一般对象和函数对象。那什么是一般对象，什么又是函数对象呢？<br>　　<code>JavaScript</code> 的类型分为<code>基本数据类型</code>和<code>引用数据类型</code>，基本数据类型目前有 6 种（<code>null</code>, <code>undefined</code>, <code>string</code>, <code>number</code>, <code>boolean</code>, <code>Symbol</code>）。 其余的数据类型都统称为 <code>object</code> 数据类型，其中，包括 <code>Array</code>, <code>Date</code>, <code>Function</code>等，所以函数可以称为函数对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> foo = <span class="function"><span class="title">function</span></span>()&#123;&#125;</span><br><span class="line">foo.name = <span class="string">"bar"</span>;</span><br><span class="line">foo.age = 24;</span><br><span class="line">console.log(foo instanceof Function)  //<span class="literal">true</span></span><br><span class="line">console.log(foo.age)  // 24</span><br></pre></td></tr></table></figure></p><p>以上代码就说明了<code>函数其实是一个对象，也可以具有属性</code>。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>　　<code>JavaScript</code> 中的对象，有一个特殊的 <code>[[prototype]]</code> 属性, 其实就是对于其他对象的引用（委托）。当我们在获取一个对象的属性时，如果这个对象上没有这个属性，那么 JS 会沿着对象的 <code>[[prototype]]</code>链 一层一层地去找，最后如果没找到就返回 <code>undefined</code>;<br>这条一层一层的查找属性的方式，就叫做原型链。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;</span><br><span class="line">  age: 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　那么，为什么一个对象要引用，或者说要委托另外一个对象来寻找属性呢？<br>　　本文开篇的第一句话，就指出来的，JavaScript 中，和一般的 OOP 语言不同，它没有 ‘类’的概念，也就没有 ‘模板’ 来创建对象，而是通过字面量或者构造函数的方式直接创建对象。那么也就不存在所谓的类的复制继承。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>　　那什么又是原型呢？<br>　　既然我们没有类，就用其他的方式实现类的行为吧，看下面这句话↓↓。</p><h4 id="每个函数都有一个原型属性-prototype-对象"><a href="#每个函数都有一个原型属性-prototype-对象" class="headerlink" title="每个函数都有一个原型属性 prototype 对象"></a>每个函数都有一个原型属性 prototype 对象</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'JayChou'</span>;</span><br><span class="line">// person1 和 person2 都是空对象</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person1.name) // JayChou</span><br><span class="line">console.log(person2.name) // JayChou</span><br></pre></td></tr></table></figure><p>　　通过构造函数创造的对象，对象在寻找 name 属性时，找到了 构造函数的 prototype 对象上。<br>　　这个构造函数的 prototype 对象，就是 <code>原型</code><br>用示意图来表示：<br><img src="/assets/images/原型.png" alt="原型"><br>　　查找对象实例属性时，会沿着原型链向上找，在现代浏览器中，标准让每个对象都有一个 <code>__proto__</code> 属性，指向原型对象。那么，我们可以知道对象实例和函数原型对象之间的关系。<br><img src="/assets/images/原型1.png" alt="原型"></p><h4 id="每个原型对象都有一个-constructor-属性指向关联的构造函数"><a href="#每个原型对象都有一个-constructor-属性指向关联的构造函数" class="headerlink" title="每个原型对象都有一个 constructor 属性指向关联的构造函数"></a>每个原型对象都有一个 constructor 属性指向关联的构造函数</h4><p>为了验证这一说话，举个例子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;&#125;</span><br><span class="line">Person === Person.prototype.constructor; // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>那么对象实例是构造函数构造而来，那么对象实例是不是也应该有一个 <code>constructor</code> 呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">const person = new Person();</span><br><span class="line">person.constructor === Person // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>但事实上，对象实例本身并没有 <code>constructor</code> 属性，对象实例的 <code>constructor</code> 属性来自于引用了原型对象的 <code>constructor</code> 属性<br><code>person.constructor === Person.prototype.constructor // true</code><br><img src="/assets/images/原型2.png" alt="原型"></p><h4 id="原型链顶层：Object-prototype-proto-null"><a href="#原型链顶层：Object-prototype-proto-null" class="headerlink" title="原型链顶层：Object.prototype.__proto__== null"></a>原型链顶层：<code>Object.prototype.__proto__== null</code></h4><p>　　既然 JS 通过原型链查找属性，那么链的顶层是什么呢，答案就是 <code>Object</code> 对象，<code>Object</code> 对象其实也有 <code>__proto__</code>属性，比较特殊的是 <code>Object.prototype.__proto__</code> 指向 <code>null</code>, 也就是空。<br><code>Object.prototype.__proto__ === null</code><br><img src="/assets/images/原型3.png" alt="原型"><br>我们回过头来看函数对象：</p><blockquote><p>所有函数对象的<code>proto</code>都指向<code>Function.prototype</code>，它是一个空函数（<code>Empty function</code>）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Number.__proto__ === Function.prototype  // <span class="literal">true</span></span><br><span class="line">Number.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Boolean.__proto__ === Function.prototype // <span class="literal">true</span></span><br><span class="line">Boolean.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">String.__proto__ === Function.prototype  // <span class="literal">true</span></span><br><span class="line">String.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 所有的构造器都来自于Function.prototype,</span><br><span class="line">// 甚至包括根构造器Object及Function自身</span><br><span class="line">Object.__proto__ === Function.prototype  // <span class="literal">true</span></span><br><span class="line">Object.constructor == Function // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 所有的构造器都来自于Function.prototype，</span><br><span class="line">// 甚至包括根构造器Object及Function自身</span><br><span class="line">Function.__proto__ === Function.prototype // <span class="literal">true</span></span><br><span class="line">Function.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Array.__proto__ === Function.prototype   // <span class="literal">true</span></span><br><span class="line">Array.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">RegExp.__proto__ === Function.prototype  // <span class="literal">true</span></span><br><span class="line">RegExp.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Error.__proto__ === Function.prototype   // <span class="literal">true</span></span><br><span class="line">Error.constructor == Function //<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Date.__proto__ === Function.prototype    // <span class="literal">true</span></span><br><span class="line">Date.constructor == Function //<span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>所有的构造器都来自于 <code>Function.prototype</code>，甚至包括根构造器<code>Object</code>及<code>Function</code>自身。所有构造器都继承了·<code>Function.prototype</code>·的属性及方法。如<code>length</code>、<code>call</code>、<code>apply</code>、<code>bind</code></p></blockquote><p>以图会友，这就是网上经常看到的 JS 原型和原型链关系图：<br><img src="/assets/images/原型4.png" alt="原型"></p><p>对于以上看似很复杂的关系图，只需要理解 5 点：<br>　　每个函数都有一个原型属性 <code>prototype</code> 对象<br>　　普通对象的构造函数是 <code>Object()</code>，所以 <code>Person.prototype.__proto__ === Object.prototype</code><br>　　函数对象都来自于 <code>Function.prototype</code><br>　　函数对象也是对象，所有 <code>Function.prototype.__proto__ === Object.prototype</code><br>　　记住，所有函数原型的都是 <code>Object()</code> 的实例<br>　　<code>Object.prototype.__proto__</code> 是 <code>null</code></p><p>转载：<br>　　<a href="https://juejin.im/post/5bc755b15188255c89015f39" target="_blank" rel="noopener">JavaScript原型与原型链</a><br>参考：<br>　　<a href="https://juejin.im/post/5c72a1766fb9a049ea3993e6#chapter-one" target="_blank" rel="noopener">2019 面试准备 - JS 原型与原型链</a><br>　　<a href="https://juejin.im/post/58f94c9bb123db411953691b#heading-2" target="_blank" rel="noopener">JS原型链与继承别再被问倒了</a><br>　　<a href="https://juejin.im/post/5835853f570c35005e413b19#heading-0" target="_blank" rel="noopener">三张图搞懂JavaScript的原型对象与原型链</a><br>　　<a href="https://hexianzhi.github.io/2017/04/27/JavaScript%E5%8E%9F%E5%9E%8B/" target="_blank" rel="noopener">JavaScript原型及原型链</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue知识点详解</title>
    <link href="http://yoursite.com/2019/04/09/Vue/Vue%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/04/09/Vue/Vue知识点详解/</id>
    <published>2019-04-09T06:07:35.000Z</published>
    <updated>2019-04-13T09:36:54.113Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>Vue watch computed nexttick<br>双向绑定 虚拟dom<br>Vue双向绑定原理/组件通讯<br>Vue 单双向绑定（dep watcher observer）</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>宏任务&amp;&amp;微任务</title>
    <link href="http://yoursite.com/2019/04/09/JavaScript/%E5%AE%8F%E4%BB%BB%E5%8A%A1&amp;&amp;%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/04/09/JavaScript/宏任务&amp;&amp;微任务/</id>
    <published>2019-04-09T01:46:03.000Z</published>
    <updated>2019-04-22T03:08:16.039Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>JavaScript 是单线程、异步、非阻塞、解释型脚本语言。</code><br>　　微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。</p><h4 id="macrotask-宏任务"><a href="#macrotask-宏任务" class="headerlink" title="(macrotask)宏任务"></a>(macrotask)宏任务</h4><p>　　<code>macrotask</code>： 包括整体代码<code>script</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>requestAnimationFrame</code>、<code>I/O</code>、<code>UI rendering</code>等（可以看到，事件队列中的每一个事件都是一个 <code>macrotask</code>，现在称之为宏任务队列）</p><h4 id="microtask-微任务"><a href="#microtask-微任务" class="headerlink" title="(microtask)微任务"></a>(microtask)微任务</h4><p>　　<code>microtask</code>:<code>原生Promise</code>(有些实现的promise将then方法放到了宏任务中)、<code>process.nextTick</code>、<code>Promises</code>、Object.observe(已废弃)、 <code>MutationObserver</code> 记住就行了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'timer over'</span>)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line">// script start</span><br><span class="line">// script end</span><br><span class="line">// promise1</span><br><span class="line">// promise2</span><br><span class="line">// timer over</span><br></pre></td></tr></table></figure></p><p>JS引擎线程首先执行主代码块。<br>　　每次执行栈执行的代码就是一个宏任务，包括任务队列(宏任务队列)中的，因为执行栈中的宏任务执行完会去取任务队列（宏任务队列）中的任务加入执行栈中，即同样是事件循环的机制。<br>　　在执行宏任务时遇到<code>Promise</code>等，会<code>创建微任务</code>（.then()里面的回调），并加入到<code>微任务队列队尾</code>。<br>　　<code>microtask</code>必然是在某个宏任务执行的时候创建的，而在下一个宏任务开始之前，浏览器会对页面重新渲染(<code>task &gt;&gt; 渲染 &gt;&gt; 下一个task(从任务队列中取一个)</code>)。同时，<code>在上一个宏任务执行完成后，渲染页面之前，会执行当前微任务队列中的所有微任务</code>。<br>　　也就是说: <code>在某一个 macrotask 执行完后，在重新渲染与开始下一个宏任务之前，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）</code>。<br>　　这样就可以解释 “promise 1” “promise 2” 在 “timer over” 之前打印了。”promise 1” “promise 2” 做为微任务加入到微任务队列中，而 “timer over” 做为宏任务加入到宏任务队列中，它们同时在等待被执行，但是微任务队列中的所有微任务都会在开始下一个宏任务之前都被执行完。</p><blockquote><p>在node环境下，<code>process.nextTick</code>的优先级高于<code>Promise</code>，也就是说：<code>在宏任务结束后会先执行微任务队列中的nextTickQueue，然后才会执行微任务中的Promise</code>。</p></blockquote><p>执行机制：<br>　　执行一个宏任务（栈中没有就从事件队列中获取）<br>　　执行过程中如果遇到微任务，就将它添加到微任务的任务队列中<br>　　宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）<br>　　当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染<br>　　渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　<code>JavaScript</code> 是单线程语言，决定于它的设计最初是用来处理浏览器网页的交互。浏览器负责解释和执行 <code>JavaScript</code> 的线程只有一个（所有说是单线程），即<code>JS引擎线程</code>，但是浏览器同样提供其他线程，如：事件触发线程、定时器触发线程等。<br>异步一般是指：<br>　　<code>网络请求`</code><br>　　<code>计时器`</code><br>　　<code>DOM事件监听`</code><br>事件循环机制：<br>　　<code>JS引擎线程</code>会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。<br>　　<code>JS引擎线程</code>遇到异步函数，会将异步函数交给相应的Webapi，而继续执行后面的任务。<br>　　<code>Webapi</code>会在条件满足的时候，将异步对应的回调加入到消息队列中，等待执行。<br>　　<code>执行栈为空时</code>，JS引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。<br>　　<code>完成后出栈</code>，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。</p><p>原文：<br>　　<a href="https://juejin.im/post/5be5a0b96fb9a049d518febc" target="_blank" rel="noopener">总结：JavaScript异步、事件循环与消息队列、微任务与宏任务</a><br>　　<a href="https://juejin.im/post/5b498d245188251b193d4059" target="_blank" rel="noopener">JS事件循环机制（event loop）之宏任务/微任务</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="http://yoursite.com/2019/04/08/HTTP/HTTP/"/>
    <id>http://yoursite.com/2019/04/08/HTTP/HTTP/</id>
    <published>2019-04-08T13:25:53.000Z</published>
    <updated>2019-04-20T01:50:39.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载&amp;&amp;参考:<br>　　<a href="https://juejin.im/post/5a77fe396fb9a063317c2e71" target="_blank" rel="noopener">Pandaaa</a><br>　　<a href="https://juejin.im/post/5b5ef5a25188251af86bfebf#heading-5" target="_blank" rel="noopener">HTTP2和HTTPS来不来了解一下？</a><br>　　<a href="https://juejin.im/post/5ba65296f265da0ac8493503#heading-14" target="_blank" rel="noopener">深入理解 HTTP 协议</a><br>　　<a href="http://www.36nu.com/post/153.html" target="_blank" rel="noopener">HTTP协议Header详解</a><br>　　<a href="https://www.jianshu.com/p/6e9e4156ece3" target="_blank" rel="noopener">一篇文章带你详解 HTTP 协议（网络协议篇一）</a><br><a href="https://juejin.im/post/5ab308e9f265da238e0da39b" target="_blank" rel="noopener">天下无难试之HTTP协议面试刁难大全（上）</a><br><a href="https://juejin.im/post/5b7919345188254312414b9c#heading-1" target="_blank" rel="noopener">通过HTTP的HEADER完成各种骚操作</a><br><a href="https://www.jianshu.com/p/59d36b01608d" target="_blank" rel="noopener">Http–Header</a><br><a href="https://juejin.im/post/5c136bd16fb9a049d37efc47" target="_blank" rel="noopener">前端缓存最佳实践</a><br><a href="https://juejin.im/post/58eacff90ce4630058668257#heading-0" target="_blank" rel="noopener">浏览器缓存机制剖析</a><br><a href="https://juejin.im/post/5a6c87c46fb9a01ca560b4d7#heading-7" target="_blank" rel="noopener">缓存详解</a><br><a href="https://juejin.im/post/5b70edd4f265da27df0938bc#heading-3" target="_blank" rel="noopener">前端也要懂Http缓存机制</a></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>　　<code>超文本传输协议</code>（英文：<code>HyperText Transfer Protocol</code>，缩写：HTTP）是一种用于<code>分布式</code>、<code>协作式</code>和<code>超媒体信息系统</code>的<code>应用层协议</code>。HTTP是万维网的数据通信的基础。<br>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p><h4 id="HTTP-Header"><a href="#HTTP-Header" class="headerlink" title="HTTP Header"></a>HTTP Header</h4><p><a href="https://juejin.im/post/5b70edd4f265da27df0938bc#heading-0" target="_blank" rel="noopener">前端也要懂Http缓存机制</a><br><a href="https://juejin.im/post/58eacff90ce4630058668257#heading-10" target="_blank" rel="noopener">浏览器缓存机制剖析</a></p><h5 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h5><p>指请求报文和响应报文都可以使用的字段<br>　　<code>Cache-Control</code><br>　　　　<code>no-cache</code> 指客户端不缓存过期资源<br>　　　　<code>no-store</code> 指不进行缓存<br>　　　　<code>max-age</code> 指缓存资源的缓存时间比指定的值小，那么客户端就接受缓存资源，且缓存服务器不对资源有效性进行再次确认<br>　　<code>Connection</code> 指控制不再转发给代理的首部字段（<code>Hop-by-hop</code>），管理持久连接<br>　　　　<code>close</code> 指服务器像明确断开连接<br>　　　　<code>Keep-Alive</code> 指保存持久连接，<code>HTTP/1.1</code>前默认连接是非持久性的，如需要保存持久连接，需要增加此字段<br>　　<code>Upgrade</code>可以用来指定一个完全不同的通信协议，对于这个字段，服务器可以返回101状态码</p><h5 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h5><p>　　<code>Accept</code> 指用户代理能够处理的媒体类型及媒体类型的相对优先级<br>　　<code>Accept-Encoding</code> 指用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序<br>　　<code>Authorization</code> 指用来告知服务器，用户代理的认证信息<br>　　<code>Host</code> 当一个 <code>IP</code> 下存在多个域名时，帮助服务器知道要请求的具体主机<br>　　<code>User-Agent</code> 会讲创建请求的浏览器和用户代理名称等信息传达给服务器</p><h4 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h4><p><code>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术</code>。<br>缓存的好处：<br>　　<code>缓解服务器压力</code>(不用每次去请求资源)；<br>　　<code>提升性能</code>(打开本地资源速度当然比请求回来再打开要快得多)；<br>　　<code>减少带宽消耗</code>(我相信你可以理解)；<br>　　关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果<code>内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面</code>。这就可以比较合理的解释了为什么同一个资源有时是<code>from memory cache</code>有时是<code>from disk cache</code>的问题了。<br>　　浏览器对于请求资源, 拥有一系列成熟的缓存策略. 按照发生的时间顺序分别为<code>存储策略</code>, <code>过期策略</code>, <code>协商策略</code>, 其中存储策略在收到响应后应用, 过期策略, 协商策略在发送请求前应用. 流程图如下所示.<br><img src="/assets/images/http缓存.png" alt="http缓存"></p><p>1.http header中与缓存有关的key.</p><table><thead><tr><th>key</th><th>描述</th><th>储存策略</th><th>过期策略</th><th>协商策略</th></tr></thead><tbody><tr><td>Cache-Control</td><td>指定缓存机制,覆盖其它设置</td><td>✔️</td><td>✔️</td><td></td></tr><tr><td>Pragma</td><td>http1.0字段,指定缓存机制</td><td>✔️</td><td></td><td></td></tr><tr><td>Expires</td><td>http1.0字段,指定缓存的过期时间</td><td></td><td>✔️</td><td></td></tr><tr><td>Last-Modified</td><td>资源最后一次的修改时间</td><td></td><td></td><td>✔️</td></tr><tr><td>ETag</td><td>唯一标识请求资源的字符串</td><td></td><td></td><td>✔️</td></tr></tbody></table><p>2.缓存协商策略用于重新验证缓存资源是否有效, 有关的key如下.</p><table><thead><tr><th>key</th><th>描述</th></tr></thead><tbody><tr><td>If-Modified-Since</td><td>缓存校验字段, 值为资源最后一次的修改时间, 即上次收到的Last-Modified值</td></tr><tr><td>If-Unmodified-Since</td><td>同上, 处理方式与之相反</td></tr><tr><td>If-Match</td><td>缓存校验字段, 值为唯一标识请求资源的字符串, 即上次收到的ETag值</td></tr><tr><td>If-None-Match</td><td>同上, 处理方式与之相反</td></tr></tbody></table><p>　　Http缓存可以分为两大类，强制缓存（也称强缓存）和协商缓存。两类缓存规则不同，强制缓存在缓存数据未失效的情况下，不需要再和服务器发生交互；而协商缓存，顾名思义，需要进行比较判断是否可以使用缓存。<br>　　两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。</p><h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><p>　　强制缓存分为两种情况，<code>Expires</code> 和 <code>Cache-Control</code>。<br>一旦资源命中强缓存, 浏览器便不会向服务器发送请求, 而是直接读取缓存.<br>对于常规请求, 只要存在该资源的缓存, 且<code>Cache-Control:max-age</code> 或者<code>expires</code>没有过期, 那么就能命中强缓存.</p><h6 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h6><p>　　 针对浏览器和服务器时间不同步，加入了新的缓存方案；这次服务器不是直接告诉浏览器过期时间，而是告诉一个相对时间Cache-Control=10秒，意思是10秒内，直接使用浏览器缓存。<br>　　 <code>浏览器缓存里, Cache-Control是金字塔顶尖的规则, 它藐视一切其他设置, 只要其他设置与其抵触, 一律覆盖之.</code><br>　　 不仅如此, 它还是一个复合规则, 包含多种值, 横跨 存储策略, 过期策略 两种, 同时在请求头和响应头都可设置.</p><h6 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h6><p>　　Expires的值是服务器告诉浏览器的缓存过期时间（值为GMT时间，即格林尼治时间），即下一次请求时，如果浏览器端的当前时间还没有到达过期时间，则直接使用缓存数据。</p><h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>　　强制缓存的弊端很明显，即每次都是根据时间来判断缓存是否过期；但是当到达过期时间后，如果文件没有改动，再次去获取文件就有点浪费服务器的资源了。协商缓存有两组报文结合使用：<br>　　<code>Last-Modified</code> 和 <code>If-Modified-Since</code><br>　　<code>ETag</code> 和 <code>If-None-Match</code></p><h6 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h6><p>　　语法: Last-Modified: 星期,日期 月份 年份 时:分:秒 GMT</p><blockquote><p><code>Last-Modified: Tue, 04 Apr 2017 10:01:15 GMT</code></p></blockquote><p>　　用于标记请求资源的最后一次修改时间, 格式为GMT(格林尼治标准时间). 如可用 new Date().toGMTString()获取当前GMT时间. Last-Modified 是 ETag 的fallback机制, 优先级比 ETag 低, 且只能精确到秒, 因此不太适合短时间内频繁改动的资源. 不仅如此, 服务器端的静态资源, 通常需要编译打包, 可能出现资源内容没有改变, 而Last-Modified却改变的情况.</p><h6 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h6><p><code>If-Modified-Since: Tue, 04 Apr 2017 10:12:27 GMT</code><br>　　缓存校验字段, 其值为上次响应头的Last-Modified值, 若与请求资源当前的Last-Modified值相同, 那么将返回304状态码的响应, 反之, 将返回200状态码响应.</p><h6 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h6><p><code>ETag:&quot;fcb82312d92970bdf0d18a4eca08ebc7efede4fe&quot;</code><br>　　实体标签, 服务器资源的唯一标识符, 浏览器可以根据ETag值缓存数据, 节省带宽. 如果资源已经改变, etag可以帮助防止同步更新资源的相互覆盖. ETag 优先级比 Last-Modified 高.</p><h6 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h6><p>语法: <code>If-None-Match: ETag_value</code> 或者 <code>If-None-Match: ETag_value, ETag_value</code>,<br>　　缓存校验字段, 结合<code>ETag</code>字段, 常用于判断缓存资源是否有效, 优先级比<code>If-Modified-Since</code>高.<br>　　对于 <code>GET</code> 或 <code>HEAD</code> 请求, 如果其etags列表均不匹配, 服务器将返回200状态码的响应, 反之, 将返回304(Not Modified)状态码的响应. 无论是200还是304响应, 都至少返回<code></code> Cache-Control<code>,</code>Content-Location<code>,</code>Date<code>,</code>ETag<code>,</code>Expires<code>,</code>and Vary<code>中之一的字段.　　对于其他更新服务器资源的请求, 如果其etags列表匹配, 服务器将执行更新, 反之, 将返回412(</code>Precondition Failed`)状态码的响应.</p><h5 id="不缓存-Pragma"><a href="#不缓存-Pragma" class="headerlink" title="不缓存(Pragma)"></a>不缓存(Pragma)</h5><p>　　当该字段值为no-cache的时候，会告诉浏览器不要对该资源缓存，即每次都得向服务器发一次请求才行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//禁止缓存</span><br><span class="line">res.setHeader(<span class="string">'Pragma'</span>, <span class="string">'no-cache'</span>)</span><br><span class="line">//2分钟</span><br><span class="line">res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'public,max-age=120'</span>)</span><br></pre></td></tr></table></figure></p><p>　　通过<code>Pragma</code>来禁止缓存，通过<code>Cache-Control</code>设置两分钟缓存，但是重新访问我们会发现浏览器会再次发起一次请求，说明了<code>Pragma的优先级高于Cache-Control</code>。</p><h5 id="缓存优先级"><a href="#缓存优先级" class="headerlink" title="缓存优先级"></a>缓存优先级</h5><p><code>Pragma &gt; Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified</code></p><h4 id="HTTP的请求方法"><a href="#HTTP的请求方法" class="headerlink" title="HTTP的请求方法"></a>HTTP的请求方法</h4><blockquote><p>GET: 获取URL指定的资源；<br>POST：传输实体信息<br>PUT：上传文件<br>DELETE：删除文件<br>HEAD：获取报文首部，与GET相比，不返回报文主体部分<br>OPTIONS：询问支持的方法<br>TRACE：追踪请求的路径；<br>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信。主要使用SSL和TLS将数据加密后通过网络隧道进行传输。</p></blockquote><h3 id="HTTP1-1-新改动"><a href="#HTTP1-1-新改动" class="headerlink" title="HTTP1.1 新改动"></a>HTTP1.1 新改动</h3><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><h4 id="请求管道化"><a href="#请求管道化" class="headerlink" title="请求管道化"></a>请求管道化</h4><h4 id="增加缓存处理-新的字段如cache-control"><a href="#增加缓存处理-新的字段如cache-control" class="headerlink" title="增加缓存处理(新的字段如cache-control)"></a>增加缓存处理(新的字段如cache-control)</h4><h4 id="增加Host字段、支持断点传输"><a href="#增加Host字段、支持断点传输" class="headerlink" title="增加Host字段、支持断点传输"></a>增加Host字段、支持断点传输</h4><h3 id="HTTP2-0-新特性"><a href="#HTTP2-0-新特性" class="headerlink" title="HTTP2.0 新特性"></a>HTTP2.0 新特性</h3><p>　　<code>HTTP2.0</code>可以说是<code>SPDY</code>的升级版（其实原本也是基于<code>SPDY</code>设计的），但是，<code>HTTP2.0</code> 跟 <code>SPDY</code> 仍有不同的地方，主要是以下两点<br>　　<code>HTTP2.0</code> 支持<code>明文 HTTP 传输</code>，而 <code>SPDY</code> 强制使用 <code>HTTPS</code><br>　　<code>HTTP2.0</code> 消息头的压缩算法采用 <code>HPACK</code>，而非 <code>SPDY</code> 采用的 <code>DEFLATE</code></p><h4 id="新的二进制格式-二进制分帧-Binary-Format"><a href="#新的二进制格式-二进制分帧-Binary-Format" class="headerlink" title="新的二进制格式/ 二进制分帧(Binary Format)"></a>新的二进制格式/ 二进制分帧(Binary Format)</h4><p>　　HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p><h4 id="多路复用-MultiPlexing"><a href="#多路复用-MultiPlexing" class="headerlink" title="多路复用(MultiPlexing)"></a>多路复用(MultiPlexing)</h4><p>　　即连接共享，即每一个<code>request</code>都是用作连接共享机制的。一个<code>request</code>对应一个<code>id</code>，这样一个连接上可以有多个<code>request</code>，每个连接的<code>request</code>可以随机的混杂在一起，接收方可以根据<code>request</code>的 <code>id</code>将<code>request</code>再归属到各自不同的服务端请求里面。。</p><h4 id="header-压缩"><a href="#header-压缩" class="headerlink" title="header 压缩"></a>header 压缩</h4><p>　　如上文中所言，对前面提到过<code>HTTP1.x</code>的<code>header</code>带有大量信息，而且每次都要重复发送，<code>HTTP2.0</code>使用<code>encoder</code>来减少需要传输的<code>header</code>大小，通讯双方各自<code>cache</code>一份<code>header</code> <code>fields</code>表，既避免了重复<code>header</code>的传输，又减小了需要传输的大小。</p><h4 id="服务端推送-server-push"><a href="#服务端推送-server-push" class="headerlink" title="服务端推送(server push)"></a>服务端推送(server push)</h4><p>　　同SPDY一样，HTTP2.0也具有<code>server push</code>功能。目前，有大多数网站已经启用<code>HTTP2.0</code>。<code>例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</code>例如YouTuBe，淘宝网等网站，利用chrome控制台可以查看是否启用H2：<code>chrome=&gt;Network=&gt;Name栏右键=&gt;√Protocol</code></p><h3 id="HTTP1-0-和-HTPP1-1-区别"><a href="#HTTP1-0-和-HTPP1-1-区别" class="headerlink" title="HTTP1.0 和 HTPP1.1 区别"></a>HTTP1.0 和 HTPP1.1 区别</h3><h4 id="HTTP1-0和HTTP1-1最主要的区别就是："><a href="#HTTP1-0和HTTP1-1最主要的区别就是：" class="headerlink" title="HTTP1.0和HTTP1.1最主要的区别就是："></a>HTTP1.0和HTTP1.1最主要的区别就是：</h4><p>　　<code>HTTP1.1默认是持久化连接！</code><br>　　<code>在HTTP1.0默认是短连接</code><br>简单来说就是：<code>每次与服务器交互，都需要新开一个连接！</code><br>在<code>HTTP1.1</code>中默认就使用持久化连接来解决：<code>建立一次连接，多次请求均由这个连接完成</code>！(如果阻塞了，还是会开新的<code>TCP</code>连接的)</p><h4 id="HTTP1-0-和-HTTP1-1-比较重要的区别："><a href="#HTTP1-0-和-HTTP1-1-比较重要的区别：" class="headerlink" title="HTTP1.0 和 HTTP1.1 比较重要的区别："></a>HTTP1.0 和 HTTP1.1 比较重要的区别：</h4><p>相对于持久化连接还有另外比较重要的改动：<br>　　<code>HTTP 1.1增加host字段</code><br>　　<code>HTTP 1.1增加host字段</code><br>　　<code>HTTP 1.1</code>中引入了<code>Chunked</code> <code>transfer-coding</code>，范围请求，实现断点续传(实际上就是利用<code>HTTP</code>消息头使用分块传输编码，将实体主体分块传输)<br>　　<code>HTTP 1.1</code>管线化(<code>pipelining</code>)理论，客户端可以同时发出多个<code>HTTP</code>请求，而不用一个个等待响应之后再请求<br>　　注意：这个<code>pipelining</code>仅仅是限于理论场景下，大部分桌面浏览器仍然会选择默认关闭<code>HTTP pipelining</code>！<br>　　所以现在使用<code>HTTP1.1</code>协议的应用，都是有可能会开多个TCP连接的！</p><h4 id="管线化-pipelining-和非管线化的区别："><a href="#管线化-pipelining-和非管线化的区别：" class="headerlink" title="管线化(pipelining)和非管线化的区别："></a>管线化(pipelining)和非管线化的区别：</h4><p>　　在<code>HTTP1.0</code>中，发送一次请求时，需要等待服务端响应了才可以继续发送请求。<br>　　在<code>HTTP1.1</code>中，发送一次请求时，不需要等待服务端响应了就可以发送请求了，但是回送数据给客户端的时候，客户端还是需要按照响应的顺序来一一接收<br>　　所以说，无论是HTTP1.0还是HTTP1.1提出了Pipelining理论，还是会出现阻塞的情况。从专业的名词上说这种情况，叫做线头阻塞（Head of line blocking）简称：HOLB</p><h3 id="HTTP1-1-和-HTTP2-区别"><a href="#HTTP1-1-和-HTTP2-区别" class="headerlink" title="HTTP1.1 和 HTTP2 区别"></a>HTTP1.1 和 HTTP2 区别</h3><p>　　<code>HTTP2</code>与<code>HTTP1.1</code>最重要的区别就是解决了<code>线头阻塞</code>的问题！其中最重要的改动是：<code>多路复用 (Multiplexing)</code><br>　　多路复用意味着线头阻塞将不在是一个问题，允许同时通过单一的 <code>HTTP/2</code> 连接发起<code>多重的请求-响应消息</code>，合并多个请求为一个的优化将不再适用。<br>　　　　(我们知道：HTTP1.1中的Pipelining是没有付诸于实际的)，之前为了减少HTTP请求，有很多操作将多个请求合并，比如：Spriting(多个图片合成一个图片)，内联Inlining(将图片的原始数据嵌入在CSS文件里面的URL里)，拼接Concatenation(一个请求就将其下载完多个JS文件)，分片Sharding(将请求分配到各个主机上)……</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>事件代理(事件委托)</title>
    <link href="http://yoursite.com/2019/04/08/JavaScript/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/08/JavaScript/事件代理/</id>
    <published>2019-04-08T05:52:17.000Z</published>
    <updated>2019-04-08T07:15:56.593Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://www.cnblogs.com/wp-js/p/7609539.html" target="_blank" rel="noopener">javascript事件代理（事件委托）原理是怎么实现的</a></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>　　那什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：<code>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件</code>。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象，我仔细揣摩了一下，这个例子还真是恰当，我就不去想别的例子来解释了，借花献佛，我摘过来，大家认真领会一下事件委托到底是一个什么原理：<br>　　有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。<br>这里其实还有2层意思的：<br>　　第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；<br>　　第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1、<code>可以大量节省内存的使用，减少注册事件</code>，例如给table中的td事件，就添加到table上<br>2、<code>实现新增子对象时无需再次对其绑定事件。对于动态部分尤为适合</code></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>仅是上述1中类似的需求才会使用，使用场景比较少。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>事件委托的原理：<br>　　<code>事件委托是利用事件的冒泡原理来实现的</code>，何为事件冒泡呢？就是<code>事件从最深的节点开始，然后逐步向上传播事件</code>，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="一般方法的例子："><a href="#一般方法的例子：" class="headerlink" title="一般方法的例子："></a>一般方法的例子：</h4><p>子节点实现相同的功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"ul1"</span>&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>实现功能是点击li，弹出123：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  var oUl = document.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">  var aLi = oUl.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line">  <span class="keyword">for</span>(var i=0;i&lt;aLi.length;i++)&#123;</span><br><span class="line">    aLi[i].onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">      alert(123);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="事件委托方式："><a href="#事件委托方式：" class="headerlink" title="事件委托方式："></a>事件委托方式：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var oUl = document.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">   oUl.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招：<br>　　<code>Event</code>对象提供了一个属性叫<code>target</code>，可以返回事件的目标节点，我们成为事件源，也就是说，<code>target</code>就可以表示为当前的事件操作的<code>dom</code>，但是不是真正操作<code>dom</code>，当然，这个是有兼容性的，标准浏览器用<code>ev.target</code>，IE浏览器用<code>event.srcElement</code>，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用<code>nodeName</code>来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　var oUl = document.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">　　oUl.onclick = <span class="keyword">function</span>(ev)&#123;</span><br><span class="line">　　　　var ev = ev || window.event;</span><br><span class="line">　　　　var target = ev.target || ev.srcElement;</span><br><span class="line">　　　　<span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;</span><br><span class="line">　 　　　　　　  alert(123);</span><br><span class="line">　　　　　　　  alert(target.innerHTML);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！</p><p>　　上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"add"</span> value=<span class="string">"添加"</span> /&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"remove"</span> value=<span class="string">"删除"</span> /&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"move"</span> value=<span class="string">"移动"</span> /&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"select"</span> value=<span class="string">"选择"</span> /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var Add = document.getElementById(<span class="string">"add"</span>);</span><br><span class="line">    var Remove = document.getElementById(<span class="string">"remove"</span>);</span><br><span class="line">    var Move = document.getElementById(<span class="string">"move"</span>);</span><br><span class="line">    var Select = document.getElementById(<span class="string">"select"</span>);</span><br><span class="line">    </span><br><span class="line">    Add.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">'添加'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Remove.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">'删除'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Move.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">'移动'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Select.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">'选择'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　上面实现的效果我就不多说了，很简单，4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  var oBox = document.getElementById(<span class="string">"box"</span>);</span><br><span class="line">  oBox.onclick = <span class="keyword">function</span> (ev) &#123;</span><br><span class="line">    var ev = ev || window.event;</span><br><span class="line">    var target = ev.target || ev.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName.toLocaleLowerCase() == <span class="string">'input'</span>)&#123;</span><br><span class="line">      switch(target.id)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'add'</span> :</span><br><span class="line">          alert(<span class="string">'添加'</span>);</span><br><span class="line">          <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'remove'</span> :</span><br><span class="line">          alert(<span class="string">'删除'</span>);</span><br><span class="line">          <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'move'</span> :</span><br><span class="line">          alert(<span class="string">'移动'</span>);</span><br><span class="line">          <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'select'</span> :</span><br><span class="line">          alert(<span class="string">'选择'</span>);</span><br><span class="line">          <span class="built_in">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> name=<span class="string">""</span> id=<span class="string">"btn"</span> value=<span class="string">"添加"</span> /&gt;</span><br><span class="line">&lt;ul id=<span class="string">"ul1"</span>&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  var oBtn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">  var oUl = document.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">  var aLi = oUl.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line">  var num = 4;</span><br><span class="line">  </span><br><span class="line">  //事件委托，添加的子元素也有事件</span><br><span class="line">  oUl.onmouseover = <span class="keyword">function</span>(ev)&#123;</span><br><span class="line">    var ev = ev || window.event;</span><br><span class="line">    var target = ev.target || ev.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;</span><br><span class="line">        target.style.background = <span class="string">"red"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  oUl.onmouseout = <span class="keyword">function</span>(ev)&#123;</span><br><span class="line">    var ev = ev || window.event;</span><br><span class="line">    var target = ev.target || ev.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;</span><br><span class="line">        target.style.background = <span class="string">"#fff"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  //添加新节点</span><br><span class="line">  oBtn.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    num++;</span><br><span class="line">    var oLi = document.createElement(<span class="string">'li'</span>);</span><br><span class="line">    oLi.innerHTML = 111*num;</span><br><span class="line">    oUl.appendChild(oLi);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>面试题详解</title>
    <link href="http://yoursite.com/2019/04/07/JavaScript/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/04/07/JavaScript/面试题详解/</id>
    <published>2019-04-07T09:52:09.000Z</published>
    <updated>2019-04-14T12:45:13.323Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>闭包<br><a href="https://alittlelittlestar.github.io/2019/04/02/JavaScript/作用域和闭包/" target="_blank" rel="noopener">闭包</a><br>作用域 this<br>声明提升(变量提升)<br><a href="https://alittlelittlestar.github.io/2019/03/27/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">声明提升</a><br>盒模型<br><a href="https://alittlelittlestar.github.io/2018/11/06/CSS3/盒子模型/" target="_blank" rel="noopener">盒模型</a><br>布局(all) flex 圣杯布局(JS实现左右高度为窗口高度)+ 双飞翼布局<br><a href="https://alittlelittlestar.github.io/2019/02/15/页面布局/CSS布局/" target="_blank" rel="noopener">布局</a></p><p>get post<br>JS 跨域<br>HTTP状态码<br><a href="https://alittlelittlestar.github.io/2018/10/10/HTTP/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81/" target="_blank" rel="noopener">HTTP状态码</a><br>position </p><p>垂直居中 定宽 不定宽<br>css布局 浮动<br>HTTP协议<br>absolute &amp;&amp; relative 区别</p><p>块级元素&amp;&amp;行内元素<br>代理事件的原理<br>JS promise原理及实现<br>float<br>手撕promise （解决回调地狱回调代码难以维护的问题）<br>js数组类型<br>instanceof<br><a href="https://juejin.im/post/5b0b9b9051882515773ae714" target="_blank" rel="noopener">浅谈 instanceof 和 typeof 的实现原理</a><br>settimeout 、 setinterval<br><a href="https://www.jianshu.com/p/3e482748369d" target="_blank" rel="noopener">彻底理解setTimeout()</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settimeout</span></span><br><span class="line">settimeout(callback, time)</span><br><span class="line"></span><br><span class="line"><span class="comment"># setinterval</span></span><br><span class="line">setinterval(callback, time)</span><br><span class="line"></span><br><span class="line">setTimeout含义是定时器，到达一定的时间触发一次，</span><br><span class="line">但是setInterval含义是计时器，到达一定时间触发一</span><br><span class="line">次，并且会持续触发</span><br></pre></td></tr></table></figure></p><p>伪元素/伪类的区别<br><a href="http://localhost:4000/2018/11/16/CSS3/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/" target="_blank" rel="noopener">伪元素/伪类的区别</a><br>form表单当前页面无刷新提交(target iframe)<br><a href="https://www.cnblogs.com/chongyao/p/7298986.html" target="_blank" rel="noopener">form表单提交方式</a><br>表单可实现无刷新页面提交，无需页面跳转，如下，通过一个隐藏的iframe实现，form表单的target设置为iframe的name名称，<br>form提交目标位当前页面iframe则不会刷新页面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"/url.do"</span> method=<span class="string">"post"</span> target=<span class="string">"targetIfr"</span>&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span>/&gt;</span><br><span class="line">&lt;/form&gt;   </span><br><span class="line">&lt;iframe name=<span class="string">"targetIfr"</span> style=<span class="string">"display:none"</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p><p>清除浮动 原理(使用clear:both 会把浮动元素的边界拉下来到标准流，从而把对应标准流的位置撑开)<br><a href="https://alittlelittlestar.github.io/2018/10/10/CSS3/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/" target="_blank" rel="noopener">清除浮动</a><br>deBounce 防抖 实现<br><a href="https://juejin.im/post/5a0b10726fb9a044fc444311" target="_blank" rel="noopener"></a><br><a href="https://juejin.im/post/5b5e724af265da0f4d0d88b2" target="_blank" rel="noopener"></a><br>http &amp;&amp; https  ssl 证书验证 加密算法<br>ES6、ES7 新特性<br>JS ES6<br>let const class声明类 promise 模板字符串 对象数组 解构赋值 箭头函数(this指向外层作用域)<br>队列里的优先级问题<br>（微任务(promise)宏任务(xhr请求、settimeout、setInterval)）当前同步操作完成后优先执行微任务队列任务<br>前端性能优化<br>xss<br>http 协议 header 缓存：（强缓存、协商缓存）<br>margin 坍塌， 水平方向会不会坍塌</p><hr><p>1、当两个对象为上下关系时，而且都具备margin属性时，上面的margin-bottom与下面的margin-top会发生塌陷<br>　　当margin-bottom和margin都为正数时，结果为两者之间的最大值<br>　　当margin-bottom和margin-top都为负时，结果为两者绝对最较大的那个值。<br>　　当margin-bottom和margin-top为一正一负时，结果为两者之和。<br>2、当两个对象为上下包含关系<br>　　父元素无填充内容，且没有设置border时，子元素的margin-top不会起作用<br>　　父元素设置border属性，子元素的margin-top起作用<br>　　父元素有填充内容，子元素的margin-top会起作用，当margin-top小于填充内容时，距离为填充内容的高度<br>　　<br>CSS及浏览器的设计者们希望我们在布局时，如果遇到上下两个并排内容块的安排，最好只设置其中每个块上或下margin的一处即可。</p><p>但对于父块DIV内含子块DIV的情况，就会按另一条CSS惯例来解释了，那就是：对于有块级子元素的元素计算高度的方式,如果元素没有垂直边框和填充,那其高度就是其子元素顶部和底部边框边缘之间的距离。<br>解决父元素塌陷的方法有，（应该给父类元素添加BFC）<br>1、为父元素添加overflow:hidden;<br>2、为父元素float非none属性，也可为子元素添加float非none属性<br>3、需要给父div设置：边框，当然可以设置边框为透明;<br>4、为父DIV添加padding，或者至少添加padding-top;<br>5，如果遇到上下两个并排内容块的安排，最好只设置其中每个块上或下margin的一处即可。</p><hr><p>如何判断一个数组/data<br><code>instanceof、typeof、 constructor、 Object.prototype.toSting.call()</code></p><p>三栏布局 float position flex<br>float 布局对后续元素的影响</p><p>数组去重<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">双重循环去重</span><br><span class="line">indexOf</span><br><span class="line">排序后去重(存疑)</span><br><span class="line">利用对象属性</span><br><span class="line">Set去重(<span class="built_in">return</span> [...new Set(arr)])</span><br><span class="line">Set和from(Array.from(new Set(arr)))</span><br></pre></td></tr></table></figure></p><p>链接<br><a href="https://juejin.im/post/5aed6110518825671b026bed#heading-3" target="_blank" rel="noopener">1</a><br><a href="https://juejin.im/post/5949d85f61ff4b006c0de98b#heading-8" target="_blank" rel="noopener">2</a><br><a href="https://juejin.im/post/5b0284ac51882542ad774c45" target="_blank" rel="noopener">3</a></p><p>原型链<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](https://juejin.im/post/5835853f570c35005e413b19<span class="comment">#heading-0)</span></span><br></pre></td></tr></table></figure></p><p>面向对象<br>哪些数组方法不能改变数组本身(concat、slice)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">改变原始数组的操作方法：</span><br><span class="line">不会改变原始数组的操作方法：</span><br></pre></td></tr></table></figure></p><p>选择器标签</p><p>判断一个变量是整数<br>数组去重 set for循环实现数组reduce<br>字符串数组操作方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[javascript 下常用的字符串操作](http://f10.moe/2014/10/15/javascript-%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/)</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">charAt()</span><br><span class="line">charCodeAt()</span><br><span class="line">fromCharCode()</span><br><span class="line">concat()</span><br><span class="line">indexOf()</span><br><span class="line">lastIndexOf()</span><br><span class="line">match()</span><br><span class="line">replace()</span><br><span class="line">search()</span><br><span class="line">slice()</span><br><span class="line">split()</span><br></pre></td></tr></table></figure><p>设计模式<br>MVC mvvm<br><a href="https://www.jianshu.com/p/fc1f75df5440" target="_blank" rel="noopener">简书</a><br><a href="https://juejin.im/post/593021272f301e0058273468" target="_blank" rel="noopener">掘金</a></p><p>原生js 封装 ajax 方法 get 、 post</p><p>Vue watch computed nexttick<br>双向绑定 虚拟dom<br>Vue双向绑定原理/组件通讯<br>Vue 单双向绑定（dep watcher observer）</p><p>数组和链表的数据结构的区别<br>underscore once 实现方法<br>框架选择<br>如何避免多重回调 promise，如何在外部进行resolve()<br>express 中间件<br>数据结构<br>算法<br>栈模拟队列<br>二分插入进数组<br>选择框实现原理<br>异步执行的原理<br>IE兼容<br>继承方法<br>原生 js实现jsonp跨域、深度克隆、模板引擎、正则表达式</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>浏览器兼容性</title>
    <link href="http://yoursite.com/2019/04/05/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/05/前端性能优化/浏览器兼容性/</id>
    <published>2019-04-05T11:46:31.000Z</published>
    <updated>2019-04-09T06:26:53.382Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://juejin.im/post/5b3da006e51d4518f140edb2#heading-5" target="_blank" rel="noopener">如何机智地回答浏览器兼容性问题</a></p><h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><p>　　浏览器的兼容性无非还是<code>样式兼容性（css）</code>，<code>交互兼容性（javascript）</code>，<code>浏览器 hack</code>三个方面。</p><h4 id="样式兼容-CSS-方面"><a href="#样式兼容-CSS-方面" class="headerlink" title="样式兼容(CSS)方面"></a>样式兼容(CSS)方面</h4><p>　　1、因为历史原因，不同的浏览器样式存在差异，可以通过 Normalize.css 抹平差异，也可以定制自己的 reset.css，例如通过通配符选择器，全局重置样式:<code>* { margin: 0; padding: 0; }</code><br>　　2、在CSS3还没有成为真正的标准时，浏览器厂商就开始支持这些属性的使用了。CSS3样式语法还存在波动时，浏览器厂商提供了针对浏览器的前缀，直到现在还是有部分的属性需要加上浏览器前缀。在开发过程中我们一般通过IDE开发插件、css 预处理器以及前端自动化构建工程帮我们处理。<br>浏览器内核与前缀的对应关系如下:</p><table><thead><tr><th>内核</th><th>主要代表的浏览器</th><th>前缀</th></tr></thead><tbody><tr><td>Trident</td><td>IE浏览器</td><td>-ms</td></tr><tr><td>Gecko</td><td>Firefox</td><td>-moz</td></tr><tr><td>Presto</td><td>Opera</td><td>-o</td></tr><tr><td>Webkit</td><td>Chrome(blink)、Safari</td><td>-webkit</td></tr></tbody></table><p>　　3、在还原设计稿的时候我们常常会需要用到透明属性，所以解决 IE9 以下浏览器不能使用 opacity。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opacity: 0.5;</span><br><span class="line">//IE6-IE8我们习惯使用filter滤镜属性来进行实现</span><br><span class="line">filter: alpha(opacity = 50); </span><br><span class="line">//IE4-IE9都支持滤镜写法progid:DXImageTransform.Microsoft.Alpha(Opacity=xx)</span><br><span class="line">filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50);</span><br></pre></td></tr></table></figure></p><h4 id="交互兼容-javascript"><a href="#交互兼容-javascript" class="headerlink" title="交互兼容(javascript)"></a>交互兼容(javascript)</h4><p>　　1、事件兼容的问题，我们通常需要会封装一个适配器的方法，过滤事件句柄绑定、移除、冒泡阻止以及默认事件行为处理<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var  helper = &#123;&#125;</span><br><span class="line">//绑定事件</span><br><span class="line">helper.on = <span class="keyword">function</span>(target, <span class="built_in">type</span>, handler) &#123;</span><br><span class="line"> <span class="keyword">if</span>(target.addEventListener) &#123;</span><br><span class="line">   target.addEventListener(<span class="built_in">type</span>, handler, <span class="literal">false</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   target.attachEvent(<span class="string">"on"</span> + <span class="built_in">type</span>,</span><br><span class="line">     <span class="keyword">function</span>(event) &#123;</span><br><span class="line">       <span class="built_in">return</span> handler.call(target, event);</span><br><span class="line">       &#125;, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//取消事件监听</span><br><span class="line">helper.remove = <span class="keyword">function</span>(target, <span class="built_in">type</span>, handler) &#123;</span><br><span class="line"> <span class="keyword">if</span>(target.removeEventListener) &#123;</span><br><span class="line">   target.removeEventListener(<span class="built_in">type</span>, handler);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   target.detachEvent(<span class="string">"on"</span> + <span class="built_in">type</span>,</span><br><span class="line">     <span class="keyword">function</span>(event) &#123;</span><br><span class="line">     <span class="built_in">return</span> handler.call(target, event);</span><br><span class="line">   &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>　　2、<code>new Date()</code>构造函数使用，’2018-07-05’是无法被各个浏览器中，使用<code>new Date(str)</code>来正确生成日期对象的。 正确的用法是’2018/07/05’.<br>　　3、获取 scrollTop 通过 <code>document.documentElement.scrollTop</code> 兼容非chrome浏览器<br><code>var scrollTop = document.documentElement.scrollTop||document.body.scrollTop;</code></p><h4 id="浏览器-hack-CSS-hack"><a href="#浏览器-hack-CSS-hack" class="headerlink" title="浏览器 hack(CSS hack)"></a>浏览器 hack(CSS hack)</h4><p>　　由于不同厂商的流览器或某浏览器的不同版本（如<code>IE6-IE11</code>,<code>Firefox/Safari/Opera/Chrome</code>等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack!<br>　　1、快速判断 IE 浏览器版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[<span class="keyword">if</span> IE 8]&gt; ie8 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[<span class="keyword">if</span> IE 9]&gt; 骚气的 ie9 浏览器 &lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></p><p>　　2、判断是否是 Safari 浏览器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Safari */</span><br><span class="line">var isSafari = /a/.__proto__==<span class="string">'//'</span>;</span><br></pre></td></tr></table></figure></p><p>　　3、判断是否是 Chrome 浏览器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Chrome */</span><br><span class="line">var isChrome = Boolean(window.chrome);</span><br></pre></td></tr></table></figure></p><p>关于 浏览器hack:<br>　　英文：<a href="http://browserhacks.com/" target="_blank" rel="noopener">BROWSERHACKS</a><br>　　中文：<a href="https://www.w3cplus.com/css/browser-hacks.html" target="_blank" rel="noopener">主流浏览器的Hack写法</a><br>　　<a href="https://blog.csdn.net/freshlover/article/details/12132801" target="_blank" rel="noopener">史上最全的CSS hack方式一览</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ES6新特性</title>
    <link href="http://yoursite.com/2019/04/05/JavaScript/ES6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/05/JavaScript/ES6新特性/</id>
    <published>2019-04-05T08:50:51.000Z</published>
    <updated>2019-04-15T11:41:12.367Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://juejin.im/post/5b1fd28d6fb9a01e615ed6d1" target="_blank" rel="noopener">带你一起敲敲ES6的新特性</a></p><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>1、常量(const， 不会变量提升，块级作用域，作用域内值不能改，const 对象仍然可以被改变的)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const aa = &#123;a: <span class="string">'12'</span>&#125;;</span><br><span class="line">aa.a // 12</span><br><span class="line">aa.a = <span class="string">"123456"</span>;</span><br><span class="line">console.log(aa); // a: <span class="string">'123456'</span></span><br></pre></td></tr></table></figure></p><p>2、块级作用域(let，不会变量提升)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i&lt;5; i++) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(i)    //0 1 2 3 4</span><br><span class="line">  &#125;,30)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i&lt;5; i++) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(i)   //5 5 5 5 5</span><br><span class="line">  &#125;,30)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> 关键词声明的变量不具备变量提升（hoisting）特性</span><br><span class="line"><span class="built_in">let</span> 和 const 声明只在最靠近的一个块中（花括号内）有效</span><br><span class="line">当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING</span><br><span class="line">const 在声明时必须被赋值</span><br><span class="line"><span class="built_in">let</span> const：</span><br><span class="line">块级作用域</span><br><span class="line">不可重复声明</span><br><span class="line">不存在变量提升</span><br></pre></td></tr></table></figure></p><p>　　特别要说明一点的是对于const和let都有<code>暂存死区</code>，所谓暂存死区就是:<code>如果作用域内有这样一个变量那么这个作用域内就会绑定这个变量,不会继续向上查找了,以下代码运行会报错</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const a = 1;</span><br><span class="line">&#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">  const a = 2;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure><h4 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a>结构赋值</h4><p>　　所谓解构赋值就是 声明和赋值都放到了一起<code>一般都是数组 对 数组, 对象 对 对象, 数组能够设置默认值，对象也能够设置默认值，默认值必须采用等号的方式</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [zhan, si, xl = 5] = [3, 4];</span><br><span class="line">console.log(zhan, si, xl) //3, 4, 5</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123;name, age = 23&#125; = &#123;name: <span class="string">'xl'</span>, bigAge: 24&#125;</span><br><span class="line">console.log(name, age) //xl, 23</span><br></pre></td></tr></table></figure></p><p>特别的，可能有时会有关键字的情况可以通过:的形式来更改名字，看下面代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; name, age: xl, default: d &#125; = &#123; name: <span class="string">'xlei'</span>, age: 9, default: <span class="string">'xxx'</span> &#125;;</span><br><span class="line">console.log(name, xl, d);</span><br></pre></td></tr></table></figure></p><p>来一个默认值的具体应用吧：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> ajax(&#123;</span><br><span class="line">    url = new Error(<span class="string">'url without'</span>),</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">'get'</span>,</span><br><span class="line">    data = xxx</span><br><span class="line">&#125;)&#123;</span><br><span class="line">  console.log(data, <span class="built_in">type</span>)   //&#123;a: 5&#125;, get</span><br><span class="line">&#125;</span><br><span class="line">ajax(&#123;</span><br><span class="line">    url: <span class="string">'/test'</span>,</span><br><span class="line">    data: &#123;a:5&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>1、模板字符串（拼接方便，可以换行）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本的字符串格式化。将表达式嵌入字符串中进行拼接。用<span class="variable">$&#123;&#125;</span>来界定；</span><br><span class="line">ES6反引号(``)直接搞定；</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> exe1 = <span class="string">'张三'</span></span><br><span class="line"><span class="built_in">let</span> exe2 = `我的名字是：<span class="variable">$&#123;exe1&#125;</span>`</span><br></pre></td></tr></table></figure><p>2、startWith, endWith 返回一个布尔值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> str1 = <span class="string">'www.bsym.online'</span></span><br><span class="line"><span class="built_in">let</span> str2 = <span class="string">'http://www.bsym.online'</span></span><br><span class="line">console.log(str1.startsWith(<span class="string">'http://'</span>))   //<span class="literal">false</span></span><br><span class="line">console.log(str2.startsWith(<span class="string">'http://'</span>))   //<span class="literal">true</span></span><br><span class="line">console.log(str2.endsWith(<span class="string">'online'</span>))     //<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>3、padStart, padEnd补全 – 不会删除原有内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// padStart padEnd 补全(记住只能增加，不能减少)</span><br><span class="line"><span class="built_in">let</span> str1 = <span class="string">'nihao'</span></span><br><span class="line"><span class="built_in">let</span> newStr = str1.padStart(8,<span class="string">'xl'</span>)</span><br><span class="line"><span class="built_in">let</span> newStr2 = str1.padEnd(8,<span class="string">'xl'</span>)</span><br><span class="line">console.log(newStr, newStr2)   //xlxnihao, nihaoxlx</span><br></pre></td></tr></table></figure></p><h4 id="箭头函数-解决this问题，书写起来更简单"><a href="#箭头函数-解决this问题，书写起来更简单" class="headerlink" title="箭头函数(解决this问题，书写起来更简单)"></a>箭头函数(解决this问题，书写起来更简单)</h4><p>　　传统函数内的this是定义时所在的环境，而箭头函数内的this是使用时上下文的环境。<br>　　ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =&gt;，紧接着是函数体；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不需要 <span class="keyword">function</span> 关键字来创建函数</span><br><span class="line">省略 <span class="built_in">return</span> 关键字</span><br><span class="line">继承当前上下文的 this 关键字</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var add = (a, b) =&gt; a + b;</span><br><span class="line">[1,2,3].map(x =&gt; x + 1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> aa = (arg1, arg2) =&gt; &#123;</span><br><span class="line">  console.log(arg1, arg2)</span><br><span class="line">&#125;</span><br><span class="line">aa(1, 2)   //1, 2</span><br><span class="line">;((arg1, arg2) =&gt; &#123;</span><br><span class="line">  console.log(arg1, arg2)</span><br><span class="line">&#125;)(3, 4);</span><br></pre></td></tr></table></figure><p>注意：<br>　　这里顺带提一下，像上面的<code>自执行匿名函数前后都要加分号</code>，这样既不会被坑，也不会坑别人。另外<code>不要使用箭头函数的argeuments</code><br>细节：<br>　　当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略<code>{}</code> 和 <code>return</code></p><h4 id="Spread-Rest-操作符"><a href="#Spread-Rest-操作符" class="headerlink" title="Spread / Rest 操作符"></a>Spread / Rest 操作符</h4><p><code>Spread / Rest 操作符指的是 ...，具体是 Spread 还是 Rest 需要看上下文语境。</code><br>　　当被用于迭代器中时，它是一个 Spread 操作符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(x,y,z) &#123;</span><br><span class="line">  console.log(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> arr = [1,2,3];</span><br><span class="line">foo(...arr); // 1 2 3</span><br></pre></td></tr></table></figure></p><p>　　当被用于函数传参时，是一个 Rest 操作符：当被用于函数传参时，是一个 Rest 操作符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(...args) &#123;</span><br><span class="line">  console.log(args);</span><br><span class="line">&#125;</span><br><span class="line">foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></p><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><p>1、数组的扩展运算符：将一个数组转为用逗号分隔的参数序列<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [...[1, 2, 3], ...[4, 5, 6]]</span><br><span class="line">console.log(arr)   // 1, 2, 3, 4, 5, 6</span><br><span class="line">console.log(Math.min(...arr))  // 1</span><br></pre></td></tr></table></figure></p><p>2、对象的解构赋值<br>　　对象的 Rest 解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面,注意Rest 解构赋值必须是最后一个参数，否则会报错。Rest解构赋值所在的对象，拷贝了对象obj的属性，Rest解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么Rest解构赋值拷贝的是这个值的引用，而不是这个值的副本，解构赋值不会拷贝继承自原型对象的属性<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;name: <span class="string">'xl'</span>, age: 23, say:<span class="string">'ok'</span>, eat: &#123;xl: <span class="string">'okok'</span>&#125;&#125;</span><br><span class="line">//尚未被读取的属性，分配到指定的对象上面,浅拷贝了对象obj的属性</span><br><span class="line"><span class="built_in">let</span> &#123;name, age, ...z&#125; = obj</span><br><span class="line">obj.say = <span class="string">'oo'</span></span><br><span class="line">obj.eat.xl = <span class="string">'o?o?'</span></span><br><span class="line">console.log(name, age, z)  </span><br><span class="line">//xl 23 &#123; say: <span class="string">'ok'</span>, eat: &#123; xl: <span class="string">'o?o?'</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> z = &#123;a: 3, b: 4, c:&#123;</span><br><span class="line">    eat:<span class="string">'ok'</span></span><br><span class="line">&#125;&#125;</span><br><span class="line">// 注意这个地方和直接赋值的区别 <span class="built_in">let</span> n = z; </span><br><span class="line">// 一个是浅拷贝对象属性，一个是浅拷贝对象</span><br><span class="line"><span class="built_in">let</span> n = &#123;...z&#125;</span><br><span class="line">z.a = 5</span><br><span class="line">z.c.eat = <span class="string">'ok?'</span></span><br><span class="line">console.log(n)  //&#123; a: 3, b: 4, c: &#123; eat: <span class="string">'ok?'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>　　那么要是想实现一个深拷贝，怎么实现呢？其实就是遍历属性如果属性是一个普通值就赋值，不是普通值就递归知道是普通值为止，然后赋值，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 实现深拷贝 保留继承关系 可以实现各种类型的拷贝 实现递归拷贝</span><br><span class="line">    <span class="keyword">function</span> deepClone(obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof obj !== <span class="string">'object'</span>) <span class="built_in">return</span> obj;</span><br><span class="line">        <span class="keyword">if</span> (obj == null) <span class="built_in">return</span> null;</span><br><span class="line">        <span class="keyword">if</span> (obj instanceof Date) <span class="built_in">return</span> new Date(obj);</span><br><span class="line">        <span class="keyword">if</span> (obj instanceof RegExp) <span class="built_in">return</span> new RegExp(obj);</span><br><span class="line">        <span class="built_in">let</span> o = new obj.constructor(); // 保留类的继承关系</span><br><span class="line"></span><br><span class="line">        Object.keys(obj).forEach((key, index) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(typeof (obj[key]) == <span class="string">'object'</span>)&#123;</span><br><span class="line">                o[key] = deepClone(obj[key])</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                // console.log(obj[key])</span><br><span class="line">                o[key] = obj[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> o = &#123; a: &#123; a: 1 &#125;, b: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(this.a)</span><br><span class="line">    &#125; &#125;</span><br><span class="line">    <span class="built_in">let</span> newObj = deepClone(o);</span><br><span class="line">    o.a.a = 2;</span><br><span class="line">    console.log( newObj.b());</span><br></pre></td></tr></table></figure></p><h4 id="数组常用方式"><a href="#数组常用方式" class="headerlink" title="数组常用方式"></a>数组常用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// (1)map返回值 返回值是一个新数组</span><br><span class="line">    Array.prototype.map = <span class="keyword">function</span> (fn) &#123;</span><br><span class="line">        <span class="built_in">let</span> arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">            arr.push(fn(this[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> arr;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">let</span> arr = [1, 2, 3].map(item =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> item * 2;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(arr);</span><br><span class="line">    // (2)filter 过滤 如果返回<span class="literal">true</span>表示留下 返回<span class="literal">false</span>表示删除</span><br><span class="line">    <span class="built_in">let</span> arr = [1, 2, 3];</span><br><span class="line">    <span class="built_in">let</span> filterArr = arr.filter(item =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> item &gt; 2;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(filterArr);</span><br><span class="line">    // (3)some找到后返回<span class="literal">true</span>,找<span class="literal">false</span>可以用every </span><br><span class="line">    <span class="built_in">let</span> r = [2, 1, 3].some(item =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> item &gt; 2;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(r);  //<span class="literal">true</span></span><br><span class="line">    // (4)every 检测数组 ages 的所有元素是否都符合条件 :</span><br><span class="line"></span><br><span class="line">    var ages = [2, 1, 3];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> r = ages.every((item) =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> item &gt; 2</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(r)  //<span class="literal">false</span></span><br><span class="line">    // (5)Array.from();   将类数组转为数组</span><br></pre></td></tr></table></figure><h4 id="ES6的Class"><a href="#ES6的Class" class="headerlink" title="ES6的Class"></a>ES6的Class</h4><p>先复习一下es5中的几个名词：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">成员属性（方法）| 实例属性（方法） ：在构造函数中通过this.属性声明的</span><br><span class="line">静态属性（方法）：通过类来声明的 类.xxx</span><br><span class="line">私有属性（方法）：只有在类的内部可以使用，其他任何地方都不可以使用的</span><br><span class="line">公有属性（方法）|原型属性（方法）：在原型上声明的属性或者方法 xx.prototype.xxx</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Parent(name) &#123;</span><br><span class="line">  this.name = name; //成员属性|实例属性</span><br><span class="line">  this.say = <span class="function"><span class="title">function</span></span>() &#123;   //成员方法</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//静态属性</span><br><span class="line">Parent.smoking = <span class="string">'no'</span></span><br><span class="line">//公有方法|原型方法</span><br><span class="line">Parent.prototype.up = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来说说es6中的class(es6中不考虑私有属性和方法):<br>ES6 中支持 class 语法，不过，ES6的class不是新的对象继承模型，它只是原型链的语法糖表现形式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    constructor(x, y)&#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        //成员属性|实例属性  可遍历 打印实例可直接打印出来, </span><br><span class="line">        // 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），</span><br><span class="line">        // 否则都是定义在原型上（即定义在class上）。</span><br><span class="line">        this.y = y;</span><br><span class="line">        //如果不返回 默认返回实例对象 this</span><br><span class="line">        <span class="built_in">return</span> this.x </span><br><span class="line">    &#125;</span><br><span class="line">    static <span class="function"><span class="title">b</span></span>()&#123; // 属于类上的方法 也称静态方法</span><br><span class="line">        <span class="built_in">return</span> 2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span></span>()&#123;</span><br><span class="line">      //原型上的方法 | 公有方法 并且都是不可枚举的 </span><br><span class="line">      // 打印实例不能显示的打印出来 </span><br><span class="line">      console.log(this.x);</span><br><span class="line">      <span class="built_in">return</span> this.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent&#123; // </span><br><span class="line">    constructor(x, y, z)&#123;</span><br><span class="line">        // Parent.call(this);返回的是子类的实例，</span><br><span class="line">        super(x, y); </span><br><span class="line">        this.age = z; // 成员属性|实例属性</span><br><span class="line">    &#125;</span><br><span class="line">    static <span class="function"><span class="title">a</span></span>()&#123; // 属于类上的方法</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">smoking</span></span>()&#123; // 原型上的方法</span><br><span class="line">        <span class="built_in">return</span> super.eat() + this.age</span><br><span class="line">        //需要说明的是 super不仅可以调用父类的原型方法</span><br><span class="line">        // 还可以调用父类的静态方法，方法内部的this指向当前的子类，</span><br><span class="line">        // 而不是子类的实例</span><br><span class="line">        // console.log(this.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> child = new Child(2, 3, 4);</span><br><span class="line">// console.log(child);</span><br><span class="line">console.log(child.smoking())</span><br><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    //constructor函数默认返回this,</span><br><span class="line">    //这里返回一个全新的对象，结果导致实例对象不是Foo类的实例</span><br><span class="line">    <span class="built_in">return</span> Object.create(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Foo() instanceof Foo</span><br><span class="line">// <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">//定义类</span><br><span class="line">class Point &#123;</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">        this.x = x;        </span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var point = new Point(2, 3);</span><br><span class="line">console.log(point)</span><br><span class="line">point.toString() // (2, 3)</span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(<span class="string">'x'</span>) // <span class="literal">true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'y'</span>) // <span class="literal">true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'toString'</span>) // <span class="literal">false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">'toString'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A // <span class="literal">true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h4 id="迭代器-Iterators"><a href="#迭代器-Iterators" class="headerlink" title="迭代器(Iterators)"></a>迭代器(Iterators)</h4><h4 id="生成器-Generators"><a href="#生成器-Generators" class="headerlink" title="生成器(Generators)"></a>生成器(Generators)</h4><h4 id="对象和数组解构"><a href="#对象和数组解构" class="headerlink" title="对象和数组解构"></a>对象和数组解构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 对象</span><br><span class="line">const student = &#123;</span><br><span class="line">    name: <span class="string">'Sam'</span>,</span><br><span class="line">    age: 22,</span><br><span class="line">    sex: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line">// 数组</span><br><span class="line">// const student = [<span class="string">'Sam'</span>, 22, <span class="string">'男'</span>];</span><br><span class="line"></span><br><span class="line">// ES5；</span><br><span class="line">const name = student.name;</span><br><span class="line">const age = student.age;</span><br><span class="line">const sex = student.sex;</span><br><span class="line">console.log(name + <span class="string">' --- '</span> + age + <span class="string">' --- '</span> + sex);</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">const &#123; name, age, sex &#125; = student;</span><br><span class="line">console.log(name + <span class="string">' --- '</span> + age + <span class="string">' --- '</span> + sex);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>常见的设计模式</title>
    <link href="http://yoursite.com/2019/04/05/JavaScript/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/05/JavaScript/常见的设计模式/</id>
    <published>2019-04-05T03:21:41.000Z</published>
    <updated>2019-04-05T07:45:20.496Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://www.cnblogs.com/smlp/p/9776789.html" target="_blank" rel="noopener">前端常用的设计模式</a><br>　　<a href="https://juejin.im/entry/5816e545570c3500607205f1" target="_blank" rel="noopener">常用的 JavaScript 设计模式</a></p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>　　设计模式（<code>Design pattern</code>）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。<br>　　使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p><h4 id="工程模式"><a href="#工程模式" class="headerlink" title="工程模式"></a>工程模式</h4><p>　　定义： 将其成员对象的实例化推迟到子类来实现的类<br>　　需求： 创建对象的流程赋值的时候，比如依赖很多设置文件等；处理大量具有相同属性的小对象，注：不能滥用<br>　　优点： 不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中<br>　　缺点： 当工厂增加到一定程度的时候，提升了代码的复杂度，可读性下降。而且没有解决对象的识别问题，即怎么知道一个对象的类型。</p><h5 id="简单工厂模式-创建单一对象，需要的类比较少"><a href="#简单工厂模式-创建单一对象，需要的类比较少" class="headerlink" title="简单工厂模式(创建单一对象，需要的类比较少)"></a>简单工厂模式(创建单一对象，需要的类比较少)</h5><p>　　使用一个类，通常为单体，来生成实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> UserFactory = <span class="keyword">function</span> (role) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">SuperAdmin</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"超级管理员"</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>, <span class="string">'应用数据'</span>, <span class="string">'权限管理'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">Admin</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"管理员"</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>, <span class="string">'应用数据'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">NormalUser</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">'普通用户'</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  switch (role) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'superAdmin'</span>:</span><br><span class="line">      <span class="built_in">return</span> new SuperAdmin();</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'admin'</span>:</span><br><span class="line">      <span class="built_in">return</span> new Admin();</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'user'</span>:</span><br><span class="line">      <span class="built_in">return</span> new NormalUser();</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    default:</span><br><span class="line">      throw new Error(<span class="string">'参数错误, 可选参数:superAdmin、admin、user'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="工厂方法模式-创建多类对象，需要的类比较多"><a href="#工厂方法模式-创建多类对象，需要的类比较多" class="headerlink" title="工厂方法模式(创建多类对象，需要的类比较多)"></a>工厂方法模式(创建多类对象，需要的类比较多)</h5><p>　　为方便后续新增类方便，只需改一处代码，封装了工厂方法而已。并且把类都放在工厂类原型中实现。<br>　　将其成员对象的实列化推到子类中，子类可以<code>重写</code>父类接口方法以便创建的时候指定自己的对象类型。<br>　　父类只对创建过程中的一般性问题进行处理，这些处理<code>会被子类继承，子类之间是相互独立的</code>，具体的业务逻辑会放在子类中进行编写。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//安全模式创建的工厂方法函数</span><br><span class="line"><span class="built_in">let</span> UserFactory = <span class="keyword">function</span>(role) &#123;</span><br><span class="line">  <span class="keyword">if</span>(this instanceof UserFactory) &#123;</span><br><span class="line">    var s = new this[role]();</span><br><span class="line">    <span class="built_in">return</span> s;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> new UserFactory(role);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂方法函数的原型中设置所有对象的构造函数</span><br><span class="line">UserFactory.prototype = &#123;</span><br><span class="line">  SuperAdmin: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"超级管理员"</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>, <span class="string">'应用数据'</span>, <span class="string">'权限管理'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  Admin: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"管理员"</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>, <span class="string">'应用数据'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  NormalUser: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">'普通用户'</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line"><span class="built_in">let</span> superAdmin = UserFactory(<span class="string">'SuperAdmin'</span>);</span><br><span class="line"><span class="built_in">let</span> admin = UserFactory(<span class="string">'Admin'</span>) </span><br><span class="line"><span class="built_in">let</span> normalUser = UserFactory(<span class="string">'NormalUser'</span>)</span><br></pre></td></tr></table></figure></p><h5 id="抽象工厂模式-创建父类，子类继承父类，具体实现在子类"><a href="#抽象工厂模式-创建父类，子类继承父类，具体实现在子类" class="headerlink" title="抽象工厂模式(创建父类，子类继承父类，具体实现在子类)"></a>抽象工厂模式(创建父类，子类继承父类，具体实现在子类)</h5><p>　　抽象工厂其实是实现子类继承父类的方法，只是一个方法。<br>　　抽象工厂模式一般用在多人协作的超大型项目中，并且严格的要求项目以面向对象的思想进行完成。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 抽象工厂方法</span><br><span class="line">var VehicleFatory = <span class="keyword">function</span>(subType, superType) &#123;</span><br><span class="line">    // 判断抽象工厂中是否有该抽象类</span><br><span class="line">    <span class="keyword">if</span>(typeof VehicleFactory[superType] === <span class="string">'function'</span>) &#123;</span><br><span class="line">        // 缓存类</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;&#125;;</span><br><span class="line">        // 继承父类属性和方法</span><br><span class="line">        F.prototype = new VehicleFactory[superType] ();</span><br><span class="line">        // 将子类constructor 指向子类</span><br><span class="line">        subType.constructor = subType;</span><br><span class="line">        // 子类原型继承<span class="string">'父类'</span></span><br><span class="line">        subType.prototype = new F();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // 不存在该抽象类抛出错误</span><br><span class="line">        throw new Error(<span class="string">'未创建该抽象类'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 小汽车抽象类</span><br><span class="line">VehicleFactory.Car = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.type = <span class="string">'car'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">VehicleFactory.Car.prototype = &#123;</span><br><span class="line">    getPrice: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;,</span><br><span class="line">    getSpeed: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 公交车抽象类</span><br><span class="line">VehicleFactory.Bus = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.type = <span class="string">'bus'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">VehicleFactory.Bus.prototype = &#123;</span><br><span class="line">    getPrice: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;,</span><br><span class="line">    getSpeed: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 货车抽象类</span><br><span class="line">VehicleFactory.Truck = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.type = <span class="string">'truck'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">VehicleFactory.Truck.prototype = &#123;</span><br><span class="line">    getPrice: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;,</span><br><span class="line">    getSpeed: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 创建产品子类继承相应的产品簇抽象类</span><br><span class="line">// 宝马汽车子类</span><br><span class="line">var BMW = <span class="keyword">function</span>(price, speed) &#123;</span><br><span class="line">    this.price = price;</span><br><span class="line">    this.speed = speed;</span><br><span class="line">&#125;</span><br><span class="line">//抽象工厂实现对Car抽象类的继承</span><br><span class="line">VehicleFactory(BMW, <span class="string">'Car'</span>);</span><br><span class="line">BMW.prototype.getPrice = <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> this.price &#125;;</span><br><span class="line">BMW.prototype.getSpeed = <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> this.speed &#125;;</span><br><span class="line"></span><br><span class="line">// 公交车...</span><br><span class="line">// 货车...</span><br></pre></td></tr></table></figure></p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>　　定义：是保证一个类只有一个实例，并且提供一个访问它的全局访问点。<br>　　需求：一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象、登录浮窗等。<br>　　实现：用一个变量标识当前是否已经为某个类创建过对象，如果是，则在下一次获取这个类的实例时，直接返回之前创建的对象。<br>　　优点：<br>　　　　<code>可以用来划分命名空间，减少全局变量的数量</code><br>　　　　<code>可以被实例化，且实例化一次，再次实例化生成的也是第一个实例</code></p><h5 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 单例模式</span><br><span class="line">var Singleton = <span class="keyword">function</span>(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.instance = null;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> this.name;</span><br><span class="line">&#125;;</span><br><span class="line">// 获取实例对象</span><br><span class="line">Singleton.getInstance = <span class="keyword">function</span>(name) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!this.instance) &#123;</span><br><span class="line">        this.instance = new Singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> this.instance;</span><br><span class="line">&#125;;</span><br><span class="line">// 测试单例模式的实例</span><br><span class="line">var a = Singleton.getInstance(<span class="string">"aa"</span>);</span><br><span class="line">var b = Singleton.getInstance(<span class="string">"bb"</span>);</span><br><span class="line"></span><br><span class="line">console.log(a===b)    // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="实践例子"><a href="#实践例子" class="headerlink" title="实践例子"></a>实践例子</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    //管理单例的逻辑代码，如果没有数据则创建，有数据则返回</span><br><span class="line">   var getSingle = <span class="keyword">function</span>(fn)&#123; //参数为创建对象的方法</span><br><span class="line">       var result;</span><br><span class="line">       <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123; //判断是Null或赋值</span><br><span class="line">           <span class="built_in">return</span> result || (result = fn.apply(this,arguments));</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;;</span><br><span class="line">    //创建登录窗口方法</span><br><span class="line">    var createLoginLayer = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var div = document.createElement(<span class="string">'div'</span>);</span><br><span class="line">        div.innerHTML = <span class="string">'我是登录浮窗'</span>;</span><br><span class="line">        div.style.display = <span class="string">'none'</span>;</span><br><span class="line">        document.body.appendChild(div);</span><br><span class="line">        <span class="built_in">return</span> div;</span><br><span class="line">    &#125;;</span><br><span class="line">    //单例方法</span><br><span class="line">    var createSingleLoginLayer = getSingle(createLoginLayer);</span><br><span class="line"></span><br><span class="line">    //使用惰性单例，进行创建</span><br><span class="line">    document.getElementById(<span class="string">'loginBtn'</span>).onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var loginLayer = createSingleLoginLayer();</span><br><span class="line">        loginLayer.style.display = <span class="string">'block'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h4 id="观察者模式-发布-订阅模式"><a href="#观察者模式-发布-订阅模式" class="headerlink" title="观察者模式(发布-订阅模式)"></a>观察者模式(发布-订阅模式)</h4><p>　　定义：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。<br>　　需求：当一个对象的状态发生变化时，所有依赖于他的对象都将得到通知。<br>　　优点：时间上的解耦，对象之间的解耦。当我们需要维护相关对象的一致性的时候，使用观察者模式，，就可以避免对象之间的紧密耦合。例如，一个对象可以通知另外一个对象，而不需要知道这个对象的信息。<br>　　缺点：在发布/订阅模式中，如果我们需要将发布者同订阅者上解耦，将会在一些情况下，导致很难确保我们应用中的特定部分按照我们预期的那样正常工作。也就是说它的优点也可能是它的缺点<br>　　实现：<br>　　　　<code>首先，指定好谁充当发布者</code>；<br>　　　　<code>然后，给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者</code>；<br>　　　　<code>最后，发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数</code>。<br>　　　　<code>退订（比如不想再接收到这些订阅的信息了，就可以取消掉）</code></p><h5 id="基础例子-1"><a href="#基础例子-1" class="headerlink" title="基础例子"></a>基础例子</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var salesOffices = &#123;&#125;;                           // 定义售楼处</span><br><span class="line">salesOffices.clientList = [];                    // 缓存列表，存放订阅者的回调函数</span><br><span class="line">salesOffices.listen = <span class="keyword">function</span>( fn )&#123;            // 增加订阅者</span><br><span class="line">    this.clientList.push( fn );                  // 订阅的消息添加进缓存列表</span><br><span class="line">&#125;;</span><br><span class="line">salesOffices.trigger = <span class="function"><span class="title">function</span></span>()&#123;               // 发布消息</span><br><span class="line">    <span class="keyword">for</span>( var i = 0, fn; fn = this.clientList[ i++ ]; )&#123;</span><br><span class="line">        fn.apply( this, arguments );             // arguments 是发布消息时带上的参数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//调用</span><br><span class="line">salesOffices.listen( <span class="keyword">function</span>( price, squareMeter )&#123;//订阅消息</span><br><span class="line">    console.log( <span class="string">'价格= '</span> + price );</span><br><span class="line">    console.log( <span class="string">'squareMeter= '</span> + squareMeter );</span><br><span class="line">&#125;);</span><br><span class="line">salesOffices.trigger( 2000000, 88 );                // 输出：200 万，88 平方米</span><br></pre></td></tr></table></figure><h5 id="实践例子-1"><a href="#实践例子-1" class="headerlink" title="实践例子"></a>实践例子</h5><p>　　登录页面登录后，会需要刷新各个模块的信息（头像、nav）这类。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">var ObserverEvent = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        var clientList = [], listen, trigger, remove;</span><br><span class="line">        listen = <span class="keyword">function</span> (key, fn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!clientList[key]) &#123;</span><br><span class="line">                clientList[key] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            clientList[key].push(fn);</span><br><span class="line">        &#125;;</span><br><span class="line">        trigger = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            var key = Array.prototype.shift.call(arguments), fns = clientList[key];</span><br><span class="line">            <span class="keyword">if</span> (!fns || fns.length === 0) &#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (var i = 0, fn; fn = fns[i++];) &#123;</span><br><span class="line">                fn.apply(this, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        remove = <span class="keyword">function</span> (key, fn) &#123;</span><br><span class="line">            var fns = clientList[key];</span><br><span class="line">            <span class="keyword">if</span> (!fns) &#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">                fns &amp;&amp; (fns.length = 0);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (var l = fns.length - 1; l &gt;= 0; l--) &#123;</span><br><span class="line">                    var _fn = fns[l];</span><br><span class="line">                    <span class="keyword">if</span> (_fn === fn) &#123;</span><br><span class="line">                        fns.splice(l, 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            listen:listen,</span><br><span class="line">            trigger:trigger,</span><br><span class="line">            remove:remove</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    ObserverEvent.listen(<span class="string">'squareMeter88'</span>, fn1 = <span class="keyword">function</span> (price) &#123;</span><br><span class="line">        console.log(<span class="string">'价格='</span> + price);</span><br><span class="line">    &#125;);</span><br><span class="line">    ObserverEvent.listen(<span class="string">'squareMeter100'</span>, <span class="keyword">function</span> (price) &#123;</span><br><span class="line">        console.log(<span class="string">'价格='</span> + price);</span><br><span class="line">    &#125;);</span><br><span class="line">    ObserverEvent.trigger(<span class="string">'squareMeter88'</span>, 200000);</span><br><span class="line"></span><br><span class="line">//刷新模块信息</span><br><span class="line">var header = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        ObserverEvent.listen(<span class="string">'loginSucc'</span>, <span class="keyword">function</span> (data) &#123;</span><br><span class="line">            header.setAvatar(data.avatar);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            setAvatar: <span class="keyword">function</span> (data) &#123;</span><br><span class="line">                console.log(data + <span class="string">"设置header成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    var nav = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        ObserverEvent.listen(<span class="string">'loginSucc'</span>, <span class="keyword">function</span> (data) &#123;</span><br><span class="line">            nav.setAvatar(data.avatar)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            setAvatar: <span class="keyword">function</span> (data) &#123;</span><br><span class="line">                console.log(data + <span class="string">'设置nav成功'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    var data = &#123;&#125;;</span><br><span class="line">    data.avatar = <span class="string">"参数"</span>;</span><br><span class="line">    ObserverEvent.trigger(<span class="string">'loginSucc'</span>, data);</span><br></pre></td></tr></table></figure></p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>　　策略模式指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>　　代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额。<br>　　没有使用策略模式的情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Price(personType, price) &#123;</span><br><span class="line">    //vip 5 折</span><br><span class="line">    <span class="keyword">if</span> (personType == <span class="string">'vip'</span>) &#123;</span><br><span class="line">        <span class="built_in">return</span> price * 0.5;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (personType == <span class="string">'old'</span>)&#123; //老客户 3 折</span><br><span class="line">        <span class="built_in">return</span> price * 0.3;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> price; //其他都全价</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　不足之处：不好的地方，当我有其他方面的折扣时，又或者我活动的折扣时经常变化的，这样就要不断的修改if..else里面的条件了。而且也违背了设计模式的一个原则：对修改关闭，对扩展开放的原则；<br>　　使用策略模式之后：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 对于vip客户</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">vipPrice</span></span>() &#123;</span><br><span class="line">    this.discount = 0.5;</span><br><span class="line">&#125;</span><br><span class="line">vipPrice.prototype.getPrice = <span class="keyword">function</span>(price) &#123;</span><br><span class="line">　　<span class="built_in">return</span> price * this.discount;</span><br><span class="line">&#125;</span><br><span class="line">// 对于老客户</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">oldPrice</span></span>() &#123;</span><br><span class="line">    this.discount = 0.3;</span><br><span class="line">&#125;</span><br><span class="line">oldPrice.prototype.getPrice = <span class="keyword">function</span>(price) &#123;</span><br><span class="line">    <span class="built_in">return</span> price * this.discount;</span><br><span class="line">&#125;</span><br><span class="line">// 对于普通客户</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Price</span></span>() &#123;</span><br><span class="line">    this.discount = 1;</span><br><span class="line">&#125;</span><br><span class="line">Price.prototype.getPrice = <span class="keyword">function</span>(price) &#123;</span><br><span class="line">    <span class="built_in">return</span> price ;</span><br><span class="line">&#125;</span><br><span class="line">// 上下文，对于客户端的使用</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Context</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">''</span>;</span><br><span class="line">    this.strategy = null;</span><br><span class="line">    this.price = 0;</span><br><span class="line">&#125;</span><br><span class="line">Context.prototype.set = <span class="keyword">function</span>(name, strategy, price) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.strategy = strategy;</span><br><span class="line">    this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">Context.prototype.getResult = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(this.name + <span class="string">' 的结账价为: '</span> + this.strategy.getPrice(this.price));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var context = new Context();</span><br><span class="line">var vip = new vipPrice();</span><br><span class="line">context.set (<span class="string">'vip客户'</span>, vip, 200);</span><br><span class="line">context.getResult();   // vip客户 的结账价为: 100</span><br><span class="line"></span><br><span class="line">var old = new oldPrice();</span><br><span class="line">context.set (<span class="string">'老客户'</span>, old, 200);</span><br><span class="line">context.getResult();  // 老客户 的结账价为: 60</span><br><span class="line"></span><br><span class="line">var Price = new Price();</span><br><span class="line">context.set (<span class="string">'普通客户'</span>, Price, 200);</span><br><span class="line">context.getResult();  // 普通客户 的结账价为: 200</span><br></pre></td></tr></table></figure></p><p>　　通过策略模式，使得客户的折扣与算法解藕，又使得修改跟扩展能独立的进行，不影到客户端或其他算法的使用；</p><h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p>　　定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 通俗的讲，就是将一些公共方法封装到父类，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。</p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>　　比如前端面试，基本包括笔试，技术面试，领导面试，HR面试等，但是每个公司的笔试题，技术面可能不一样，也可能一样，一样的就继承父类的方法，不一样的就重写父类的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">var Interview = <span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">// 笔试</span><br><span class="line">Interview.prototype.writtenTest = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"这里是前端笔试题"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">// 技术面试</span><br><span class="line">Interview.prototype.technicalInterview = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"这里是技术面试"</span>);</span><br><span class="line">&#125;; </span><br><span class="line">// 领导面试</span><br><span class="line">Interview.prototype.leader = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"领导面试"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">// 领导面试</span><br><span class="line">Interview.prototype.HR = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"HR面试"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">// 等通知</span><br><span class="line">Interview.prototype.waitNotice = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"等通知啊，不知道过了没有哦"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">// 代码初始化</span><br><span class="line">Interview.prototype.init = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    this.writtenTest();</span><br><span class="line">    this.technicalInterview();</span><br><span class="line">    this.leader();</span><br><span class="line">    this.HR();</span><br><span class="line">    this.waitNotice();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 阿里巴巴的笔试和技术面不同，重写父类方法，其他继承父类方法。</span><br><span class="line">var AliInterview = <span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">AliInterview.prototype = new Interview();</span><br><span class="line"></span><br><span class="line">// 子类重写方法 实现自己的业务逻辑</span><br><span class="line">AliInterview.prototype.writtenTest = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"阿里的技术题就是难啊"</span>);</span><br><span class="line">&#125;</span><br><span class="line">AliInterview.prototype.technicalInterview = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"阿里的技术面就是叼啊"</span>);</span><br><span class="line">&#125;</span><br><span class="line">var AliInterview = new AliInterview();</span><br><span class="line">AliInterview.init();</span><br><span class="line"></span><br><span class="line">// 阿里的技术题就是难啊</span><br><span class="line">// 阿里的技术面就是叼啊</span><br><span class="line">// 领导面试</span><br><span class="line">// HR面试</span><br><span class="line">// 等通知啊，不知道过了没有哦</span><br></pre></td></tr></table></figure></p><p><strong>应用场景：</strong><br>　　模板模式主要应用在一些代码刚开要一次性实现不变的部分。但是将来页面有修改，需要更改业务逻辑的部分或者重新添加新业务的情况。主要是通过子类来改写父类的情况，其他不需要改变的部分继承父类。　　</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>概念：<br>　　代理模式的中文含义就是帮别人做事，<code>javascript</code>的解释为：把对一个对象的访问, 交给另一个代理对象来操作.<br>代码实现：<br>　　比如我们公司的补打卡是最后是要交给大boss来审批的，但是公司那么多人，每天都那么多补打卡，那大boss岂不是被这些琐事累死。所以大boss下会有一个助理，来帮忙做这个审批，最后再将每个月的补打卡统一交给大boss看看就行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 补打卡事件</span><br><span class="line">var fillOut = <span class="keyword">function</span> (lateDate) &#123;</span><br><span class="line"></span><br><span class="line">    this.lateDate = lateDate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 这是bigBoss</span><br><span class="line">var bigBoss = <span class="keyword">function</span> (fillOut) &#123;</span><br><span class="line"></span><br><span class="line">    this.state = <span class="keyword">function</span> (isSuccess) &#123;</span><br><span class="line">        console.log(<span class="string">"忘记打卡的日期为："</span> + fillOut.lateDate + <span class="string">", 补打卡状态："</span> + isSuccess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 助理代理大boss 完成补打卡审批</span><br><span class="line">var proxyAssis = <span class="keyword">function</span> (fillOut) &#123;</span><br><span class="line">    </span><br><span class="line">    this.state = <span class="keyword">function</span> (isSuccess) &#123;</span><br><span class="line">        (new bigBoss(fillOut)).state(isSuccess); // 替bigBoss审批</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 调用方法：</span><br><span class="line">var proxyAssis = new proxyAssis(new fillOut(<span class="string">"2016-9-11"</span>));</span><br><span class="line">proxyAssis.state(<span class="string">"补打卡成功"</span>);</span><br><span class="line">// 忘记打卡的日期为：2016-9-11, 补打卡状态：补打卡成功</span><br></pre></td></tr></table></figure></p><p>应用场景：<br>　　比如图片的懒加载，我们就可以运用这种技术。在图片未加载完成之前，给个loading图片，加载完成后再替换成实体路径。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var myImage = (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var imgNode = document.createElement(<span class="string">"img"</span>);</span><br><span class="line">    document.body.appendChild(imgNode);</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(src)&#123;</span><br><span class="line">        imgNode.src = src; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">// 代理模式</span><br><span class="line">var ProxyImage = (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        myImage(this.src);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(src) &#123;</span><br><span class="line">      // 占位图片loading</span><br><span class="line">      myImage(<span class="string">"http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif"</span>);</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">// 调用方式</span><br><span class="line"></span><br><span class="line">ProxyImage(<span class="string">"https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png"</span>); // 真实要展示的图片</span><br></pre></td></tr></table></figure></p><p>　　当然，这种懒加载方法不用代理模式也是可以实现的，只是用代理模式。我们可以让 myImage 只做一件事，只负责将实际图片加入到页面中，而loading图片交给ProxyImage去做。从而降低代码的耦合度。因为当我不想用loading的时候，可以直接调用myImage 方法。也即是说假如我门不需要代理对象的话，直接可以换成本体对象调用该方法即可。</p><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>　　概念：<br>　　外观模式是很常见。其实它就是通过编写一个单独的函数，来简化对一个或多个更大型的，可能更为复杂的函数的访问。也就是说可以视外观模式为一种简化某些内容的手段。<br>　　说白了，外观模式就是一个函数，封装了复杂的操作。<br>代码实现：<br>　　比如一个跨浏览器的ajax调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> ajaxCall(<span class="built_in">type</span>,url,callback,data)&#123;</span><br><span class="line">    // 根据当前浏览器获取对ajax连接对象的引用</span><br><span class="line">    var xhr=(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 所有现代浏览器所使用的标准方法</span><br><span class="line">            <span class="built_in">return</span> new XMLHttpRequest();</span><br><span class="line">        &#125;catch(e)&#123;&#125;</span><br><span class="line">        // 较老版本的internet Explorer兼容</span><br><span class="line">        try&#123;</span><br><span class="line">            <span class="built_in">return</span> new ActiveXObject(<span class="string">"Msxml2.XMLHTTP.6.0"</span>);</span><br><span class="line">        &#125;catch(e)&#123;&#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            <span class="built_in">return</span> new ActiveXObject(<span class="string">"Msxml2.XMLHTTP.3.0"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;catch(e)&#123;&#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            <span class="built_in">return</span> new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">        &#125;catch(e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        // 如果没能找到相关的ajax连接对象，则跑出一个错误。</span><br><span class="line">        throw new Error(<span class="string">"Ajax not support in this browser."</span>)</span><br><span class="line"></span><br><span class="line">    &#125;()),</span><br><span class="line">    STATE_LOADED=4,</span><br><span class="line">    STATUS_OK=200;</span><br><span class="line"></span><br><span class="line">    // 一但从服务器收到表示成功的相应消息，则执行所给定的回调方法</span><br><span class="line">    xhr.onreadystatechange=<span class="keyword">function</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState !==STATE_LOADED)&#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xhr.state==STATUS_OK)&#123;</span><br><span class="line">            callback(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用浏览器的ajax连接对象来向所给定的URL发出相关的调用</span><br><span class="line">    xhr.open(type.toUpperCase(),url);</span><br><span class="line">    xhr.send(data);</span><br><span class="line">&#125;</span><br><span class="line">// 使用方法</span><br><span class="line">ajaxCall(<span class="string">"get"</span>,<span class="string">"/user/12345"</span>,<span class="keyword">function</span>(rs)&#123;</span><br><span class="line">    alert(<span class="string">'收到的数据为：'</span>+rs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>应用场景：<br>　　当需要通过一个单独的函数或方法来访问一系列的函数或方法调用，以简化代码库的其余内容，使得代码更容易跟踪管理或者更好的维护时，可以使用外观模式。其实我们平时代码中这种模式应该是用的比较多的。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCP和UDP的区别</title>
    <link href="http://yoursite.com/2019/04/05/HTTP/TCP&amp;&amp;UDP/"/>
    <id>http://yoursite.com/2019/04/05/HTTP/TCP&amp;&amp;UDP/</id>
    <published>2019-04-05T02:25:09.000Z</published>
    <updated>2019-04-05T03:08:22.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://segmentfault.com/a/1190000018582150" target="_blank" rel="noopener">TCP和UDP比较</a></p><h3 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP/IP网络模型"></a>TCP/IP网络模型</h3><p>　　计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（<code>protocol</code>）。<br>　　<code>TCP/IP</code> 是互联网相关的各类协议族的总称，比如：<code>TCP</code>，<code>UDP</code>，<code>IP</code>，<code>FTP</code>，<code>HTTP</code>，<code>ICMP</code>，<code>SMTP</code> 等都属于 <code>TCP/IP</code> 族内的协议。<br>　　<code>TCP/IP</code>模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为<code>链路层</code>、<code>网络层</code>、<code>传输层</code>和<code>应用层</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</span><br><span class="line">网络层：负责路由以及把分组报文发送给目标网络或主机。</span><br><span class="line">传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</span><br><span class="line">应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</span><br></pre></td></tr></table></figure></p><p>详情图片:<br><img src="/assets/images/httposi.png" alt="HTPPOSI七层模型"><br>　　在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>　　当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。<br>　　TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p><h4 id="TCP连接过程"><a href="#TCP连接过程" class="headerlink" title="TCP连接过程"></a>TCP连接过程</h4><p>三次握手:<br><strong>第一次握手</strong><br>　　客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。<br><strong>第二次握手</strong><br>　　服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。<br><strong>第三次握手</strong><br>　　当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。<br>　　这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</p><h4 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h4><p>　　TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。<br><strong>第一次挥手</strong><br>　　若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。<br><strong>第二次挥手</strong><br>　　B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。<br><strong>第三次挥手</strong><br>　　B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。<br><strong>第四次挥手</strong><br>　　A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p><h4 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h4><h5 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h5><p>　　面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p><h5 id="仅支持单播传输"><a href="#仅支持单播传输" class="headerlink" title="仅支持单播传输"></a>仅支持单播传输</h5><p>　　每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><h5 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h5><p>　　TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><h5 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h5><p>　　对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p><h5 id="提供拥塞控制"><a href="#提供拥塞控制" class="headerlink" title="提供拥塞控制"></a>提供拥塞控制</h5><p>　　当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p><h5 id="TCP提供双工通信"><a href="#TCP提供双工通信" class="headerlink" title="TCP提供双工通信"></a>TCP提供双工通信</h5><p>　　TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>　　UDP协议全称是<code>用户数据报协议</code>，在网络中它与<code>TCP</code>协议一样用于处理数据包，是一种<code>无连接的协议</code>。在OSI模型中，在<code>第四层——传输层</code>，处于IP协议的上一层。<code>UDP</code>有<code>不提供数据包分组</code>、<code>组装</code>和<code>不能对数据包进行排序</code>的缺点，也就是说，<code>当报文发送之后，是无法得知其是否安全完整到达的</code>。</p><h4 id="UDP的特点"><a href="#UDP的特点" class="headerlink" title="UDP的特点"></a>UDP的特点</h4><h5 id="面向无连接"><a href="#面向无连接" class="headerlink" title="面向无连接"></a>面向无连接</h5><p>　　首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。<br>具体来说就是：<br>　　在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了<br>　　在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</p><h5 id="有单播、多播、广播的功能"><a href="#有单播、多播、广播的功能" class="headerlink" title="有单播、多播、广播的功能"></a>有单播、多播、广播的功能</h5><p>　　UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><h5 id="UDP是面向报文的"><a href="#UDP是面向报文的" class="headerlink" title="UDP是面向报文的"></a>UDP是面向报文的</h5><p>　　发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><h5 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h5><p>　　首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。<br>　　并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。<br>　　再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p><h5 id="头部开销小，传输数据报文时是很高效的。"><a href="#头部开销小，传输数据报文时是很高效的。" class="headerlink" title="头部开销小，传输数据报文时是很高效的。"></a>头部开销小，传输数据报文时是很高效的。</h5><p>UDP 头部包含了以下几个数据：<br>　　两个十六位的端口号，分别为源端口（可选字段）和目标端口<br>　　整个数据报文的长度<br>　　整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误<br>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p><h3 id="TCP和UDP的比较"><a href="#TCP和UDP的比较" class="headerlink" title="TCP和UDP的比较"></a>TCP和UDP的比较</h3><table><thead><tr><th>对比项</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>无连接</td></tr><tr><td>是否可靠</td><td>可靠传输，使用流量控制和拥塞控制</td><td>不可靠传输，不使用流量控制和拥塞控制</td></tr><tr><td>连接对象个数</td><td>只能是一对一通信</td><td>支持一对一，一对多，多对一和多对多交互通信</td></tr><tr><td>传输方式</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>首部开销</td><td>首部最小20字节，最大60字节</td><td>首部开销小，仅8字节</td></tr><tr><td>使用场景</td><td>适用于要求可靠传输的应用，例如文件传输</td><td>适用于实时应用（IP电话、视频会议、直播等）</td></tr></tbody></table><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>　　TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。<br>　　虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为<br>　　对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
</feed>
