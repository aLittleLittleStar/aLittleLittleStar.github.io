<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>昨夜小楼又东风</title>
  
  <subtitle>纵豆蔻词工，青楼好梦，难赋深情</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-26T09:31:29.509Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LittleStar</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>媒体查询</title>
    <link href="http://yoursite.com/2019/03/26/CSS3/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"/>
    <id>http://yoursite.com/2019/03/26/CSS3/媒体查询/</id>
    <published>2019-03-26T06:49:49.000Z</published>
    <updated>2019-03-26T09:31:29.509Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>css的媒体查询允许通过@media标签为特定媒体的浏览器设定样式，其中包含众多筛选，功能强大。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>　　HTML4和CSS2支持为不同的媒体类型指定专用的样式表，<code>screen</code>和<code>print</code>, <code>projection</code>是已定义的媒体类型<br>媒体查询由 媒体类型 和 一个或多个检测媒体特性的的条件表达式组成。<a id="more"></a><br>相对于CSS2只支持对媒体类型进行判断，<code>媒体查询</code>增加了<code>媒体特性</code>的判断，能够更准确地根据设备特性指定专用的样式。</p><h4 id="语法逻辑"><a href="#语法逻辑" class="headerlink" title="语法逻辑"></a>语法逻辑</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和</span></span><br><span class="line">and</span><br><span class="line"><span class="comment"># 也就是 or 的逻辑</span></span><br><span class="line">,</span><br><span class="line"><span class="comment"># 对查询结果取反</span></span><br><span class="line">not</span><br><span class="line"><span class="comment"># only操作符仅在媒体查询匹配成功的情况下被用于应用一个样式，</span></span><br><span class="line"><span class="comment"># 这对于防止让选中的样式在老式浏览器中被应用到。</span></span><br><span class="line">only</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>　　媒体查询包含一个可选的媒体类型和媒体特性表达式(0或多个)最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示文档所使用的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># link元素中的CSS媒体查询</span></span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> media=<span class="string">"(max-width: 800px)"</span> href=<span class="string">"example.css"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 样式表中的CSS媒体查询</span></span><br><span class="line">&lt;style&gt;</span><br><span class="line">@media (max-width: 600px) &#123;</span><br><span class="line">  .facet_sidebar &#123;</span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h5 id="使用媒体类型"><a href="#使用媒体类型" class="headerlink" title="使用媒体类型"></a>使用媒体类型</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> href=<span class="string">"site.css"</span> media=<span class="string">"screen"</span> /&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> href=<span class="string">"print.css"</span> media=<span class="string">"print"</span> /&gt;</span><br></pre></td></tr></table></figure><p><strong>media 属性定义了应该用于指定每种媒体类型的样式表：</strong><br>　　<code>screen</code> 适用于计算机彩色屏幕。<br>　　<code>print</code> 适用于打印预览模式下查看的内容或者打印机打印的内容。<br>　　作为 CSS v3 规范的一部分，可以扩展媒体类型函数，并允许在样式表中使用更精确的显示规则。媒体查询 是评估 True 或 False 的一种表达。如果为 True，则继续使用样式表。如果为 False，则不能使用样式表。这种简单逻辑通过表达式变得更加强大，使您能够更灵活地对特定的设计场景使用自定义的显示规则。</p><h5 id="媒体查询规则"><a href="#媒体查询规则" class="headerlink" title="媒体查询规则"></a>媒体查询规则</h5><p><code>@media all and (min-width: 800px) { ... }</code><br><code>@media all</code> 是媒体类型，也就是说，将此 <code>CSS</code> 应用于所有媒体类型<br><code>(min-width:800px)</code> 是包含媒体查询的表达式，如果浏览器的最小宽度为 800 像素，则会告诉浏览器只运用下列 <code>CSS</code>。<br><strong>请注意</strong>:可以省略关键词 <code>all</code> 和 <code>and</code>。在将某个媒体查询应用于所有媒体类型时，会省略<code>all</code>。后面的 <code>and</code> 也是可选的。使用简写语法重新编写媒体查询</p><h5 id="简写语法"><a href="#简写语法" class="headerlink" title="简写语法"></a>简写语法</h5><p><code>@media (min-width:800px) { ... }</code></p><h5 id="复杂表达式"><a href="#复杂表达式" class="headerlink" title="复杂表达式"></a>复杂表达式</h5><p>创建一个仅在最小宽度为 800 像素且最大宽度为 1200 像素时应用的样式<br><code>@media (min-width:800px) and (max-width:1200px) { ... }</code></p><h5 id="and-条件"><a href="#and-条件" class="headerlink" title="and 条件"></a>and 条件</h5><p>在您的表达式中，您可以根据自己的喜好使用任意数量的 and 条件。如果您想要增加其他条件来检查特定的屏幕方向，只需添加另一个 and 关键词，后跟 orientation 媒体查询.<br><code>@media (min-width:800px) and (max-width:1200px) and (orientation:portrait) { ... }</code><br>仅在宽度为 800 到 1200 像素且方向是纵向时才能激活.</p><h5 id="or-关键词"><a href="#or-关键词" class="headerlink" title="or 关键词"></a>or 关键词</h5><p>and 关键词的反义词是 or 关键词。和 and 一样，这些条件组合在一起会构成复杂表达式。如果其中有一个条件为 True，那么整个表达式或分离的两个条件都会为 True，如清单 6 所示。<br><code>@media (min-width:800px) or (orientation:portrait) { ... }</code><br>如果宽度至少是 800 像素或方向是纵向的，则会应用该规则。</p><h5 id="使用-not"><a href="#使用-not" class="headerlink" title="使用 not"></a>使用 not</h5><p><code>@media not all and (min-width: 800px) { ... }</code><br><code>@media not (all and (min-width: 800px)) { ... }</code><br>当最小宽度不是 800 像素时，会应用下列 CSS 规则。这些示例只是将像素作为媒体查询中的测量单位，但是测量单位并不仅限于像素。您可以使用任何有效的 CSS 测量单位，比如厘米 (cm)、英寸 (in)、毫米 (mm) 等。</p><h5 id="only"><a href="#only" class="headerlink" title="only"></a>only</h5><p><code>@media only (min-width: 300px) { ... }</code></p><h4 id="有用的媒体特性"><a href="#有用的媒体特性" class="headerlink" title="有用的媒体特性"></a>有用的媒体特性</h4><h5 id="orientation-媒体查询"><a href="#orientation-媒体查询" class="headerlink" title="orientation 媒体查询"></a>orientation 媒体查询</h5><p>方向： <code>orientation</code><br>值为：横排方向（ <code>landscape</code>）竖排方向（<code>portrait</code>）<br><code>@media (orientation: portrait) { ... }</code><br>高度和宽度行为十分相似，都支持以 min- 和 max- 为前缀</p><h5 id="高度和宽度媒体查询"><a href="#高度和宽度媒体查询" class="headerlink" title="高度和宽度媒体查询"></a>高度和宽度媒体查询</h5><p><code>@media (min-width:800px) and (min-height:400px) { ... }</code></p><h5 id="不带-min-和-max-前缀"><a href="#不带-min-和-max-前缀" class="headerlink" title="不带 min- 和 max- 前缀"></a>不带 min- 和 max- 前缀</h5><p><code>@media (width:800px) and (height:400px) { ... }</code></p><h4 id="媒体属性特征"><a href="#媒体属性特征" class="headerlink" title="媒体属性特征"></a>媒体属性特征</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前缀`min-`表示“至少”，即“大于等于”的意思。</span><br><span class="line">前缀`max-`表示“至多”，即“小于等于”的意思。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">width: 视口宽度</span><br><span class="line">height: 视口高度</span><br><span class="line">device-width: 渲染表面的高度(设备高度)</span><br><span class="line">device-height: 渲染表面的宽度(设备宽度)</span><br><span class="line">orientation: 检测设备是处于横向(landscape)还是纵向(portrait)</span><br><span class="line">aspect-ratio: 基于视口宽度和高度的宽高比</span><br><span class="line">device-aspect-ratio: 基于设备渲染表面的宽度和高度的宽高比</span><br><span class="line">color: 每种颜色的位数</span><br><span class="line">color-index: 设备的颜色索引表中的颜色数</span><br><span class="line">monochrome: 检测单色帧缓冲区中每像素所使用的位数</span><br><span class="line">resoluion: 用来检测屏幕和打印机的分辨率,dpi/dpcm</span><br><span class="line">scan: 电视机的扫描方式,逐行扫描(progressive)或隔行扫描(interlace)</span><br><span class="line">grid: 用来检测输出设备是网格设备还是位图设备</span><br></pre></td></tr></table></figure><p>参考：<br>　　<a href="https://www.ibm.com/developerworks/cn/web/wa-cssqueries/" target="_blank" rel="noopener">使用 CSS 媒体查询创建响应式网站</a><br>　　<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#-moz-device-pixel-ratio" target="_blank" rel="noopener">CSS媒体查询</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;css的媒体查询允许通过@media标签为特定媒体的浏览器设定样式，其中包含众多筛选，功能强大。&lt;/p&gt;
&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;　　HTML4和CSS2支持为不同的媒体类型指定专用的样式表，&lt;code&gt;screen&lt;/code&gt;和&lt;code&gt;print&lt;/code&gt;, &lt;code&gt;projection&lt;/code&gt;是已定义的媒体类型&lt;br&gt;媒体查询由 媒体类型 和 一个或多个检测媒体特性的的条件表达式组成。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>mate标签</title>
    <link href="http://yoursite.com/2019/03/26/H5/mate%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2019/03/26/H5/mate标签/</id>
    <published>2019-03-26T01:38:01.000Z</published>
    <updated>2019-03-26T02:34:04.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载:<br>　　<a href="https://juejin.im/post/5b94d8965188255c5a0cdc02#heading-4" target="_blank" rel="noopener">2018前端面试总结，看完弄懂，工资少说加3K | 掘金技术征文</a><br>参考:<br>　　<a href="https://www.cnblogs.com/2050/p/3877280.html" target="_blank" rel="noopener">移动前端开发之viewport的深入理解</a><br><code>&lt;mate&gt;</code>标签: 提供页面的元信息但和内容无关，元数据可以被浏览器、搜索引擎和其他web服务器使用。<a id="more"></a></p><p>mate两种属性：http-equiv和name<br>　　<code>http-equiv</code> 相当于HTTP头<br>　　<code>content-type</code> 定义文档的字符集<br>　　<code>&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</code><br>　　<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code><br>　　<code>expires</code>网页到期时间<br>　　<code>&lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri, 12 Jan 2001 18:18:18 GMT&quot;&gt;</code><br>　　<code>X-UA-Compatible</code> 浏览器采取何种版本渲染当前页面<br>　　<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;</code><br>　　指定IE和Chrome使用最新版本渲染当前页面<br>　　<code>cache-control</code> 指定请求和响应遵循的缓存机制<br>　　<code>refresh</code> 自动刷新，病指向某个页面<br>　　<code>&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2; URL=http://www.root.net&quot;&gt;</code><br>　　<code>set-cookie</code> 设置cookie<br>　　<code>&lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx; expires=Friday, 12-Jan-2001 18:18:18 GMT; path=/&quot;&gt;</code><br>　　<code>cleartype</code>只对IE有用，用于平滑字体,不推荐使用<br>　　<code>&lt;!--[if IEMobile]&gt;&lt;meta http-equiv=&quot;cleartype&quot; content=&quot;on&quot;&gt;&lt;![endif]--&gt;`</code><br><code>name</code> 描述网页<br>　　<code>author</code> 作者<br>　　<code>&lt;meta name=&quot;author&quot; content=&quot;xx@xx&quot;&gt;</code><br>　　<code>description</code> 描述，网站主要内容<br>　　<code>&lt;meta name=&quot;description&quot; content=&quot;This page is about&quot;&gt;</code><br>　　<code>keywords</code> 关键字，搜索引擎会使用这些关键字分类<br>　　<code>&lt;meta name =&quot;keywords&quot; content=&quot;science, education&quot;&gt;</code><br>　　<code>renderer</code> 双核浏览器渲染方式，指定以哪种渲染方式<br>　　<code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</code><br>　　<code>viewport</code>视口，定义设备的大小<br>　　<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</code><br>　　<code>HandheldFriendly</code>针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓<br>　　<code>&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;True&quot;&gt;</code><br>　　<code>MobileOptimized</code> 微软为IE Mobile版设置的定义宽度标记<br>　　<code>&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;</code><br>　　<code>apple-mobile-web-app-capable</code> 是否启动webapp功能（全屏），会删除默认的苹果工具栏和菜单栏。<br>　　<code>apple-mobile-web-app-capable</code><br>　　<code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</code><br>　　<code>apple-mobile-web-app-status-bar-style</code> 当启动webapp功能时，手机顶部导航栏的颜色<br>　　<code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;</code><br>　　<code>apple-mobile-web-app-title</code> 添加到主屏后的标题<br>　　<code>&lt;meta name=&quot;apple-mobile-we-app-title&quot; content=&quot;&quot;&gt;</code><br>　　<code>format-detection</code> 格式检测，识别页面中的电话号码<br>　　<code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</code><br>　　<code>format-detection</code> 格式检测，识别页面中的email<br>　　<code>&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;&gt;</code></p><p><strong>viewPort</strong><br>|属性|作用|<br>|—-|—–|<br>|width| 设置layout viewport  的宽度，为一个正整数，或字符串”width-device”|<br>|initial-scale| 设置页面的初始缩放值，为一个数字，可以带小数|<br>|minimum-scale| 允许用户的最小缩放值，为一个数字，可以带小数|<br>|maximum-scale| 允许用户的最大缩放值，为一个数字，可以带小数|<br>|height | 设置layout viewport  的高度，这个属性对我们并不重要，很少使用|<br>|user-scalable | 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许|</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># H5标准声明，使用 HTML5 doctype，不区分大小写</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="comment"># 标准的 lang 属性写法</span></span><br><span class="line">&lt;head lang=”en”&gt;</span><br><span class="line"><span class="comment"># 声明文档使用的字符编码</span></span><br><span class="line">&lt;meta charset=’utf-8′&gt;</span><br><span class="line"><span class="comment"># 优先使用 IE 最新版本和 Chrome</span></span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt;   </span><br><span class="line"><span class="comment"># 页面描述</span></span><br><span class="line">&lt;meta name=”description” content=”不超过150个字符”/&gt;</span><br><span class="line"><span class="comment"># 页面关键词</span></span><br><span class="line">&lt;meta name=”keywords” content=””/&gt;</span><br><span class="line"><span class="comment"># 网页作者</span></span><br><span class="line">&lt;meta name=”author” content=”name, email@gmail.com”/&gt;</span><br><span class="line"><span class="comment"># 搜索引擎抓取</span></span><br><span class="line">&lt;meta name=”robots” content=”index,follow”/&gt;</span><br><span class="line"><span class="comment"># 为移动设备添加 viewport</span></span><br><span class="line">&lt;meta name=”viewport” content=”initial-scale=1,</span><br><span class="line">maximum-scale=3, minimum-scale=1, user-scalable=no”&gt;</span><br><span class="line"><span class="comment"># iOS 设备 begin</span></span><br><span class="line">&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt;</span><br><span class="line"><span class="comment"># 添加到主屏后的标题（iOS 6 新增）</span></span><br><span class="line">&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt;</span><br><span class="line"><span class="comment"># 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏</span></span><br><span class="line">&lt;meta name=”apple-itunes-app” </span><br><span class="line">content=”app-id=myAppStoreID,</span><br><span class="line"> 1affiliate-data=myAffiliateData, app-argument=myURL”&gt;</span><br><span class="line"><span class="comment"># 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）</span></span><br><span class="line">&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;</span><br><span class="line"><span class="comment"># 设置苹果工具栏颜色</span></span><br><span class="line">&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt;  </span><br><span class="line"><span class="comment"># 启用360浏览器的极速模式(webkit)</span></span><br><span class="line">&lt;meta name=”renderer” content=”webkit”&gt; </span><br><span class="line"><span class="comment"># 避免IE使用兼容模式</span></span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt;</span><br><span class="line"><span class="comment"># 不让百度转码</span></span><br><span class="line">&lt;meta name=”HandheldFriendly” content=”<span class="literal">true</span>”&gt;</span><br><span class="line"><span class="comment"># 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓</span></span><br><span class="line">&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt;</span><br><span class="line"><span class="comment"># 微软的老式浏览器</span></span><br><span class="line">&lt;meta name=”MobileOptimized” content=”320″&gt;</span><br><span class="line"><span class="comment"># uc强制竖屏</span></span><br><span class="line">&lt;meta name=”screen-orientation” content=”portrait”&gt;</span><br><span class="line"><span class="comment"># QQ强制竖屏</span></span><br><span class="line">&lt;meta name=”x5-orientation” content=”portrait”&gt;</span><br><span class="line"><span class="comment"># UC强制全屏</span></span><br><span class="line">&lt;meta name=”full-screen” content=”yes”&gt;</span><br><span class="line"><span class="comment"># QQ强制全屏</span></span><br><span class="line">&lt;meta name=”x5-fullscreen” content=”<span class="literal">true</span>”&gt;</span><br><span class="line"><span class="comment"># UC应用模式</span></span><br><span class="line">&lt;meta name=”browsermode” content=”application”&gt;</span><br><span class="line"><span class="comment"># QQ应用模式</span></span><br><span class="line">&lt;meta name=”x5-page-mode” content=”app”&gt;</span><br><span class="line"><span class="comment"># windows phone 点击无高光</span></span><br><span class="line">&lt;meta name=”msapplication-tap-highlight” content=”no”&gt;</span><br><span class="line">设置页面不缓存</span><br><span class="line">&lt;meta http-equiv=”pragma” content=”no-cache”&gt;</span><br><span class="line">&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;</span><br><span class="line">&lt;meta http-equiv=”expires” content=”0″&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载:&lt;br&gt;　　&lt;a href=&quot;https://juejin.im/post/5b94d8965188255c5a0cdc02#heading-4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2018前端面试总结，看完弄懂，工资少说加3K | 掘金技术征文&lt;/a&gt;&lt;br&gt;参考:&lt;br&gt;　　&lt;a href=&quot;https://www.cnblogs.com/2050/p/3877280.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移动前端开发之viewport的深入理解&lt;/a&gt;&lt;br&gt;&lt;code&gt;&amp;lt;mate&amp;gt;&lt;/code&gt;标签: 提供页面的元信息但和内容无关，元数据可以被浏览器、搜索引擎和其他web服务器使用。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/25/HTTP/TCP%E3%80%81UDP%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E3%80%81DNS/"/>
    <id>http://yoursite.com/2019/03/25/HTTP/TCP、UDP、套接字、DNS/</id>
    <published>2019-03-25T07:45:35.303Z</published>
    <updated>2019-03-25T07:46:51.896Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载：<br>　　<a href="https://juejin.im/post/5bbaa549e51d450e827b6b13#heading-0" target="_blank" rel="noopener">一篇文章搞定前端面试</a></p><p>TCP<br>UDP<br>套接字socket<br>HTTP协议<br>DNS解析<br>HTTP请求发起和响应<br>页面渲染的过程<br>页面的性能优化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/25/JavaScript/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/25/JavaScript/面试题/</id>
    <published>2019-03-25T07:11:32.199Z</published>
    <updated>2019-03-25T08:07:21.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一行代码实现数组去重？<br><code>[...new Set([1,2,3,1,&#39;a&#39;,1,&#39;a&#39;])]</code><br>怎么判断两个对象相等？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">obj=&#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:2</span><br><span class="line">&#125;</span><br><span class="line">obj2=&#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:2</span><br><span class="line">&#125;</span><br><span class="line">obj3=&#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:&apos;2&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JSON.stringify(obj)==JSON.stringify(obj2);//true</span><br><span class="line">JSON.stringify(obj)==JSON.stringify(obj3);//false</span><br></pre></td></tr></table></figure></p><p>CommonJS 中的 require/exports 和 ES6 中的 import/export 区别？</p><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。<br>ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。<br>import/export 最终都是编译为 require/exports 来执行的。<br>CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。<br>export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><p>浏览器缓存<br>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：</p><p>先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；<br>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；<br>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；<br>区别是，强缓存不对发送请求到服务器，但协商缓存会。<br>当协商缓存也没命中时，服务器就会将资源发送回客户端。<br>当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；<br>当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；</p><p>强缓存</p><p>Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）<br>Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）</p><p>协商缓存</p><p>Last-Modified（值为资源最后更新时间，随服务器response返回）<br>If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）<br>ETag（表示资源内容的唯一标识，随服务器response返回）<br>If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</p><p>页面渲染的完整流程是怎样的？</p><h3 id="图片里的-alt-属性是做什么的？"><a href="#图片里的-alt-属性是做什么的？" class="headerlink" title="图片里的 alt 属性是做什么的？"></a>图片里的 alt 属性是做什么的？</h3><p>查看答案<br>如果用户看不到图像，alt 属性可以提供替代信息。alt 属性应该用于描述，而那些仅仅是装饰目的图像，可以为空</p><p>小贴士<br>装饰性的图像应该有一个空的 alt 属性<br>web 爬虫可以通过 alt 属性理解图像的信息，因此认为它对于搜索引擎优化（SEO）非常重要<br>在 alt 末尾加 . 可以提高访问性</p><h3 id="不采用缓存的目的是什么，你如何实现它？"><a href="#不采用缓存的目的是什么，你如何实现它？" class="headerlink" title="不采用缓存的目的是什么，你如何实现它？"></a>不采用缓存的目的是什么，你如何实现它？</h3><p>查看答案<br>浏览器有一个临时的存储网站文件的缓存，所以他们不需要在切换或重新加载同一个页面时再次重新下载。服务器设置发送头信息告诉浏览器在给定的一段时间内使用存储文件。这极大加快了网站的速度和节省了带宽</p><p>然而，当开发人员网站更新时，因为用户的缓存依然指向旧的文件，这会造成问题。如果缓存的 CSS 和 JavaScript 文件引用的元素不再存在，已移除或已重命名时，它会保留原有功能或破坏网站</p><p>禁用缓存是一个强制浏览器下载新文件的过程。通过命名来区分于旧文件</p><p>一个常用的强制浏览器重新下载文件的技术是在文件的结尾处增加一个查询字符串</p><p>src=”js/script.js” =&gt; src=”js/script.js?v=2”<br>浏览器认为这是一个不同的文件但是避免了修改文件名的必要</p><h3 id="一个页面里是否可以包含多个-元素，-元素呢？"><a href="#一个页面里是否可以包含多个-元素，-元素呢？" class="headerlink" title="一个页面里是否可以包含多个  元素，  元素呢？"></a>一个页面里是否可以包含多个 <header> 元素， <footer> 元素呢？</footer></header></h3><p>查看答案<br>都可以。W3C 文档声明这些标签代表离它们最近祖先区域的页眉（<header>）和页脚（<footer>）。因此，不只是可以在页面的 <body> 里包含页眉和页脚，而且每一个 <article> 和 <section> 元素都可以包含</section></article></body></footer></header></p><p>小贴士<br>W3C 推荐你想用多少就用多少，但是每一个页面的区域只能有一个，即，body，section 等等</p><h3 id="lt-script-gt-标签的-defer-和-async-是什么？"><a href="#lt-script-gt-标签的-defer-和-async-是什么？" class="headerlink" title="&lt;script&gt; 标签的 defer 和 async 是什么？"></a><code>&lt;script&gt;</code> 标签的 defer 和 async 是什么？</h3><p>查看答案<br>如果两个属性都没有的话，脚本将同步下载和执行，并且会阻塞 document 解析，直到脚本执行完成（默认行为）。脚本下载和执行按它们书写的顺序进行</p><p>defer 属性在 document 解析的过程中下载脚本，但是在 document 解析完成之前执行，等价于执行了一个内置的事件监听器 DOMContentLoaded。defer 脚本顺序执行</p><p>async 属性在 document 解析过程中下载脚本，但是会暂停解析器，直到脚本解析执行完成。async 不一定按顺序执行</p><p>注意：两个属性必须在脚本拥有 src 属性时才起作用（即，在内联脚本不起作用）</p><p><script src="myscript.js"></script></p><p><script src="myscript.js" defer></script></p><p><script src="myscript.js" async></script><br>小贴士<br>请用 <head> 中放置一个 defer，允许浏览器在页面还在解析过程中下载脚本，因此把脚本放到 body 之前是更好的选择<br>如果脚本之间相互依赖，请用 defer.<br>如果脚本是独立的，请用 async.<br>如果 DOM 必须加载完并且内容还未放置到 DOMContentLoaded 监听器中时，请用 defer</head></p><h3 id="相比-HTML，XHTML-有哪些不同？"><a href="#相比-HTML，XHTML-有哪些不同？" class="headerlink" title="相比 HTML，XHTML 有哪些不同？"></a>相比 HTML，XHTML 有哪些不同？</h3><p>查看答案<br>有一些关键区别：</p><p>一个 XHTML 元素必须要有一个 XHTML <doctype><br>属性值必须用引号包裹<br>禁止属性简写（例如，checked=”checked” 不能简写为 checked）<br>元素必须正确的被嵌套<br>元素必须闭合<br>特殊字符必须被转义<br>小贴士<br>任何被标签都是自闭合<br>标签和属性区分大小写，通常小写</doctype></p><h3 id="你能说出-media-属性的四种类型吗？"><a href="#你能说出-media-属性的四种类型吗？" class="headerlink" title="你能说出 @media 属性的四种类型吗？"></a>你能说出 @media 属性的四种类型吗？</h3><p>查看答案<br>all，适用于所有媒体设备<br>print，仅适用于打印机<br>screen，仅适用于屏幕设备（台式电脑、平板电脑、移动设备等）<br>speech，仅适用于屏幕阅读器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>定位</title>
    <link href="http://yoursite.com/2019/03/22/CSS3/%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2019/03/22/CSS3/定位/</id>
    <published>2019-03-22T10:09:02.000Z</published>
    <updated>2019-03-22T10:22:56.422Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>position<br>static<br>表示没有定位，元素出现在正常的文档流中。<br>为静态定位的元素设置 top|bottom|left|right 不起作用。<a id="more"></a><br>fixed<br>元素的位置相对于浏览器窗口是固定位置。<br>即使浏览器的窗口是滚动的它也不会移动。<br>fixed定位使得元素脱离了文档流，因而不占据空间。<br>设置了固定定位的元素宽高由其内部元素撑起。<br>relative<br>相对定位的元素是相对其正常位置。<br>1.使用了相对定位元素的元素，其参照物是其本身，其偏移量由TRBL(top，right,bottom,left)的值确定。<br>2.使用了相对定位的元素，仍然会在标准流中占据原来的位置，它对父元素和兄弟元素没有影响。<br>3.相对定位的使用场景往往是作为绝对定位元素的参照物。<br>absolute<br>绝对定位的元素的位置是相对其最近的已定位父元素（也就是除static之外），如果找不到已定位的父元素，那么就相对于<code>&lt;html&gt;</code>元素。<br>absolute定位使得元素脱离了文档流，因而不占据空间。<br>设置了绝对定位的元素宽高由其内部元素撑起。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;position&lt;br&gt;static&lt;br&gt;表示没有定位，元素出现在正常的文档流中。&lt;br&gt;为静态定位的元素设置 top|bottom|left|right 不起作用。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/22/Vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/03/22/Vue/Vue生命周期/</id>
    <published>2019-03-22T09:02:49.704Z</published>
    <updated>2019-03-22T09:13:58.586Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.cnblogs.com/happ0/p/8075562.html" target="_blank" rel="noopener">vue 生命周期 详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络安全(SQL、XSS、CSRF)</title>
    <link href="http://yoursite.com/2019/03/21/JavaScript/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2019/03/21/JavaScript/网络安全/</id>
    <published>2019-03-21T12:40:40.000Z</published>
    <updated>2019-03-21T13:34:55.904Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载：<br>　　<a href="http://netsecurity.51cto.com/art/201901/590563.htm" target="_blank" rel="noopener">3大Web安全漏洞防御详解：XSS、CSRF、以及SQL注入解决方案</a><br>参考：<br>　　<a href="https://www.cnblogs.com/443855539-wind/p/6055816.html" target="_blank" rel="noopener">前端安全（XSS、CSRF防御）</a><br>　　<a href="https://segmentfault.com/a/1190000007059639" target="_blank" rel="noopener">用大白话谈谈XSS与CSRF</a><br>常见的Web安全分为两种前端安全(XSS攻击、CSRF攻击)和后端安全(SQL注入)</p><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>　　XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。<code>这类攻击通常包含了HTML以及用户端脚本语言</code>。<a id="more"></a><br>　　XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码。</p><h4 id="XSS攻击的危害"><a href="#XSS攻击的危害" class="headerlink" title="XSS攻击的危害"></a>XSS攻击的危害</h4><p>　　1. 盗取用户资料，比如：登录帐号、网银帐号等<br>　　2. 利用用户身份，读取、篡改、添加、删除数据等<br>　　3. 盗窃重要的具有商业价值的资料<br>　　4. 非法转账<br>　　5. 强制发送电子邮件<br>　　6. 网站挂马<br>　　7. 控制受害者机器向其它网站发起攻击</p><h4 id="防止XSS的解决方法"><a href="#防止XSS的解决方法" class="headerlink" title="防止XSS的解决方法"></a>防止XSS的解决方法</h4><p><code>XSS</code>的根源主要是没完全过滤客户端提交的数据 ，所以重点是要过滤用户提交的信息。<br>　　1. 将重要的cookie标记为<code>http only</code>, 这样的话js 中的<code>document.cookie</code>语句就不能获取到<code>cookie</code>了.<br>　　2. 只允许用户输入我们期望的数据。 例如：<code>age</code>用户年龄只允许用户输入数字，而数字之外的字符都过滤掉。<br>　　3. 对数据进行<code>Html Encode</code>处理：用户将数据提交上来的时候进行<code>HTML</code>编码，将相应的符号转换为实体名称再进行下一步的处理。<br>　　4. 过滤或移除特殊的<code>Html</code>标签。<br>　　5. 过滤<code>js</code>事件的标签。例如 <code>&quot;onclick=&quot;</code>, <code>&quot;onfocus&quot;</code>等等。</p><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>　　CSRF:跨站请求伪造（英语：<code>Cross-site request forgery</code>），也被称为 <code>one-click attack</code> 或者 <code>session riding</code>，通常缩写为 <code>CSRF</code> 或者 <code>XSRF</code>，是一种挟制用户在当前已登录的Web应用程序上<code>执行非本意的操作的攻击方法</code>。<br>　　XSS主要是利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求，来利用受信任的网站。与XSS攻击相比，CSRF更具危险性。</p><h4 id="CSRF攻击危害"><a href="#CSRF攻击危害" class="headerlink" title="CSRF攻击危害"></a>CSRF攻击危害</h4><p>　　主要的危害来自于，攻击者盗用用户身份，发送恶意请求。比如：模拟用户发送邮件，发消息，以及支付、转账等。</p><h4 id="防止CSRF的解决方法"><a href="#防止CSRF的解决方法" class="headerlink" title="防止CSRF的解决方法"></a>防止CSRF的解决方法</h4><p>　　1. 重要数据交互采用POST进行接收，当然是用POST也不是万能的，伪造一个form表单即可破解。<br>　　2. 使用验证码，只要是涉及到数据交互就先进行验证码验证，这个方法可以完全解决CSRF。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。<br>　　3. 验证HTTP Referer字段，该字段记录了此次HTTP请求的来源地址，最常见的应用是图片防盗链。<br>　　4. 为每个表单添加令牌token并验证。</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>　　SQL注入是比较常见的网络攻击方式之一，主要是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，实现无帐号登录，甚至篡改数据库。</p><h4 id="SQL注入的危害"><a href="#SQL注入的危害" class="headerlink" title="SQL注入的危害"></a>SQL注入的危害</h4><p>　　1. 数据库信息泄漏：数据库中存放的用户的隐私信息的泄露<br>　　2. 网页篡改：通过操作数据库对特定网页进行篡改<br>　　3. 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改<br>　　4. 服务器被远程控制，被安装后门<br>　　5. 删除和修改数据库表信息</p><h4 id="SQL注入的方式"><a href="#SQL注入的方式" class="headerlink" title="SQL注入的方式"></a>SQL注入的方式</h4><p>通常情况下，SQL注入的位置包括：<br>　　1. 表单提交，主要是POST请求，也包括GET请求;<br>　　2. URL参数提交，主要为GET请求参数;<br>　　3. Cookie参数提交;<br>　　4. HTTP请求头部的一些可修改的值，比如Referer、User_Agent等;</p><h4 id="防止SQL注入的解决方法"><a href="#防止SQL注入的解决方法" class="headerlink" title="防止SQL注入的解决方法"></a>防止SQL注入的解决方法</h4><p>　　1. 对用户的输入进行校验，使用正则表达式过滤传入的参数<br>　　2. 使用参数化语句，不要拼接sql，也可以使用安全的存储过程<br>　　3. 不要使用管理员权限的数据库连接，为每个应用使用权限有限的数据库连接<br>　　4. 检查数据存储类型<br>　　5. 重要的信息一定要加密</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;转载：&lt;br&gt;　　&lt;a href=&quot;http://netsecurity.51cto.com/art/201901/590563.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;3大Web安全漏洞防御详解：XSS、CSRF、以及SQL注入解决方案&lt;/a&gt;&lt;br&gt;参考：&lt;br&gt;　　&lt;a href=&quot;https://www.cnblogs.com/443855539-wind/p/6055816.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端安全（XSS、CSRF防御）&lt;/a&gt;&lt;br&gt;　　&lt;a href=&quot;https://segmentfault.com/a/1190000007059639&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;用大白话谈谈XSS与CSRF&lt;/a&gt;&lt;br&gt;常见的Web安全分为两种前端安全(XSS攻击、CSRF攻击)和后端安全(SQL注入)&lt;/p&gt;
&lt;h3 id=&quot;XSS攻击&quot;&gt;&lt;a href=&quot;#XSS攻击&quot; class=&quot;headerlink&quot; title=&quot;XSS攻击&quot;&gt;&lt;/a&gt;XSS攻击&lt;/h3&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;　　XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。&lt;code&gt;这类攻击通常包含了HTML以及用户端脚本语言&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/21/JavaScript/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/21/JavaScript/面试题总结/</id>
    <published>2019-03-21T11:42:26.566Z</published>
    <updated>2019-03-22T10:59:29.857Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>. vue的生命周期?<br>Mvvm响应式原理？<br>常见设计模式及其应用场景？<br>原型链？<br>闭包？应用场景？<br>Es6的新特性？<br>Css position相关？<br>Html语义化？<br>冒泡排序？<br> Html大纲？<br> 浏览器兼容性？<br>腾讯二面（视频，24min左右）：<br>vue的生命周期？</p><p>Js数据类型，堆和栈的区别？</p><p>Vue的diff算法？怎么样才算samenode（源码相关）？比较子节点的时候顺序比较行不行？</p><p>用defineProperty进行数据劫持的缺点？怎么办（考察vue3.0数据劫持的方式proxy）？</p><p>手写二分查找</p><p>Css盒子模型？</p><p>Express中间件？</p><p>Symbol？作用？<br>三面约的19：10，结果前面面试的同学太多了，到19：45才面上<br>腾讯三面（电话，20min左右）：</p><ol><li><p>从输入url到显示页面的过程？</p></li><li><p>这个过程中有哪些会影响性能？</p></li><li><p>闭包原理？适用场景？</p></li></ol><p>5、闭包的优点<br>（1）逻辑连续，当闭包作为另一个函数调用参数时，避免脱离当前逻辑而单独编写额外逻辑。</p><p>（2）方便调用上下文的局部变量。</p><p>（3）加强封装性，是第2点的延伸，可以达到对变量的保护作用。</p><p>6、使用闭包的注意点（缺点）<br>（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><p>7、闭包的特性<br>（1）作为函数变量的一个引用。当函数返回时，其处于激活状态。</p><p>（2）闭包就是当一个函数返回时，并没有释放资源的栈区。</p><ol start="4"><li>Es6有哪些了解？</li></ol><p>1.自我介绍<br>2.做过什么项目？<br>3.了解es6吗<br>4.promise原理<br>5.了解什么算法？<br>6.堆排序过程，时间复杂度（nlogn,他还让我再想一下？？），应用场景（没答出来，哭）。<br>7.用过的技术栈<br>8.怎么学习前端<br>9.问题：公司主要用react，vue哪个，为什么用它呢？</p><p>什么时候开始学习的前端？<br>==和===的区别<br>JS 继承（ES6 extends、ES5 各种继承）<br>怎么判断参数是数组还是对象？（Array.isArray、toString、instanceOf）<br>问项目，技术方案，话题转 Vue<br>Vue 生命周期有哪些？（Create、Mount、Active、Update、Deactive、Destory）<br>DOM 结点在什么时候挂载？<br>Vue 能不能挂载到body或html标签上，为什么？<br>项目开发联调方式？<br>自我介绍</p><p>写一个两边定宽，中间自适应的布局（dispaly: flex、双飞翼/圣杯、position: absolute）<br>垂直居中方案（line-height、transform）<br>JS 怎么对象的属性是数组还是对象（参考一面第 8 问），解释下每个方法怎么判断（数组 Object.prototype.toString.call之后是[object, Array]，对象toString之后是[object, object]，instanceOf就是返回true还是false）<br>JS 继承（ES6 extends、原型链、构造），解释下原型链和构造哪个好，好在哪里，原型链继承的时候，可不可以直接A.prototype = B()，而不是A.prototype = new B()，为什么<br>构造继承为什么用call，而不是apply？（参数不同，一个数组，一个不定参数），追问哪个参数是数组？（apply）<br>实现一个数组去重（Array.from(new Set(arr))），不用 ES6 实现一个对所有数组有可以调用的去重（forindexOf，添加到Array.prototype），面试官说i</p><p>跨域的方式<br>websocket和Http的区别<br>长轮询<br>cookie和session，没有cookie的话session能不能使用<br>浏览器缓存机制，304是协商缓存还是强缓存<br>类数组变成数组<br>let和var的区别<br>CSRF以及Token验证的Token放在哪里<br>TCP三次握手，如果没有三次握手会怎样<br>Vue用watch实现数据双向绑定<br>重绘和重排，什么操作会造成重排<br>LESS怎么遍历一个列表<br>await语法<br>JS继承有哪几种，具体的实现及原理<br>常见的HTTP状态码各个是什么意思<br>介绍浏览器缓存？各个响应头优先级？以及之间的区别，可以取的值，分别是什么意思<br>介绍浏览器时间<br>介绍一下跨域，各个跨域的具体实现方法？以及JSONP实现方式中服务器是怎样交互的<br>介绍一下网络安全（xss以及csrf具体防范方法）</p><p>行内元素和块级元素二者区别<br>css选择器有哪些，怎么样计算<br>JS面向对象的理解<br>盒子模型，box-sizing<br>常用的设计模式，<br>封装一个函数判断数据类型，数组还是对象<br>状态码404 400 502 304<br>http底层协议<br>http协议用在tcp还是udp<br>三次握手，四次握手，两次握手，<br>time wait 2ml 的原因<br>浏览器缓存，硬盘（持久化）<br>数据结构，快速排序，稳定的还是不稳定的。最差的时间复杂度<br>内存存不下，很多个数据，找出最大的10个或者100个<br>哈希<br>操作系统 nio, i/o操作<br>计算机组成原理，数据用什么码储存的，正负数的储存，负数的源码补码<br>基址寻址和变址寻址<br>get，post请求最本质的区别<br>多路复用<br>事件代理。常规做法的优势体现在哪里<br>session。分布式集群，如何保障session可以保持相同<br>浏览器cookie禁掉session是哪一端session特别多怎么办</p><p>OSI七层模型及作用<br>http。tcp三次握手四次挥手、http和https<br>tcp、cdp<br>post和get<br>进程和线层的区别<br>输入一个url发生了什么<br>内存分配<br>闭包、作用域链<br>vue生命周期<br>css3动画，怎么做<br>单行文本溢出，多行文本溢出代码实现<br>bfc布局<br>js类型，封装一个类型鉴定函数<br>闭包，哪里用到立即执行函数解决闭包中访问变量的问题<br>时间轮询机制<br>原生js实现bind函数<br>一个函数，然后让你说他们的值是多少，为什么<br>预编译、严格模式、作用域链<br>算法 快排 选择排序<br>浏览器渲染原理</p><p>实现一个构造函数new的时候每次加一<br>计算机网络tcp与udp区别，tcp拥塞机制，tcp三次握手四次挥手<br>css性能优化</p><p>js作用域链怎么来的<br>this<br>url到浏览器解析过程<br>dns解析<br>tcp连接<br>http和https。ssl层在哪里加入<br>浏览器解析过程<br>cdn有存在的必要吗</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>主流浏览器内核</title>
    <link href="http://yoursite.com/2019/03/19/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/"/>
    <id>http://yoursite.com/2019/03/19/前端性能优化/主流浏览器内核/</id>
    <published>2019-03-19T05:26:48.000Z</published>
    <updated>2019-03-19T06:11:42.947Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p>　　浏览器内核可以分为两部分：<strong>渲染引擎</strong>(<code>layout engineer</code> 或者 <code>Rendering Engine</code>)和<strong>JS引擎</strong><a id="more"></a><br>　　浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p><h5 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h5><p>　　渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等）、以及计算网页的显示方式，然后会输出至显示器或打印机。</p><h5 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h5><p>　　JS 引擎则是解析<code>Javascript</code>语言，执行<code>javascript</code>语言来实现网页的动态效果。<br>　　最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 <code>JS引擎越来越独立，内核就倾向于只指渲染引擎</code>。</p><h4 id="主流浏览器内核"><a href="#主流浏览器内核" class="headerlink" title="主流浏览器内核"></a>主流浏览器内核</h4><p><code>Trident</code>内核：IE<br><code>Gecko</code>内核：NETSCAPE6及以上版本，火狐(Mozilla FireFox)<br><code>Presto</code>内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink;]<br><code>Webkit</code>内核：Safari，Chrome等。<br>Chrome的：<code>Blink</code>（WebKit的分支）</p><h4 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h4><p>移动端的浏览器内核主要说的是<code>系统内置浏览器的内核</code>。<br>目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 。<br>1、iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit。<br>2、Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink。<br>3、Windows Phone 8 系统浏览器内核是 Trident。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h4 id=&quot;浏览器内核&quot;&gt;&lt;a href=&quot;#浏览器内核&quot; class=&quot;headerlink&quot; title=&quot;浏览器内核&quot;&gt;&lt;/a&gt;浏览器内核&lt;/h4&gt;&lt;p&gt;　　浏览器内核可以分为两部分：&lt;strong&gt;渲染引擎&lt;/strong&gt;(&lt;code&gt;layout engineer&lt;/code&gt; 或者 &lt;code&gt;Rendering Engine&lt;/code&gt;)和&lt;strong&gt;JS引擎&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSS3新特性</title>
    <link href="http://yoursite.com/2019/03/18/CSS3/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/03/18/CSS3/CSS3新特性/</id>
    <published>2019-03-18T13:17:09.000Z</published>
    <updated>2019-03-26T09:37:11.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>实现圆角<code>border-radius</code>，<br>阴影<code>box-shadow</code>，<br>边框图片<code>border-image</code><br>对文字加特效<code>text-shadow</code>，<br>强制文本换行<code>word-wrap</code>，<br>线性渐变<code>linear-gradient</code><a id="more"></a><br>实现旋转<code>transform:rotate(90deg)</code>,<br>缩放<code>scale(0.85,0.90)</code>,<br>定位<code>translate(0px,-30px)</code>,<br>倾斜<code>skew(-9deg,0deg)</code>;<br>增加了更多的<code>CSS</code>选择器、多背景、<code>rgba()</code><br>唯一引入的伪元素是<code>::selection</code>；<br>实现媒体查询<code>@media</code>，多栏布局<code>flex</code><br>过渡<code>transition</code><br>动画<code>animation</code><br><code>text-overflow</code>(文本溢出隐藏)<br><code>CSS3</code>中，<code>text-shadow</code>可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。<br><code>CSS3</code>新增了几个关于背景的属性，分别是<code>background-clip</code>、<code>background-origin</code>、<code>background-size</code>和<code>background-break</code>。<br><code>text-decoration</code>:CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：<br>　　<code>text-fill-color</code>: 设置文字内部填充颜色<br>　　<code>text-stroke-color</code>: 设置文字边界填充颜色<br>　　<code>text-stroke-width</code>: 设置文字边界宽度</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现圆角&lt;code&gt;border-radius&lt;/code&gt;，&lt;br&gt;阴影&lt;code&gt;box-shadow&lt;/code&gt;，&lt;br&gt;边框图片&lt;code&gt;border-image&lt;/code&gt;&lt;br&gt;对文字加特效&lt;code&gt;text-shadow&lt;/code&gt;，&lt;br&gt;强制文本换行&lt;code&gt;word-wrap&lt;/code&gt;，&lt;br&gt;线性渐变&lt;code&gt;linear-gradient&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>Url、Href、Src、Link详解</title>
    <link href="http://yoursite.com/2019/03/18/CSS3/Url%E3%80%81Href%E3%80%81Src%E3%80%81Link/"/>
    <id>http://yoursite.com/2019/03/18/CSS3/Url、Href、Src、Link/</id>
    <published>2019-03-18T11:49:44.000Z</published>
    <updated>2019-03-26T03:00:04.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载：<br>　　<a href="https://segmentfault.com/a/1190000002877022" target="_blank" rel="noopener">url、href、src 详解</a><br><a id="more"></a></p><h4 id="Url"><a href="#Url" class="headerlink" title="Url"></a>Url</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>　　<code>URL</code>(<code>Uniform Resource Locator</code>)统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的<code>URL</code>，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><h5 id="Url格式"><a href="#Url格式" class="headerlink" title="Url格式"></a>Url格式</h5><p><strong>标准格式</strong><br>　　协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名?查询<br><strong>完整格式</strong><br>　　协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名?查询</p><h6 id="Url语法规则"><a href="#Url语法规则" class="headerlink" title="Url语法规则"></a>Url语法规则</h6><p>　　比如网址<code>http://segmentfault.com/html/index.asp</code>必须遵守以下的语法规则:<br><code>scheme://host.domain:port/path/filename</code><br><strong>说明</strong><br>　　<code>scheme</code> - 定义因特网服务的类型。最常见的类型是 http<br>　　<code>host</code> - 定义域主机（http 的默认主机是 www）<br>　　<code>domain</code> - 定义因特网域名，比如 w3school.com.cn<br>　　<code>:port</code> - 定义主机上的端口号（http 的默认端口号是 80）<br>　　<code>path</code> - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。<br>　　<code>filename</code> - 定义文档/资源的名称</p><h6 id="URL-Schemes"><a href="#URL-Schemes" class="headerlink" title="URL Schemes"></a>URL Schemes</h6><table><thead><tr><th style="text-align:left">Scheme</th><th style="text-align:left">访问</th><th style="text-align:center">用于</th></tr></thead><tbody><tr><td style="text-align:left">http</td><td style="text-align:left">超文本传输协议</td><td style="text-align:center">以 http:// 开头的普通网页。不加密。</td></tr><tr><td style="text-align:left">https</td><td style="text-align:left">安全超文本传输协议</td><td style="text-align:center">安全网页。加密所有信息交换。</td></tr><tr><td style="text-align:left">ftp</td><td style="text-align:left">文件传输协议</td><td style="text-align:center">用于将文件下载或上传至网站。</td></tr><tr><td style="text-align:left">file</td><td style="text-align:left"></td><td style="text-align:center">您计算机上的文件。</td></tr></tbody></table><h6 id="URL的类型"><a href="#URL的类型" class="headerlink" title="URL的类型"></a>URL的类型</h6><p><strong>绝对URL</strong><br>　　绝对<code>URL</code>（<code>absolute URL</code>）显示文件的完整路径，这意味着绝对<code>URL</code>本身所在的位置与被引用的实际文件的位置无关。<br><strong>相对URL</strong><br>　　相对<code>URL</code>（<code>relative URL</code>）以包含<code>URL</code>本身的文件夹的位置为参考点，描述目标文件夹的位置。<br>　　一般来说，对于同一服务器上的文件，应该总是使用相对<code>URL</code>，它们更容易输入，而且在将页面从本地系统转移到服务器上时更方便，只要每个文件的相对位置保持不变，链接就仍然是有效地。<br><code>.</code>：代表目前所在的目录，相对路径。<br>例： <code>&lt;a href=&quot;./abc&quot;&gt;文本&lt;/a&gt;</code> 或 <code>&lt;img src=&quot;./abc&quot; /&gt;</code><br><code>..</code>：代表上一层目录，相对路径。<br>例： <code>&lt;a href=&quot;../abc&quot;&gt;文本&lt;/a&gt;</code>或 <code>&lt;img src=&quot;../abc&quot; /&gt;</code><br><code>../../</code>：代表的是上一层目录的上一层目录，相对路径。<br>例： <code>&lt;img src=&quot;../../abc&quot; /&gt;</code><br><code>/</code>：代表根目录，绝对路径。<br>例： <code>&lt;a href=&quot;/abc&quot;&gt;文本&lt;/a&gt;</code> 或 <code>&lt;img src=&quot;/abc&quot; /&gt;</code></p><h4 id="Href"><a href="#Href" class="headerlink" title="Href"></a>Href</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>　　<code>href</code> (<code>Hypertext Reference</code>)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。</p><h5 id="通俗理解"><a href="#通俗理解" class="headerlink" title="通俗理解"></a>通俗理解</h5><p>　　<code>href</code>: 目的不是为了引用资源，而是为了建立这个标签与外部资源之间的关系，让当前标签能够链接到目标地址。<br><code>&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;</code>浏览器加载到这里的时候，html的渲染和解析不会暂停，css文件的加载是同时进行的</p><h4 id="Src"><a href="#Src" class="headerlink" title="Src"></a>Src</h4><p>　　<code>src</code>用于替代这个元素: <code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code>当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个js文件</p><h4 id="Href和Src的区别"><a href="#Href和Src的区别" class="headerlink" title="Href和Src的区别"></a>Href和Src的区别</h4><p><strong>请求资源类型不同</strong><br>　　href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。<br>　　在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；<br><strong>作用结果不同</strong><br>　　href 用于在当前文档和引用资源之间确立联系；<br>　　src 用于替换当前内容；<br><strong>浏览器解析方式不同</strong><br>　　若在文档中添加 <code>&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;/&gt;</code>，浏览器会识别该文档为 <code>CSS</code> 文件，就会并行下载资源并且<code>不会停止</code>对当前文档的处理。这也是为什么建议使用 <code>link</code> 方式加载 <code>CSS</code>，而不是使用<code>@import</code> 方式。<br>　　当浏览器解析到 <code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code>，会<code>暂停</code>其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 <code>js</code> 脚本放在底部而不是头部的原因。</p><h4 id="Link和-import的区别"><a href="#Link和-import的区别" class="headerlink" title="Link和@import的区别"></a>Link和@import的区别</h4><p>两者都是外部引用 <code>CSS</code> 的方式，但是存在一定的区别：<br>（1）<code>link</code>是<code>XHTML</code>标签，除了能够加载<code>CSS</code>，还可以定义<code>RSS</code>等其他事务；而<code>@import</code>属于<code>CSS</code>范畴，只可以加载<code>CSS</code>。<br>（2）<code>link</code>引用<code>CSS</code>时，在页面载入时同时加载；<code>@import</code>需要页面完全载入以后再加载。<br>（3）<code>link</code>是<code>XHTML</code>标签，无兼容问题；<code>@import</code>则是在<code>CSS2.1</code>提出的，低版本的浏览器不支持。<br>（4）<code>link</code>支持使用<code>Javascript</code>控制<code>DOM</code>改变样式；而<code>@import</code>不支持。</p><h4 id="为什么尽量不要使用-import加载css"><a href="#为什么尽量不要使用-import加载css" class="headerlink" title="为什么尽量不要使用@import加载css"></a>为什么尽量不要使用@import加载css</h4><p>使用<code>@import</code>会导致和预期不一致的下载顺 序。<br>我们确实要避免使用<code>css @import，</code>但原因却不是什么相当于放在了页面底部，而是这样做会导致<code>css</code>无法并行下载，因为使用<code>@import</code>引用的文件只有在引用它的那个<code>css</code>文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建<code>render tree</code>等一系列操作。 浏览器在页面所有<code>css</code>下载并解析完成后才会开始渲染页面（<code>Before a browser can begin to render a web page, it mustdownload and parse any stylesheets that are required to lay out thepage. Even if a stylesheet is in an external file that is cached,rendering is blocked until the browser loads the stylesheet from disk.</code>），因此<code>css @import</code>引起的<code>css</code>解析延迟会加长页面留白期。 所以，要尽量避免使用<code>css @import</code>而尽量采用<code>link</code>标签的方式引入。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;转载：&lt;br&gt;　　&lt;a href=&quot;https://segmentfault.com/a/1190000002877022&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;url、href、src 详解&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>同源策略和跨域</title>
    <link href="http://yoursite.com/2019/03/17/Ajax/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/03/17/Ajax/同源策略和跨域/</id>
    <published>2019-03-17T08:56:03.000Z</published>
    <updated>2019-03-17T12:46:35.362Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载:<br>　　<a href="https://segmentfault.com/a/1190000012469713" target="_blank" rel="noopener">ajax跨域，这应该是最全的解决方案了</a><br>参考:<br>　　<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法</a><br>　　<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>同源即指：协议相同、域名相同、端口号相同。<br><a id="more"></a><br>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/dir2/other.html：同源</span><br><span class="line">http://example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://v2.www.example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://www.example.com:81/dir/other.html：不同源（端口不同）</span><br></pre></td></tr></table></figure></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>　　同源政策的目的，是为了<strong>为了保证使用者信息的安全，防止恶意网站篡改用户数据</strong>。<br>　　设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的<code>Cookie</code>，会发生什么？<br>　　很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，<code>Cookie</code> 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。<br>　　由此可见，”同源政策”是必需的，否则 <code>Cookie</code> 可以共享，互联网就毫无安全可言了。</p><h3 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h3><p>　　随着互联网的发展，”同源政策”越来越严格。目前，非同源的网站之间，共有四种行为受到限制。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1） Cookie、LocalStorage 和 IndexDB 无法读取。</span><br><span class="line">（2） DOM 无法获得。</span><br><span class="line">（3） AJAX 请求不能发送。</span><br><span class="line">（4）无法通过 flash 发送 http 请求</span><br></pre></td></tr></table></figure></p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>　　同源策略做了很严格的限制，但是在实际的场景中，又确实有很多地方需要突破同源策略的限制，也就是我们常说的跨域。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>　　同源策略最早被提出的时候，为的就是防止不同域名的网页之间共享 <code>cookie</code>。<code>Cookie</code>是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享<code>Cookie</code>。<br>举个例子，<br><code>https://market.douban.com</code>和<code>https://book.douban.com</code>，这两个网页的一级域名都是 <code>douban.com</code>，如果我在 <code>market.douban.com</code>中执行了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#A、B页面设置相同的document.domain</span></span><br><span class="line">document.domain = <span class="string">'douban.com'</span></span><br><span class="line"><span class="comment"># A页面通过脚本设置一个Cookie</span></span><br><span class="line">document.cookie = <span class="string">'cross=yes'</span></span><br><span class="line">或</span><br><span class="line">document.cookie = <span class="string">'cross=yes;path=/;domain=douban.com'</span></span><br><span class="line"><span class="comment"># B页面就可以读取到Cookie</span></span><br><span class="line">var allCookie = document.cookie</span><br></pre></td></tr></table></figure></p><p>这样设置了 <code>cookie</code>之后，在<code>book.douban.com</code>中是可以取到这个<code>cookie</code>的。<br>除了在前端设置之外，也可以直接在<code>response</code>里将<code>cookie</code>的<code>domain</code>设置成 <code>.douban.com</code>。</p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="什么是Ajax跨域"><a href="#什么是Ajax跨域" class="headerlink" title="什么是Ajax跨域"></a>什么是Ajax跨域</h4><h5 id="ajax跨域的原理"><a href="#ajax跨域的原理" class="headerlink" title="ajax跨域的原理"></a>ajax跨域的原理</h5><p>　　<code>ajax</code>出现请求跨域错误问题,主要原因就是因为浏览器的“同源策略”,可以参考</p><h5 id="ajax跨域的表现"><a href="#ajax跨域的表现" class="headerlink" title="ajax跨域的表现"></a>ajax跨域的表现</h5><p>　　<code>ajax</code>请求时,如果存在跨域现象,并且没有进行解决,会有如下表现:(注意，是<code>ajax</code>请求，请不要说为什么<code>http</code>请求可以，而<code>ajax</code>不行，因为<code>ajax</code>是伴随着跨域的，所以仅仅是<code>http</code>请求<code>ok</code>是不行的)<br><strong>第一种现象</strong>:<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>,并且<code>The response had HTTP status code 404</code><br><img src="/assets/images/ajax001.png" alt="ajax001"><br>出现这种情况的原因如下：<br>　　本次ajax请求是“非简单请求”,所以请求前会发送一次预检请求(<code>OPTIONS</code>)<br>　　服务器端后台接口没有允许<code>OPTIONS</code>请求,导致无法找到对应接口地址<br>解决方案: 后端允许options请求<br><strong>第二种现象</strong>:<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>,并且<code>The response had HTTP status code 405</code><br><img src="/assets/images/ajax002.png" alt="ajax001"><br>这种现象和第一种有区别,这种情况下，后台方法允许<code>OPTIONS</code>请求,但是一些配置文件中(如安全配置),阻止了<code>OPTIONS</code>请求,才会导致这个现象<br>解决方案: 后端关闭对应的安全配置<br><strong>第三种现象</strong>:<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>,并且<code>status 200</code><br><img src="/assets/images/ajax003.png" alt="ajax001"><br>这种现象和第一种和第二种有区别,这种情况下，服务器端后台允许<code>OPTIONS</code>请求,并且接口也允许<code>OPTIONS</code>请求,但是头部匹配时出现不匹配现象<br>比如<code>origin</code>头部检查不匹配,比如少了一些头部的支持(如常见的<code>X-Requested-With</code>头部),然后服务端就会将<code>response</code>返回给前端,前端检测到这个后就触发<code>XHR.onerror</code>,导致前端控制台报错<br>解决方案: 后端增加对应的头部支持<br><strong>第四种现象</strong>:<code>heade contains multiple values &#39;*,*&#39;</code><br><img src="/assets/images/ajax004.jpg" alt="ajax001"><br>表现现象是，后台响应的http头部信息有两个<code>Access-Control-Allow-Origin:*</code><br>说实话，这种问题出现的主要原因就是进行跨域配置的人不了解原理，导致了重复配置，如:<br>常见于<code>.net</code>后台(一般在<code>web.config</code>中配置了一次<code>origin</code>,然后代码中又手动添加了一次<code>origin</code>(比如代码手动设置了返回<code>*</code>))<br>常见于<code>.net</code>后台(在<code>IIS</code>和项目的<code>webconfig</code>中同时设置<code>Origin:*</code>)<br>解决方案(一一对应):<br>　　建议删除代码中手动添加的<code>*</code>，只用项目配置中的即可<br>　　建议删除IIS下的配置<code>*</code>，只用项目配置中的即可</p><h4 id="如何解决ajax跨域"><a href="#如何解决ajax跨域" class="headerlink" title="如何解决ajax跨域"></a>如何解决ajax跨域</h4><p>　　一般ajax跨域解决就是通过<code>JSONP</code>解决或者<code>CORS</code>解决,如以下:(注意，现在已经几乎不会再使用<code>JSONP</code>了，所以<code>JSONP</code>了解下即可)</p><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p>jsonp 其实算是一种 hack 形式的请求。<br>jsonp 的本质其实是请求一段 js 代码，是对静态文件资源的请求，所以并不遵循同源策略。但是因为是对静态文件资源的请求，所以只能支持 GET 请求，对于其他方法没有办法支持。</p><h5 id="设置CORS"><a href="#设置CORS" class="headerlink" title="设置CORS"></a>设置CORS</h5><p>　　<code>CORS</code>是一个<code>W3C</code>标准，全称是”跨域资源共享”（<code>Cross-origin resource sharing</code>）。<br>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了<code>AJAX</code>只能同源使用的限制。<br>本文详细介绍CORS的内部机制。</p><h6 id="CORS简介"><a href="#CORS简介" class="headerlink" title="CORS简介"></a>CORS简介</h6><p>　　<code>CORS</code>需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于<code>IE10</code>。<br>　　整个<code>CORS</code>通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现<code>AJAX</code>请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><h6 id="CORS两种请求"><a href="#CORS两种请求" class="headerlink" title="CORS两种请求"></a>CORS两种请求</h6><p>浏览器将CORS请求分成两类：简单请求（<code>simple request</code>）和非简单请求（<code>not-so-simple request</code>）。<br>只要同时满足以下两大条件，就属于简单请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">（1) 请求方法是以下三种方法之一：</span><br><span class="line">  HEAD</span><br><span class="line">  GET</span><br><span class="line">  POST</span><br><span class="line">（2）HTTP的头信息不超出以下几种字段：</span><br><span class="line">  Accept</span><br><span class="line">  Accept-Language</span><br><span class="line">  Content-Language</span><br><span class="line">  Last-Event-ID</span><br><span class="line">  Content-Type：只限于三个值</span><br><span class="line">                application/x-www-form-urlencoded、</span><br><span class="line">                multipart/form-data、</span><br><span class="line">                text/plain</span><br></pre></td></tr></table></figure></p><p>凡是不同时满足上面两个条件，就属于<code>非简单请求</code>。<br>浏览器对这两种请求的处理，是不一样的。</p><h6 id="CORS简单请求"><a href="#CORS简单请求" class="headerlink" title="CORS简单请求"></a>CORS简单请求</h6><p>对于简单请求，浏览器直接发出<code>CORS</code>请求。具体来说，就是在头信息之中，增加一个<code>Origin(protocal + host + path + port)</code>字段,来标明这个请求是来自哪里。<br>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>　　如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest的onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。<br>　　如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。<br>（1）Access-Control-Allow-Origin<br>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。<br>（2）Access-Control-Allow-Credentials<br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。<br>（3）Access-Control-Expose-Headers<br>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。<br>withCredentials 属性<br>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。<br><code>Access-Control-Allow-Credentials: true</code><br>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>否则，即使服务器同意发送<code>Cookie</code>，浏览器也不会发送。或者，服务器要求设置<code>Cookie</code>，浏览器也不会处理。<br>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送<code>Cookie</code>。这时，可以显式关闭<code>withCredentials</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，如果要发送<code>Cookie</code>，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，<code>Cookie</code>依然遵循同源政策，只有用服务器域名设置的<code>Cookie</code>才会上传，其他域名的<code>Cookie</code>并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的<code>Cookie</code>。</p><h6 id="CORS非简单请求"><a href="#CORS非简单请求" class="headerlink" title="CORS非简单请求"></a>CORS非简单请求</h6><p>与<code>简单请求</code>最大的不同在于，<code>非简单请求</code>实际上是发送了两个请求。<br><strong>预请求</strong><br>首先，在正式请求之前，会先发送一个预请求(preflight-request)，这个请求的作用是尽可能少的携带信息，供服务端判断是否响应该请求。<br><strong>浏览器</strong><br>浏览器发送预请求，请求的 Request Method 会设置为 options。<br>另外，还会带上这几个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin: 同简单请求的origin</span><br><span class="line">Access-Control-Request-Method: 请求将要使用的方法</span><br><span class="line">Access-Control-Request-Headers: 浏览器会额外发送哪些头信息</span><br></pre></td></tr></table></figure></p><p><strong>服务端</strong><br>服务端收到预请求之后会根据request中的origin,Access-Control-Request-Method和Access-Control-Request-Headers判断是否响应该请求。<br>如果判断响应这个请求，返回的response中将会携带：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: origin</span><br><span class="line">Access-Control-Allow-Methods: like request</span><br><span class="line">Access-Control-Allow-Headers: like request</span><br></pre></td></tr></table></figure></p><p>如果否定这个请求，直接返回不带这三个字段的response就可以，浏览器将会把这种返回判断为失败的返回，触发onerror方法<br><strong>正式响应</strong><br>如果预请求被正确响应，接下来就会发送正式请求，正式请求的request和正常的 ajax 请求基本没有区别，只是会携带 origin 字段；response和简单请求一样，会携带上Access-Control-*这些字段</p><h5 id="WebScoket"><a href="#WebScoket" class="headerlink" title="WebScoket"></a>WebScoket</h5><p>websocket 不遵循同源策略。</p><p>但是在 websocket 请求头中会带上 origin 这个字段，服务端可以通过这个字段来判断是否需要响应，在浏览器端并没有做任何限制。</p><h5 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h5><h5 id="代理请求方式"><a href="#代理请求方式" class="headerlink" title="代理请求方式"></a>代理请求方式</h5>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;转载:&lt;br&gt;　　&lt;a href=&quot;https://segmentfault.com/a/1190000012469713&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ajax跨域，这应该是最全的解决方案了&lt;/a&gt;&lt;br&gt;参考:&lt;br&gt;　　&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浏览器同源政策及其规避方法&lt;/a&gt;&lt;br&gt;　　&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/cors.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;跨域资源共享 CORS 详解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;同源即指：协议相同、域名相同、端口号相同。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ajax" scheme="http://yoursite.com/categories/Ajax/"/>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>Axios</title>
    <link href="http://yoursite.com/2019/03/17/Ajax/Axios/"/>
    <id>http://yoursite.com/2019/03/17/Ajax/Axios/</id>
    <published>2019-03-17T07:55:58.000Z</published>
    <updated>2019-03-17T12:55:16.713Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># helpers.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"># 定义常量ERR_OK</span><br><span class="line"><span class="keyword">const</span> ERR_OK = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 导出一个getDate方法</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getDate(url) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(url, &#123;</span><br><span class="line">      params</span><br><span class="line">      # 成功之后的.then方法</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      # 通过结构赋值的方法难道error和data的数值</span><br><span class="line">      <span class="keyword">const</span> &#123; error, data&#125; = res.data</span><br><span class="line">      # 如果成功的话，返回data数据</span><br><span class="line">      <span class="keyword">if</span>(error === ERR_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">      &#125;</span><br><span class="line">      # 如果失败的话打印失败的原因</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) =&gt; </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"error:"</span>, error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 出口文件</span><br><span class="line"># index.js</span><br><span class="line"><span class="keyword">import</span> &#123; getDate &#125; <span class="keyword">from</span> <span class="string">'./helpers'</span></span><br><span class="line"></span><br><span class="line"># 定义getSeller方法</span><br><span class="line"><span class="keyword">const</span> getSeller = getDate(<span class="string">'./api/seller'</span>)</span><br><span class="line"></span><br><span class="line"># 导出getSeller方法</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  getSeller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="Axios" scheme="http://yoursite.com/categories/Axios/"/>
    
    
      <category term="Axios" scheme="http://yoursite.com/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="http://yoursite.com/2019/03/16/Ajax/Ajax/"/>
    <id>http://yoursite.com/2019/03/16/Ajax/Ajax/</id>
    <published>2019-03-16T09:09:14.000Z</published>
    <updated>2019-03-16T09:10:31.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Ajax" scheme="http://yoursite.com/categories/Ajax/"/>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/15/JavaScript/index/"/>
    <id>http://yoursite.com/2019/03/15/JavaScript/index/</id>
    <published>2019-03-15T02:25:58.824Z</published>
    <updated>2019-03-26T09:19:03.467Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>test</title><script src="https://unpkg.com/axios/dist/axios.min.js"></script><style>body {background: yellow;}@media not all and (min-width: 400px) {body {background: blue;}}</style></head><script>localStorage.setItem('x', 121313);localStorage.setItem('xxxx', 'baozhen');localStorage.getItem('x');for(let i = 0; i< localStorage.length; i++) {var name = localStorage.key(i);var value = localStorage.getItem(name)console.log("name:", name, "value:", value);}localStorage.removeItem("x");localStorage.clear();</script></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/15/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/vue%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/15/面试题-思维/vue面试题/</id>
    <published>2019-03-15T01:03:34.091Z</published>
    <updated>2019-03-15T01:03:44.046Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单自我介绍, 做过哪些项目, 使用哪些技术栈 ?<br>如何看待前端框架选型 ?<br>vue的如何实现双向绑定的 ？<br>react 虚拟DOM 是什么? 如何实现? 说一下diff算法 ?<br>工作中最出色的点, 和你最头疼的问题 如何解决的 ?<br>平时如何学习, 最近接触了解了哪些新的知识 ?<br>技术一面<br>简单自我介绍, 介绍一下你的项目, 技术栈 ?<br>react和vue的比较 ?<br>React Diff 算法 ?<br>观察者模式实现 ?<br>http报文头部有哪些字段? 有什么意义 ?<br>移动端高清方案如何解决 ?<br>webpack的原理, loader 和 plugin 是干什么的? 有自己手写过么 ?<br>简述从网页输入url到网页展示的过程发生了哪些事情 ?<br>SSR 和 客户端渲染有什么区别 , vue是如何实现绑定事件的 ?<br>简述公司node架构中容灾的实现 ?<br>浏览器事件有哪些过程? 为什么一般在冒泡阶段, 而不是在捕获阶段注册监听? addEventListener 参数分别是什么 ?<br>面向对象如何实现? 需要复用的变量 怎么处理 ?<br>移动端300ms延时的原因? 如何处理?<br>主流框架的数据单向/双向绑定实现原理 ?<br>简述转行经历, 如何学习 ?<br>你觉得自己在前端工作的最大的优点是什么 拿实际工作的内容举例?<br>技术二面<br>和一面前3问基本一致,简述项目,React vue区别 virsualDOM实现<br>DIFF算法为什么是O(n)复杂度而不是O(n^3)<br>http code码?<br>移动端rem布局如何实现? 简述原理?<br>JSbridge原理, js和native是如何通信的?<br>Rollup和webpack区别, treeshaking是什么?<br>TCP三次握手的过程, get post请求的区别 ?<br>静态文件的浏览器缓存如何实现?<br>前端跨域方案<br>http 请求包含哪些字段 分别是什么意思<br>js 有哪些数据类型 如何判断? null 和 undefined区别 应用场景?<br>new String(‘a’) 和 ‘a’ 是一样的么?<br>移动端如何实现下拉到底部 跟随移动 结束后回弹的动画?<br>移动端如何优化首页白屏时间过长 ?<br>ES6 generator函数简述<br>数组去重实现?<br>js浮点数运算不精确 如何解决?<br>工作中最得意和出色的点, 头疼的点, 问题如何解决的<br>为何换工作?<br>聊了下阿里的压力,文化<br>技术三面<br>公司的前端工程化实践<br>转行之后是如何自学前端的, 学习途径 有没有一些自己的代码<br>DOM基础知识,添加元素,删除元素等等…<br>DOM节点类型<br>正则表达式如何匹配一段url ?在正则表达式中有哪几种作用?<br>移动端优化方式? 离线包是如何实现的?</p><p><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">https://ustbhuangyi.github.io/vue-analysis/</a></p><p>我的手机 2019/3/14 10:04:34<br><a href="https://www.jianshu.com/p/a804606ad8e9" target="_blank" rel="noopener">https://www.jianshu.com/p/a804606ad8e9</a></p><p>我的手机 2019/3/14 10:04:50<br><a href="https://www.cnblogs.com/chinabin1993/p/9115396.html" target="_blank" rel="noopener">https://www.cnblogs.com/chinabin1993/p/9115396.html</a></p><p>我的手机 2019/3/14 10:05:03<br><a href="https://segmentfault.com/a/1190000012996217" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012996217</a></p><p>我的手机 2019/3/14 10:05:20<br><a href="https://blog.csdn.net/qq_35430000/article/details/79291287" target="_blank" rel="noopener">https://blog.csdn.net/qq_35430000/article/details/79291287</a></p><p>我的手机 2019/3/14 10:05:37<br><a href="https://m.jb51.net/article/140581.htm" target="_blank" rel="noopener">https://m.jb51.net/article/140581.htm</a></p><p><a href="https://yukwan.cn/fronttech/front-end/" target="_blank" rel="noopener">https://yukwan.cn/fronttech/front-end/</a><br>2019/3/8 16:31:10<br>我的手机 2019/3/8 16:31:10<br><a href="https://mp.weixin.qq.com/s/L8P0RIXym4myfknzM5Nsog" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/L8P0RIXym4myfknzM5Nsog</a><br>2019/3/9 16:28:42<br>我的手机 2019/3/9 16:28:42<br><a href="https://campushr.hikvision.com/JobDetails.html?id=057c01652bb444b597345337c7b8c14f&amp;type=0" target="_blank" rel="noopener">https://campushr.hikvision.com/JobDetails.html?id=057c01652bb444b597345337c7b8c14f&amp;type=0</a></p><p><a href="https://wx2.sinaimg.cn/mw690/005NaMhPly1g0nayy8lbij30hs59p7wh.jpg?from=singlemessage" target="_blank" rel="noopener">https://wx2.sinaimg.cn/mw690/005NaMhPly1g0nayy8lbij30hs59p7wh.jpg?from=singlemessage</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/15/JavaScript/%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2019/03/15/JavaScript/学习知识点/</id>
    <published>2019-03-15T01:02:08.431Z</published>
    <updated>2019-03-16T08:52:17.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h3><h3 id="在HTML中使用JavaScript"><a href="#在HTML中使用JavaScript" class="headerlink" title="在HTML中使用JavaScript"></a>在HTML中使用JavaScript</h3><h4 id="混杂模式与标准模式"><a href="#混杂模式与标准模式" class="headerlink" title="混杂模式与标准模式"></a>混杂模式与标准模式</h4><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>变量、函数名和操作符都区分大小写</p><p>标识符，就是指变量、函数、属性的名字，或者函数的参数。ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的<br>首字母大写</p><p>严格模式： “use strict”; </p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><blockquote><p>简单数据类型(基本数据类型)：Undefined、Null、Boolean、Number、String  <br><br>复杂数据类型：Object      <br><br>typeof 操作符来区分函数和其他对象是有必要的  <br></p></blockquote><h5 id="Undefind"><a href="#Undefind" class="headerlink" title="Undefind"></a>Undefind</h5><p>　　即便未初始化的变量会自动被赋予 undefined 值，但显式地初始化变量依然是<br>明智的选择。如果能够做到这一点，那么当 typeof 操作符返回”undefined”值时，<br>我们就知道被检测的变量还没有被声明，而不是尚未初始化。</p><h5 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h5><h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h5><h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><h6 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h6><h6 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h6><h6 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h6><p>即非数值（Not a Number）<br>ECMAScript 定义了 isNaN()函数。这个函数接受一个参数，该参数可以<br>是任何类型，而函数会帮我们确定这个参数是否“不是数值”。</p><h6 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h6><p>把非数值转换为数值：Number()、parseInt()和 parseFloat()。</p><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><h4 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h4><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h3 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h3><h4 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h4><p>基本类型值指的是<br>简单的数据段，而引用类型值指那些可能由多个值构成的对象</p><h5 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h5><p>如果从一个变量向另一个变量复制<strong>基本类型</strong>的值，会在变量对象上创建一个新值，然后把该值复制<br>到为新变量分配的位置上.<br><br>当从一个变量向另一个变量复制<strong>引用类型</strong>的值时，同样也会将存储在变量对象中的值复制一份放到<br>为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一<br>个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另<br>一个变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = new Object(); </span><br><span class="line">var obj2 = obj1; </span><br><span class="line">obj1.name = <span class="string">"Nicholas"</span>; </span><br><span class="line">alert(obj2.name); //<span class="string">"Nicholas"</span></span><br></pre></td></tr></table></figure></p><h5 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h5><p>typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具 <br></p><p>虽然在检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的<br>用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript<br>提供了 instanceof 操作符，其语法如下所示：<br><code>result = variable instanceof constructor</code></p><h4 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h4><h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><h5 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h5><h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；</li><li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；</li><li>引用类型的值是对象，保存在堆内存中；</li><li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；</li><li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同<br>一个对象；</li><li>确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用<br>instanceof 操作符。</li><li>所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执<br>行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。</li></ol><h5 id="以下是关于执行环境的几点总结："><a href="#以下是关于执行环境的几点总结：" class="headerlink" title="以下是关于执行环境的几点总结："></a>以下是关于执行环境的几点总结：</h5><ul><li>执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；</li><li>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；<br>函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全<br>局环境；</li><li>全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；</li><li>变量的执行环境有助于确定应该何时释放内存。</li><li>JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。</li></ul><h5 id="可以对-JavaScript-的垃圾收集例程作如下总结："><a href="#可以对-JavaScript-的垃圾收集例程作如下总结：" class="headerlink" title="可以对 JavaScript 的垃圾收集例程作如下总结："></a>可以对 JavaScript 的垃圾收集例程作如下总结：</h5><ul><li>离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。<br>“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然<br>后再回收其内存。</li><li>另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript<br>引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种<br>算法仍然可能会导致问题。</li><li>当代码中存在循环引用现象时，“引用计数”算法就会导致问题。</li><li>解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回<br>收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h4><h5 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h5><ul><li>Array类型<ul><li>检测数组  value instanceof Array、 Array.isArray()方</li><li>转换方法 toLocaleString()、toString()和 valueOf()</li><li>栈方法 后进先出 push()、pop()</li><li>队列方法 后进先出 shift()、unshift()</li><li>重排序方法 reverse()、sort()</li><li>操作方法 concat() 连接数组、splice()</li><li>位置方法 indexOf()、lastIndexOf()</li><li>迭代方法<ul><li>every()  全部</li><li>filter() 筛选</li><li>forEach()</li><li>map() </li><li>some() 存在</li></ul></li><li>归并方法<ul><li>reduce()</li><li>reduceRight()</li></ul></li></ul></li><li>Date类型<ul><li>new Date()、Date.parse() 、Date.UTC()</li><li>继承的方法</li><li>日期格式化方法<ul><li>toDateString()——以特定于实现的格式显示星期几、月、日和年</li><li>toTimeString()——以特定于实现的格式显示时、分、秒和时区；</li><li>toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年</li><li>toLocaleTimeString()——以特定于实现的格式显示时、分、秒</li><li>toUTCString()——以特定于实现的格式完整的 UTC 日期</li></ul></li><li>日期/时间组件<ul><li>getTime() 返回表示日期的毫秒数；与valueOf()方法返回的值相同</li><li>setTime(毫秒) 以毫秒数设置日期，会改变整个日期</li><li>getFullYear() 取得4位数的年份（如2007而非仅07）</li><li>getUTCFullYear() 返回UTC日期的4位数年份</li></ul></li></ul></li><li>RegExp()类型</li><li>Function类型<ul><li>没有重载</li><li>函数声明与函数表达式<ul><li>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）</li><li>至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真<br>正被解释执行。</li></ul></li><li>作为值的函数</li><li>函数内部属性<ul><li>arguments</li><li>this</li><li>callee</li></ul></li><li>函数属性和方法<ul><li>length</li><li>prototype</li><li>apply()</li><li>call()</li></ul></li><li>基本包装类型<ul><li>Boolean类型</li><li>Number<ul><li>toFixed()方法会按照指定的小数位返回数值的字符串表示</li><li>toExponential()</li></ul></li><li>String<ul><li>trim()方法： 这个方法会创建一个字符串的副本，删除前置及<br>后缀的所有空格，然后返回结果</li><li>字符串大小写转换方法<ul><li>toLowerCase()</li><li>toLocaleLowerCase()</li><li>toUpperCase()</li><li>toLocaleUpperCase()。</li></ul></li></ul></li><li>字符串的模式匹配方法</li><li>localeCompare()</li><li>localeCompare()</li><li>fromCharCode()</li></ul></li><li>单体内置对象<ul><li>Global对象</li><li>Math对象<ul><li>Math对象的属性</li><li>min()、max()</li><li>舍入方法<ul><li>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数</li><li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数</li><li>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</li></ul></li><li>random() Math.radom()</li></ul></li></ul></li></ul></li></ul><p>160</p><h4 id="创建并操作数组"><a href="#创建并操作数组" class="headerlink" title="创建并操作数组"></a>创建并操作数组</h4><h4 id="基本的JavaScript类型"><a href="#基本的JavaScript类型" class="headerlink" title="基本的JavaScript类型"></a>基本的JavaScript类型</h4><h4 id="基本类型和基本包装类型"><a href="#基本类型和基本包装类型" class="headerlink" title="基本类型和基本包装类型"></a>基本类型和基本包装类型</h4><h3 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h3><h4 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h4><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><h3 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a>客户端检测</h3><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><h3 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h3><h3 id="DOM2和DOM3"><a href="#DOM2和DOM3" class="headerlink" title="DOM2和DOM3"></a>DOM2和DOM3</h3><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h3 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h3><h3 id="使用Canvas绘图"><a href="#使用Canvas绘图" class="headerlink" title="使用Canvas绘图"></a>使用Canvas绘图</h3><h3 id="HTML5脚本编程"><a href="#HTML5脚本编程" class="headerlink" title="HTML5脚本编程"></a>HTML5脚本编程</h3><h3 id="错误处理与调试"><a href="#错误处理与调试" class="headerlink" title="错误处理与调试"></a>错误处理与调试</h3><h3 id="JavaScript与XML"><a href="#JavaScript与XML" class="headerlink" title="JavaScript与XML"></a>JavaScript与XML</h3><h3 id="E4X"><a href="#E4X" class="headerlink" title="E4X"></a>E4X</h3><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><h3 id="Ajax与Comet"><a href="#Ajax与Comet" class="headerlink" title="Ajax与Comet"></a>Ajax与Comet</h3><h3 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h3><h3 id="离线应用和客户端储存"><a href="#离线应用和客户端储存" class="headerlink" title="离线应用和客户端储存"></a>离线应用和客户端储存</h3><h3 id="最佳实战"><a href="#最佳实战" class="headerlink" title="最佳实战"></a>最佳实战</h3><h3 id="新兴的API"><a href="#新兴的API" class="headerlink" title="新兴的API"></a>新兴的API</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>客户端渲染和服务端渲染详细执行流程</title>
    <link href="http://yoursite.com/2019/03/14/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/SSR%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2019/03/14/前端性能优化/SSR和客户端渲染/</id>
    <published>2019-03-14T13:09:08.000Z</published>
    <updated>2019-03-14T13:30:12.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>客户端渲染：CSR (client side render)<br>在服务端放了一个html 页面，里面有<script>//发请求，拿数据，模版引擎渲染等，$.ajax  ,</script><br>客户端发起请求，服务端把页面（响应的是字符串）发送过去，客户端从上到下依次解析，如果在解析的过程中，发现ajax<br>请求，再次像服务器发送新的请求，客户端拿到ajax 响应结果，模板引擎渲染。<br>过程至少和服务端发起两次请求</p></li><li><p>服务端渲染：SSR (server side render)<br>sever 端页面+数据，服务端过程：<br>1.读取index.html<br>2.模版进行渲染，在发送给客户端之前，在服务端已经把index.html 渲染处理了。var 渲染结果 = tempeter.render(模板字符串，｛解析替换对象｝)   response.end(渲染结果)，服务端响应的就是最总的结果<br>服务端只请求一次<br>多数网站既有服务端渲染又有客户端渲染</p></li><li><p>服务端渲染和客户端渲染的区别</p><ul><li>客户端渲染不利于 SEO 搜索引擎优化</li><li>服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的</li><li>所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的</li><li>而是两者结合来做的</li><li>例如京东的商品列表就采用的是服务端渲染，目的了为了 SEO 搜索引擎优化</li><li>而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端性能优化" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件间通信&amp;传值</title>
    <link href="http://yoursite.com/2019/03/14/Vue/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1&amp;%E4%BC%A0%E5%80%BC/"/>
    <id>http://yoursite.com/2019/03/14/Vue/Vue组件间通信&amp;传值/</id>
    <published>2019-03-14T02:18:02.000Z</published>
    <updated>2019-03-14T12:41:39.999Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- 目录 --><!-- toc --><p>转载：<br>　　<a href="https://blog.csdn.net/qq_35430000/article/details/79291287" target="_blank" rel="noopener">vue通信、传值的多种方式（详细）</a><br>　　<a href="https://www.jianshu.com/p/a804606ad8e9" target="_blank" rel="noopener">Vue.js——十分钟入门Vuex</a></p><h4 id="通过路由带参数进行传值"><a href="#通过路由带参数进行传值" class="headerlink" title="通过路由带参数进行传值"></a>通过路由带参数进行传值</h4><ol><li>两个组件 A和B,A组件通过query把orderId传递给B组件（触发事件可以是点击事件、钩子函数等）<br><code>this.$router.push({ path: &#39;/conponentsB&#39;, query: { orderId: 123 } }) // 跳转到B</code></li><li>在B组件中获取A组件传递过来的参数<br><code>this.$route.query.orderId</code><a id="more"></a></li></ol><h4 id="通过设置-Session-Storage缓存的形式进行传递"><a href="#通过设置-Session-Storage缓存的形式进行传递" class="headerlink" title="通过设置 Session Storage缓存的形式进行传递"></a>通过设置 Session Storage缓存的形式进行传递</h4><ol><li><p>两个组件A和B，在A组件中设置缓存orderData</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const orderData = &#123; &apos;orderId&apos;: 123, &apos;price&apos;: 88 &#125;</span><br><span class="line"> </span><br><span class="line">sessionStorage.setItem(&apos;缓存名称&apos;, JSON.stringify(orderData))</span><br></pre></td></tr></table></figure></li><li><p>B组件就可以获取在A中设置的缓存了<br><code>const dataB = JSON.parse(sessionStorage.getItem(&#39;缓存名称&#39;))</code><br>此时 dataB 就是数据 orderData</p><h4 id="父子组件之间的传值"><a href="#父子组件之间的传值" class="headerlink" title="父子组件之间的传值"></a>父子组件之间的传值</h4><h5 id="父组件往子组件传值props"><a href="#父组件往子组件传值props" class="headerlink" title="父组件往子组件传值props"></a>父组件往子组件传值props</h5><p>①定义父组件，父组件传递 number这个数值给子组件，如果传递的参数很多，推荐使用json数组{}的形式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"parent"</span>&gt;  <span class="comment"># 例如：传递数组88给子组件</span></span><br><span class="line">    &lt;children number=888&gt;&lt;/children&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">import Children from <span class="string">'components/children'</span>  <span class="comment"># 引入子组件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>②定义子组件，子组件通过 props方法获取父组件传递过来的值。props中可以定义能接收的数据类型，如果不符合会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># children.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"children"</span>&gt;</span><br><span class="line">    &#123;&#123;number&#125;&#125;  <span class="comment"># 显示父组件传递过来的值，显示88</span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  props: &#123;  <span class="comment"># 限制父组件传递过来的数据类型，如果不符合就报错</span></span><br><span class="line">    <span class="string">'number'</span>: [Number, String, Object],</span><br><span class="line">    <span class="string">'string'</span>: [String] <span class="comment">#可以传递多个值，逗号隔开</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然也可以简单一点，如果不考虑数据类型，直接 props:[“number”,”string”]就可以了,中括号包裹，多个值使用，分隔。<br>③假如接收的参数 是动态的，比如 input输入的内容 v-model的形式<br><strong>注意</strong>：传递的参数名称 支持驼峰命名，下面示例描述不正确（1.0是不支持的）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"parent"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"inputText"</span>&gt;</span><br><span class="line">    &lt;children :input-val = <span class="string">'inputText'</span>&gt;&lt;/children&gt; </span><br><span class="line">    <span class="comment"># 注意 :input-val 不支持驼峰命名，建议 - 分割 </span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import Children from <span class="string">'components/children'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"children"</span>&gt;</span><br><span class="line">    &#123;&#123;inputVal&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="string">'input-val'</span>: [String]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④父子组件传值，数据是异步请求，有可能数据渲染时报错<br>原因：异步请求时，数据还没有获取到但是此时已经渲染节点了<br>解决方案：可以在 父组件需要传递数据的节点加上<code>v-if = false</code>,异步请求获取数据后,<code>v-if = true</code></p><h5 id="子组件往父组件传值，通过emit事件"><a href="#子组件往父组件传值，通过emit事件" class="headerlink" title="子组件往父组件传值，通过emit事件"></a>子组件往父组件传值，通过emit事件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># children.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=<span class="string">"children"</span>&gt;</span><br><span class="line">      &lt;button @click=<span class="string">"emitToParent"</span>&gt;按钮点击传值给父组件&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">emitToParent</span></span>() &#123;</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">'child-event'</span>, <span class="string">'我是子组件往父组件传递的内容'</span>)</span><br><span class="line">      <span class="comment"># child-event 不支持驼峰命名</span></span><br><span class="line">      <span class="comment"># 子组件通过emit事件给父组件传递内容</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"parent"</span>&gt; <span class="comment"># 触发父组件的一个方法，然后进行相应的操作</span></span><br><span class="line">    &lt;children @child-event=<span class="string">"parentEvent"</span>&gt;&lt;/children&gt;</span><br><span class="line">    <span class="comment"># @child-event 这是子组件自定义的方法</span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import Children from <span class="string">'components/children'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    parentEvent(data) &#123; </span><br><span class="line">      <span class="comment"># data 就是子组件传递过来的数据</span></span><br><span class="line">      console.log(data)</span><br><span class="line">      <span class="comment"># 我是子组件往父组件传递的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用-vuex）"><a href="#不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用-vuex）" class="headerlink" title="不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用 vuex）"></a>不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用 vuex）</h4><p>①定义一个新的vue实例专门用于传递数据，并导出<br><br>就是定义一个公共的传值用的组件进行数据的交互<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建文佳eventBus.js</span></span><br><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line"><span class="built_in">export</span> default new Vue()</span><br></pre></td></tr></table></figure></p><p>②定义传递的方法名和传输内容，点击事件或钩子函数触发eventBus.emit事件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># componentA.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"componentsA"</span>&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"emitToB"</span>&gt;按钮点击传递数据给兄弟组件B&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import eventBus from <span class="string">'common/js/eventBus.js'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">emitToB</span></span>() &#123;</span><br><span class="line">      eventBus.<span class="variable">$emit</span>(<span class="string">'eventFromA'</span>, <span class="string">'我是组件A传递给组件B的数据'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>③接收传递过来的数据<br>注意：enentBus是一个另一个新的Vue实例，区分两个this所代表得vue实例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">componentB.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"componentsB"</span>&gt;</span><br><span class="line">    &#123;&#123;title&#125;&#125; <span class="comment"># 显示传递过来的值</span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import eventBus from <span class="string">'common/js/eventBus.js'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      title: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">    this.getEventData()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">getEventData</span></span>() &#123;</span><br><span class="line">      const that = this </span><br><span class="line">      <span class="comment">#this是项目vue的实例，用that接收，与eventBus的vue区分</span></span><br><span class="line">      eventBus.<span class="variable">$on</span>(<span class="string">'eventFormA'</span>, <span class="keyword">function</span>(val) &#123;</span><br><span class="line">        that.title = val</span><br><span class="line">        <span class="comment"># this.title = val </span></span><br><span class="line">        <span class="comment"># 这个this指的是eventBus的vue实例</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h4 id="Vuex进行传值"><a href="#Vuex进行传值" class="headerlink" title="Vuex进行传值"></a>Vuex进行传值</h4><h5 id="什么是Vuex"><a href="#什么是Vuex" class="headerlink" title="什么是Vuex"></a>什么是Vuex</h5><p>　　Vuex是一个专门为Vue.js应用程序开发的状态管理模式, 它采用集中式存储管理所有组件的公共状态, 并以相应的规则保证状态以一种可预测的方式发生变化.<br><img src="/assets/images/vuex.png" alt="vuex"><br>　　上图中绿色虚线包裹起来的部分就是Vuex的核心, <code>state</code>中保存的就是公共状态, 改变<code>state</code>的唯一方式就是通过<code>mutations</code>进行更改. 可能你现在看这张图有点不明白, 等经过本文的解释和案例演示, 再回来看这张图, 相信你会有更好的理解.</p><h5 id="为什么要使用Vuex"><a href="#为什么要使用Vuex" class="headerlink" title="为什么要使用Vuex"></a>为什么要使用Vuex</h5><p>　　试想这样的场景, 比如一个Vue的根实例下面有一个根组件名为App.vue, 它下面有两个子组件A.vue和B.vue, App.vue想要与A.vue或者B.vue通讯可以通过props传值的方式, 但是如果A.vue和B.vue之间的通讯就很麻烦了, 他们需要共有的父组件通过自定义事件进行实现, A组件想要和B组件通讯往往是这样的:<br><img src="/assets/images/vuex1.png" alt="vuex"></p><ul><li>A组件说: “报告老大, 能否帮我托个信给小弟B” =&gt; dispatch一个事件给App</li><li>App老大说: “包在我身上, 它需要监听A组件的dispatch的时间, 同时需要broadcast一个事件给B组件”</li><li>B小弟说: “信息已收到”, 它需要on监听App组件分发的事件</li></ul><p>　　这只是一条通讯路径, 如果父组件下有多个子组件, 子组件之间通讯的路径就会变的很繁琐, 父组件需要监听大量的事件, 还需要负责分发给不同的子组件, 很显然这并不是我们想要的组件化的开发体验.<br><strong>Vuex就是为了解决这一问题出现的</strong></p><h5 id="如何引入Vuex"><a href="#如何引入Vuex" class="headerlink" title="如何引入Vuex"></a>如何引入Vuex</h5><p>下载vuex: <code>npm install vuex --save</code> <br><br>在<code>main.js</code>添加:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import Vuex from <span class="string">'vuex'</span></span><br><span class="line"><span class="comment"># 使用vuex</span></span><br><span class="line">Vue.use( Vuex );</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    //待添加</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    store,</span><br><span class="line">    render: h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="Vuex的核心概念"><a href="#Vuex的核心概念" class="headerlink" title="Vuex的核心概念"></a>Vuex的核心概念</h5><p>　　在介绍Vuex的核心概念之前, 我使用<code>vue-cli</code>初始化了一个demo, 准备以代码的形式来说明Vuex的核心概念,这个demo分别有两个组件<code>ProductListOne.vue</code>和<code>ProductListTwo.vue</code>, 在<code>App.vue</code>的d<code>atat</code>中保存着共有的商品列表, 代码和初始化的效果如下图所示:<br><img src="/assets/images/vuex2.png" alt="vuex"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//App.vue中的初始化代码</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;product-list-one v-bind:products=<span class="string">"products"</span>&gt;&lt;/product-list-one&gt;</span><br><span class="line">    &lt;product-list-two v-bind:products=<span class="string">"products"</span>&gt;&lt;/product-list-two&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ProductListOne from <span class="string">'./components/ProductListOne.vue'</span></span><br><span class="line">import ProductListTwo from <span class="string">'./components/ProductListTwo.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    name: <span class="string">'app'</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">'product-list-one'</span>: ProductListOne,</span><br><span class="line">        <span class="string">'product-list-two'</span>: ProductListTwo</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products: [</span><br><span class="line">                &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">                &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">                &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">                &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">body&#123;</span><br><span class="line">  font-family: Ubuntu;</span><br><span class="line">  color: <span class="comment">#555;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//ProductListOne.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"product-list-one"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Product List One&lt;/h2&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=<span class="string">"product in products"</span>&gt;</span><br><span class="line">                &lt;span class=<span class="string">"name"</span>&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span class=<span class="string">"price"</span>&gt;<span class="variable">$&#123;&#123; product.price &#125;</span>&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    props: [<span class="string">'products'</span>],</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="comment">#product-list-one&#123;</span></span><br><span class="line">    background: <span class="comment">#FFF8B1;</span></span><br><span class="line">    box-shadow: 1px 2px 3px rgba(0,0,0,0.2);</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">    padding: 10px 20px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#product-list-one ul&#123;</span></span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#product-list-one li&#123;</span></span><br><span class="line">    display: inline-block;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    background: rgba(255,255,255,0.7);</span><br><span class="line">&#125;</span><br><span class="line">.price&#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    color: <span class="comment">#E8800C;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//ProductListTwo.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"product-list-two"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Product List Two&lt;/h2&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=<span class="string">"product in products"</span>&gt;</span><br><span class="line">                &lt;span class=<span class="string">"name"</span>&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span class=<span class="string">"price"</span>&gt;<span class="variable">$&#123;&#123; product.price &#125;</span>&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    props: [<span class="string">'products'</span>],</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="comment">#product-list-two&#123;</span></span><br><span class="line">    background: <span class="comment">#D1E4FF;</span></span><br><span class="line">    box-shadow: 1px 2px 3px rgba(0,0,0,0.2);</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">    padding: 10px 20px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#product-list-two ul&#123;</span></span><br><span class="line">    padding: 0;</span><br><span class="line">    list-style-type: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#product-list-two li&#123;</span></span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    background: rgba(255,255,255,0.7);</span><br><span class="line">&#125;</span><br><span class="line">.price&#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    color: <span class="comment">#860CE8;</span></span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h6 id="State"><a href="#State" class="headerlink" title="State"></a>State</h6><p>　　<code>state</code>就是Vuex中的公共的状态, 我是将<code>state</code>看作是所有组件的data, 用于保存所有组件的公共数据.</p><ol><li>此时我们就可以把App.vue中的两个组件共同使用的data抽离出来, 放到<code>state</code>中,代码如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.js</span></span><br><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import App from <span class="string">'./App.vue'</span></span><br><span class="line">import Vuex from <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use( Vuex )</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state:&#123; </span><br><span class="line">    products: [</span><br><span class="line">      &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">      &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">      &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">      &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>此时,<code>ProductListOne.vue</code>和<code>ProductListTwo.vue</code>也需要做相应的更改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ProductListOne.vue</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products : this.<span class="variable">$store</span>.state.products //获取store中state的数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ProductListTwo.vue</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products: this.<span class="variable">$store</span>.state.products //获取store中state的数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的页面如下图所示, 可以看到, 将公共数据抽离出来后, 页面没有发生变化.<br><img src="/assets/images/vuex3.png" alt="vuex"></p><h6 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h6><p>　　我将getters属性理解为所有组件的<code>computed</code>属性, 也就是计算属性. <code>vuex</code>的官方文档也是说到可以将<code>getter</code>理解为<code>store</code>的计算属性, <code>getters</code>的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>　　此时,我们可以在main.js中添加一个<code>getters</code>属性, 其中的<code>saleProducts</code>对象将state中的价格减少一半(除以2)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.js</span></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    products: [</span><br><span class="line">      &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">      &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">      &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">      &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters:&#123; //添加getters</span><br><span class="line">    saleProducts: (state) =&gt; &#123;</span><br><span class="line">      <span class="built_in">let</span> saleProducts = state.products.map( product =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">          name: product.name,</span><br><span class="line">          price: product.price / 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">return</span> saleProducts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>将<code>productListOne.vue</code>中的<code>products</code>的值更换为<code>this.$store.getters.saleProducts</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products : this.<span class="variable">$store</span>.getters.saleProducts </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在的页面中,Product List One中的每项商品的价格都减少了一半<br><img src="/assets/images/vuex4.png" alt="vuex"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">###### Mutations</span></span><br><span class="line">　　我将mutaions理解为store中的methods, mutations对象中保存着更改数据的回调函数,该函数名官方规定叫<span class="built_in">type</span>, 第一个参数是state, 第二参数是payload, 也就是自定义的参数.</span><br><span class="line"></span><br><span class="line">下面,我们在main.js中添加mutations属性,其中minusPrice这个回调函数用于将商品的价格减少payload这么多, 代码如下:</span><br><span class="line">```bash</span><br><span class="line">//main.js</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    products: [</span><br><span class="line">      &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">      &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">      &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">      &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters:&#123;</span><br><span class="line">    saleProducts: (state) =&gt; &#123;</span><br><span class="line">      <span class="built_in">let</span> saleProducts = state.products.map( product =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">          name: product.name,</span><br><span class="line">          price: product.price / 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">return</span> saleProducts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123; //添加mutations</span><br><span class="line">    minusPrice (state, payload ) &#123;</span><br><span class="line">      <span class="built_in">let</span> newPrice = state.products.forEach( product =&gt; &#123;</span><br><span class="line">        product.price -= payload</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在<code>ProductListTwo.vue</code>中添加一个按钮,为其添加一个点击事件, 给点击事件触发<code>minusPrice</code>方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ProductListTwo.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"product-list-two"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Product List Two&lt;/h2&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=<span class="string">"product in products"</span>&gt;</span><br><span class="line">                &lt;span class=<span class="string">"name"</span>&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span class=<span class="string">"price"</span>&gt;<span class="variable">$&#123;&#123; product.price &#125;</span>&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;button @click=<span class="string">"minusPrice"</span>&gt;减少价格&lt;/button&gt; //添加按钮</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>在<code>ProductListTwo.vue</code>中注册<code>minusPrice</code>方法, 在该方法中<code>commitmutations</code>中的<code>minusPrice</code>这个回调函数<br><strong>注意:调用<code>mutaions</code>中回调函数, 只能使用<code>store.commit(type, payload)</code></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ProductListTwo.vue</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products: this.<span class="variable">$store</span>.state.products</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">minusPrice</span></span>() &#123;</span><br><span class="line">            this.<span class="variable">$store</span>.commit(<span class="string">'minusPrice'</span>, 2); //提交`minusPrice,payload为2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加按钮, 可以发现,<code>Product List Two</code>中的价格减少了2, 当然你可以自定义<code>payload</code>,以此自定义减少对应的价格.<br><img src="/assets/images/vuex5.png" alt="vuex"></p><h6 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h6><p><code>actions</code> 类似于 <code>mutations</code>，不同在于：<br><code>actions</code>提交的是<code>mutations</code>而不是直接变更状态<br><code>actions</code>中可以包含异步操作, <code>mutations</code>中绝对不允许出现异步<br><code>actions</code>中的回调函数的第一个参数是<code>context</code>, 是一个与<code>store</code>实例具有相同属性和方法的对象<br>　　此时,我们在<code>store</code>中添加<code>actions</code>属性, 其中<code>minusPriceAsync</code>采用<code>setTimeout</code>来模拟异步操作,延迟2s执行 该方法用于异步改变我们刚才在<code>mutaions</code>中定义的<code>minusPrice</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    products: [</span><br><span class="line">      &#123;name: <span class="string">'鼠标'</span>, price: 20&#125;,</span><br><span class="line">      &#123;name: <span class="string">'键盘'</span>, price: 40&#125;,</span><br><span class="line">      &#123;name: <span class="string">'耳机'</span>, price: 60&#125;,</span><br><span class="line">      &#123;name: <span class="string">'显示屏'</span>, price: 80&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters:&#123;</span><br><span class="line">    saleProducts: (state) =&gt; &#123;</span><br><span class="line">      <span class="built_in">let</span> saleProducts = state.products.map( product =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">          name: product.name,</span><br><span class="line">          price: product.price / 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">return</span> saleProducts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123;</span><br><span class="line">    minusPrice (state, payload ) &#123;</span><br><span class="line">      <span class="built_in">let</span> newPrice = state.products.forEach( product =&gt; &#123;</span><br><span class="line">        product.price -= payload</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions:&#123; //添加actions</span><br><span class="line">    minusPriceAsync( context, payload ) &#123;</span><br><span class="line">      setTimeout( () =&gt; &#123;</span><br><span class="line">        context.commit( <span class="string">'minusPrice'</span>, payload ); //context提交</span><br><span class="line">      &#125;, 2000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在<code>ProductListTwo.vue</code>中添加一个按钮,为其添加一个点击事件, 给点击事件触发<code>minusPriceAsync</code>方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"product-list-two"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Product List Two&lt;/h2&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=<span class="string">"product in products"</span>&gt;</span><br><span class="line">                &lt;span class=<span class="string">"name"</span>&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span class=<span class="string">"price"</span>&gt;<span class="variable">$&#123;&#123; product.price &#125;</span>&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;button @click=<span class="string">"minusPrice"</span>&gt;减少价格&lt;/button&gt;</span><br><span class="line">            &lt;button @click=<span class="string">"minusPriceAsync"</span>&gt;异步减少价格&lt;/button&gt; //添加按钮</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>在<code>ProductListTwo.vue</code>中注册<code>minusPriceAsync</code>方法, 在该方法中<code>dispatchactions</code>中的<code>minusPriceAsync</code>这个回调函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            products: this.<span class="variable">$store</span>.state.products</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">minusPrice</span></span>() &#123;</span><br><span class="line">            this.<span class="variable">$store</span>.commit(<span class="string">'minusPrice'</span>, 2);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">minusPriceAsync</span></span>() &#123;</span><br><span class="line">            this.<span class="variable">$store</span>.dispatch(<span class="string">'minusPriceAsync'</span>, 5); //分发actions中的minusPriceAsync这个异步函数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加按钮, 可以发现, <code>Product List Two</code>中的价格延迟2s后减少了5<br><img src="/assets/images/vuex6.png" alt="vuex"></p><h6 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h6><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，<code>store</code> 对象就有可能变得相当臃肿。为了解决以上问题，<code>Vuex</code>允许我们将 <code>store</code> 分割成模块<code>（module）</code>。每个模块拥有自己的 <code>state</code>、<code>mutation</code>、<code>action</code>、<code>getter</code>、甚至是嵌套子模块——从上至下进行同样方式的分割</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure><h5 id="mapactions-amp-amp-…mapgetters"><a href="#mapactions-amp-amp-…mapgetters" class="headerlink" title="..mapactions&amp;&amp; …mapgetters"></a>..mapactions&amp;&amp; …mapgetters</h5>]]></content>
    
    <summary type="html">
    
      &lt;!-- 目录 --&gt;
&lt;!-- toc --&gt;
&lt;p&gt;转载：&lt;br&gt;　　&lt;a href=&quot;https://blog.csdn.net/qq_35430000/article/details/79291287&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue通信、传值的多种方式（详细）&lt;/a&gt;&lt;br&gt;　　&lt;a href=&quot;https://www.jianshu.com/p/a804606ad8e9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue.js——十分钟入门Vuex&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;通过路由带参数进行传值&quot;&gt;&lt;a href=&quot;#通过路由带参数进行传值&quot; class=&quot;headerlink&quot; title=&quot;通过路由带参数进行传值&quot;&gt;&lt;/a&gt;通过路由带参数进行传值&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;两个组件 A和B,A组件通过query把orderId传递给B组件（触发事件可以是点击事件、钩子函数等）&lt;br&gt;&lt;code&gt;this.$router.push({ path: &amp;#39;/conponentsB&amp;#39;, query: { orderId: 123 } }) // 跳转到B&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在B组件中获取A组件传递过来的参数&lt;br&gt;&lt;code&gt;this.$route.query.orderId&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue基础" scheme="http://yoursite.com/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="http://yoursite.com/2019/03/08/CSS3/flex%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2019/03/08/CSS3/flex布局/</id>
    <published>2019-03-08T11:03:14.000Z</published>
    <updated>2019-03-22T12:30:19.334Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>转载：<br>　　阮一峰：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a><br><img src="/assets/images/flex.jpg" alt="flex布局"><br>　　2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。<br><a id="more"></a><br><img src="/assets/images/flexSupport.jpg" alt="flex"></p><h4 id="Flex布局是什么？"><a href="#Flex布局是什么？" class="headerlink" title="Flex布局是什么？"></a>Flex布局是什么？</h4><p>　　Flex 是 <code>Flexible Box</code> 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: felx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>行内元素也可以使用 <code>Flex</code> 布局。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: -webkit-flex; /* Safari */</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="注意，设为-Flex-布局以后，子元素的float、clear和vertical-align属性将失效。"><a href="#注意，设为-Flex-布局以后，子元素的float、clear和vertical-align属性将失效。" class="headerlink" title="注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。"></a>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</h5><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>　　采用 <code>Flex</code> 布局的元素，称为 <code>Flex</code> 容器（<code>flex container</code>），简称”容器”。它的所有子元素自动成为容器成员，称为 <code>Flex</code> 项目（<code>flex item</code>），简称”项目”。<br><img src="/assets/images/flex01.png" alt="flex01"><br>容器默认存在两根轴：水平的主轴（<code>main axis</code>）和垂直的交叉轴（<code>cross axis</code>）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h4 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h4><p>　　以下6个属性设置在容器上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-direction</span><br><span class="line">flex-wrap</span><br><span class="line">flex-flow</span><br><span class="line">justify-content</span><br><span class="line">align-items</span><br><span class="line">align-content</span><br></pre></td></tr></table></figure></p><h5 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h5><p>　　<code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex02.png" alt="flex02"><br>　　它可能有4个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row（默认值）：主轴为水平方向，起点在左端。</span><br><span class="line">row-reverse：主轴为水平方向，起点在右端。</span><br><span class="line">column：主轴为垂直方向，起点在上沿。</span><br><span class="line">column-reverse：主轴为垂直方向，起点在下沿。</span><br></pre></td></tr></table></figure></p><h5 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h5><p>　　默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。<br><img src="/assets/images/flex03.png" alt="flex03"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　它可能取三个值。<br>（1）<code>nowrap</code>（默认）：不换行。<br><img src="/assets/images/flex04.png" alt="flex04"><br>（2）<code>wrap</code>：换行，第一行在上方。<br><img src="/assets/images/flex05.jpg" alt="flex05"><br>（3）<code>wrap-reverse</code>：换行，第一行在下方。<br><img src="/assets/images/flex06.jpg" alt="flex06"></p><h5 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h5><p>　　<code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h5><p>　　<code>justify-content</code>属性定义了项目在主轴上的对齐方式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex07.png" alt="flex07"><br>　　它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex-start（默认值）：左对齐</span><br><span class="line">flex-end：右对齐</span><br><span class="line">center： 居中</span><br><span class="line">space-between：两端对齐，项目之间的间隔都相等。</span><br><span class="line">space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br></pre></td></tr></table></figure></p><h5 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h5><p>　　<code>align-items</code>属性定义项目在交叉轴上如何对齐。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>建立在主轴为水平方向时测试，即 <code>flex-direction: row</code></strong><br>默认值为 <code>stretch</code> 即如果项目未设置高度或者设为 <code>auto</code>，将占满整个容器的高度。<br><img src="/assets/images/flex08.jpg" alt="flex08"><br>假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。<br><img src="/assets/images/flex08.png" alt="flex08"><br>　　它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex-start：交叉轴的起点对齐。</span><br><span class="line">flex-end：交叉轴的终点对齐。</span><br><span class="line">center：交叉轴的中点对齐。</span><br><span class="line">baseline: 项目的第一行文字的基线对齐。</span><br><span class="line">stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span><br></pre></td></tr></table></figure></p><h5 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h5><p>　　<code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex09.png" alt="flex09"><br>　　该属性可能取6个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-start：与交叉轴的起点对齐。</span><br><span class="line">flex-end：与交叉轴的终点对齐。</span><br><span class="line">center：与交叉轴的中点对齐。</span><br><span class="line">space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</span><br><span class="line">space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</span><br><span class="line">stretch（默认值）：轴线占满整个交叉轴。</span><br></pre></td></tr></table></figure></p><h4 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h4><p>以下6个属性设置在项目上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">order</span><br><span class="line">flex-grow</span><br><span class="line">flex-shrink</span><br><span class="line">flex-basis</span><br><span class="line">flex</span><br><span class="line">align-self</span><br></pre></td></tr></table></figure></p><h5 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h5><p>　　<code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  order: &lt;<span class="built_in">integer</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex10.png" alt="flex10"></p><h5 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h5><p>　　<code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-grow: &lt;number&gt;; /* default 0 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex11.png" alt="flex11"><br>　　如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h5 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h5><p>　　<code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-shrink: &lt;number&gt;; /* default 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex12.jpg" alt="flex12"></p><p>　　如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h5 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h5><p>　　flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><p>.item {<br>  flex-basis: <length> | auto; /<em> default auto </em>/<br>}<br>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</length></p><h5 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h5><p>　　<code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该属性有两个快捷值：<code>auto (1 1 auto)`</code> 和 <code>none (0 0 auto)</code>。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h5 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h5><p>　　<code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/flex13.png" alt="flex13"><br>　　该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;转载：&lt;br&gt;　　阮一峰：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flex 布局教程：语法篇&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/assets/images/flex.jpg&quot; alt=&quot;flex布局&quot;&gt;&lt;br&gt;　　2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
</feed>
