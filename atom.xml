<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>昨夜小楼又东风</title>
  
  <subtitle>纵豆蔻词工，青楼好梦，难赋深情</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-06T11:50:25.251Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LittleStar</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>伪元素和伪类</title>
    <link href="http://yoursite.com/2018/11/16/CSS3/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/11/16/CSS3/伪元素和伪类/</id>
    <published>2018-11-16T11:34:19.000Z</published>
    <updated>2018-11-06T11:50:25.251Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>伪类</strong>包含两种：<strong>状态伪类</strong>和<strong>结构性伪类</strong>。<br><strong>状态伪类</strong>是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。<br>当元素处于某状态时会呈现该样式，而进入另一状态后，该样式也会失去。常见的状态伪类主要包括：</p><p>:link 应用于未被访问过的链接；<br>:hover 应用于鼠标悬停到的元素；<br>:active 应用于被激活的元素；<br>:visited 应用于被访问过的链接，与:link互斥。<br>:focus 应用于拥有键盘输入焦点的元素。<br><strong>结构性伪类</strong>是css3新增选择器，利用dom树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少class和id属性的定义，使文档结构更简洁。常见的包括：</p><p>:first-child 选择某个元素的第一个子元素；<br>:last-child 选择某个元素的最后一个子元素；<br>:nth-child() 选择某个元素的一个或多个特定的子元素；<br>:nth-last-child() 选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算；<br>:nth-of-type() 选择指定的元素；<br>:nth-last-of-type() 选择指定的元素，从元素的最后一个开始计算；<br>:first-of-type 选择一个上级元素下的第一个同类子元素；<br>:last-of-type 选择一个上级元素的最后一个同类子元素；<br>:only-child 选择的元素是它的父元素的唯一一个子元素；<br>:only-of-type 选择一个元素是它的上级元素的唯一一个相同类型的子元素；<br>:empty 选择的元素里面没有任何内容。</p><p><strong>伪元素</strong>是对元素中的特定内容进行操作，而不是描述状态。它的操作层次比伪类更深一层，因此动态性比伪类低很多。实际上，伪元素就是选取某些元素前面或后面这种普通选择器无法完成的工作。控制的内容和元素是相同的，但它本身是基于元素的抽象，并不存在于文档结构中！常见的伪元素选择器包括：</p><p>:first-letter 选择元素文本的第一个字（母）。<br>:first-line 选择元素文本的第一行。<br>:before 在元素内容的最前面添加新内容。<br>:after 在元素内容的最后面添加新内容。</p><p>注意事项<br>有时你会发现伪类元素使用了两个冒号 (::) 而不是一个冒号 (:)，这是 CSS3 规范中的一部分要求，目的是为了区分伪类和伪元素，大多数浏览器都支持这两种表示方式。单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。对于 CSS2 中已经有的伪元素，例如 :before，单冒号和双冒号的写法 ::before 作用是一样的。</p><p>所以，如果你的网站只需要兼容 webkit、firefox、opera 等浏览器，建议对于伪元素采用双冒号的写法，如果不得不兼容 IE 浏览器，还是用 CSS2 的单冒号写法比较安全。</p><p>参考文章： <a href="https://segmentfault.com/a/1190000012156828" target="_blank" rel="noopener">谈谈css伪类与伪元素</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/11/06/H5/H5/"/>
    <id>http://yoursite.com/2018/11/06/H5/H5/</id>
    <published>2018-11-06T12:10:06.000Z</published>
    <updated>2018-11-06T12:14:21.186Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>盒子模型</title>
    <link href="http://yoursite.com/2018/11/06/CSS3/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/11/06/CSS3/盒子模型/</id>
    <published>2018-11-06T12:10:06.000Z</published>
    <updated>2019-02-12T13:42:40.476Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="盒子样式介绍"><a href="#盒子样式介绍" class="headerlink" title="盒子样式介绍"></a>盒子样式介绍</h4><ul><li>width和height：内容的宽度、高度（不是盒子的宽度、高度）</li><li>padding：内边距。</li><li>border：边框。</li><li>margin：外边距。</li></ul><hr><h4 id="盒子模型的分类与概念"><a href="#盒子模型的分类与概念" class="headerlink" title="盒子模型的分类与概念"></a>盒子模型的分类与概念</h4><p>　　盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是<strong><em>IE盒子模型</em></strong>和<strong><em>标准 w3c 盒子模型</em></strong>。<br>他们对盒子模型的解释各不相同:<br>　　IE 盒子模型的范围也包括 <strong><em>margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading</em></strong>。<br><img src="/assets/images/盒子模型-IE.jpg" alt="IE盒子模型"><br>　　标准 W3C 盒子模型的范围包括 <strong><em>margin、border、padding、content，并且 content 部分不包含其他部分</em></strong>。<br><img src="/assets/images/盒子模型-标准.jpg" alt="标准盒子模型"></p><p><strong>ps</strong>:<br>　　1. ie8以上都是w3c标准盒模型 　　<br>　　2. ie5极其以下都是ie盒子模型，ie6、ie7、ie8在混杂模式下ie盒模型，<br>　　3. 在标准模式下是w3c标准盒模型<br>　　4. 注意：ie6在混杂模式下一定是Ie盒模型，而ie7、ie8在混杂模式下不一定是ie盒模型</p><p>box-sizing 属性可以被用来调整这些表现:<br>　　1. content-box 是默认值。<br>如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。<br>　　2. border-box 告诉浏览器去理解你设置的边框和内边距的值是包含在width内的。<br>也就是说，如果你将一个元素的width设为100px,那么这100px会包含其它的border和padding，内容区的实际宽度会是width减去border + padding的计算值。大多数情况下这使得我们更容易的去设定一个元素的宽高。<br>　　3. border-box定义的盒子，不会随着padding和boder的加入而增大盒子的占用空间</p><blockquote><p>border-box  width 和 height 属性包括内容，内边距和边框，但不包括外边距。<br>这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。注意，填充和边框将在盒子内 。<br>例如, .box {width: 350px; border: 10px solid black;} 导致在浏览器中呈现的宽度为350px<br>的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。<br>这里的维度计算为：<br>width = border + padding + 内容的  width，<br>height = border + padding + 内容的 height。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>H5语义化标签</title>
    <link href="http://yoursite.com/2018/11/06/CSS3/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2018/11/06/CSS3/语义化标签/</id>
    <published>2018-11-06T10:30:06.000Z</published>
    <updated>2018-11-06T11:05:30.466Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><h3>H5中关于语义化的标签有哪些，语义化标签有什么作用？为什么要使用语义化标签?</h3><p></p><h4>1. H5中关于语义化的标签有哪些</h4><p>title  简短、描述性、唯一（提升搜索引擎排名）<br>header 页眉通常包括网站标志、主导航、全站链接以及搜索框。<br>section 具有相似主题的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。<br><a id="more"></a><br>footer 页脚，只有当父级是body时，才是整个页面的页脚。<br>article 包含像报纸一样的内容= =||是这么理解的，表示文档、页面、应用或一个独立的容器<br>a<br>hgroup 标签用于对网页或区段（section）的标题进行组合<br>nav 标记导航，仅对文档中重要的链接群使用。<br>aside 指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。<br>address 作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）<br>mark 突出显示文本（yellow），提醒读者。<br>time 标记时间。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式<br>figure 创建图（默认有40px左右margin）<br>figcaption figure的标题，必须是figure内嵌的第一个或者最后一个元素。<br>datailst<br>details<br>summary<br>dialog<br>dd<br>progress 完成进度。可通过js动态更新value<br>keygen<br>small 指定细则，输入免责声明、注解、署名、版权。</p><h4>2. 语义化标签有什么作用？为什么要使用语义化标签？</h4><p></p><p>在HTML5出现之前，我们一般采用div+css布局我们的页面。但是这样的布局方式不仅<br>使我们的文档结构不够清晰，而且不利于搜索引擎爬虫对我们页面的爬取。为了解决上述缺点，<br>HTML5新增了很多新的语义化标签。</p><p></p><ul><li>引入语义化标签的好处主要有<ul><li>比div标签有更加丰富的含义，方便开发与维护</li><li>搜索引擎能更方便的识别页面的每个部分</li><li>方便其他设备解析（如移动设备、盲人阅读器等）</li></ul></li></ul><p></p><h4>H5新增的语义化标签</h4><br>header<br>footer<br>article<br>aside  定义页面的侧边栏内容<br>time<br>details 用于描述文档或者文档某一部分细节，summary是details元素的标题<br>ruby 加注释，ruby标签有两个子元素，rt注释的内容，rp是该标签不显示时显示的文字<br>mark 定义带有几号的文本，它会给你想要突出显示的文本加个 背景色<br>nav<br>progress<br>section<br>video 定义视频，属性src引入资源，controls视频的控制控件<br>audio 该标签可定义声音，及其他的音频文件，不加controls不显示音频的控制界面<br>datalist 提示可能的值，datalist及其选项不会被显示出来，它仅仅是合法输入值的列表使用input元素的list属性来邦定datalist<br>embed 定义插入的内容，如插件，flash，标签中间不要加内容会显现出来<br>canvas canvas画布只是个容器，你可以通过控制坐标在canvas上绘制图形，一般配合js可以实现非常复杂的动画效果<p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h3&gt;H5中关于语义化的标签有哪些，语义化标签有什么作用？为什么要使用语义化标签?&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;h4&gt;1. H5中关于语义化的标签有哪些&lt;/h4&gt;

&lt;p&gt;title  简短、描述性、唯一（提升搜索引擎排名）&lt;br&gt;header 页眉通常包括网站标志、主导航、全站链接以及搜索框。&lt;br&gt;section 具有相似主题的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>块级元素行内元素</title>
    <link href="http://yoursite.com/2018/11/06/CSS3/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2018/11/06/CSS3/块级元素行内元素/</id>
    <published>2018-11-06T10:21:49.000Z</published>
    <updated>2018-11-06T12:09:27.625Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>行内元素指的是书写完成后不会自动换行，并且元素没有宽和高。<br>块级元素写完后会自动换行，有宽高可以修改。<br>还有一种特殊的元素叫做行内联元素。</p><p>行内元素有：span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、<br>u（下划线）、button（默认display：inline-block<br>块级元素有：div、p、h1~h6、ul、ol、dl、li、dd、table、hr、blockquote、address、table、menu、pre，HTML5新增的header、section、aside、footer<br>内联元素： a , b , br , em , font , img , input , label , select , small , span , textarea </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="http://yoursite.com/2018/10/22/Vue/"/>
    <id>http://yoursite.com/2018/10/22/Vue/</id>
    <published>2018-10-22T13:30:27.000Z</published>
    <updated>2018-10-22T13:31:41.872Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>README</title>
    <link href="http://yoursite.com/2018/10/22/README/"/>
    <id>http://yoursite.com/2018/10/22/README/</id>
    <published>2018-10-22T11:23:46.000Z</published>
    <updated>2018-10-22T13:28:38.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>It just a test music, but i like it </p>        <div id="aplayer-YbsRfzNI" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-YbsRfzNI"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "起风了",              author: "买辣椒也用券",              url: "/assets/music/music.mp3",              pic: "/assets/music/music.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="情感" scheme="http://yoursite.com/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>深浅拷贝</title>
    <link href="http://yoursite.com/2018/10/16/JS/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2018/10/16/JS/深浅拷贝/</id>
    <published>2018-10-16T10:12:26.000Z</published>
    <updated>2018-10-18T12:04:28.680Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载： <a href="https://www.cnblogs.com/136asdxxl/p/8645750.html" target="_blank" rel="noopener">js 深浅拷贝 笔记总结</a>、<a href="https://www.cnblogs.com/echolun/p/7889848.html" target="_blank" rel="noopener">[JS]深拷贝与浅拷贝的区别，实现深拷贝的几种方法</a></p><h5 id="JS-数据类型"><a href="#JS-数据类型" class="headerlink" title="JS 数据类型"></a>JS 数据类型</h5><p>JavaScript的数据类型有： <strong>数值类型</strong>(number) 、 <strong>字符串类型</strong>(string) 、 <strong>布尔类型</strong>(boolean) 、 <strong>null</strong> 、<strong>undefined</strong> 、<strong>对象(数组、正则表达式、日期、函数)</strong><br>大致分为两种： <strong>基本数据类型</strong> 和 <strong>引用数据类型</strong><br>基本数据类型： 数字类型(number)、字符串类型(string)、布尔类型(boolean)、null、undefined<br>引用数据类型： 常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等</p><h5 id="深浅拷贝区别"><a href="#深浅拷贝区别" class="headerlink" title="深浅拷贝区别"></a>深浅拷贝区别</h5><p>如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。</p><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>浅拷贝只是拷贝基本类型的数据，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，因此存在父对象被篡改的可能，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存<br><a id="more"></a></p><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>深拷贝就是能够实现真正意义上的数组和对象的拷贝。递归调用”浅拷贝”。（深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象）</p><p>浅拷贝例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    b=a;</span><br><span class="line"><span class="built_in">console</span>.log(a===b);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/assets/images/浅拷贝1.png" alt="浅拷贝例子结果"><br>嗯？明明b复制了a，为啥修改数组a，数组b也跟着变了，这里我不禁陷入了沉思。<br>那么这里，就得引入基本数据类型与引用数据类型的概念了。</p><p>a.<strong>基本类型</strong>–名值存储在栈内存中，例如let a=1;<br><img src="/assets/images/拷贝2.jpg" alt="基本类型"><br>当你b=a复制时，栈内存会新开辟一个内存，例如这样：<br><img src="/assets/images/拷贝3.jpg" alt="基本类型"><br>所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。</p><p>b.<strong>引用数据类型</strong>–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：<br><img src="/assets/images/拷贝4.jpg" alt="引用数据类型"><br>当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。<br><img src="/assets/images/拷贝5.jpg" alt="引用数据类型"><br>而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。<br><img src="/assets/images/拷贝6.jpg" alt="引用数据类型"><br>那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，起步就达到深拷贝的效果了<br><img src="/assets/images/拷贝7.jpg" alt="引用数据类型"></p><p>1.我们怎么去实现深拷贝呢，这里可以递归递归去复制所有层级属性。<br>这么我们封装一个深拷贝的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> objClone = <span class="built_in">Array</span>.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj===<span class="string">"object"</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">                <span class="comment">//判断ojb子元素是否为对象，如果是，递归复制</span></span><br><span class="line">                <span class="keyword">if</span>(obj[key]&amp;&amp;<span class="keyword">typeof</span> obj[key] ===<span class="string">"object"</span>)&#123;</span><br><span class="line">                    objClone[key] = deepClone(obj[key]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果不是，简单复制</span></span><br><span class="line">                    objClone[key] = obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="/assets/images/深拷贝1.png" alt="深拷贝例子结果"><br>跟之前想象的一样，现在b脱离了a的控制，不再受a影响了。<br>这里再次强调，深拷贝，是拷贝对象各个层级的属性，可以看个例子。JQ里有一个extend方法也可以拷贝对象，我们来看看<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    b=a.slice();</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/assets/images/深拷贝2.png" alt="深拷贝例子2结果"><br>那是不是说slice方法也是深拷贝了，毕竟b也没受a的影响，上面说了，深拷贝是会拷贝所有层级的属性，还是这个例子，我们把a改改<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">        b=a.slice();</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/深拷贝3.png" alt="深拷贝例子3结果"><br>拷贝的不彻底啊，b对象的一级属性确实不受影响了，但是二级属性还是没能拷贝成功，仍然脱离不了a的控制，说明slice根本不是真正的深拷贝。<br>这里引用知乎问答里面的一张图</p><p><img src="/assets/images/拷贝知乎.jpg" alt="深拷贝知乎"></p><p>第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。</p><p>同理，concat方法与slice也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。</p><p>2.除了递归，我们还可以借用JSON对象的parse和stringify</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _obj = <span class="built_in">JSON</span>.stringify(obj),</span><br><span class="line">        objClone = <span class="built_in">JSON</span>.parse(_obj);</span><br><span class="line">    <span class="keyword">return</span> objClone</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure><p><img src="/assets/images/json深拷贝.png" alt="深拷贝例子4结果"><br>可以看到，这下b是完全不受a的影响了。</p><p>附带说下，JSON.stringify与JSON.parse除了实现深拷贝，还能结合localStorage实现对象数组存储</p><p>3.除了上面两种方法之外，我们还可以借用JQ的extend方法。</p><p>$.extend( [deep ], target, object1 [, objectN ] )</p><p>deep表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝</p><p>target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。</p><p>object1  objectN可选。 Object类型 第一个以及第N个被合并的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">    b=$.extend(<span class="literal">true</span>,[],a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure></p><p>可以看到，效果与上面方法一样，只是需要依赖JQ库。<br><img src="/assets/images/深拷贝jquery.png" alt="深拷贝jquery方法"></p><p>说了这么多，了解深拷贝也不仅仅是为了应付面试题，在实际开发中也是非常有用的。例如后台返回了一堆数据，你需要对这堆数据做操作，但多人开发情况下，你是没办法明确这堆数据是否有其它功能也需要使用，直接修改可能会造成隐性问题，深拷贝能帮你更安全安心的去操作数据，根据实际情况来使用深拷贝，大概就是这个意思。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载： &lt;a href=&quot;https://www.cnblogs.com/136asdxxl/p/8645750.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;js 深浅拷贝 笔记总结&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/echolun/p/7889848.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[JS]深拷贝与浅拷贝的区别，实现深拷贝的几种方法&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;JS-数据类型&quot;&gt;&lt;a href=&quot;#JS-数据类型&quot; class=&quot;headerlink&quot; title=&quot;JS 数据类型&quot;&gt;&lt;/a&gt;JS 数据类型&lt;/h5&gt;&lt;p&gt;JavaScript的数据类型有： &lt;strong&gt;数值类型&lt;/strong&gt;(number) 、 &lt;strong&gt;字符串类型&lt;/strong&gt;(string) 、 &lt;strong&gt;布尔类型&lt;/strong&gt;(boolean) 、 &lt;strong&gt;null&lt;/strong&gt; 、&lt;strong&gt;undefined&lt;/strong&gt; 、&lt;strong&gt;对象(数组、正则表达式、日期、函数)&lt;/strong&gt;&lt;br&gt;大致分为两种： &lt;strong&gt;基本数据类型&lt;/strong&gt; 和 &lt;strong&gt;引用数据类型&lt;/strong&gt;&lt;br&gt;基本数据类型： 数字类型(number)、字符串类型(string)、布尔类型(boolean)、null、undefined&lt;br&gt;引用数据类型： 常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等&lt;/p&gt;
&lt;h5 id=&quot;深浅拷贝区别&quot;&gt;&lt;a href=&quot;#深浅拷贝区别&quot; class=&quot;headerlink&quot; title=&quot;深浅拷贝区别&quot;&gt;&lt;/a&gt;深浅拷贝区别&lt;/h5&gt;&lt;p&gt;如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。&lt;/p&gt;
&lt;h5 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h5&gt;&lt;p&gt;浅拷贝只是拷贝基本类型的数据，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，因此存在父对象被篡改的可能，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>面试题-思维</title>
    <link href="http://yoursite.com/2018/10/16/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4/"/>
    <id>http://yoursite.com/2018/10/16/面试题-思维/面试题-思维/</id>
    <published>2018-10-16T09:53:08.000Z</published>
    <updated>2018-10-16T10:11:32.528Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="题目：-给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值"><a href="#题目：-给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值" class="headerlink" title="题目： 给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值"></a>题目： 给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值</h4><p>方法一：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a^b;</span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br></pre></td></tr></table></figure></p><h4 id="题目：-给两个杯子，一个5升，一个6升，水随便用，最后取出3升水"><a href="#题目：-给两个杯子，一个5升，一个6升，水随便用，最后取出3升水" class="headerlink" title="题目： 给两个杯子，一个5升，一个6升，水随便用，最后取出3升水"></a>题目： 给两个杯子，一个5升，一个6升，水随便用，最后取出3升水</h4><p>方法：</p><ol><li>6升装满倒入5升杯子，6升杯子里剩1升水；</li><li>6升杯子中的1升倒入5升杯子；</li><li>6升杯子装满水倒入5升杯子，6升杯子里剩2升水；把5升杯子水倒掉；</li><li>6升杯子中的2升倒入5升杯子；</li><li>6升杯子装满水倒入5升杯子，6升杯子里剩3升水，完成。</li></ol><h4 id="题目：-给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子"><a href="#题目：-给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子" class="headerlink" title="题目： 给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子"></a>题目： 给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子</h4><p>方法：<br>二分法：<br>用天平左右各五个进行称量，10 =&gt; 5<br>较轻的一组留下一个，继续进行分开称量，如果左右相等，则剩余的那一个为最轻的，否则剩下的两个继续进行比较5 =&gt; 1 || 5 =&gt; 2<br>最后一次比较 2 =&gt; 1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="思维能力" scheme="http://yoursite.com/categories/%E6%80%9D%E7%BB%B4%E8%83%BD%E5%8A%9B/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HTTP和HTTPS的区别</title>
    <link href="http://yoursite.com/2018/10/15/HTTP/HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/10/15/HTTP/HTTP和HTTPS的区别/</id>
    <published>2018-10-15T01:04:39.000Z</published>
    <updated>2018-11-06T12:31:32.992Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><p>&nbsp; &nbsp; &nbsp;超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，<strong>HTTP协议以明文方式发送内容</strong>，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。<br>&nbsp; &nbsp; &nbsp;为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，<strong>HTTPS在HTTP的基础上加入了SSL协议</strong>，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。<br><a id="more"></a></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP的基本概念"><a href="#HTTP的基本概念" class="headerlink" title="HTTP的基本概念"></a>HTTP的基本概念</h4><p>HTTP: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br>HTTP: 是超文本传输协议，信息是明文传输</p><h4 id="HTTP的优点"><a href="#HTTP的优点" class="headerlink" title="HTTP的优点"></a>HTTP的优点</h4><h4 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h4><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="HTTPS的基本概念"><a href="#HTTPS的基本概念" class="headerlink" title="HTTPS的基本概念"></a>HTTPS的基本概念</h4><p>HTTPS(Secure Hypertext Transfer Protocol)是安全超文本传输协议,<br>HTTPS: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，<strong>即HTTP下加入SSL层</strong>，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br>https: 是具有安全性的ssl加密传输协议；<br>HTTPS协议的主要作用可以分为两种：一种是建立一个<strong><em>信息安全通道</em></strong>，来保证数据传输的安全；另一种就是<strong><em>确认网站的真实性</em></strong>。</p><h4 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h4><ol><li>客户端发起HTTPS请求<br>用户在浏览器里输入一个https网址，然后连接到server的443端口。</li><li>服务端的配置<br>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。<br>这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li><li>传送证书<br>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</li><li>客户端解析证书<br>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。<br>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</li><li>传送加密信息<br>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li><li>服务段解密信息<br>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li><li>传输加密后的信息<br>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</li><li>客户端解密信息<br>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</li></ol><h4 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h4><ol><li>SEO方面<br>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li><li>安全性</li></ol><ul><li><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></li><li><p>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p></li><li><p>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本</p></li></ul><h4 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h4><ol><li>SEO方面<br>据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。<br>而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。<br>最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li><li>经济方面</li></ol><ul><li><p>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p></li><li><p>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。</p></li><li><p>HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。</p></li><li><p>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去。</p></li><li><p>HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。</p></li></ul><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ul><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443；</li><li>、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全；</li><li>https协议需要到ca申请证书，一般免费证书很少，需要交费。 </li><li></li></ul><p>参考文章：<a href="http://www.mahaixiang.cn/internet/1233.html" target="_blank" rel="noopener">HTTP和HTTPS的区别</a>、<a href="https://www.cnblogs.com/wudaoyongchang/p/6253451.html" target="_blank" rel="noopener">HTTP与HTTPS的区别</a> 、<a href="http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/" target="_blank" rel="noopener">HTTP详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，&lt;strong&gt;HTTP协议以明文方式发送内容&lt;/strong&gt;，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，&lt;strong&gt;HTTPS在HTTP的基础上加入了SSL协议&lt;/strong&gt;，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>http连接性能优化</title>
    <link href="http://yoursite.com/2018/10/14/HTTP/http%E8%BF%9E%E6%8E%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/10/14/HTTP/http连接性能优化/</id>
    <published>2018-10-14T02:23:06.000Z</published>
    <updated>2018-10-15T00:50:59.177Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h3 id="HTTP和TCP-IP的关系"><a href="#HTTP和TCP-IP的关系" class="headerlink" title="HTTP和TCP/IP的关系"></a>HTTP和TCP/IP的关系</h3><p>HTTP—&gt;(TSL/SSL)—&gt;TCP—&gt;IP<br>HTTP处于应用层、TCP处于传输层、IP处于网络层</p><ol><li>HTTP将所需要传输的数据以流的形式传递给TCP程序</li><li>TCP解析数据中的IP地址和端口号，将数据流分割成数据段，并添加上TCP段首部，如TCP握手（ACK、SYNC等），源端口，目的端口、TCP校验和等</li><li>TCP程序将包装好的TCP数据段叫给IP程序，IP程序在此基础上封装进去IP分组首部，如源IP地址、目的IP地址，数据报总长度、分组ID、首部长度、首部校验和等等</li><li>最后交给数据链路层去发送这个IP分组数据段<a id="more"></a><h3 id="TCP性能的考虑"><a href="#TCP性能的考虑" class="headerlink" title="TCP性能的考虑"></a>TCP性能的考虑</h3><strong>HTTP紧挨着TCP，所以TCP的链接性能考虑直接影响的HTTP事务的性能。</strong></li></ol><h4 id="HTTP事务时延"><a href="#HTTP事务时延" class="headerlink" title="HTTP事务时延"></a>HTTP事务时延</h4><p>一次HTTP请求可分为 <strong>DNS查询</strong>、<strong>连接</strong>、<strong>请求</strong>、<strong>事务处理</strong>、<strong>响应</strong>、<strong>关闭连接</strong>。每一步都会产生时延。其中，相对于<strong>连接</strong>、<strong>请求</strong>所消耗的时间，<strong><em>事务处理</em></strong>的时间是很短的。</p><p>对HTTP程序员产生影响的时延 </p><ul><li>TCP握手建立链接 </li><li>TCP慢启动拥塞控制 </li><li>数据聚集的Nagle算法 </li><li>用于捎带确认的TCP延迟确认算法 </li><li>TIME_WAIT 时延和端口耗尽</li></ul><h4 id="HTTP连接处理"><a href="#HTTP连接处理" class="headerlink" title="HTTP连接处理"></a>HTTP连接处理</h4><h5 id="Connection首部真正用途"><a href="#Connection首部真正用途" class="headerlink" title="Connection首部真正用途"></a>Connection首部真正用途</h5><p>HTTP允许客户端和源服务器之间存在多个代理服务器或高速缓存服务器，进行HTTP连接通信时，可以将HTTP首部逐跳的经过这些设备。这个时候，怎么在相邻的HTTP应用程序之间的连接应用一些特殊的选项呢？— Connection首部，可以承载3种不同类型的标签，这些标签不会传播到其它连接中去。<br>a、HTTP首部字段名，列出了只与此连接有关的选项<br>b、任意标签，用于描述此连接的非标准选项<br>c、值close，说明操作完成之后需关闭这条持久连接<br>由于添加Connection首部的其它首部字段，不能随着报文转发出去。因此将逐跳首部放入Connection首部，就可以达到对首部的保护。<br>例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Cache-control: max-age=<span class="number">3600</span></span><br><span class="line">Connection: meter,close,bill-my-credit-card</span><br><span class="line">Meter: max-uses=<span class="number">3</span>,max-refuses=<span class="number">6</span>,dont-report</span><br></pre></td></tr></table></figure></p><p>实例说明：不应该转发Meter首部，要应用假想的bill-my-credit-card选项，且本次事务后应关闭持久连接。</p><h5 id="串行事务处理延迟"><a href="#串行事务处理延迟" class="headerlink" title="串行事务处理延迟"></a>串行事务处理延迟</h5><p>如果只对HTTP事务进行简单管理，TCP的性能时延可能会叠加起来，包括多次的建立连接和断开连接。</p><h4 id="提高HTTP连接性能的四个方法："><a href="#提高HTTP连接性能的四个方法：" class="headerlink" title="提高HTTP连接性能的四个方法："></a>提高HTTP连接性能的四个方法：</h4><h5 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h5><p>通过多条TCP连接发起并发的HTTP请求<br>并行连接从理论上回提高页面的加载速度，因为多个请求同时发出，时延可以重叠起来。<br>但并行连接并不是一点更快，原因可能是：客户端带宽限制、消耗更多的内存和计算资源。<br>现代浏览器确实使用并行连接，但会限制连接数在一个较小的值（通常是4），并且服务器可以关闭来自特定客户端的超量连接。</p><h5 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h5><p>重用TCP连接，以消除连接及关闭的时延<br>重用连接：HTTP/1.1(HTTP/1.0增强版)允许HTTP设备在事务处理结束后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接。</p><h6 id="持久连接-并行连接"><a href="#持久连接-并行连接" class="headerlink" title="持久连接+并行连接"></a>持久连接+并行连接</h6><p>持久的连接的管理很重要，不小心会累积出大量的空闲连接</p><h6 id="HTTP-1-0-Keep-alive连接"><a href="#HTTP-1-0-Keep-alive连接" class="headerlink" title="HTTP/1.0 + Keep-alive连接"></a>HTTP/1.0 + Keep-alive连接</h6><p>Connection： Keep-alive属性出现在1996年HTTP/1.0版本中，当初也是被当做实验型持久连接。</p><p>可以用通用首部Keep-Alive属性指定由逗号分隔的选项来调节keep-alive的行为。例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection：Keep-alive</span><br><span class="line">Keep-Alive: max=<span class="number">5</span>,timeout=<span class="number">120</span></span><br></pre></td></tr></table></figure></p><p>说明：服务器还会为另外5个事务保持连接的打开状态，或者将打开状态保持到连接空闲后2分钟。</p><p>Connection属于逐跳首部，只适用于单条传输链路。</p><p>现在HTTP/1.1不再需要此属性，默认开启持久连接的。</p><h6 id="HTTP-1-1-持久连接"><a href="#HTTP-1-1-持久连接" class="headerlink" title="HTTP/1.1 持久连接"></a>HTTP/1.1 持久连接</h6><p>HTTP/1.1逐渐停止了对keep-alive连接的支持，用一种名为持久连接(persistentconnection)的改进型设计取代了它。</p><p>必须显示指定Connection: close才会指定TCP连接在响应后立即关闭。当客户端发送了Connection: close请求首部之后，客户端就无法在那条连接上发送更多请求了。<br>只有当连接上所有的报文都有正确的、自定义报文长度时，连接才能持久保持。</p><h5 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h5><p>通过共享的TCP连接发起并发的HTTP请求</p><p>HTTP/1.1 允许在持久连接上可选的使用请求管道。在响应到达之前，可以将多条请求放入队列，降低网络回环时间。</p><p>注：HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST），因为出错时，无法安全的重试POST这样的非幂请求。</p><h5 id="复用的连接"><a href="#复用的连接" class="headerlink" title="复用的连接"></a>复用的连接</h5><p>交替传送请求和相应报文（实验阶段）</p><h3 id="HTTP1-1-的特点"><a href="#HTTP1-1-的特点" class="headerlink" title="HTTP1.1 的特点"></a>HTTP1.1 的特点</h3><h4 id="持久连接-1"><a href="#持久连接-1" class="headerlink" title="持久连接"></a>持久连接</h4><p>每个TCP连接开始都有三次握手，要经历一次客户端与服务器间完整的往返，而开启了持久连接就不需要每次都要握手<br><img src="/assets/images/keep-alive.png" alt="开启Keep-Alive"><br>在连接中有这个属性的就是打开了持久化连接。下图展示了通过持久 TCP 连接取得 HTML 和 CSS 文件：<br><img src="/assets/images/keep-alive1.jpg" alt="开启Keep-Alive"></p><h3 id="HTTP2-0-的特点"><a href="#HTTP2-0-的特点" class="headerlink" title="HTTP2.0 的特点"></a>HTTP2.0 的特点</h3><h3 id="HTTP-长连接与短连接"><a href="#HTTP-长连接与短连接" class="headerlink" title="HTTP 长连接与短连接"></a>HTTP 长连接与短连接</h3><p><strong>HTTP  是无状态的</strong><br>也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话.<br>http1.0中默认是关闭的，需要在http头加入”Connection: Keep-Alive”，才能启用Keep-Alive<br>http 1.1中默认启用Keep-Alive，如果加入”Connection: close”才关闭。<br>目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。<br>下图是普通模式和长连接模式的请求对比：<br><img src="/assets/images/keep-alive2.png" alt="普通模式和长连接模式的请求对比"></p><h4 id="开启Keep-Alive的优缺点"><a href="#开启Keep-Alive的优缺点" class="headerlink" title="开启Keep-Alive的优缺点"></a>开启Keep-Alive的优缺点</h4><p>优点： Keep-Alive模式更加高效，因为避免了连接建立和释放的开销<br>缺点： 长时间的Tcp连接容易导致资源无效占用，浪费系统资源</p><h4 id="当保持长连接时，如何判断一次请求已经完成？"><a href="#当保持长连接时，如何判断一次请求已经完成？" class="headerlink" title="当保持长连接时，如何判断一次请求已经完成？"></a>当保持长连接时，如何判断一次请求已经完成？</h4><p>当保持长连接时，如何判断一次请求已经完成？ </p><h5 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h5><p>Content-Length表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。<br>所以，当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置Content-Length来控制请求的结束。但当服务器并不知道请求结果的长度时，如一个动态的页面或者数据，Content-Length就无法解决上面的问题，这个时候就需要用到Transfer-Encoding字段。</p><h5 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h5><p>Transfer-Encoding是指<strong>传输编码</strong>，在上面的问题中，当服务端无法知道实体内容的长度时，就可以通过指定Transfer-Encoding: chunked来告知浏览器当前的编码是将数据分成一块一块传递的。当然, 还可以指定Transfer-Encoding: gzip, chunked表明实体内容不仅是gzip压缩的，还是分块传递的。最后，当浏览器接收到一个长度为0的chunked时， 知道当前请求内容已全部接收。</p><h4 id="Keep-Alive-timeout："><a href="#Keep-Alive-timeout：" class="headerlink" title="Keep-Alive timeout："></a>Keep-Alive timeout：</h4><p>Httpd守护进程，一般都提供了keep-alive timeout时间设置参数。比如nginx的keepalive_timeout，和Apache的KeepAliveTimeout。这个keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住keepalive_timeout秒后，才开始关闭这个连接。<br>当httpd守护进程发送完一个响应后，理应马上主动关闭相应的tcp连接，设置 keepalive_timeout后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到浏览器发过来http请求，则关闭这个http连接。</p><h4 id="Tcp的Keepalive："><a href="#Tcp的Keepalive：" class="headerlink" title="Tcp的Keepalive："></a>Tcp的Keepalive：</h4><p>连接建立之后，如果客户端一直不发送数据，或者隔很长时间才发送一次数据，当连接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，连接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。<br>TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文（侦测包）给对方，如果对方回应了这个报文，说明对方还在线，连接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持连接。</p><p>tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。tcp keep-alive保鲜定时器，支持三个系统内核配置参数：<br>net.ipv4.tcp_keepalive_intvl = 15<br>net.ipv4.tcp_keepalive_probes = 5<br>net.ipv4.tcp_keepalive_time = 1800<br>keepalive是TCP保鲜定时器，当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）了tcp_keepalive_time后，服务器就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 tcp_keepalive_intvl后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试tcp_keepalive_probes,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。</p><p>参考文章： <a href="https://blog.csdn.net/weixin_37672169/article/details/80283935" target="_blank" rel="noopener">浅谈Http长连接和Keep-Alive以及Tcp的Keepalive</a>、<a href="https://blog.csdn.net/joye123/article/details/51931375?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">http性能优化</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h3 id=&quot;HTTP和TCP-IP的关系&quot;&gt;&lt;a href=&quot;#HTTP和TCP-IP的关系&quot; class=&quot;headerlink&quot; title=&quot;HTTP和TCP/IP的关系&quot;&gt;&lt;/a&gt;HTTP和TCP/IP的关系&lt;/h3&gt;&lt;p&gt;HTTP—&amp;gt;(TSL/SSL)—&amp;gt;TCP—&amp;gt;IP&lt;br&gt;HTTP处于应用层、TCP处于传输层、IP处于网络层&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP将所需要传输的数据以流的形式传递给TCP程序&lt;/li&gt;
&lt;li&gt;TCP解析数据中的IP地址和端口号，将数据流分割成数据段，并添加上TCP段首部，如TCP握手（ACK、SYNC等），源端口，目的端口、TCP校验和等&lt;/li&gt;
&lt;li&gt;TCP程序将包装好的TCP数据段叫给IP程序，IP程序在此基础上封装进去IP分组首部，如源IP地址、目的IP地址，数据报总长度、分组ID、首部长度、首部校验和等等&lt;/li&gt;
&lt;li&gt;最后交给数据链路层去发送这个IP分组数据段&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://yoursite.com/2018/10/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/10/12/git常用命令/git常用命令/</id>
    <published>2018-10-12T06:16:09.000Z</published>
    <updated>2018-10-18T11:59:17.183Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h3 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h3><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ls        <span class="comment">// 查看目录</span></span><br><span class="line">ls -al    <span class="comment">//查看所有目录</span></span><br><span class="line">cat git.md <span class="comment">//查看文件内容</span></span><br><span class="line">git --version   <span class="comment">//查看git的版本信息</span></span><br><span class="line">git clone git@github.com:aLittleLittleStar/Vue-Music-App.git  </span><br><span class="line"><span class="comment">//从服务器上将代码给拉下来</span></span><br><span class="line">git init      <span class="comment">//本地初始化</span></span><br><span class="line"></span><br><span class="line">git branch    <span class="comment">//查看本地所有分支，当前分支会被星号标示出</span></span><br><span class="line">git branch -r <span class="comment">//查看远程所有分支</span></span><br><span class="line">git branch -a <span class="comment">//查看所有分支</span></span><br><span class="line">git branch -v <span class="comment">//可以看见每一个分支的最后一次提交.</span></span><br><span class="line">git branch dev                        <span class="comment">//新建分支dev</span></span><br><span class="line">git branch -d (branchname)            <span class="comment">//删除一个分支, 如果在分支</span></span><br><span class="line">                                      <span class="comment">//中有一些未merge的提交，那么会删除分支失败</span></span><br><span class="line">git branch -D dev                     <span class="comment">//强制删除dev分支</span></span><br><span class="line">git push origin --<span class="keyword">delete</span> &lt;BranchName&gt; <span class="comment">//删除远程分支</span></span><br><span class="line">git branch -vv                        <span class="comment">//可以查看本地分支对应的远程分支</span></span><br><span class="line">git branch -m oldName newName         <span class="comment">//给分支重命名</span></span><br><span class="line"></span><br><span class="line">git status    <span class="comment">//查看当前状态[组件、删除、修改了哪些]</span></span><br><span class="line">git status -s <span class="comment">// 查询repo的状态. -s表示short,</span></span><br><span class="line">              <span class="comment">// -s的输出标记会有两列,第一列是</span></span><br><span class="line">              <span class="comment">// 对staging区域而言,第二列是对working目录而言.</span></span><br><span class="line"></span><br><span class="line">git commit    <span class="comment">//提交</span></span><br><span class="line">git commit -am <span class="string">"init"</span>         <span class="comment">//提交并添加注释</span></span><br><span class="line"></span><br><span class="line">git checkout dev             <span class="comment">// 切换到dev分支</span></span><br><span class="line">git checkout -b dev          <span class="comment">//建立一个新的本地分支dev并切换到该分支</span></span><br><span class="line">git merge origin/dev         <span class="comment">//将分支dev与当前分支进行合并</span></span><br><span class="line">git checkout dev             <span class="comment">//切换到本地dev分支</span></span><br><span class="line">git log --online             <span class="comment">//看你commit的日志</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git checkout --help         <span class="comment">// 查看帮助</span></span><br></pre></td></tr></table></figure><h4 id="Git-fetch-amp-amp-Git-pull-详解"><a href="#Git-fetch-amp-amp-Git-pull-详解" class="headerlink" title="Git fetch &amp;&amp; Git pull 详解"></a>Git fetch &amp;&amp; Git pull 详解</h4><p><strong>git fetch</strong>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。<br><strong>git pull</strong> 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。<br><strong>分支的概念：</strong><br>分支是用来标记特定代码的提交，每一个分支通过SHA1sum值来标识，所以对分支的操作是轻量级的，你改变的仅仅是SHA1sum值。</p><p>如下图所示，当前有2个分支，A,C,E属于master分支，而A,B，D,F属于dev分支<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A----C----E（master）</span><br><span class="line"> \</span><br><span class="line">  B---D---F(dev)</span><br></pre></td></tr></table></figure></p><p>它们的head指针分别指向E和F，对上述做如下操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master <span class="comment">//选择or切换到master分支</span></span><br><span class="line">git merge dev      <span class="comment">//将dev分支合并到当前分支(master)中</span></span><br></pre></td></tr></table></figure></p><p>之后的情形是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---C---E---G(master)</span><br><span class="line"> \         /</span><br><span class="line">  B---D---F（dev）</span><br></pre></td></tr></table></figure></p><p>现在A，B,C,D,E,F,G属于master，G是一次合并后的结果，是将E和Ｆ的代码合并后的结果，可能会出现冲突。而A,B，D,F依然属于dev分支。可以继续在dev的分支上进行开发:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---C---E---G---H(master)</span><br><span class="line"> \         /</span><br><span class="line">  B---D---F---I（dev）</span><br></pre></td></tr></table></figure></p><p>理解gitfetch,关键是理解FETCH_HEAD，FETCH_HEAD指的是：某个branch在服务器上的最新状态。</p><h5 id="git-fetch-用法"><a href="#git-fetch-用法" class="headerlink" title="git fetch 用法"></a>git fetch 用法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; <span class="comment">//这个命令将某个远程主机的更新全部取回本地</span></span><br></pre></td></tr></table></figure><p>如果只想取回特定分支的更新，可以指定分支名：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; <span class="xml"><span class="tag">&lt;<span class="name">分支名</span>&gt;</span> //注意之间有空格</span></span><br></pre></td></tr></table></figure></p><p>最常见的命令如取回origin 主机的master 分支：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure></p><p>取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p FETCH_HEAD</span><br></pre></td></tr></table></figure><h5 id="git-pull-用法"><a href="#git-pull-用法" class="headerlink" title="git pull 用法"></a>git pull 用法</h5><p>前面提到，git pull 的过程可以理解为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master <span class="comment">//从远程主机的master分支拉取最新内容 </span></span><br><span class="line">git merge FETCH_HEAD    <span class="comment">//将拉取下来的最新内容合并到当前所在的分支中</span></span><br></pre></td></tr></table></figure></p><p>即将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; <span class="xml"><span class="tag">&lt;<span class="name">远程分支名</span>&gt;</span>:<span class="tag">&lt;<span class="name">本地分支名</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin next</span><br></pre></td></tr></table></figure></p><!-- ![git常用命令图片](/assets/images/git.png) --><p>参考文章: <a href="https://blog.csdn.net/tomatozaitian/article/details/73515849" target="_blank" rel="noopener">Git 常用命令总结</a>、<a href="https://blog.csdn.net/halaoda/article/details/78661334" target="_blank" rel="noopener">git常用命令大全</a>、<a href="https://blog.csdn.net/qq_36113598/article/details/78906882" target="_blank" rel="noopener">Git fetch &amp; pull 详解</a></p><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h3 id=&quot;git-常用命令&quot;&gt;&lt;a href=&quot;#git-常用命令&quot; class=&quot;headerlink&quot; title=&quot;git 常用命令&quot;&gt;&lt;/a&gt;git 常用命令&lt;/h3&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="GIT" scheme="http://yoursite.com/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>常用的状态响应码</title>
    <link href="http://yoursite.com/2018/10/10/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81/"/>
    <id>http://yoursite.com/2018/10/10/常用的状态响应码/常用的状态响应码/</id>
    <published>2018-10-10T10:56:44.000Z</published>
    <updated>2018-10-12T08:48:09.649Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- 设置目录 --><!-- toc --><h3 id="状态码大类"><a href="#状态码大类" class="headerlink" title="状态码大类"></a>状态码大类</h3><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:right">说明</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:left">1XX</td><td style="text-align:right"><strong>响应中</strong>——表示请求已经接受，继续处理</td><td style="text-align:center">消息：一般是告诉<strong>客户端请求已经收到了</strong>，正在处理，别急</td></tr><tr><td style="text-align:left">2XX</td><td style="text-align:right"><strong>成功</strong>——表示请求已经被成功接收、理解、接受。</td><td style="text-align:center"><strong> 处理成功</strong>：一般表示请求收悉、我明白你要的、请求已受理、已经处理完成等信息</td></tr><tr><td style="text-align:left">3XX</td><td style="text-align:right"><strong> 重定向</strong>——要完成请求必须进行更进一步的操作</td><td style="text-align:center">重定向到其它地方：它让客户端再发起一个请求以完成整个处理</td></tr><tr><td style="text-align:left">4XX</td><td style="text-align:right"><strong>客户端错误</strong>——请求有语法错误或请求无法实现</td><td style="text-align:center">处理发生错误，责任在客户端：如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。</td></tr><tr><td style="text-align:left">5XX</td><td style="text-align:right"><strong> 服务器端错误</strong>——服务器未能实现合法的请求。</td><td style="text-align:center">处理发生错误，责任在服务端：如服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><blockquote><p>HTTP响应状态码有很多，但是实际经常使用的大概只有14个。<br><a id="more"></a></p></blockquote><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul><li>200 OK            //表示从客户端发来的请求在服务器端被正常处理了。</li><li>204 No Content该状态码表示服务器接收的请求已成功处理 ，但在返回的响应报文中不含实体的主体部分。<ul><li>比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。</li></ul></li><li>206 Partial Content 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。</li><li>301 Moved Permanently 永久性重定向。该状态码表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。<ul><li>像下方给出的请求URI，当指定的资源路径的最后忘记添加斜杠”/“，就会产生301状态码</li></ul></li><li>302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户(本次)能使用新的URI访问。</li><li>303 Other         //我把你redirect到其它的页面，目标的URL通过响应报文头的Location告诉你。<ul><li>See Other 该状态码表示由于请求对应的资源存在另外一个URI，应使用GET方法定向获取请求的资源。 303状态码和302状态码有着相同的功能，但303状态码明确表明客户端应当采用GET方法获取资源。 当301，302，303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文的主体，之后请求会自动再次发送。 301，302标准是禁止将POST方法改变成GET方法的，但实际上使用时大家都会这么做。</li></ul></li><li>304 Not Modified  // 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。<ul><li>304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。</li></ul></li><li>307 Temporary Redirect 临时重定向。该状态码与302 Found有着相同的含义。307会遵照浏览器标准，不会从POST变成GET</li><li>400 Bad Request   //客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized  //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<ul><li>该状态码表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过1此请求，则表示用户认证失败。</li></ul></li><li>403 Forbidden     //服务器收到请求，但是拒绝提供服务</li><li>404 Not Found     //该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</li><li>500 Internal Server Error //该状态码表明服务器端在执行请求时发生了错误。</li><li>503 Server Unavailable    //该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><blockquote><p>参考文章 <a href="https://www.cnblogs.com/jpdoutop/p/HTTP-Status-Code.html" target="_blank" rel="noopener">常见的HTTP响应状态码解析</a>、<a href="https://www.jianshu.com/p/e358607a3e1b" target="_blank" rel="noopener">常见的响应状态码</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- 设置目录 --&gt;
&lt;!-- toc --&gt;
&lt;h3 id=&quot;状态码大类&quot;&gt;&lt;a href=&quot;#状态码大类&quot; class=&quot;headerlink&quot; title=&quot;状态码大类&quot;&gt;&lt;/a&gt;状态码大类&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;状态码&lt;/th&gt;
&lt;th style=&quot;text-align:right&quot;&gt;说明&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;1XX&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;&lt;strong&gt;响应中&lt;/strong&gt;——表示请求已经接受，继续处理&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;消息：一般是告诉&lt;strong&gt;客户端请求已经收到了&lt;/strong&gt;，正在处理，别急&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;2XX&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;&lt;strong&gt;成功&lt;/strong&gt;——表示请求已经被成功接收、理解、接受。&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;strong&gt; 处理成功&lt;/strong&gt;：一般表示请求收悉、我明白你要的、请求已受理、已经处理完成等信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;3XX&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;&lt;strong&gt; 重定向&lt;/strong&gt;——要完成请求必须进行更进一步的操作&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;重定向到其它地方：它让客户端再发起一个请求以完成整个处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;4XX&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;&lt;strong&gt;客户端错误&lt;/strong&gt;——请求有语法错误或请求无法实现&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;处理发生错误，责任在客户端：如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;5XX&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;&lt;strong&gt; 服务器端错误&lt;/strong&gt;——服务器未能实现合法的请求。&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;处理发生错误，责任在服务端：如服务端抛出异常，路由出错，HTTP版本不支持等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP响应状态码有很多，但是实际经常使用的大概只有14个。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>冒泡和捕获</title>
    <link href="http://yoursite.com/2018/10/10/JS/%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7/"/>
    <id>http://yoursite.com/2018/10/10/JS/冒泡和捕获/</id>
    <published>2018-10-10T10:53:19.000Z</published>
    <updated>2018-10-12T08:48:49.399Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>  冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。<br>事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。<br>因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是p -&gt; div -&gt; body -&gt; html -&gt; document</p><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)<br>上面的例子在事件捕获的概念下发生click事件的顺序应该是document -&gt; html -&gt; body -&gt; div -&gt; p</p><p>IE只支持事件冒泡，Chrome,Mozilla, Opera 7 和 Konqueror两种都支持，旧版本的Opera’s 和 iCab两种都不支持 。</p><h4 id="捕获和冒泡过程图"><a href="#捕获和冒泡过程图" class="headerlink" title="捕获和冒泡过程图"></a>捕获和冒泡过程图</h4><p><img src="/assets/images/maopao.png" alt="冒泡和捕获"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>event<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"obj1"</span>&gt;</span></span><br><span class="line">        welcome</span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span> <span class="attr">id</span>=<span class="string">"obj2"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span> <span class="attr">id</span>=<span class="string">"obj3"</span>&gt;</span>world<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> obj1=<span class="built_in">document</span>.getElementById(<span class="string">'obj1'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> obj2=<span class="built_in">document</span>.getElementById(<span class="string">'obj2'</span>);</span></span><br><span class="line"><span class="javascript">        obj1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'hello'</span>);</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">        obj2.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'world'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并且分别在obj1,obj2上绑定了一个点击事件，由于addEventListener的第三个参数为false,所以页面是在冒泡阶段处理绑定事件。此时整个页面可以有三种行为出现</p><ol><li>点击文字welcome时，弹出hello。<br>此时就只触发了绑定在obj1上的点击事件。具体冒泡实现过程如下：welcome 属于文本节点，点击后，开始从文本节点查找，当前文本节点没有绑定点击事件，继续向上找，找到父级（id为obj1的div），有绑定的点击事件，执行，再向上找，body，没有绑定点击事件，再到html,document,都没再有绑定的点击事件，好，整个冒泡过程结束。</li><li>点击文字hello时，先弹出world，再弹出hello</li><li>点击world时，弹出hello。</li></ol><h4 id="addEventListener的第三个参数"><a href="#addEventListener的第三个参数" class="headerlink" title="addEventListener的第三个参数"></a>addEventListener的第三个参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lement.addEventListener(event, <span class="function"><span class="keyword">function</span>, <span class="title">useCapture</span>)</span></span><br></pre></td></tr></table></figure><p>第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。</p><p>我们想要在点击每个h5标签时，弹出对应的innerHTML 。常规做法是遍历每个h5,然后在每个h5上绑定一个点击事件，这种做法在h5较少的时候可以使用，但如果有一万个h5，那就会导致性能降低。这时就需要事件代理出场了。 </p><h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><p>使用事件代理的好处不仅在于将多个事件处理函数减为一个，而且对于不同的元素可以有不同的处理方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> e=e||<span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">if</span>(e.target.nodeName.toLowerCase()==<span class="string">'h5'</span>)&#123;</span><br><span class="line">      alert(e.target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>由于事件冒泡机制，点击了h5后会冒泡到div,此时就会触发绑定在div上的点击事件，再利用target找到事件实际发生的元素，就可以达到预期的效果。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="阻止冒泡的方法，阻止默认事件的方法-兼容IE"><a href="#阻止冒泡的方法，阻止默认事件的方法-兼容IE" class="headerlink" title="阻止冒泡的方法，阻止默认事件的方法(兼容IE)"></a>阻止冒泡的方法，阻止默认事件的方法(兼容IE)</h5><h5 id="w3c的方法是e-stopPropagation-，IE则是使用e-cancelBubble-true"><a href="#w3c的方法是e-stopPropagation-，IE则是使用e-cancelBubble-true" class="headerlink" title="w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true"></a>w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true</h5><p>阻止事件的传播兼容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=e||<span class="built_in">window</span>.event; <span class="comment">// window.event 这是IE浏览器</span></span><br><span class="line">    e.stopPropagation();<span class="comment">//阻止事件的传播(包括捕获也包括冒泡)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兼容处理</span></span><br><span class="line">    <span class="keyword">if</span> (e &amp;&amp; e.stopPropagation) &#123; <span class="comment">//这是其他浏览器</span></span><br><span class="line">        e.stopPropagation(); <span class="comment">//阻止冒泡事件</span></span><br><span class="line">        e.preventDefault();<span class="comment">//阻止默认事件</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// IE浏览器</span></span><br><span class="line">        e.cancelBubble=<span class="literal">true</span>; <span class="comment">//阻止冒泡事件</span></span><br><span class="line">        e.returnValue=<span class="literal">false</span>;<span class="comment">//阻止默认事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻止冒泡事件的兼容性处理<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopBubble</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(e &amp;&amp; e.stopPropagation) &#123; <span class="comment">//非IE </span></span><br><span class="line">    e.stopPropagation(); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//IE </span></span><br><span class="line">    <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h5><p>w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false;</p><p>我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，会执行几次事件，会先执行冒泡还是捕获？</p><p>首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段</p><blockquote><p>参考文章 <a href="https://blog.csdn.net/chenjuan1993/article/details/81347590" target="_blank" rel="noopener">终于弄懂了事件冒泡和事件捕获</a><br><a href="https://segmentfault.com/a/1190000000749838" target="_blank" rel="noopener">浅谈事件冒泡与事件捕获</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。&lt;br&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;outer&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;inner&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Click me!&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>get和post请求</title>
    <link href="http://yoursite.com/2018/10/10/HTTP/get%E5%92%8Cpost%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2018/10/10/HTTP/get和post请求/</id>
    <published>2018-10-10T10:52:53.000Z</published>
    <updated>2018-10-12T08:50:00.119Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在HTTP中，与服务器交互的方法，最常用的有4种：即Put（增）、Delete（删）、Post（改）、Get（查）。<br>get是获取数据，post是修改数据。<br><a id="more"></a></p><h5 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="headerlink" title="get 和 post 的区别"></a>get 和 post 的区别</h5><p>get把请求的数据放在url上，即HTTP协议头上，其格式为：<br>    以?分割URL和传输数据，参数之间以&amp;相连。<br>    数据如果是英文字母/数字，原样发送，<br>    如果是空格，转换为+，<br>    如果是中文/其他字符，则直接把字符串用BASE64加密，及“%”加上“字符串的16进制ASCII码”。<br>post把数据放在HTTP的包体内（requrest body）。</p><p>get提交的数据最大是2k（原则上url长度无限制，那么get提交的数据也没有限制咯？限制实际上取决于浏览器，(大多数)浏览器通常都会限制url长度在2K个字节，即使(大多数)服务器最多处理64K大小的url。也没有卵用。）。<br>post理论上没有限制。实际上IIS4中最大量为80KB，IIS5中为100KB。</p><p>GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);<br>POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p><p>GET在浏览器回退时是无害的，POST会再次提交请求。 </p><p>GET产生的URL地址可以被Bookmark，而POST不可以。 </p><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置。 </p><p>GET请求只能进行url编码，而POST支持多种编码方式。 </p><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 </p><p>GET只接受ASCII字符的参数的数据类型，而POST没有限制</p><p>那么，post那么好为什么还用get？get效率高！。</p><p><img src="/assets/images/get-post.png" alt="get post"></p><h5 id="其他-HTTP-请求方法"><a href="#其他-HTTP-请求方法" class="headerlink" title="其他 HTTP 请求方法"></a>其他 HTTP 请求方法</h5><p><img src="/assets/images/http.png" alt="get post"></p><blockquote><p>参考文章 <a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">HTTP 方法：GET 对比 POST</a> 、<a href="https://blog.csdn.net/qq_26360877/article/details/70665820" target="_blank" rel="noopener">get和post的区别–面试经常被问到！</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在HTTP中，与服务器交互的方法，最常用的有4种：即Put（增）、Delete（删）、Post（改）、Get（查）。&lt;br&gt;get是获取数据，post是修改数据。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>bind、apply和call的区别</title>
    <link href="http://yoursite.com/2018/10/10/JS/bind%E5%92%8Ccall/"/>
    <id>http://yoursite.com/2018/10/10/JS/bind和call/</id>
    <published>2018-10-10T10:21:49.000Z</published>
    <updated>2018-11-06T11:32:40.284Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ing…<br>bind和call的作用都是将某个函数的this指向绑定到另外一个作用域中，<br>他们的参数调用都是相同的，第一个参数为绑定的作用域对象是什么，接下<br>来就是可以添加不限的参数，而区别就是call在绑定的同时调用函数，<br>bind是返回一个改变this指向的函数。<br>apply方法和call方法有些相似，它也可以改变this的指向<br>同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>渐进增强和优雅降级</title>
    <link href="http://yoursite.com/2018/10/10/CSS3/%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7/"/>
    <id>http://yoursite.com/2018/10/10/CSS3/渐进增强和优雅降级/</id>
    <published>2018-10-10T10:21:49.000Z</published>
    <updated>2018-10-16T12:14:05.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="渐进增强"><a href="#渐进增强" class="headerlink" title="渐进增强"></a>渐进增强</h3><blockquote><p>一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.transition</span> &#123; <span class="comment">/*渐进增强写法*/</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">     <span class="attribute">-moz-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">       <span class="attribute">-o-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">          <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h3><blockquote><p>一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.transition</span> &#123; <span class="comment">/*优雅降级写法*/</span></span><br><span class="line">          <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">       <span class="attribute">-o-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">     <span class="attribute">-moz-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渐进增强和优雅降级的区别"><a href="#渐进增强和优雅降级的区别" class="headerlink" title="渐进增强和优雅降级的区别"></a>渐进增强和优雅降级的区别</h3><blockquote><p>渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的</p></blockquote><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>渐进增强和优雅降级如何抉择<ul><li>如果你采用渐进增强的开发流程，先做一个基本功能版，然后针对各个浏览器进行渐进增加，增加各种功能。相对于优雅降级来说，开发周期长，初期投入资金大。</li><li>那采用优雅降级呢，这样可以在较短时间内开发出一个只用于一个浏览器的完整功能版，然后就可以拿给PM找客户谈呀，可以拿去测试，市场试水呀，对于功能尚未确定的 产品，优雅降级不失为一种节约成本的方法。</li><li>采用优雅降级的写法，如果一个浏览器同时支持前缀写法和正常写法，后面的旧版浏览器样式就覆盖了新版样式，出现一些奇怪的问题 ，但是用渐进增强的写法就不存在这个问题。这种属性不止border-radius一个，所以为了避免这个不必要的错误，建议大家都采用渐进增强的写法。</li><li>绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。</li></ul></li></ul><blockquote><p>参考文章 <a href="https://blog.csdn.net/jnshu_it/article/details/77016996" target="_blank" rel="noopener">渐进增强和优雅降级之间有什么不同?</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>语义化标签</title>
    <link href="http://yoursite.com/2018/10/10/H5/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2018/10/10/H5/语义化标签/</id>
    <published>2018-10-10T10:21:49.000Z</published>
    <updated>2018-11-06T11:26:41.483Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><h4>H5中关于语义化的标签有哪些，语义化标签有什么作用？为什么要使用语义化标签?</h4><p></p><ol><li><p>H5中关于语义化的标签有哪些<br>title 简短、描述性、唯一（提升搜索引擎排名）<br>header 页眉通常包括网站标志、主导航、全站链接以及搜索框。<br>section 具有相似主题的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。</p><a id="more"></a><p>footer 页脚，只有当父级是body时，才是整个页面的页脚。<br>article 包含像报纸一样的内容= =||是这么理解的，表示文档、页面、应用或一个独立的容器<br>a<br>hgroup 标签用于对网页或区段（section）的标题进行组合<br>nav 标记导航，仅对文档中重要的链接群使用。<br>aside 指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。<br>address 作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）<br>mark 突出显示文本（yellow），提醒读者。<br>time 标记时间。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式<br>figure 创建图（默认有40px左右margin）<br>figcaption figure的标题，必须是figure内嵌的第一个或者最后一个元素。<br>datailst<br>details<br>summary<br>dialog<br>dd<br>progress 完成进度。可通过js动态更新value<br>keygen<br>small 指定细则，输入免责声明、注解、署名、版权。</p></li><li><p>语义化标签有什么作用？为什么要使用语义化标签？<br>在HTML5出现之前，我们一般采用div+css布局我们的页面。但是这样的布局方式不仅<br>使我们的文档结构不够清晰，而且不利于搜索引擎爬虫对我们页面的爬取。为了解决上述缺点，<br>HTML5新增了很多新的语义化标签。</p></li></ol><ul><li>引入语义化标签的好处主要有<ul><li>比div标签有更加丰富的含义，方便开发与维护</li><li>搜索引擎能更方便的识别页面的每个部分</li><li>方便其他设备解析（如移动设备、盲人阅读器等）</li></ul></li></ul><p><strong>H5新增的语义化标签  </strong></p><p>header<br>footer<br>article<br>aside 定义页面的侧边栏内容<br>time<br>details 用于描述文档或者文档某一部分细节，summary是details元素的标题<br>ruby 加注释，ruby标签有两个子元素，rt注释的内容，rp是该标签不显示时显示的文字<br>mark 定义带有几号的文本，它会给你想要突出显示的文本加个 背景色<br>nav<br>progress<br>section<br>video 定义视频，属性src引入资源，controls视频的控制控件<br>audio 该标签可定义声音，及其他的音频文件，不加controls不显示音频的控制界面<br>datalist 提示可能的值，datalist及其选项不会被显示出来，它仅仅是合法输入值的列表使用input元素的list属性来邦定datalist<br>embed 定义插入的内容，如插件，flash，标签中间不要加内容会显现出来<br>canvas canvas画布只是个容器，你可以通过控制坐标在canvas上绘制图形，一般配合js可以实现非常复杂的动画效果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h4&gt;H5中关于语义化的标签有哪些，语义化标签有什么作用？为什么要使用语义化标签?&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;H5中关于语义化的标签有哪些&lt;br&gt;title 简短、描述性、唯一（提升搜索引擎排名）&lt;br&gt;header 页眉通常包括网站标志、主导航、全站链接以及搜索框。&lt;br&gt;section 具有相似主题的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>清除浮动</title>
    <link href="http://yoursite.com/2018/10/10/CSS3/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    <id>http://yoursite.com/2018/10/10/CSS3/清除浮动/</id>
    <published>2018-10-10T10:21:49.000Z</published>
    <updated>2018-10-16T12:58:55.451Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载：<a href="https://segmentfault.com/a/1190000004865198" target="_blank" rel="noopener">CSS-清除浮动</a></p><h5 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h5><ol><li>使用带clear属性的空元素 div、hr、br都可以<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clear"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> <span class="attr">class</span>=<span class="string">"clear"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">class</span>=<span class="string">"clear"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.clear &#123;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">优点：通俗易懂，容易掌握</span><br><span class="line">缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。</span><br><span class="line">2. 使用CSS的overflow属性</span><br><span class="line">给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发</span><br><span class="line">hasLayout，例如为父元素设置容器宽高或设置 zoom:1。在添加overflow属性后，浮动元素又回到了容</span><br><span class="line">器层，把容器高度撑起，达到了清理浮动的效果。</span><br><span class="line"></span><br><span class="line">``` css</span><br><span class="line">.news &#123;</span><br><span class="line">  background-color: gray;</span><br><span class="line">  border: solid 1px black;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  *zoom: 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news img &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news p &#123;</span><br><span class="line">  float: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;news&quot;&gt;</span><br><span class="line">&lt;img src=&quot;news-pic.jpg&quot; /&gt;</span><br><span class="line">&lt;p&gt;some text&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">优点：不存在结构和语义化问题，代码量极少</span><br><span class="line">缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；04年POPO就发现overflow:hidden会导致中键失效，这是我作为一个多标签浏览控所不能接受的。所以还是不要使用.</span><br><span class="line">3. 父元素也设置浮动(给浮动的元素的容器添加浮动)</span><br><span class="line">优点：不存在结构和语义化问题，代码量极少</span><br><span class="line">缺点：给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。</span><br><span class="line">4. 使用邻接元素处理</span><br><span class="line">什么都不做，给浮动元素后面的元素添加clear属性。</span><br><span class="line">``` css</span><br><span class="line">.news &#123;</span><br><span class="line">  background-color: gray;</span><br><span class="line">  border: solid 1px black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news img &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news p &#123;</span><br><span class="line">  float: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.content&#123;</span><br><span class="line">  clear:both;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;news&quot;&gt;</span><br><span class="line">&lt;img src=&quot;news-pic.jpg&quot; /&gt;</span><br><span class="line">&lt;p&gt;some text&lt;/p&gt;</span><br><span class="line">&lt;div class=&quot;content&quot;&gt;***&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用:after 伪元素<br>结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。<br>给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.news</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"020"</span>; </span><br><span class="line">  <span class="attribute">display</span>: block; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">clear</span>: both; </span><br><span class="line">  <span class="attribute">visibility</span>: hidden;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="comment">/* 触发 hasLayout */</span> </span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class="news clearfix"&gt;</span><br><span class="line">&lt;img src="news-pic.jpg" /&gt;</span><br><span class="line">&lt;p&gt;some text&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>清除浮动：清除对应的单词是 clear，对应CSS中的属性是 clear：left | right | both | none；<br>闭合浮动：更确切的含义是使浮动元素闭合，从而减少浮动带来的影响。其中涉及的原理有：hasLayout 和 Block formatting contexts 。</p><p>通过上面的例子，我们不难发现清除浮动的方法可以分成两类：</p><p>一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。</p><p>二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。</p><p>在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。</p><p>最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>css模块化</title>
    <link href="http://yoursite.com/2018/10/10/CSS3/css%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://yoursite.com/2018/10/10/CSS3/css模块化/</id>
    <published>2018-10-10T10:21:49.000Z</published>
    <updated>2018-11-04T11:18:06.551Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>未完成ing…</p><ul><li>设计原则<ul><li>可复用能继承要完整</li><li>周期性迭代<ul><li>优秀的代码是模仿/设计/重构出来的</li></ul></li></ul></li><li>设计方法<ul><li>先整体后部分再颗粒化<ul><li>布局-&gt; 页面 -&gt; 功能-&gt;业务</li></ul></li><li>先抽象再具体</li></ul></li></ul><p>css模块化设计<br><img src="/assets/images/css模块化.webp" alt="模块化"></p><p>reset.scss：<br>浏览器不同，对默认的标签有默认的样式，为了表现统一化，要加一个这个。<br>layout.scss:<br>布局抽象成这个<br>element.scss:<br>列表、按钮</p><p>global的方式引用，比如说直接把某个模块引用进来，然后就可以写具体的样式了。<br>scope就是用的module方法。比如说两个组件都叫做.btn，这样在之前会导致两个样式的名称一致，会被覆盖，如果想用相同的名称，样式不一样，就要用css module这样就不一致，因为编译出来的class带了一串编码。</p><ul><li>优点：<ul><li>提高代码重用率</li><li>提高开发效率、减少沟通成本</li><li>降低耦合</li><li>降低发布风险</li><li>减少Bug定位时间和Fix成本</li><li>提高页面容错</li><li>更好的实现快速迭代</li><li>更好的支持灰度发布</li></ul></li></ul><p>参考: <a href="https://www.aliyun.com/jiaocheng/693575.html" target="_blank" rel="noopener">CSS模块化如何实现？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
</feed>
