<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>昨夜小楼又东风</title>
  
  <subtitle>纵豆蔻词工，青楼好梦，难赋深情</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-09T08:55:30.370Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LittleStar</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue知识点详解</title>
    <link href="http://yoursite.com/2019/04/09/Vue/Vue%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/04/09/Vue/Vue知识点详解/</id>
    <published>2019-04-09T06:07:35.000Z</published>
    <updated>2019-04-09T08:55:30.370Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>Vue watch computed nexttick<br>双向绑定 虚拟dom<br>Vue双向绑定原理/组件通讯<br>Vue 单双向绑定（dep watcher observer）</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>宏任务&amp;&amp;微任务</title>
    <link href="http://yoursite.com/2019/04/09/JavaScript/%E5%AE%8F%E4%BB%BB%E5%8A%A1&amp;&amp;%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/04/09/JavaScript/宏任务&amp;&amp;微任务/</id>
    <published>2019-04-09T01:46:03.000Z</published>
    <updated>2019-04-09T02:22:35.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>JavaScript 是单线程、异步、非阻塞、解释型脚本语言。</code><br>　　微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。</p><h4 id="macrotask-宏任务"><a href="#macrotask-宏任务" class="headerlink" title="(macrotask)宏任务"></a>(macrotask)宏任务</h4><p>　　<code>macrotask</code>： 包括整体代码<code>script</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>等（可以看到，事件队列中的每一个事件都是一个 <code>macrotask</code>，现在称之为宏任务队列）</p><h4 id="microtask-微任务"><a href="#microtask-微任务" class="headerlink" title="(microtask)微任务"></a>(microtask)微任务</h4><p>　　<code>microtask</code>:<code>原生Promise</code>(有些实现的promise将then方法放到了宏任务中)、<code>process.nextTick</code>、Object.observe(已废弃)、 <code>MutationObserver</code> 记住就行了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'timer over'</span>)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line">// script start</span><br><span class="line">// script end</span><br><span class="line">// promise1</span><br><span class="line">// promise2</span><br><span class="line">// timer over</span><br></pre></td></tr></table></figure></p><p>JS引擎线程首先执行主代码块。<br>　　每次执行栈执行的代码就是一个宏任务，包括任务队列(宏任务队列)中的，因为执行栈中的宏任务执行完会去取任务队列（宏任务队列）中的任务加入执行栈中，即同样是事件循环的机制。<br>　　在执行宏任务时遇到<code>Promise</code>等，会<code>创建微任务</code>（.then()里面的回调），并加入到<code>微任务队列队尾</code>。<br>　　<code>microtask</code>必然是在某个宏任务执行的时候创建的，而在下一个宏任务开始之前，浏览器会对页面重新渲染(<code>task &gt;&gt; 渲染 &gt;&gt; 下一个task(从任务队列中取一个)</code>)。同时，<code>在上一个宏任务执行完成后，渲染页面之前，会执行当前微任务队列中的所有微任务</code>。<br>　　也就是说: <code>在某一个 macrotask 执行完后，在重新渲染与开始下一个宏任务之前，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）</code>。<br>　　这样就可以解释 “promise 1” “promise 2” 在 “timer over” 之前打印了。”promise 1” “promise 2” 做为微任务加入到微任务队列中，而 “timer over” 做为宏任务加入到宏任务队列中，它们同时在等待被执行，但是微任务队列中的所有微任务都会在开始下一个宏任务之前都被执行完。</p><blockquote><p>在node环境下，<code>process.nextTick</code>的优先级高于<code>Promise</code>，也就是说：<code>在宏任务结束后会先执行微任务队列中的nextTickQueue，然后才会执行微任务中的Promise</code>。</p></blockquote><p>执行机制：<br>　　执行一个宏任务（栈中没有就从事件队列中获取）<br>　　执行过程中如果遇到微任务，就将它添加到微任务的任务队列中<br>　　宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）<br>　　当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染<br>　　渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　<code>JavaScript</code> 是单线程语言，决定于它的设计最初是用来处理浏览器网页的交互。浏览器负责解释和执行 <code>JavaScript</code> 的线程只有一个（所有说是单线程），即<code>JS引擎线程</code>，但是浏览器同样提供其他线程，如：事件触发线程、定时器触发线程等。<br>异步一般是指：<br>　　<code>网络请求`</code><br>　　<code>计时器`</code><br>　　<code>DOM事件监听`</code><br>事件循环机制：<br>　　<code>JS引擎线程</code>会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。<br>　　<code>JS引擎线程</code>遇到异步函数，会将异步函数交给相应的Webapi，而继续执行后面的任务。<br>　　<code>Webapi</code>会在条件满足的时候，将异步对应的回调加入到消息队列中，等待执行。<br>　　<code>执行栈为空时</code>，JS引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。<br>　　<code>完成后出栈</code>，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。</p><p>原文：<br>　　<a href="https://juejin.im/post/5be5a0b96fb9a049d518febc" target="_blank" rel="noopener">总结：JavaScript异步、事件循环与消息队列、微任务与宏任务</a><br>　　<a href="https://juejin.im/post/5b498d245188251b193d4059" target="_blank" rel="noopener">JS事件循环机制（event loop）之宏任务/微任务</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/04/09/JavaScript/debounce/"/>
    <id>http://yoursite.com/2019/04/09/JavaScript/debounce/</id>
    <published>2019-04-09T00:40:16.231Z</published>
    <updated>2019-04-09T01:18:37.451Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>防抖和节流</title><style>button {width: 100px;height: 50px;}.log {width: 100%;height: 30px;border: 1px solid #ccc;margin-top: 10px;}</style></head><body><button id="debounced">Debounced</button><button id="throttled">Throttled</button><div id="log1" class="log"></div><div id="log2" class="log"></div><script>/*  节流说白了就是每ms执行一次函数，  防抖就是 我最后一次触发后ms后执行一次回调函数*//*debounced（防抖动）函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 fn 方法。*/function debounce(fn, wait, options) {// 等待时间wait = wait || 0// 点击次数let timerId;console.log("timerId:", timerId);// 这个函数的功能是：// return function() {if (timerId) {clearTimeout(timerId);timerId = null;}timerId = setTimeout(function() {fn();}, wait);console.log("timerId:", timerId);}}// 节流函数，在 wait 秒内最多执行 fn 一次的函数。function throttle(fn, wait, options) {wait = wait || 0;let timerId;let lastTime = 0;return function() {let currentTime = new Date();if (currentTime >= lastTime + wait) {fn();lastTime = currentTime;} else {if (timerId) {clearTimeout(timerId);timerId = null;}timerId = setTimeout(function() {fn();}, wait);}}}let debouncedBtn = document.getElementById('debounced');let throttledBtn = document.getElementById('throttled');let log1 = document.getElementById('log1');let log2 = document.getElementById('log2');function handleDebounce() {log1.innerHTML += 'debounced';console.log("debounced");}function handleThrottle() {log2.innerHTML += 'throttle';console.log("throttle");}debouncedBtn.addEventListener('click', debounce(handleDebounce, 2000));throttledBtn.addEventListener('click', throttle(handleThrottle, 2000));</script></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="http://yoursite.com/2019/04/08/HTTP/HTTP/"/>
    <id>http://yoursite.com/2019/04/08/HTTP/HTTP/</id>
    <published>2019-04-08T13:25:53.000Z</published>
    <updated>2019-04-09T05:51:36.184Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>　　<a href="https://juejin.im/post/5ba65296f265da0ac8493503#heading-14" target="_blank" rel="noopener">深入理解 HTTP 协议</a><br>　　<a href="http://www.36nu.com/post/153.html" target="_blank" rel="noopener">HTTP协议Header详解</a><br>　　<a href="https://www.jianshu.com/p/6e9e4156ece3" target="_blank" rel="noopener">一篇文章带你详解 HTTP 协议（网络协议篇一）</a><br><a href="https://juejin.im/post/5ab308e9f265da238e0da39b" target="_blank" rel="noopener">天下无难试之HTTP协议面试刁难大全（上）</a><br><a href="https://juejin.im/post/5b7919345188254312414b9c#heading-1" target="_blank" rel="noopener">通过HTTP的HEADER完成各种骚操作</a><br><a href="https://www.jianshu.com/p/59d36b01608d" target="_blank" rel="noopener">Http–Header</a><br><a href="https://juejin.im/post/5c136bd16fb9a049d37efc47" target="_blank" rel="noopener">前端缓存最佳实践</a><br><a href="https://juejin.im/post/58eacff90ce4630058668257#heading-0" target="_blank" rel="noopener">浏览器缓存机制剖析</a><br><a href="https://juejin.im/post/5a6c87c46fb9a01ca560b4d7#heading-7" target="_blank" rel="noopener">缓存详解</a><br><a href="https://juejin.im/post/5b70edd4f265da27df0938bc#heading-3" target="_blank" rel="noopener">前端也要懂Http缓存机制</a></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h4 id="HTTP-Header"><a href="#HTTP-Header" class="headerlink" title="HTTP Header"></a>HTTP Header</h4><p><a href="https://juejin.im/post/5b70edd4f265da27df0938bc#heading-0" target="_blank" rel="noopener">前端也要懂Http缓存机制</a><br><a href="https://juejin.im/post/58eacff90ce4630058668257#heading-10" target="_blank" rel="noopener">浏览器缓存机制剖析</a></p><h4 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h4><p><code>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术</code>。<br>缓存的好处：<br>　　<code>缓解服务器压力</code>(不用每次去请求资源)；<br>　　<code>提升性能</code>(打开本地资源速度当然比请求回来再打开要快得多)；<br>　　<code>减少带宽消耗</code>(我相信你可以理解)；<br>　　关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果<code>内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面</code>。这就可以比较合理的解释了为什么同一个资源有时是<code>from memory cache</code>有时是<code>from disk cache</code>的问题了。<br>　　浏览器对于请求资源, 拥有一系列成熟的缓存策略. 按照发生的时间顺序分别为<code>存储策略</code>, <code>过期策略</code>, <code>协商策略</code>, 其中存储策略在收到响应后应用, 过期策略, 协商策略在发送请求前应用. 流程图如下所示.<br><img src="/assets/images/http缓存.png" alt="http缓存"></p><p>1.http header中与缓存有关的key.</p><table><thead><tr><th>key</th><th>描述</th><th>储存策略</th><th>过期策略</th><th>协商策略</th></tr></thead><tbody><tr><td>Cache-Control</td><td>指定缓存机制,覆盖其它设置</td><td>✔️</td><td>✔️</td><td></td></tr><tr><td>Pragma</td><td>http1.0字段,指定缓存机制</td><td>✔️</td><td></td><td></td></tr><tr><td>Expires</td><td>http1.0字段,指定缓存的过期时间</td><td></td><td>✔️</td><td></td></tr><tr><td>Last-Modified</td><td>资源最后一次的修改时间</td><td></td><td></td><td>✔️</td></tr><tr><td>ETag</td><td>唯一标识请求资源的字符串</td><td></td><td></td><td>✔️</td></tr></tbody></table><p>2.缓存协商策略用于重新验证缓存资源是否有效, 有关的key如下.</p><table><thead><tr><th>key</th><th>描述</th></tr></thead><tbody><tr><td>If-Modified-Since</td><td>缓存校验字段, 值为资源最后一次的修改时间, 即上次收到的Last-Modified值</td></tr><tr><td>If-Unmodified-Since</td><td>同上, 处理方式与之相反</td></tr><tr><td>If-Match</td><td>缓存校验字段, 值为唯一标识请求资源的字符串, 即上次收到的ETag值</td></tr><tr><td>If-None-Match</td><td>同上, 处理方式与之相反</td></tr></tbody></table><p>　　Http缓存可以分为两大类，强制缓存（也称强缓存）和协商缓存。两类缓存规则不同，强制缓存在缓存数据未失效的情况下，不需要再和服务器发生交互；而协商缓存，顾名思义，需要进行比较判断是否可以使用缓存。<br>　　两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。</p><h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><p>　　强制缓存分为两种情况，<code>Expires</code> 和 <code>Cache-Control</code>。<br>一旦资源命中强缓存, 浏览器便不会向服务器发送请求, 而是直接读取缓存.<br>对于常规请求, 只要存在该资源的缓存, 且Cache-Control:max-age 或者expires没有过期, 那么就能命中强缓存.</p><h6 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h6><p>　　 针对浏览器和服务器时间不同步，加入了新的缓存方案；这次服务器不是直接告诉浏览器过期时间，而是告诉一个相对时间Cache-Control=10秒，意思是10秒内，直接使用浏览器缓存。<br>　　 浏览器缓存里, Cache-Control是金字塔顶尖的规则, 它藐视一切其他设置, 只要其他设置与其抵触, 一律覆盖之.<br>　　 不仅如此, 它还是一个复合规则, 包含多种值, 横跨 存储策略, 过期策略 两种, 同时在请求头和响应头都可设置.</p><h6 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h6><p>　　Expires的值是服务器告诉浏览器的缓存过期时间（值为GMT时间，即格林尼治时间），即下一次请求时，如果浏览器端的当前时间还没有到达过期时间，则直接使用缓存数据。</p><h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>　　强制缓存的弊端很明显，即每次都是根据时间来判断缓存是否过期；但是当到达过期时间后，如果文件没有改动，再次去获取文件就有点浪费服务器的资源了。协商缓存有两组报文结合使用：<br>　　<code>Last-Modified</code> 和 <code>If-Modified-Since</code><br>　　<code>ETag</code> 和 <code>If-None-Match</code></p><h6 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h6><p>　　语法: Last-Modified: 星期,日期 月份 年份 时:分:秒 GMT</p><blockquote><p><code>Last-Modified: Tue, 04 Apr 2017 10:01:15 GMT</code></p></blockquote><p>　　用于标记请求资源的最后一次修改时间, 格式为GMT(格林尼治标准时间). 如可用 new Date().toGMTString()获取当前GMT时间. Last-Modified 是 ETag 的fallback机制, 优先级比 ETag 低, 且只能精确到秒, 因此不太适合短时间内频繁改动的资源. 不仅如此, 服务器端的静态资源, 通常需要编译打包, 可能出现资源内容没有改变, 而Last-Modified却改变的情况.</p><h6 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h6><p><code>If-Modified-Since: Tue, 04 Apr 2017 10:12:27 GMT</code><br>　　缓存校验字段, 其值为上次响应头的Last-Modified值, 若与请求资源当前的Last-Modified值相同, 那么将返回304状态码的响应, 反之, 将返回200状态码响应.</p><h6 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h6><p><code>ETag:&quot;fcb82312d92970bdf0d18a4eca08ebc7efede4fe&quot;</code><br>　　实体标签, 服务器资源的唯一标识符, 浏览器可以根据ETag值缓存数据, 节省带宽. 如果资源已经改变, etag可以帮助防止同步更新资源的相互覆盖. ETag 优先级比 Last-Modified 高.</p><h6 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h6><p>语法: <code>If-None-Match: ETag_value</code> 或者 <code>If-None-Match: ETag_value, ETag_value</code>,<br>　　缓存校验字段, 结合<code>ETag</code>字段, 常用于判断缓存资源是否有效, 优先级比<code>If-Modified-Since</code>高.<br>　　对于 <code>GET</code> 或 <code>HEAD</code> 请求, 如果其etags列表均不匹配, 服务器将返回200状态码的响应, 反之, 将返回304(Not Modified)状态码的响应. 无论是200还是304响应, 都至少返回<code></code> Cache-Control<code>,</code>Content-Location<code>,</code>Date<code>,</code>ETag<code>,</code>Expires<code>,</code>and Vary<code>中之一的字段.　　对于其他更新服务器资源的请求, 如果其etags列表匹配, 服务器将执行更新, 反之, 将返回412(</code>Precondition Failed`)状态码的响应.</p><h5 id="不缓存-Pragma"><a href="#不缓存-Pragma" class="headerlink" title="不缓存(Pragma)"></a>不缓存(Pragma)</h5><p>　　当该字段值为no-cache的时候，会告诉浏览器不要对该资源缓存，即每次都得向服务器发一次请求才行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//禁止缓存</span><br><span class="line">res.setHeader(<span class="string">'Pragma'</span>, <span class="string">'no-cache'</span>)</span><br><span class="line">//2分钟</span><br><span class="line">res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'public,max-age=120'</span>)</span><br></pre></td></tr></table></figure></p><p>　　通过<code>Pragma</code>来禁止缓存，通过<code>Cache-Control</code>设置两分钟缓存，但是重新访问我们会发现浏览器会再次发起一次请求，说明了<code>Pragma的优先级高于Cache-Control</code>。</p><h5 id="缓存优先级"><a href="#缓存优先级" class="headerlink" title="缓存优先级"></a>缓存优先级</h5><p><code>Pragma &gt; Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified</code></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>事件代理(事件委托)</title>
    <link href="http://yoursite.com/2019/04/08/JavaScript/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/08/JavaScript/事件代理/</id>
    <published>2019-04-08T05:52:17.000Z</published>
    <updated>2019-04-08T07:15:56.593Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://www.cnblogs.com/wp-js/p/7609539.html" target="_blank" rel="noopener">javascript事件代理（事件委托）原理是怎么实现的</a></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>　　那什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：<code>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件</code>。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象，我仔细揣摩了一下，这个例子还真是恰当，我就不去想别的例子来解释了，借花献佛，我摘过来，大家认真领会一下事件委托到底是一个什么原理：<br>　　有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。<br>这里其实还有2层意思的：<br>　　第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；<br>　　第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1、<code>可以大量节省内存的使用，减少注册事件</code>，例如给table中的td事件，就添加到table上<br>2、<code>实现新增子对象时无需再次对其绑定事件。对于动态部分尤为适合</code></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>仅是上述1中类似的需求才会使用，使用场景比较少。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>事件委托的原理：<br>　　<code>事件委托是利用事件的冒泡原理来实现的</code>，何为事件冒泡呢？就是<code>事件从最深的节点开始，然后逐步向上传播事件</code>，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="一般方法的例子："><a href="#一般方法的例子：" class="headerlink" title="一般方法的例子："></a>一般方法的例子：</h4><p>子节点实现相同的功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"ul1"</span>&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>实现功能是点击li，弹出123：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  var oUl = document.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">  var aLi = oUl.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line">  <span class="keyword">for</span>(var i=0;i&lt;aLi.length;i++)&#123;</span><br><span class="line">    aLi[i].onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">      alert(123);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="事件委托方式："><a href="#事件委托方式：" class="headerlink" title="事件委托方式："></a>事件委托方式：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var oUl = document.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">   oUl.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招：<br>　　<code>Event</code>对象提供了一个属性叫<code>target</code>，可以返回事件的目标节点，我们成为事件源，也就是说，<code>target</code>就可以表示为当前的事件操作的<code>dom</code>，但是不是真正操作<code>dom</code>，当然，这个是有兼容性的，标准浏览器用<code>ev.target</code>，IE浏览器用<code>event.srcElement</code>，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用<code>nodeName</code>来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　var oUl = document.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">　　oUl.onclick = <span class="keyword">function</span>(ev)&#123;</span><br><span class="line">　　　　var ev = ev || window.event;</span><br><span class="line">　　　　var target = ev.target || ev.srcElement;</span><br><span class="line">　　　　<span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;</span><br><span class="line">　 　　　　　　  alert(123);</span><br><span class="line">　　　　　　　  alert(target.innerHTML);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！</p><p>　　上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"add"</span> value=<span class="string">"添加"</span> /&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"remove"</span> value=<span class="string">"删除"</span> /&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"move"</span> value=<span class="string">"移动"</span> /&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"select"</span> value=<span class="string">"选择"</span> /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var Add = document.getElementById(<span class="string">"add"</span>);</span><br><span class="line">    var Remove = document.getElementById(<span class="string">"remove"</span>);</span><br><span class="line">    var Move = document.getElementById(<span class="string">"move"</span>);</span><br><span class="line">    var Select = document.getElementById(<span class="string">"select"</span>);</span><br><span class="line">    </span><br><span class="line">    Add.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">'添加'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Remove.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">'删除'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Move.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">'移动'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Select.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">'选择'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　上面实现的效果我就不多说了，很简单，4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  var oBox = document.getElementById(<span class="string">"box"</span>);</span><br><span class="line">  oBox.onclick = <span class="keyword">function</span> (ev) &#123;</span><br><span class="line">    var ev = ev || window.event;</span><br><span class="line">    var target = ev.target || ev.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName.toLocaleLowerCase() == <span class="string">'input'</span>)&#123;</span><br><span class="line">      switch(target.id)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'add'</span> :</span><br><span class="line">          alert(<span class="string">'添加'</span>);</span><br><span class="line">          <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'remove'</span> :</span><br><span class="line">          alert(<span class="string">'删除'</span>);</span><br><span class="line">          <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'move'</span> :</span><br><span class="line">          alert(<span class="string">'移动'</span>);</span><br><span class="line">          <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'select'</span> :</span><br><span class="line">          alert(<span class="string">'选择'</span>);</span><br><span class="line">          <span class="built_in">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> name=<span class="string">""</span> id=<span class="string">"btn"</span> value=<span class="string">"添加"</span> /&gt;</span><br><span class="line">&lt;ul id=<span class="string">"ul1"</span>&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  var oBtn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">  var oUl = document.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">  var aLi = oUl.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line">  var num = 4;</span><br><span class="line">  </span><br><span class="line">  //事件委托，添加的子元素也有事件</span><br><span class="line">  oUl.onmouseover = <span class="keyword">function</span>(ev)&#123;</span><br><span class="line">    var ev = ev || window.event;</span><br><span class="line">    var target = ev.target || ev.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;</span><br><span class="line">        target.style.background = <span class="string">"red"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  oUl.onmouseout = <span class="keyword">function</span>(ev)&#123;</span><br><span class="line">    var ev = ev || window.event;</span><br><span class="line">    var target = ev.target || ev.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;</span><br><span class="line">        target.style.background = <span class="string">"#fff"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  //添加新节点</span><br><span class="line">  oBtn.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    num++;</span><br><span class="line">    var oLi = document.createElement(<span class="string">'li'</span>);</span><br><span class="line">    oLi.innerHTML = 111*num;</span><br><span class="line">    oUl.appendChild(oLi);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>面试题详解</title>
    <link href="http://yoursite.com/2019/04/07/JavaScript/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/04/07/JavaScript/面试题详解/</id>
    <published>2019-04-07T09:52:09.000Z</published>
    <updated>2019-04-09T09:45:31.554Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>闭包<br><a href="https://alittlelittlestar.github.io/2019/04/02/JavaScript/作用域和闭包/" target="_blank" rel="noopener">闭包</a><br>作用域 this<br>声明提升(变量提升)<br><a href="https://alittlelittlestar.github.io/2019/03/27/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">声明提升</a><br>盒模型<br><a href="https://alittlelittlestar.github.io/2018/11/06/CSS3/盒子模型/" target="_blank" rel="noopener">盒模型</a><br>布局(all) flex 圣杯布局(JS实现左右高度为窗口高度)+ 双飞翼布局<br><a href="https://alittlelittlestar.github.io/2019/02/15/页面布局/CSS布局/" target="_blank" rel="noopener">布局</a></p><p>get post<br>JS 跨域<br>HTTP状态码<br><a href="https://alittlelittlestar.github.io/2018/10/10/HTTP/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81/" target="_blank" rel="noopener">HTTP状态码</a><br>position </p><p>垂直居中 定宽 不定宽<br>css布局 浮动<br>HTTP协议<br>absolute &amp;&amp; relative 区别</p><p>块级元素&amp;&amp;行内元素<br>代理事件的原理<br>JS promise原理及实现<br>float<br>手撕promise （解决回调地狱回调代码难以维护的问题）<br>js数组类型<br>instanceof<br><a href="https://juejin.im/post/5b0b9b9051882515773ae714" target="_blank" rel="noopener">浅谈 instanceof 和 typeof 的实现原理</a><br>settimeout 、 setinterval<br><a href="https://www.jianshu.com/p/3e482748369d" target="_blank" rel="noopener">彻底理解setTimeout()</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settimeout</span></span><br><span class="line">settimeout(callback, time)</span><br><span class="line"></span><br><span class="line"><span class="comment"># setinterval</span></span><br><span class="line">setinterval(callback, time)</span><br><span class="line"></span><br><span class="line">setTimeout含义是定时器，到达一定的时间触发一次，</span><br><span class="line">但是setInterval含义是计时器，到达一定时间触发一</span><br><span class="line">次，并且会持续触发</span><br></pre></td></tr></table></figure></p><p>伪元素/伪类的区别<br><a href="http://localhost:4000/2018/11/16/CSS3/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/" target="_blank" rel="noopener">伪元素/伪类的区别</a><br>form表单当前页面无刷新提交(target iframe)<br><a href="https://www.cnblogs.com/chongyao/p/7298986.html" target="_blank" rel="noopener">form表单提交方式</a><br>表单可实现无刷新页面提交，无需页面跳转，如下，通过一个隐藏的iframe实现，form表单的target设置为iframe的name名称，<br>form提交目标位当前页面iframe则不会刷新页面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"/url.do"</span> method=<span class="string">"post"</span> target=<span class="string">"targetIfr"</span>&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span>/&gt;</span><br><span class="line">&lt;/form&gt;   </span><br><span class="line">&lt;iframe name=<span class="string">"targetIfr"</span> style=<span class="string">"display:none"</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p><p>清除浮动 原理(使用clear:both 会把浮动元素的边界拉下来到标准流，从而把对应标准流的位置撑开)<br><a href="https://alittlelittlestar.github.io/2018/10/10/CSS3/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/" target="_blank" rel="noopener">清除浮动</a><br>deBounce 防抖 实现<br><a href="https://juejin.im/post/5a0b10726fb9a044fc444311" target="_blank" rel="noopener"></a><br><a href="https://juejin.im/post/5b5e724af265da0f4d0d88b2" target="_blank" rel="noopener"></a><br>http &amp;&amp; https  ssl 证书验证 加密算法<br>ES6、ES7 新特性<br>JS ES6<br>let const class声明类 promise 模板字符串 对象数组 解构赋值 箭头函数(this指向外层作用域)<br>队列里的优先级问题<br>（微任务(promise)宏任务(xhr请求、settimeout、setInterval)）当前同步操作完成后优先执行微任务队列任务<br>前端性能优化<br>xss<br>http 协议 header 缓存：（强缓存、协商缓存）<br>margin 坍塌， 水平方向会不会坍塌</p><hr><p>1、当两个对象为上下关系时，而且都具备margin属性时，上面的margin-bottom与下面的margin-top会发生塌陷<br>　　当margin-bottom和margin都为正数时，结果为两者之间的最大值<br>　　当margin-bottom和margin-top都为负时，结果为两者绝对最较大的那个值。<br>　　当margin-bottom和margin-top为一正一负时，结果为两者之和。<br>2、当两个对象为上下包含关系<br>　　父元素无填充内容，且没有设置border时，子元素的margin-top不会起作用<br>　　父元素设置border属性，子元素的margin-top起作用<br>　　父元素有填充内容，子元素的margin-top会起作用，当margin-top小于填充内容时，距离为填充内容的高度<br>　　<br>CSS及浏览器的设计者们希望我们在布局时，如果遇到上下两个并排内容块的安排，最好只设置其中每个块上或下margin的一处即可。</p><p>但对于父块DIV内含子块DIV的情况，就会按另一条CSS惯例来解释了，那就是：对于有块级子元素的元素计算高度的方式,如果元素没有垂直边框和填充,那其高度就是其子元素顶部和底部边框边缘之间的距离。<br>解决父元素塌陷的方法有，（应该给父类元素添加BFC）<br>1、为父元素添加overflow:hidden;，<br>2、为父元素float非none属性，也可为子元素添加float非none属性<br>3、需要给父div设置：边框，当然可以设置边框为透明;<br>4、为父DIV添加padding，或者至少添加padding-top;<br>5，如果遇到上下两个并排内容块的安排，最好只设置其中每个块上或下margin的一处即可。</p><hr><p>如何判断一个数组/data<br><code>instanceof、typeof、 constructor、 Object.prototype.toSting.call()</code><br>选择框实现原理</p><p>三栏布局 float position flex<br>float 布局对后续元素的影响<br>面向对象<br>哪些数组方法不能改变数组本身(concat、slice)</p><p>Vue watch computed nexttick<br>双向绑定 虚拟dom<br>Vue双向绑定原理/组件通讯<br>Vue 单双向绑定（dep watcher observer）</p><p>异步执行的原理<br>数组去重<br>原型链</p><p>数组和链表的数据结构的区别<br>选择器标签</p><p>原生 js实现jsonp跨域、深度克隆、模板引擎、正则表达式<br>IE兼容<br>字符串数组操作方法<br>继承方法<br>设计模式<br>MVC mvvm</p><p>underscore once 实现方法<br>框架选择<br>判断一个变量是整数<br>如何避免多重回调 promise，如何在外部进行resolve()<br>数组去重 set for循环实现数组reduce<br>express 中间件<br>原生js 封装 ajax 方法 get 、 post<br>数据结构<br>算法<br>栈模拟队列<br>二分插入进数组</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>浏览器兼容性</title>
    <link href="http://yoursite.com/2019/04/05/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/05/前端性能优化/浏览器兼容性/</id>
    <published>2019-04-05T11:46:31.000Z</published>
    <updated>2019-04-09T06:26:53.382Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://juejin.im/post/5b3da006e51d4518f140edb2#heading-5" target="_blank" rel="noopener">如何机智地回答浏览器兼容性问题</a></p><h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><p>　　浏览器的兼容性无非还是<code>样式兼容性（css）</code>，<code>交互兼容性（javascript）</code>，<code>浏览器 hack</code>三个方面。</p><h4 id="样式兼容-CSS-方面"><a href="#样式兼容-CSS-方面" class="headerlink" title="样式兼容(CSS)方面"></a>样式兼容(CSS)方面</h4><p>　　1、因为历史原因，不同的浏览器样式存在差异，可以通过 Normalize.css 抹平差异，也可以定制自己的 reset.css，例如通过通配符选择器，全局重置样式:<code>* { margin: 0; padding: 0; }</code><br>　　2、在CSS3还没有成为真正的标准时，浏览器厂商就开始支持这些属性的使用了。CSS3样式语法还存在波动时，浏览器厂商提供了针对浏览器的前缀，直到现在还是有部分的属性需要加上浏览器前缀。在开发过程中我们一般通过IDE开发插件、css 预处理器以及前端自动化构建工程帮我们处理。<br>浏览器内核与前缀的对应关系如下:</p><table><thead><tr><th>内核</th><th>主要代表的浏览器</th><th>前缀</th></tr></thead><tbody><tr><td>Trident</td><td>IE浏览器</td><td>-ms</td></tr><tr><td>Gecko</td><td>Firefox</td><td>-moz</td></tr><tr><td>Presto</td><td>Opera</td><td>-o</td></tr><tr><td>Webkit</td><td>Chrome(blink)、Safari</td><td>-webkit</td></tr></tbody></table><p>　　3、在还原设计稿的时候我们常常会需要用到透明属性，所以解决 IE9 以下浏览器不能使用 opacity。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opacity: 0.5;</span><br><span class="line">//IE6-IE8我们习惯使用filter滤镜属性来进行实现</span><br><span class="line">filter: alpha(opacity = 50); </span><br><span class="line">//IE4-IE9都支持滤镜写法progid:DXImageTransform.Microsoft.Alpha(Opacity=xx)</span><br><span class="line">filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50);</span><br></pre></td></tr></table></figure></p><h4 id="交互兼容-javascript"><a href="#交互兼容-javascript" class="headerlink" title="交互兼容(javascript)"></a>交互兼容(javascript)</h4><p>　　1、事件兼容的问题，我们通常需要会封装一个适配器的方法，过滤事件句柄绑定、移除、冒泡阻止以及默认事件行为处理<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var  helper = &#123;&#125;</span><br><span class="line">//绑定事件</span><br><span class="line">helper.on = <span class="keyword">function</span>(target, <span class="built_in">type</span>, handler) &#123;</span><br><span class="line"> <span class="keyword">if</span>(target.addEventListener) &#123;</span><br><span class="line">   target.addEventListener(<span class="built_in">type</span>, handler, <span class="literal">false</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   target.attachEvent(<span class="string">"on"</span> + <span class="built_in">type</span>,</span><br><span class="line">     <span class="keyword">function</span>(event) &#123;</span><br><span class="line">       <span class="built_in">return</span> handler.call(target, event);</span><br><span class="line">       &#125;, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//取消事件监听</span><br><span class="line">helper.remove = <span class="keyword">function</span>(target, <span class="built_in">type</span>, handler) &#123;</span><br><span class="line"> <span class="keyword">if</span>(target.removeEventListener) &#123;</span><br><span class="line">   target.removeEventListener(<span class="built_in">type</span>, handler);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   target.detachEvent(<span class="string">"on"</span> + <span class="built_in">type</span>,</span><br><span class="line">     <span class="keyword">function</span>(event) &#123;</span><br><span class="line">     <span class="built_in">return</span> handler.call(target, event);</span><br><span class="line">   &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>　　2、<code>new Date()</code>构造函数使用，’2018-07-05’是无法被各个浏览器中，使用<code>new Date(str)</code>来正确生成日期对象的。 正确的用法是’2018/07/05’.<br>　　3、获取 scrollTop 通过 <code>document.documentElement.scrollTop</code> 兼容非chrome浏览器<br><code>var scrollTop = document.documentElement.scrollTop||document.body.scrollTop;</code></p><h4 id="浏览器-hack-CSS-hack"><a href="#浏览器-hack-CSS-hack" class="headerlink" title="浏览器 hack(CSS hack)"></a>浏览器 hack(CSS hack)</h4><p>　　由于不同厂商的流览器或某浏览器的不同版本（如<code>IE6-IE11</code>,<code>Firefox/Safari/Opera/Chrome</code>等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack!<br>　　1、快速判断 IE 浏览器版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[<span class="keyword">if</span> IE 8]&gt; ie8 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[<span class="keyword">if</span> IE 9]&gt; 骚气的 ie9 浏览器 &lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></p><p>　　2、判断是否是 Safari 浏览器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Safari */</span><br><span class="line">var isSafari = /a/.__proto__==<span class="string">'//'</span>;</span><br></pre></td></tr></table></figure></p><p>　　3、判断是否是 Chrome 浏览器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Chrome */</span><br><span class="line">var isChrome = Boolean(window.chrome);</span><br></pre></td></tr></table></figure></p><p>关于 浏览器hack:<br>　　英文：<a href="http://browserhacks.com/" target="_blank" rel="noopener">BROWSERHACKS</a><br>　　中文：<a href="https://www.w3cplus.com/css/browser-hacks.html" target="_blank" rel="noopener">主流浏览器的Hack写法</a><br>　　<a href="https://blog.csdn.net/freshlover/article/details/12132801" target="_blank" rel="noopener">史上最全的CSS hack方式一览</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ES6新特性</title>
    <link href="http://yoursite.com/2019/04/05/JavaScript/ES6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/05/JavaScript/ES6新特性/</id>
    <published>2019-04-05T08:50:51.000Z</published>
    <updated>2019-04-05T11:26:06.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://juejin.im/post/5b1fd28d6fb9a01e615ed6d1" target="_blank" rel="noopener">带你一起敲敲ES6的新特性</a></p><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>1、常量(const， 不会变量提升，块级作用域，作用域内值不能改，const 对象仍然可以被改变的)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const aa = &#123;a: <span class="string">'12'</span>&#125;;</span><br><span class="line">aa.a // 12</span><br><span class="line">aa.a = <span class="string">"123456"</span>;</span><br><span class="line">console.log(aa); // a: <span class="string">'123456'</span></span><br></pre></td></tr></table></figure></p><p>2、块级作用域(let，不会变量提升)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i&lt;5; i++) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(i)    //0 1 2 3 4</span><br><span class="line">  &#125;,30)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i&lt;5; i++) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(i)   //5 5 5 5 5</span><br><span class="line">  &#125;,30)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> 关键词声明的变量不具备变量提升（hoisting）特性</span><br><span class="line"><span class="built_in">let</span> 和 const 声明只在最靠近的一个块中（花括号内）有效</span><br><span class="line">当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING</span><br><span class="line">const 在声明时必须被赋值</span><br></pre></td></tr></table></figure></p><p>　　特别要说明一点的是对于const和let都有<code>暂存死区</code>，所谓暂存死区就是:<code>如果作用域内有这样一个变量那么这个作用域内就会绑定这个变量,不会继续向上查找了,以下代码运行会报错</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const a = 1;</span><br><span class="line">&#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">  const a = 2;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure><h4 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a>结构赋值</h4><p>　　所谓解构赋值就是 声明和赋值都放到了一起<code>一般都是数组 对 数组, 对象 对 对象, 数组能够设置默认值，对象也能够设置默认值，默认值必须采用等号的方式</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [zhan, si, xl = 5] = [3, 4];</span><br><span class="line">console.log(zhan, si, xl) //3, 4, 5</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123;name, age = 23&#125; = &#123;name: <span class="string">'xl'</span>, bigAge: 24&#125;</span><br><span class="line">console.log(name, age) //xl, 23</span><br></pre></td></tr></table></figure></p><p>特别的，可能有时会有关键字的情况可以通过:的形式来更改名字，看下面代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; name, age: xl, default: d &#125; = &#123; name: <span class="string">'xlei'</span>, age: 9, default: <span class="string">'xxx'</span> &#125;;</span><br><span class="line">console.log(name, xl, d);</span><br></pre></td></tr></table></figure></p><p>来一个默认值的具体应用吧：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> ajax(&#123;</span><br><span class="line">    url = new Error(<span class="string">'url without'</span>),</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">'get'</span>,</span><br><span class="line">    data = xxx</span><br><span class="line">&#125;)&#123;</span><br><span class="line">  console.log(data, <span class="built_in">type</span>)   //&#123;a: 5&#125;, get</span><br><span class="line">&#125;</span><br><span class="line">ajax(&#123;</span><br><span class="line">    url: <span class="string">'/test'</span>,</span><br><span class="line">    data: &#123;a:5&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>1、模板字符串（拼接方便，可以换行）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本的字符串格式化。将表达式嵌入字符串中进行拼接。用<span class="variable">$&#123;&#125;</span>来界定；</span><br><span class="line">ES6反引号(``)直接搞定；</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> exe1 = <span class="string">'张三'</span></span><br><span class="line"><span class="built_in">let</span> exe2 = `我的名字是：<span class="variable">$&#123;exe1&#125;</span>`</span><br></pre></td></tr></table></figure><p>2、startWith, endWith 返回一个布尔值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> str1 = <span class="string">'www.bsym.online'</span></span><br><span class="line"><span class="built_in">let</span> str2 = <span class="string">'http://www.bsym.online'</span></span><br><span class="line">console.log(str1.startsWith(<span class="string">'http://'</span>))   //<span class="literal">false</span></span><br><span class="line">console.log(str2.startsWith(<span class="string">'http://'</span>))   //<span class="literal">true</span></span><br><span class="line">console.log(str2.endsWith(<span class="string">'online'</span>))     //<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>3、padStart, padEnd补全 – 不会删除原有内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// padStart padEnd 补全(记住只能增加，不能减少)</span><br><span class="line"><span class="built_in">let</span> str1 = <span class="string">'nihao'</span></span><br><span class="line"><span class="built_in">let</span> newStr = str1.padStart(8,<span class="string">'xl'</span>)</span><br><span class="line"><span class="built_in">let</span> newStr2 = str1.padEnd(8,<span class="string">'xl'</span>)</span><br><span class="line">console.log(newStr, newStr2)   //xlxnihao, nihaoxlx</span><br></pre></td></tr></table></figure></p><h4 id="箭头函数-解决this问题，书写起来更简单"><a href="#箭头函数-解决this问题，书写起来更简单" class="headerlink" title="箭头函数(解决this问题，书写起来更简单)"></a>箭头函数(解决this问题，书写起来更简单)</h4><p>　　传统函数内的this是定义时所在的环境，而箭头函数内的this是使用时上下文的环境。<br>　　ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =&gt;，紧接着是函数体；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不需要 <span class="keyword">function</span> 关键字来创建函数</span><br><span class="line">省略 <span class="built_in">return</span> 关键字</span><br><span class="line">继承当前上下文的 this 关键字</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var add = (a, b) =&gt; a + b;</span><br><span class="line">[1,2,3].map(x =&gt; x + 1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> aa = (arg1, arg2) =&gt; &#123;</span><br><span class="line">  console.log(arg1, arg2)</span><br><span class="line">&#125;</span><br><span class="line">aa(1, 2)   //1, 2</span><br><span class="line">;((arg1, arg2) =&gt; &#123;</span><br><span class="line">  console.log(arg1, arg2)</span><br><span class="line">&#125;)(3, 4);</span><br></pre></td></tr></table></figure><p>注意：<br>　　这里顺带提一下，像上面的<code>自执行匿名函数前后都要加分号</code>，这样既不会被坑，也不会坑别人。另外<code>不要使用箭头函数的argeuments</code><br>细节：<br>　　当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略<code>{}</code> 和 <code>return</code></p><h4 id="Spread-Rest-操作符"><a href="#Spread-Rest-操作符" class="headerlink" title="Spread / Rest 操作符"></a>Spread / Rest 操作符</h4><p><code>Spread / Rest 操作符指的是 ...，具体是 Spread 还是 Rest 需要看上下文语境。</code><br>　　当被用于迭代器中时，它是一个 Spread 操作符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(x,y,z) &#123;</span><br><span class="line">  console.log(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> arr = [1,2,3];</span><br><span class="line">foo(...arr); // 1 2 3</span><br></pre></td></tr></table></figure></p><p>　　当被用于函数传参时，是一个 Rest 操作符：当被用于函数传参时，是一个 Rest 操作符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(...args) &#123;</span><br><span class="line">  console.log(args);</span><br><span class="line">&#125;</span><br><span class="line">foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></p><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><p>1、数组的扩展运算符：将一个数组转为用逗号分隔的参数序列<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [...[1, 2, 3], ...[4, 5, 6]]</span><br><span class="line">console.log(arr)   // 1, 2, 3, 4, 5, 6</span><br><span class="line">console.log(Math.min(...arr))  // 1</span><br></pre></td></tr></table></figure></p><p>2、对象的解构赋值<br>　　对象的 Rest 解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面,注意Rest 解构赋值必须是最后一个参数，否则会报错。Rest解构赋值所在的对象，拷贝了对象obj的属性，Rest解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么Rest解构赋值拷贝的是这个值的引用，而不是这个值的副本，解构赋值不会拷贝继承自原型对象的属性<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;name: <span class="string">'xl'</span>, age: 23, say:<span class="string">'ok'</span>, eat: &#123;xl: <span class="string">'okok'</span>&#125;&#125;</span><br><span class="line">//尚未被读取的属性，分配到指定的对象上面,浅拷贝了对象obj的属性</span><br><span class="line"><span class="built_in">let</span> &#123;name, age, ...z&#125; = obj</span><br><span class="line">obj.say = <span class="string">'oo'</span></span><br><span class="line">obj.eat.xl = <span class="string">'o?o?'</span></span><br><span class="line">console.log(name, age, z)  </span><br><span class="line">//xl 23 &#123; say: <span class="string">'ok'</span>, eat: &#123; xl: <span class="string">'o?o?'</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> z = &#123;a: 3, b: 4, c:&#123;</span><br><span class="line">    eat:<span class="string">'ok'</span></span><br><span class="line">&#125;&#125;</span><br><span class="line">// 注意这个地方和直接赋值的区别 <span class="built_in">let</span> n = z; </span><br><span class="line">// 一个是浅拷贝对象属性，一个是浅拷贝对象</span><br><span class="line"><span class="built_in">let</span> n = &#123;...z&#125;</span><br><span class="line">z.a = 5</span><br><span class="line">z.c.eat = <span class="string">'ok?'</span></span><br><span class="line">console.log(n)  //&#123; a: 3, b: 4, c: &#123; eat: <span class="string">'ok?'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>　　那么要是想实现一个深拷贝，怎么实现呢？其实就是遍历属性如果属性是一个普通值就赋值，不是普通值就递归知道是普通值为止，然后赋值，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 实现深拷贝 保留继承关系 可以实现各种类型的拷贝 实现递归拷贝</span><br><span class="line">    <span class="keyword">function</span> deepClone(obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof obj !== <span class="string">'object'</span>) <span class="built_in">return</span> obj;</span><br><span class="line">        <span class="keyword">if</span> (obj == null) <span class="built_in">return</span> null;</span><br><span class="line">        <span class="keyword">if</span> (obj instanceof Date) <span class="built_in">return</span> new Date(obj);</span><br><span class="line">        <span class="keyword">if</span> (obj instanceof RegExp) <span class="built_in">return</span> new RegExp(obj);</span><br><span class="line">        <span class="built_in">let</span> o = new obj.constructor(); // 保留类的继承关系</span><br><span class="line"></span><br><span class="line">        Object.keys(obj).forEach((key, index) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(typeof (obj[key]) == <span class="string">'object'</span>)&#123;</span><br><span class="line">                o[key] = deepClone(obj[key])</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                // console.log(obj[key])</span><br><span class="line">                o[key] = obj[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> o = &#123; a: &#123; a: 1 &#125;, b: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(this.a)</span><br><span class="line">    &#125; &#125;</span><br><span class="line">    <span class="built_in">let</span> newObj = deepClone(o);</span><br><span class="line">    o.a.a = 2;</span><br><span class="line">    console.log( newObj.b());</span><br></pre></td></tr></table></figure></p><h4 id="数组常用方式"><a href="#数组常用方式" class="headerlink" title="数组常用方式"></a>数组常用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// (1)map返回值 返回值是一个新数组</span><br><span class="line">    Array.prototype.map = <span class="keyword">function</span> (fn) &#123;</span><br><span class="line">        <span class="built_in">let</span> arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">            arr.push(fn(this[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> arr;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">let</span> arr = [1, 2, 3].map(item =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> item * 2;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(arr);</span><br><span class="line">    // (2)filter 过滤 如果返回<span class="literal">true</span>表示留下 返回<span class="literal">false</span>表示删除</span><br><span class="line">    <span class="built_in">let</span> arr = [1, 2, 3];</span><br><span class="line">    <span class="built_in">let</span> filterArr = arr.filter(item =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> item &gt; 2;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(filterArr);</span><br><span class="line">    // (3)some找到后返回<span class="literal">true</span>,找<span class="literal">false</span>可以用every </span><br><span class="line">    <span class="built_in">let</span> r = [2, 1, 3].some(item =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> item &gt; 2;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(r);  //<span class="literal">true</span></span><br><span class="line">    // (4)every 检测数组 ages 的所有元素是否都符合条件 :</span><br><span class="line"></span><br><span class="line">    var ages = [2, 1, 3];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> r = ages.every((item) =&gt; &#123;</span><br><span class="line">        <span class="built_in">return</span> item &gt; 2</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(r)  //<span class="literal">false</span></span><br><span class="line">    // (5)Array.from();   将类数组转为数组</span><br></pre></td></tr></table></figure><h4 id="ES6的Class"><a href="#ES6的Class" class="headerlink" title="ES6的Class"></a>ES6的Class</h4><p>先复习一下es5中的几个名词：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">成员属性（方法）| 实例属性（方法） ：在构造函数中通过this.属性声明的</span><br><span class="line">静态属性（方法）：通过类来声明的 类.xxx</span><br><span class="line">私有属性（方法）：只有在类的内部可以使用，其他任何地方都不可以使用的</span><br><span class="line">公有属性（方法）|原型属性（方法）：在原型上声明的属性或者方法 xx.prototype.xxx</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Parent(name) &#123;</span><br><span class="line">  this.name = name; //成员属性|实例属性</span><br><span class="line">  this.say = <span class="function"><span class="title">function</span></span>() &#123;   //成员方法</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//静态属性</span><br><span class="line">Parent.smoking = <span class="string">'no'</span></span><br><span class="line">//公有方法|原型方法</span><br><span class="line">Parent.prototype.up = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来说说es6中的class(es6中不考虑私有属性和方法):<br>ES6 中支持 class 语法，不过，ES6的class不是新的对象继承模型，它只是原型链的语法糖表现形式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    constructor(x, y)&#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        //成员属性|实例属性  可遍历 打印实例可直接打印出来, </span><br><span class="line">        // 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），</span><br><span class="line">        // 否则都是定义在原型上（即定义在class上）。</span><br><span class="line">        this.y = y;</span><br><span class="line">        //如果不返回 默认返回实例对象 this</span><br><span class="line">        <span class="built_in">return</span> this.x </span><br><span class="line">    &#125;</span><br><span class="line">    static <span class="function"><span class="title">b</span></span>()&#123; // 属于类上的方法 也称静态方法</span><br><span class="line">        <span class="built_in">return</span> 2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span></span>()&#123;</span><br><span class="line">      //原型上的方法 | 公有方法 并且都是不可枚举的 </span><br><span class="line">      // 打印实例不能显示的打印出来 </span><br><span class="line">      console.log(this.x);</span><br><span class="line">      <span class="built_in">return</span> this.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent&#123; // </span><br><span class="line">    constructor(x, y, z)&#123;</span><br><span class="line">        // Parent.call(this);返回的是子类的实例，</span><br><span class="line">        super(x, y); </span><br><span class="line">        this.age = z; // 成员属性|实例属性</span><br><span class="line">    &#125;</span><br><span class="line">    static <span class="function"><span class="title">a</span></span>()&#123; // 属于类上的方法</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">smoking</span></span>()&#123; // 原型上的方法</span><br><span class="line">        <span class="built_in">return</span> super.eat() + this.age</span><br><span class="line">        //需要说明的是 super不仅可以调用父类的原型方法</span><br><span class="line">        // 还可以调用父类的静态方法，方法内部的this指向当前的子类，</span><br><span class="line">        // 而不是子类的实例</span><br><span class="line">        // console.log(this.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> child = new Child(2, 3, 4);</span><br><span class="line">// console.log(child);</span><br><span class="line">console.log(child.smoking())</span><br><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    //constructor函数默认返回this,</span><br><span class="line">    //这里返回一个全新的对象，结果导致实例对象不是Foo类的实例</span><br><span class="line">    <span class="built_in">return</span> Object.create(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Foo() instanceof Foo</span><br><span class="line">// <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">//定义类</span><br><span class="line">class Point &#123;</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">        this.x = x;        </span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var point = new Point(2, 3);</span><br><span class="line">console.log(point)</span><br><span class="line">point.toString() // (2, 3)</span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(<span class="string">'x'</span>) // <span class="literal">true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'y'</span>) // <span class="literal">true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'toString'</span>) // <span class="literal">false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">'toString'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A // <span class="literal">true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h4 id="迭代器-Iterators"><a href="#迭代器-Iterators" class="headerlink" title="迭代器(Iterators)"></a>迭代器(Iterators)</h4><h4 id="生成器-Generators"><a href="#生成器-Generators" class="headerlink" title="生成器(Generators)"></a>生成器(Generators)</h4><h4 id="对象和数组解构"><a href="#对象和数组解构" class="headerlink" title="对象和数组解构"></a>对象和数组解构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 对象</span><br><span class="line">const student = &#123;</span><br><span class="line">    name: <span class="string">'Sam'</span>,</span><br><span class="line">    age: 22,</span><br><span class="line">    sex: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line">// 数组</span><br><span class="line">// const student = [<span class="string">'Sam'</span>, 22, <span class="string">'男'</span>];</span><br><span class="line"></span><br><span class="line">// ES5；</span><br><span class="line">const name = student.name;</span><br><span class="line">const age = student.age;</span><br><span class="line">const sex = student.sex;</span><br><span class="line">console.log(name + <span class="string">' --- '</span> + age + <span class="string">' --- '</span> + sex);</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">const &#123; name, age, sex &#125; = student;</span><br><span class="line">console.log(name + <span class="string">' --- '</span> + age + <span class="string">' --- '</span> + sex);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>常见的设计模式</title>
    <link href="http://yoursite.com/2019/04/05/JavaScript/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/05/JavaScript/常见的设计模式/</id>
    <published>2019-04-05T03:21:41.000Z</published>
    <updated>2019-04-05T07:45:20.496Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://www.cnblogs.com/smlp/p/9776789.html" target="_blank" rel="noopener">前端常用的设计模式</a><br>　　<a href="https://juejin.im/entry/5816e545570c3500607205f1" target="_blank" rel="noopener">常用的 JavaScript 设计模式</a></p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>　　设计模式（<code>Design pattern</code>）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。<br>　　使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p><h4 id="工程模式"><a href="#工程模式" class="headerlink" title="工程模式"></a>工程模式</h4><p>　　定义： 将其成员对象的实例化推迟到子类来实现的类<br>　　需求： 创建对象的流程赋值的时候，比如依赖很多设置文件等；处理大量具有相同属性的小对象，注：不能滥用<br>　　优点： 不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中<br>　　缺点： 当工厂增加到一定程度的时候，提升了代码的复杂度，可读性下降。而且没有解决对象的识别问题，即怎么知道一个对象的类型。</p><h5 id="简单工厂模式-创建单一对象，需要的类比较少"><a href="#简单工厂模式-创建单一对象，需要的类比较少" class="headerlink" title="简单工厂模式(创建单一对象，需要的类比较少)"></a>简单工厂模式(创建单一对象，需要的类比较少)</h5><p>　　使用一个类，通常为单体，来生成实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> UserFactory = <span class="keyword">function</span> (role) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">SuperAdmin</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"超级管理员"</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>, <span class="string">'应用数据'</span>, <span class="string">'权限管理'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">Admin</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"管理员"</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>, <span class="string">'应用数据'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">NormalUser</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">'普通用户'</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  switch (role) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'superAdmin'</span>:</span><br><span class="line">      <span class="built_in">return</span> new SuperAdmin();</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'admin'</span>:</span><br><span class="line">      <span class="built_in">return</span> new Admin();</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'user'</span>:</span><br><span class="line">      <span class="built_in">return</span> new NormalUser();</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    default:</span><br><span class="line">      throw new Error(<span class="string">'参数错误, 可选参数:superAdmin、admin、user'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="工厂方法模式-创建多类对象，需要的类比较多"><a href="#工厂方法模式-创建多类对象，需要的类比较多" class="headerlink" title="工厂方法模式(创建多类对象，需要的类比较多)"></a>工厂方法模式(创建多类对象，需要的类比较多)</h5><p>　　为方便后续新增类方便，只需改一处代码，封装了工厂方法而已。并且把类都放在工厂类原型中实现。<br>　　将其成员对象的实列化推到子类中，子类可以<code>重写</code>父类接口方法以便创建的时候指定自己的对象类型。<br>　　父类只对创建过程中的一般性问题进行处理，这些处理<code>会被子类继承，子类之间是相互独立的</code>，具体的业务逻辑会放在子类中进行编写。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//安全模式创建的工厂方法函数</span><br><span class="line"><span class="built_in">let</span> UserFactory = <span class="keyword">function</span>(role) &#123;</span><br><span class="line">  <span class="keyword">if</span>(this instanceof UserFactory) &#123;</span><br><span class="line">    var s = new this[role]();</span><br><span class="line">    <span class="built_in">return</span> s;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> new UserFactory(role);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂方法函数的原型中设置所有对象的构造函数</span><br><span class="line">UserFactory.prototype = &#123;</span><br><span class="line">  SuperAdmin: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"超级管理员"</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>, <span class="string">'应用数据'</span>, <span class="string">'权限管理'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  Admin: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"管理员"</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>, <span class="string">'应用数据'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  NormalUser: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">'普通用户'</span>,</span><br><span class="line">    this.viewPage = [<span class="string">'首页'</span>, <span class="string">'通讯录'</span>, <span class="string">'发现页'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line"><span class="built_in">let</span> superAdmin = UserFactory(<span class="string">'SuperAdmin'</span>);</span><br><span class="line"><span class="built_in">let</span> admin = UserFactory(<span class="string">'Admin'</span>) </span><br><span class="line"><span class="built_in">let</span> normalUser = UserFactory(<span class="string">'NormalUser'</span>)</span><br></pre></td></tr></table></figure></p><h5 id="抽象工厂模式-创建父类，子类继承父类，具体实现在子类"><a href="#抽象工厂模式-创建父类，子类继承父类，具体实现在子类" class="headerlink" title="抽象工厂模式(创建父类，子类继承父类，具体实现在子类)"></a>抽象工厂模式(创建父类，子类继承父类，具体实现在子类)</h5><p>　　抽象工厂其实是实现子类继承父类的方法，只是一个方法。<br>　　抽象工厂模式一般用在多人协作的超大型项目中，并且严格的要求项目以面向对象的思想进行完成。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 抽象工厂方法</span><br><span class="line">var VehicleFatory = <span class="keyword">function</span>(subType, superType) &#123;</span><br><span class="line">    // 判断抽象工厂中是否有该抽象类</span><br><span class="line">    <span class="keyword">if</span>(typeof VehicleFactory[superType] === <span class="string">'function'</span>) &#123;</span><br><span class="line">        // 缓存类</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;&#125;;</span><br><span class="line">        // 继承父类属性和方法</span><br><span class="line">        F.prototype = new VehicleFactory[superType] ();</span><br><span class="line">        // 将子类constructor 指向子类</span><br><span class="line">        subType.constructor = subType;</span><br><span class="line">        // 子类原型继承<span class="string">'父类'</span></span><br><span class="line">        subType.prototype = new F();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // 不存在该抽象类抛出错误</span><br><span class="line">        throw new Error(<span class="string">'未创建该抽象类'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 小汽车抽象类</span><br><span class="line">VehicleFactory.Car = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.type = <span class="string">'car'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">VehicleFactory.Car.prototype = &#123;</span><br><span class="line">    getPrice: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;,</span><br><span class="line">    getSpeed: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 公交车抽象类</span><br><span class="line">VehicleFactory.Bus = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.type = <span class="string">'bus'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">VehicleFactory.Bus.prototype = &#123;</span><br><span class="line">    getPrice: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;,</span><br><span class="line">    getSpeed: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 货车抽象类</span><br><span class="line">VehicleFactory.Truck = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.type = <span class="string">'truck'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">VehicleFactory.Truck.prototype = &#123;</span><br><span class="line">    getPrice: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;,</span><br><span class="line">    getSpeed: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 创建产品子类继承相应的产品簇抽象类</span><br><span class="line">// 宝马汽车子类</span><br><span class="line">var BMW = <span class="keyword">function</span>(price, speed) &#123;</span><br><span class="line">    this.price = price;</span><br><span class="line">    this.speed = speed;</span><br><span class="line">&#125;</span><br><span class="line">//抽象工厂实现对Car抽象类的继承</span><br><span class="line">VehicleFactory(BMW, <span class="string">'Car'</span>);</span><br><span class="line">BMW.prototype.getPrice = <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> this.price &#125;;</span><br><span class="line">BMW.prototype.getSpeed = <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> this.speed &#125;;</span><br><span class="line"></span><br><span class="line">// 公交车...</span><br><span class="line">// 货车...</span><br></pre></td></tr></table></figure></p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>　　定义：是保证一个类只有一个实例，并且提供一个访问它的全局访问点。<br>　　需求：一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象、登录浮窗等。<br>　　实现：用一个变量标识当前是否已经为某个类创建过对象，如果是，则在下一次获取这个类的实例时，直接返回之前创建的对象。<br>　　优点：<br>　　　　<code>可以用来划分命名空间，减少全局变量的数量</code><br>　　　　<code>可以被实例化，且实例化一次，再次实例化生成的也是第一个实例</code></p><h5 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 单例模式</span><br><span class="line">var Singleton = <span class="keyword">function</span>(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.instance = null;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> this.name;</span><br><span class="line">&#125;;</span><br><span class="line">// 获取实例对象</span><br><span class="line">Singleton.getInstance = <span class="keyword">function</span>(name) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!this.instance) &#123;</span><br><span class="line">        this.instance = new Singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> this.instance;</span><br><span class="line">&#125;;</span><br><span class="line">// 测试单例模式的实例</span><br><span class="line">var a = Singleton.getInstance(<span class="string">"aa"</span>);</span><br><span class="line">var b = Singleton.getInstance(<span class="string">"bb"</span>);</span><br><span class="line"></span><br><span class="line">console.log(a===b)    // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="实践例子"><a href="#实践例子" class="headerlink" title="实践例子"></a>实践例子</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    //管理单例的逻辑代码，如果没有数据则创建，有数据则返回</span><br><span class="line">   var getSingle = <span class="keyword">function</span>(fn)&#123; //参数为创建对象的方法</span><br><span class="line">       var result;</span><br><span class="line">       <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123; //判断是Null或赋值</span><br><span class="line">           <span class="built_in">return</span> result || (result = fn.apply(this,arguments));</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;;</span><br><span class="line">    //创建登录窗口方法</span><br><span class="line">    var createLoginLayer = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var div = document.createElement(<span class="string">'div'</span>);</span><br><span class="line">        div.innerHTML = <span class="string">'我是登录浮窗'</span>;</span><br><span class="line">        div.style.display = <span class="string">'none'</span>;</span><br><span class="line">        document.body.appendChild(div);</span><br><span class="line">        <span class="built_in">return</span> div;</span><br><span class="line">    &#125;;</span><br><span class="line">    //单例方法</span><br><span class="line">    var createSingleLoginLayer = getSingle(createLoginLayer);</span><br><span class="line"></span><br><span class="line">    //使用惰性单例，进行创建</span><br><span class="line">    document.getElementById(<span class="string">'loginBtn'</span>).onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var loginLayer = createSingleLoginLayer();</span><br><span class="line">        loginLayer.style.display = <span class="string">'block'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h4 id="观察者模式-发布-订阅模式"><a href="#观察者模式-发布-订阅模式" class="headerlink" title="观察者模式(发布-订阅模式)"></a>观察者模式(发布-订阅模式)</h4><p>　　定义：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。<br>　　需求：当一个对象的状态发生变化时，所有依赖于他的对象都将得到通知。<br>　　优点：时间上的解耦，对象之间的解耦。当我们需要维护相关对象的一致性的时候，使用观察者模式，，就可以避免对象之间的紧密耦合。例如，一个对象可以通知另外一个对象，而不需要知道这个对象的信息。<br>　　缺点：在发布/订阅模式中，如果我们需要将发布者同订阅者上解耦，将会在一些情况下，导致很难确保我们应用中的特定部分按照我们预期的那样正常工作。也就是说它的优点也可能是它的缺点<br>　　实现：<br>　　　　<code>首先，指定好谁充当发布者</code>；<br>　　　　<code>然后，给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者</code>；<br>　　　　<code>最后，发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数</code>。<br>　　　　<code>退订（比如不想再接收到这些订阅的信息了，就可以取消掉）</code></p><h5 id="基础例子-1"><a href="#基础例子-1" class="headerlink" title="基础例子"></a>基础例子</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var salesOffices = &#123;&#125;;                           // 定义售楼处</span><br><span class="line">salesOffices.clientList = [];                    // 缓存列表，存放订阅者的回调函数</span><br><span class="line">salesOffices.listen = <span class="keyword">function</span>( fn )&#123;            // 增加订阅者</span><br><span class="line">    this.clientList.push( fn );                  // 订阅的消息添加进缓存列表</span><br><span class="line">&#125;;</span><br><span class="line">salesOffices.trigger = <span class="function"><span class="title">function</span></span>()&#123;               // 发布消息</span><br><span class="line">    <span class="keyword">for</span>( var i = 0, fn; fn = this.clientList[ i++ ]; )&#123;</span><br><span class="line">        fn.apply( this, arguments );             // arguments 是发布消息时带上的参数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//调用</span><br><span class="line">salesOffices.listen( <span class="keyword">function</span>( price, squareMeter )&#123;//订阅消息</span><br><span class="line">    console.log( <span class="string">'价格= '</span> + price );</span><br><span class="line">    console.log( <span class="string">'squareMeter= '</span> + squareMeter );</span><br><span class="line">&#125;);</span><br><span class="line">salesOffices.trigger( 2000000, 88 );                // 输出：200 万，88 平方米</span><br></pre></td></tr></table></figure><h5 id="实践例子-1"><a href="#实践例子-1" class="headerlink" title="实践例子"></a>实践例子</h5><p>　　登录页面登录后，会需要刷新各个模块的信息（头像、nav）这类。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">var ObserverEvent = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        var clientList = [], listen, trigger, remove;</span><br><span class="line">        listen = <span class="keyword">function</span> (key, fn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!clientList[key]) &#123;</span><br><span class="line">                clientList[key] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            clientList[key].push(fn);</span><br><span class="line">        &#125;;</span><br><span class="line">        trigger = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            var key = Array.prototype.shift.call(arguments), fns = clientList[key];</span><br><span class="line">            <span class="keyword">if</span> (!fns || fns.length === 0) &#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (var i = 0, fn; fn = fns[i++];) &#123;</span><br><span class="line">                fn.apply(this, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        remove = <span class="keyword">function</span> (key, fn) &#123;</span><br><span class="line">            var fns = clientList[key];</span><br><span class="line">            <span class="keyword">if</span> (!fns) &#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">                fns &amp;&amp; (fns.length = 0);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (var l = fns.length - 1; l &gt;= 0; l--) &#123;</span><br><span class="line">                    var _fn = fns[l];</span><br><span class="line">                    <span class="keyword">if</span> (_fn === fn) &#123;</span><br><span class="line">                        fns.splice(l, 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            listen:listen,</span><br><span class="line">            trigger:trigger,</span><br><span class="line">            remove:remove</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    ObserverEvent.listen(<span class="string">'squareMeter88'</span>, fn1 = <span class="keyword">function</span> (price) &#123;</span><br><span class="line">        console.log(<span class="string">'价格='</span> + price);</span><br><span class="line">    &#125;);</span><br><span class="line">    ObserverEvent.listen(<span class="string">'squareMeter100'</span>, <span class="keyword">function</span> (price) &#123;</span><br><span class="line">        console.log(<span class="string">'价格='</span> + price);</span><br><span class="line">    &#125;);</span><br><span class="line">    ObserverEvent.trigger(<span class="string">'squareMeter88'</span>, 200000);</span><br><span class="line"></span><br><span class="line">//刷新模块信息</span><br><span class="line">var header = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        ObserverEvent.listen(<span class="string">'loginSucc'</span>, <span class="keyword">function</span> (data) &#123;</span><br><span class="line">            header.setAvatar(data.avatar);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            setAvatar: <span class="keyword">function</span> (data) &#123;</span><br><span class="line">                console.log(data + <span class="string">"设置header成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    var nav = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        ObserverEvent.listen(<span class="string">'loginSucc'</span>, <span class="keyword">function</span> (data) &#123;</span><br><span class="line">            nav.setAvatar(data.avatar)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            setAvatar: <span class="keyword">function</span> (data) &#123;</span><br><span class="line">                console.log(data + <span class="string">'设置nav成功'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    var data = &#123;&#125;;</span><br><span class="line">    data.avatar = <span class="string">"参数"</span>;</span><br><span class="line">    ObserverEvent.trigger(<span class="string">'loginSucc'</span>, data);</span><br></pre></td></tr></table></figure></p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>　　策略模式指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>　　代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额。<br>　　没有使用策略模式的情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Price(personType, price) &#123;</span><br><span class="line">    //vip 5 折</span><br><span class="line">    <span class="keyword">if</span> (personType == <span class="string">'vip'</span>) &#123;</span><br><span class="line">        <span class="built_in">return</span> price * 0.5;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (personType == <span class="string">'old'</span>)&#123; //老客户 3 折</span><br><span class="line">        <span class="built_in">return</span> price * 0.3;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> price; //其他都全价</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　不足之处：不好的地方，当我有其他方面的折扣时，又或者我活动的折扣时经常变化的，这样就要不断的修改if..else里面的条件了。而且也违背了设计模式的一个原则：对修改关闭，对扩展开放的原则；<br>　　使用策略模式之后：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 对于vip客户</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">vipPrice</span></span>() &#123;</span><br><span class="line">    this.discount = 0.5;</span><br><span class="line">&#125;</span><br><span class="line">vipPrice.prototype.getPrice = <span class="keyword">function</span>(price) &#123;</span><br><span class="line">　　<span class="built_in">return</span> price * this.discount;</span><br><span class="line">&#125;</span><br><span class="line">// 对于老客户</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">oldPrice</span></span>() &#123;</span><br><span class="line">    this.discount = 0.3;</span><br><span class="line">&#125;</span><br><span class="line">oldPrice.prototype.getPrice = <span class="keyword">function</span>(price) &#123;</span><br><span class="line">    <span class="built_in">return</span> price * this.discount;</span><br><span class="line">&#125;</span><br><span class="line">// 对于普通客户</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Price</span></span>() &#123;</span><br><span class="line">    this.discount = 1;</span><br><span class="line">&#125;</span><br><span class="line">Price.prototype.getPrice = <span class="keyword">function</span>(price) &#123;</span><br><span class="line">    <span class="built_in">return</span> price ;</span><br><span class="line">&#125;</span><br><span class="line">// 上下文，对于客户端的使用</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Context</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">''</span>;</span><br><span class="line">    this.strategy = null;</span><br><span class="line">    this.price = 0;</span><br><span class="line">&#125;</span><br><span class="line">Context.prototype.set = <span class="keyword">function</span>(name, strategy, price) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.strategy = strategy;</span><br><span class="line">    this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">Context.prototype.getResult = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(this.name + <span class="string">' 的结账价为: '</span> + this.strategy.getPrice(this.price));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var context = new Context();</span><br><span class="line">var vip = new vipPrice();</span><br><span class="line">context.set (<span class="string">'vip客户'</span>, vip, 200);</span><br><span class="line">context.getResult();   // vip客户 的结账价为: 100</span><br><span class="line"></span><br><span class="line">var old = new oldPrice();</span><br><span class="line">context.set (<span class="string">'老客户'</span>, old, 200);</span><br><span class="line">context.getResult();  // 老客户 的结账价为: 60</span><br><span class="line"></span><br><span class="line">var Price = new Price();</span><br><span class="line">context.set (<span class="string">'普通客户'</span>, Price, 200);</span><br><span class="line">context.getResult();  // 普通客户 的结账价为: 200</span><br></pre></td></tr></table></figure></p><p>　　通过策略模式，使得客户的折扣与算法解藕，又使得修改跟扩展能独立的进行，不影到客户端或其他算法的使用；</p><h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p>　　定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 通俗的讲，就是将一些公共方法封装到父类，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。</p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>　　比如前端面试，基本包括笔试，技术面试，领导面试，HR面试等，但是每个公司的笔试题，技术面可能不一样，也可能一样，一样的就继承父类的方法，不一样的就重写父类的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">var Interview = <span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">// 笔试</span><br><span class="line">Interview.prototype.writtenTest = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"这里是前端笔试题"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">// 技术面试</span><br><span class="line">Interview.prototype.technicalInterview = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"这里是技术面试"</span>);</span><br><span class="line">&#125;; </span><br><span class="line">// 领导面试</span><br><span class="line">Interview.prototype.leader = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"领导面试"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">// 领导面试</span><br><span class="line">Interview.prototype.HR = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"HR面试"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">// 等通知</span><br><span class="line">Interview.prototype.waitNotice = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"等通知啊，不知道过了没有哦"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">// 代码初始化</span><br><span class="line">Interview.prototype.init = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    this.writtenTest();</span><br><span class="line">    this.technicalInterview();</span><br><span class="line">    this.leader();</span><br><span class="line">    this.HR();</span><br><span class="line">    this.waitNotice();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 阿里巴巴的笔试和技术面不同，重写父类方法，其他继承父类方法。</span><br><span class="line">var AliInterview = <span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">AliInterview.prototype = new Interview();</span><br><span class="line"></span><br><span class="line">// 子类重写方法 实现自己的业务逻辑</span><br><span class="line">AliInterview.prototype.writtenTest = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"阿里的技术题就是难啊"</span>);</span><br><span class="line">&#125;</span><br><span class="line">AliInterview.prototype.technicalInterview = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"阿里的技术面就是叼啊"</span>);</span><br><span class="line">&#125;</span><br><span class="line">var AliInterview = new AliInterview();</span><br><span class="line">AliInterview.init();</span><br><span class="line"></span><br><span class="line">// 阿里的技术题就是难啊</span><br><span class="line">// 阿里的技术面就是叼啊</span><br><span class="line">// 领导面试</span><br><span class="line">// HR面试</span><br><span class="line">// 等通知啊，不知道过了没有哦</span><br></pre></td></tr></table></figure></p><p><strong>应用场景：</strong><br>　　模板模式主要应用在一些代码刚开要一次性实现不变的部分。但是将来页面有修改，需要更改业务逻辑的部分或者重新添加新业务的情况。主要是通过子类来改写父类的情况，其他不需要改变的部分继承父类。　　</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>概念：<br>　　代理模式的中文含义就是帮别人做事，<code>javascript</code>的解释为：把对一个对象的访问, 交给另一个代理对象来操作.<br>代码实现：<br>　　比如我们公司的补打卡是最后是要交给大boss来审批的，但是公司那么多人，每天都那么多补打卡，那大boss岂不是被这些琐事累死。所以大boss下会有一个助理，来帮忙做这个审批，最后再将每个月的补打卡统一交给大boss看看就行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 补打卡事件</span><br><span class="line">var fillOut = <span class="keyword">function</span> (lateDate) &#123;</span><br><span class="line"></span><br><span class="line">    this.lateDate = lateDate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 这是bigBoss</span><br><span class="line">var bigBoss = <span class="keyword">function</span> (fillOut) &#123;</span><br><span class="line"></span><br><span class="line">    this.state = <span class="keyword">function</span> (isSuccess) &#123;</span><br><span class="line">        console.log(<span class="string">"忘记打卡的日期为："</span> + fillOut.lateDate + <span class="string">", 补打卡状态："</span> + isSuccess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 助理代理大boss 完成补打卡审批</span><br><span class="line">var proxyAssis = <span class="keyword">function</span> (fillOut) &#123;</span><br><span class="line">    </span><br><span class="line">    this.state = <span class="keyword">function</span> (isSuccess) &#123;</span><br><span class="line">        (new bigBoss(fillOut)).state(isSuccess); // 替bigBoss审批</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 调用方法：</span><br><span class="line">var proxyAssis = new proxyAssis(new fillOut(<span class="string">"2016-9-11"</span>));</span><br><span class="line">proxyAssis.state(<span class="string">"补打卡成功"</span>);</span><br><span class="line">// 忘记打卡的日期为：2016-9-11, 补打卡状态：补打卡成功</span><br></pre></td></tr></table></figure></p><p>应用场景：<br>　　比如图片的懒加载，我们就可以运用这种技术。在图片未加载完成之前，给个loading图片，加载完成后再替换成实体路径。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var myImage = (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var imgNode = document.createElement(<span class="string">"img"</span>);</span><br><span class="line">    document.body.appendChild(imgNode);</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(src)&#123;</span><br><span class="line">        imgNode.src = src; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">// 代理模式</span><br><span class="line">var ProxyImage = (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        myImage(this.src);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(src) &#123;</span><br><span class="line">      // 占位图片loading</span><br><span class="line">      myImage(<span class="string">"http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif"</span>);</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">// 调用方式</span><br><span class="line"></span><br><span class="line">ProxyImage(<span class="string">"https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png"</span>); // 真实要展示的图片</span><br></pre></td></tr></table></figure></p><p>　　当然，这种懒加载方法不用代理模式也是可以实现的，只是用代理模式。我们可以让 myImage 只做一件事，只负责将实际图片加入到页面中，而loading图片交给ProxyImage去做。从而降低代码的耦合度。因为当我不想用loading的时候，可以直接调用myImage 方法。也即是说假如我门不需要代理对象的话，直接可以换成本体对象调用该方法即可。</p><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>　　概念：<br>　　外观模式是很常见。其实它就是通过编写一个单独的函数，来简化对一个或多个更大型的，可能更为复杂的函数的访问。也就是说可以视外观模式为一种简化某些内容的手段。<br>　　说白了，外观模式就是一个函数，封装了复杂的操作。<br>代码实现：<br>　　比如一个跨浏览器的ajax调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> ajaxCall(<span class="built_in">type</span>,url,callback,data)&#123;</span><br><span class="line">    // 根据当前浏览器获取对ajax连接对象的引用</span><br><span class="line">    var xhr=(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 所有现代浏览器所使用的标准方法</span><br><span class="line">            <span class="built_in">return</span> new XMLHttpRequest();</span><br><span class="line">        &#125;catch(e)&#123;&#125;</span><br><span class="line">        // 较老版本的internet Explorer兼容</span><br><span class="line">        try&#123;</span><br><span class="line">            <span class="built_in">return</span> new ActiveXObject(<span class="string">"Msxml2.XMLHTTP.6.0"</span>);</span><br><span class="line">        &#125;catch(e)&#123;&#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            <span class="built_in">return</span> new ActiveXObject(<span class="string">"Msxml2.XMLHTTP.3.0"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;catch(e)&#123;&#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            <span class="built_in">return</span> new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">        &#125;catch(e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        // 如果没能找到相关的ajax连接对象，则跑出一个错误。</span><br><span class="line">        throw new Error(<span class="string">"Ajax not support in this browser."</span>)</span><br><span class="line"></span><br><span class="line">    &#125;()),</span><br><span class="line">    STATE_LOADED=4,</span><br><span class="line">    STATUS_OK=200;</span><br><span class="line"></span><br><span class="line">    // 一但从服务器收到表示成功的相应消息，则执行所给定的回调方法</span><br><span class="line">    xhr.onreadystatechange=<span class="keyword">function</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState !==STATE_LOADED)&#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xhr.state==STATUS_OK)&#123;</span><br><span class="line">            callback(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用浏览器的ajax连接对象来向所给定的URL发出相关的调用</span><br><span class="line">    xhr.open(type.toUpperCase(),url);</span><br><span class="line">    xhr.send(data);</span><br><span class="line">&#125;</span><br><span class="line">// 使用方法</span><br><span class="line">ajaxCall(<span class="string">"get"</span>,<span class="string">"/user/12345"</span>,<span class="keyword">function</span>(rs)&#123;</span><br><span class="line">    alert(<span class="string">'收到的数据为：'</span>+rs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>应用场景：<br>　　当需要通过一个单独的函数或方法来访问一系列的函数或方法调用，以简化代码库的其余内容，使得代码更容易跟踪管理或者更好的维护时，可以使用外观模式。其实我们平时代码中这种模式应该是用的比较多的。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCP和UDP的区别</title>
    <link href="http://yoursite.com/2019/04/05/HTTP/TCP&amp;&amp;UDP/"/>
    <id>http://yoursite.com/2019/04/05/HTTP/TCP&amp;&amp;UDP/</id>
    <published>2019-04-05T02:25:09.000Z</published>
    <updated>2019-04-05T03:08:22.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://segmentfault.com/a/1190000018582150" target="_blank" rel="noopener">TCP和UDP比较</a></p><h3 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP/IP网络模型"></a>TCP/IP网络模型</h3><p>　　计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（<code>protocol</code>）。<br>　　<code>TCP/IP</code> 是互联网相关的各类协议族的总称，比如：<code>TCP</code>，<code>UDP</code>，<code>IP</code>，<code>FTP</code>，<code>HTTP</code>，<code>ICMP</code>，<code>SMTP</code> 等都属于 <code>TCP/IP</code> 族内的协议。<br>　　<code>TCP/IP</code>模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为<code>链路层</code>、<code>网络层</code>、<code>传输层</code>和<code>应用层</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</span><br><span class="line">网络层：负责路由以及把分组报文发送给目标网络或主机。</span><br><span class="line">传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</span><br><span class="line">应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</span><br></pre></td></tr></table></figure></p><p>详情图片:<br><img src="/assets/images/httposi.png" alt="HTPPOSI七层模型"><br>　　在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>　　当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。<br>　　TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p><h4 id="TCP连接过程"><a href="#TCP连接过程" class="headerlink" title="TCP连接过程"></a>TCP连接过程</h4><p>三次握手:<br><strong>第一次握手</strong><br>　　客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。<br><strong>第二次握手</strong><br>　　服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。<br><strong>第三次握手</strong><br>　　当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。<br>　　这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</p><h4 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h4><p>　　TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。<br><strong>第一次挥手</strong><br>　　若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。<br><strong>第二次挥手</strong><br>　　B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。<br><strong>第三次挥手</strong><br>　　B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。<br><strong>第四次挥手</strong><br>　　A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p><h4 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h4><h5 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h5><p>　　面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p><h5 id="仅支持单播传输"><a href="#仅支持单播传输" class="headerlink" title="仅支持单播传输"></a>仅支持单播传输</h5><p>　　每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><h5 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h5><p>　　TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><h5 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h5><p>　　对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p><h5 id="提供拥塞控制"><a href="#提供拥塞控制" class="headerlink" title="提供拥塞控制"></a>提供拥塞控制</h5><p>　　当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p><h5 id="TCP提供双工通信"><a href="#TCP提供双工通信" class="headerlink" title="TCP提供双工通信"></a>TCP提供双工通信</h5><p>　　TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>　　UDP协议全称是<code>用户数据报协议</code>，在网络中它与<code>TCP</code>协议一样用于处理数据包，是一种<code>无连接的协议</code>。在OSI模型中，在<code>第四层——传输层</code>，处于IP协议的上一层。<code>UDP</code>有<code>不提供数据包分组</code>、<code>组装</code>和<code>不能对数据包进行排序</code>的缺点，也就是说，<code>当报文发送之后，是无法得知其是否安全完整到达的</code>。</p><h4 id="UDP的特点"><a href="#UDP的特点" class="headerlink" title="UDP的特点"></a>UDP的特点</h4><h5 id="面向无连接"><a href="#面向无连接" class="headerlink" title="面向无连接"></a>面向无连接</h5><p>　　首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。<br>具体来说就是：<br>　　在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了<br>　　在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</p><h5 id="有单播、多播、广播的功能"><a href="#有单播、多播、广播的功能" class="headerlink" title="有单播、多播、广播的功能"></a>有单播、多播、广播的功能</h5><p>　　UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><h5 id="UDP是面向报文的"><a href="#UDP是面向报文的" class="headerlink" title="UDP是面向报文的"></a>UDP是面向报文的</h5><p>　　发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><h5 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h5><p>　　首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。<br>　　并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。<br>　　再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p><h5 id="头部开销小，传输数据报文时是很高效的。"><a href="#头部开销小，传输数据报文时是很高效的。" class="headerlink" title="头部开销小，传输数据报文时是很高效的。"></a>头部开销小，传输数据报文时是很高效的。</h5><p>UDP 头部包含了以下几个数据：<br>　　两个十六位的端口号，分别为源端口（可选字段）和目标端口<br>　　整个数据报文的长度<br>　　整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误<br>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p><h3 id="TCP和UDP的比较"><a href="#TCP和UDP的比较" class="headerlink" title="TCP和UDP的比较"></a>TCP和UDP的比较</h3><table><thead><tr><th>对比项</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>无连接</td></tr><tr><td>是否可靠</td><td>可靠传输，使用流量控制和拥塞控制</td><td>不可靠传输，不使用流量控制和拥塞控制</td></tr><tr><td>连接对象个数</td><td>只能是一对一通信</td><td>支持一对一，一对多，多对一和多对多交互通信</td></tr><tr><td>传输方式</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>首部开销</td><td>首部最小20字节，最大60字节</td><td>首部开销小，仅8字节</td></tr><tr><td>使用场景</td><td>适用于要求可靠传输的应用，例如文件传输</td><td>适用于实时应用（IP电话、视频会议、直播等）</td></tr></tbody></table><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>　　TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。<br>　　虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为<br>　　对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>DOM操作和BOM操作</title>
    <link href="http://yoursite.com/2019/04/02/JavaScript/DOM%E6%93%8D%E4%BD%9C%E5%92%8CBOM%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/04/02/JavaScript/DOM操作和BOM操作/</id>
    <published>2019-04-02T09:43:03.000Z</published>
    <updated>2019-04-02T13:24:22.404Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><p>　　当网页被加载时，浏览器会创建页面的文档对象模型(DOM),我们可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。接下来我们介绍常见DOM操作：<a href="https://alittlelittlestar.github.io/2019/03/31/JavaScript/DOM基本操作/" target="_blank" rel="noopener">DOM基本操作</a></p><h3 id="DOM事件模型和事件流"><a href="#DOM事件模型和事件流" class="headerlink" title="DOM事件模型和事件流"></a>DOM事件模型和事件流</h3><p>　　<code>DOM事件模型分为捕获和冒泡</code>。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。<br>　　（1）捕获阶段：事件从window对象自上而下向目标节点传播的阶段,捕获阶段不会响应任何事件；<br>　　（2）目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；<br>　　（3）冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；<br>详情：<br>　　<a href="https://alittlelittlestar.github.io/2018/10/10/JavaScript/冒泡和捕获/" target="_blank" rel="noopener">冒泡和捕获</a></p><h3 id="事件代理-事件委托"><a href="#事件代理-事件委托" class="headerlink" title="事件代理(事件委托)"></a>事件代理(事件委托)</h3><p>　　由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。<br>　　我们设定一种场景，如下代码，一个<code>&lt;div&gt;</code>中包含了若干个<code>&lt;a&gt;</code>，而且还能继续增加。那如何快捷方便地为所有<code>&lt;a&gt;</code>绑定事件呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"div1"</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span>&gt;a1&lt;/a&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span>&gt;a2&lt;/a&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span>&gt;a3&lt;/a&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span>&gt;a4&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;button&gt;点击增加一个 a 标签&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><p>　　如果给每个<code>&lt;a&gt;</code>标签一一都绑定一个事件，那对于内存消耗是非常大的。借助事件代理，我们只需要给父容器<code>div</code>绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把父容器的<code>click</code>行为触发，然后把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而完成不同的事。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var div1 = document.getElementById(<span class="string">'div1'</span>)</span><br><span class="line">div1.addEventListener(<span class="string">'click'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    // e.target 可以监听到触发点击事件的元素是哪一个</span><br><span class="line">    var target = e.target</span><br><span class="line">    <span class="keyword">if</span> (e.nodeName === <span class="string">'A'</span>) &#123;</span><br><span class="line">        // 点击的是 &lt;a&gt; 元素</span><br><span class="line">        alert(target.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>最后，使用代理的优点如下：<br>　　使代码简洁<br>　　减少浏览器的内存占用<br>　　动态昂定事件</p><h3 id="BOM操作"><a href="#BOM操作" class="headerlink" title="BOM操作"></a>BOM操作</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>　　BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含有关用户屏幕的信息</span></span><br><span class="line">window.screen对象</span><br><span class="line"><span class="comment"># 用于获得当前页面的地址(URL)，并把浏览器重定向到新的页面</span></span><br><span class="line">window.location对象</span><br><span class="line"><span class="comment"># 浏览历史的前进后退等</span></span><br><span class="line">window.history对象</span><br><span class="line"><span class="comment"># 常常用来获取浏览器信息、是否移动端访问等等</span></span><br><span class="line">window.navigator对象</span><br></pre></td></tr></table></figure></p><p>获取屏幕的宽度和高度<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(screen.width)</span><br><span class="line">console.log(screen.height)</span><br></pre></td></tr></table></figure></p><p>获取网址、协议、path、参数、hash 等<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如当前网址是 </span></span><br><span class="line">https://juejin.im/timeline/frontend?a=10&amp;b=10<span class="comment">#some</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回（当前页面的）整个 URL</span></span><br><span class="line"><span class="comment"># https://juejin.im/timeline/frontend?a=10&amp;b=10#some</span></span><br><span class="line">console.log(location.href)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回所使用的 web 协议（http:// 或 https://）</span></span><br><span class="line"><span class="comment"># https:</span></span><br><span class="line">console.log(location.protocol) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性返回 URL 的路径名</span></span><br><span class="line"><span class="comment"># /timeline/frontend</span></span><br><span class="line">console.log(location.pathname) </span><br><span class="line"></span><br><span class="line"><span class="comment"># ?a=10&amp;b=10</span></span><br><span class="line">console.log(location.search) </span><br><span class="line"></span><br><span class="line"><span class="comment"># #some</span></span><br><span class="line">console.log(location.hash)</span><br></pre></td></tr></table></figure></p><p>另外，还有调用浏览器的前进、后退功能等<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history.back()</span><br><span class="line">history.forward()</span><br></pre></td></tr></table></figure></p><p>获取浏览器特性（即俗称的UA）然后识别客户端，例如判断是不是 Chrome 浏览器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ua = navigator.userAgent</span><br><span class="line">var isChrome = ua.indexOf(<span class="string">'Chrome'</span>)</span><br><span class="line">console.log(isChrome)</span><br></pre></td></tr></table></figure></p><p>转载：<br>　　<a href="https://segmentfault.com/a/1190000018696018#articleHeader18" target="_blank" rel="noopener">思否</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>作用域和闭包</title>
    <link href="http://yoursite.com/2019/04/02/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2019/04/02/JavaScript/作用域和闭包/</id>
    <published>2019-04-02T07:47:36.000Z</published>
    <updated>2019-04-09T01:45:46.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="执行上下文和执行栈"><a href="#执行上下文和执行栈" class="headerlink" title="执行上下文和执行栈"></a>执行上下文和执行栈</h3><p>　　执行上下文就是当前 <code>JavaScript</code>代码被解析和执行时所在环境的抽象概念， <code>JavaScript</code> 中运行任何的代码都是在执行上下文中运行。</p><h4 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h4><p>执行上下文总共有三种类型：<br>　　<code>全局执行上下文</code>： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：<br>　　　　1、 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。<br>　　　　2、 将this指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。<br>　　<code>函数执行上下文</code>： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。<br>　　<code>Eval 函数执行上下文</code>： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。</p><h4 id="执行上下文：创建阶段"><a href="#执行上下文：创建阶段" class="headerlink" title="执行上下文：创建阶段"></a>执行上下文：创建阶段</h4><p>　　执行上下文的生命周期包括三个阶段：<code>创建阶段</code>→<code>执行阶段</code>→<code>回收阶段</code>，我们重点介绍创建阶段。<br>创建阶段（当函数被调用，但未执行任何其内部代码之前）会做以下三件事：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。</span><br><span class="line">创建作用域链：下文会介绍</span><br><span class="line">确定this指向：下文会介绍</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(arg)&#123;</span><br><span class="line">    // 1. 形参 arg 是 <span class="string">"hi"</span></span><br><span class="line">    // 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 <span class="keyword">function</span></span><br><span class="line">    console.log(arg);  </span><br><span class="line">    var arg = <span class="string">'hello'</span>; // 3.var arg 变量声明被忽略， arg = <span class="string">'hello'</span>被执行</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">arg</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'hello world'</span>) </span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arg);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>(<span class="string">'hi'</span>);</span><br><span class="line">/* 输出：</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">arg</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'hello world'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">hello </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>这是因为当函数执行的时候,首先会形成一个新的私有的作用域，然后依次按照如下的步骤执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果有形参，先给形参赋值</span><br><span class="line">进行私有作用域中的预解释，函数声明优先级比变量声明高，最后后者会被前者所覆盖，但是可以重新赋值</span><br><span class="line">私有作用域中的代码从上到下执行</span><br></pre></td></tr></table></figure></p><h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>　　函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？<br>　　<code>JavaScript</code> 引擎创建了执行栈来管理执行上下文。<code>可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</code>。<br>　　执行栈，在其他编程语言中也被叫做调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。<br>　　当 JavaScript 引擎首次读取你的脚本时，它会创建一个全局执行上下文并将其推入当前的执行栈。每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈的顶端。</p><p>　　引擎会运行执行上下文在执行栈顶端的函数，当此函数运行完成后，其对应的执行上下文将会从执行栈中弹出，上下文控制权将移到当前执行栈的下一个执行上下文。<br><img src="/assets/images/执行栈.gif" alt="执行栈"><br>从上面的流程图，我们需要记住几个关键点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaScript执行在单线程上，所有的代码都是排队执行。</span><br><span class="line">一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</span><br><span class="line">每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。</span><br><span class="line">当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。</span><br><span class="line">浏览器的JS执行引擎总是访问栈顶的执行上下文。</span><br><span class="line">全局上下文只有唯一的一个，它在浏览器关闭时出栈。</span><br></pre></td></tr></table></figure></p><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>　　ES6 到来JavaScript 有全局作用域、函数作用域和块级作用域（ES6新增）。我们可以这样理解：<code>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</code>。<br>　　在介绍作用域链之前，先要了解下自由变量，如下代码中，console.log(a)要得到a变量，但是在当前的作用域中没有定义a（可对比一下b）。当前作用域没有定义的变量，这成为 自由变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 100</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">    var b = 200</span><br><span class="line">    console.log(a) // 这里的a在这里就是一个自由变量</span><br><span class="line">    console.log(b)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure></p><p><code>自由变量的值如何得到 —— 向父级作用域(创建该函数的那个父级作用域)</code>寻找。如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">F1</span></span>() &#123;</span><br><span class="line">    var a = 100</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> F2(f1) &#123;</span><br><span class="line">    var a = 200</span><br><span class="line">    console.log(f1())</span><br><span class="line">&#125;</span><br><span class="line">var f1 = F1()</span><br><span class="line">F2(f1) // 100</span><br></pre></td></tr></table></figure></p><p>　　上述代码中，自由变量a的值，从函数F1中查找而不是F2,这是因为当自由变量从作用域链中去寻找，依据的是函数定义时的作用域链，而不是函数执行时。</p><h3 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h3><p>　　闭包这个概念也是JavaScript中比较抽象的概念，我个人理解，闭包是就是函数中的函数(其他语言不能这样),里面的函数可以访问外面函数的变量，外面的变量的是这个内部函数的一部分。<br>闭包的优点：<br>　　（1）逻辑连续，当闭包作为另一个函数调用参数时，避免脱离当前逻辑而单独编写额外逻辑<br>　　（2）方便调用上下文的局部变量。<br>　　（3）加强封装性，是第2点的延伸，可以达到对变量的保护作用。<br>使用闭包的注意点（缺点）：<br>　　（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>　　（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（<code>object</code>）使用，把闭包当作它的公用方法（<code>Public Method</code>），把内部变量当作它的私有属性（<code>private value</code><br>），这时一定要小心，不要随便改变父函数内部变量的值。<br>闭包的特性:<br>　　（1）作为函数变量的一个引用。当函数返回时，其处于激活状态。<br>　　（2）闭包就是当一个函数返回时，并没有释放资源的栈区。<br>闭包的作用：<br>　　<code>使用闭包可以访问函数中的变量</code>。<br>　　<code>可以使变量长期保存在内存中，生命周期比较长</code>。<br>闭包主要有两个应用场景：<br>　　<code>函数作为参数传递</code>（见作用域部分例子）<br>　　<code>函数作为返回值</code>（如下例）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">outer</span></span>() &#123;</span><br><span class="line">  var num = 0 //内部变量</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">    //通过<span class="built_in">return</span>返回add函数，就可以在outer函数外访问了。</span><br><span class="line">    num++ //内部函数有引用，作为add函数的一部分了</span><br><span class="line">    console.log(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var func1 = outer() //</span><br><span class="line">func1() //实际上是调用add函数， 输出1</span><br><span class="line">func1() //输出2</span><br><span class="line">var func2 = outer()</span><br><span class="line">func2() // 输出1</span><br><span class="line">func2() // 输出2</span><br></pre></td></tr></table></figure></p><h3 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h3><p>先搞明白一个很重要的概念 —— <code>this的值是在执行的时候才能确认，定义的时候不能确认！</code> 为什么呢 —— 因为this是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 情况1</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  console.log(this.a) //1</span><br><span class="line">&#125;</span><br><span class="line">var a = 1</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 情况2</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>()&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var obj=&#123;fn:fn&#125;;</span><br><span class="line">obj.fn(); //this-&gt;obj</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 情况3</span><br><span class="line"><span class="keyword">function</span> CreateJsPerson(name,age)&#123;</span><br><span class="line">//this是当前类的一个实例p1</span><br><span class="line">this.name=name; //=&gt;p1.name=name</span><br><span class="line">this.age=age; //=&gt;p1.age=age</span><br><span class="line">&#125;</span><br><span class="line">var p1=new CreateJsPerson(<span class="string">"尹华芝"</span>,48);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 情况4</span><br><span class="line"><span class="keyword">function</span> add(c, d)&#123;</span><br><span class="line">  <span class="built_in">return</span> this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line">var o = &#123;a:1, b:3&#125;;</span><br><span class="line">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</span><br><span class="line">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 情况5</span><br><span class="line">&lt;button id=<span class="string">"btn1"</span>&gt;箭头函数this&lt;/button&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;   </span><br><span class="line">    <span class="built_in">let</span> btn1 = document.getElementById(<span class="string">'btn1'</span>);</span><br><span class="line">    <span class="built_in">let</span> obj = &#123;</span><br><span class="line">        name: <span class="string">'kobe'</span>,</span><br><span class="line">        age: 39,</span><br><span class="line">        getName: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            btn1.onclick = () =&gt; &#123;</span><br><span class="line">                console.log(this);//obj</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.getName();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>接下来我们逐一解释上面几种情况:<br>　　对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window<br>　　对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象<br>　　在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例<br>　　call、apply和bind：this 是第一个参数<br>　　箭头函数this指向:箭头函数没有自己的this，看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="http://yoursite.com/2019/04/01/Vue/Vuex/"/>
    <id>http://yoursite.com/2019/04/01/Vue/Vuex/</id>
    <published>2019-04-01T11:52:12.000Z</published>
    <updated>2019-04-02T00:59:17.069Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>　　Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>　　每一个 Vuex 应用的核心就是<code>store</code>（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (<code>state</code>)。<code>Vuex</code> 和单纯的全局对象有以下两点不同：<br>　　1、<code>Vuex</code> 的状态存储是响应式的。当 <code>Vue</code> 组件从 <code>store</code> 中读取状态的时候，若 <code>store</code> 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>　　2、你不能直接改变 <code>store</code> 中的状态。改变 <code>store</code> 中的状态的唯一途径就是显式地提交 <code>(commit) mutation</code>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>下载: <code>&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;</code><br><code>&lt;script src=&quot;/path/to/vuex.js&quot;&gt;&lt;/script&gt;</code><br>CND: <code>https://unpkg.com/vuex</code><br>也可以通过 <code>https://unpkg.com/vuex@2.0.0</code> 这样的方式指定特定的版本。<br>npm: <code>npm install vuex --save</code><br>在一个模块化的打包系统中，您必须显式地通过 Vue.use() 来安装 Vuex：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import Vuex from <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure></p><p>当使用全局 script 标签引用 Vuex 时，不需要以上安装过程。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期和钩子函数</title>
    <link href="http://yoursite.com/2019/04/01/Vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/04/01/Vue/Vue生命周期和钩子函数/</id>
    <published>2019-04-01T07:43:08.000Z</published>
    <updated>2019-04-01T11:28:45.177Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p><img src="/assets/images/vue.png" alt="vue生命周期"></p><h3 id="Vue生命周期和钩子函数"><a href="#Vue生命周期和钩子函数" class="headerlink" title="Vue生命周期和钩子函数"></a>Vue生命周期和钩子函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate</span><br><span class="line">created</span><br><span class="line">beforeMount</span><br><span class="line">mounted</span><br><span class="line">beforeUpdate</span><br><span class="line">updated</span><br><span class="line">beforeDestroy</span><br><span class="line">destroyed</span><br></pre></td></tr></table></figure><p>创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。<br>　　载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。<br>　　更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。<br>　　销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在</p><h4 id="生命周期探究"><a href="#生命周期探究" class="headerlink" title="生命周期探究"></a>生命周期探究</h4><p>　　对于执行顺序和什么时候执行，看上面两个图基本有个了解了。下面我们将结合代码去看看钩子函数的执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;title&gt;<span class="built_in">test</span>&lt;/title&gt;</span><br><span class="line">  &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> </span><br><span class="line">    src=<span class="string">"https://cdn.jsdelivr.net/vue/2.1.3/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message : <span class="string">"xuxiao is boy"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeCreate: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.group(<span class="string">'beforeCreate 创建前状态===============》'</span>);</span><br><span class="line">    //undefined</span><br><span class="line">    console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">    //undefined </span><br><span class="line">    console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>);</span><br><span class="line">    console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message)</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.group(<span class="string">'created 创建完毕状态===============》'</span>);</span><br><span class="line">    //undefined</span><br><span class="line">    console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">    //已被初始化 </span><br><span class="line">    console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>);</span><br><span class="line">    //已被初始化</span><br><span class="line">    console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message);</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.group(<span class="string">'beforeMount 挂载前状态===============》'</span>);</span><br><span class="line">      //已被初始化</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + (this.<span class="variable">$el</span>));</span><br><span class="line">      console.log(this.<span class="variable">$el</span>);</span><br><span class="line">      //已被初始化  </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>);</span><br><span class="line">      //已被初始化  </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message);</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.group(<span class="string">'mounted 挂载结束状态===============》'</span>);</span><br><span class="line">      //已被初始化</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(this.<span class="variable">$el</span>);    </span><br><span class="line">      //已被初始化</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>);</span><br><span class="line">      //已被初始化 </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message);</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeUpdate: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.group(<span class="string">'beforeUpdate 更新前状态===============》'</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>); </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message); </span><br><span class="line">    &#125;,</span><br><span class="line">    updated: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.group(<span class="string">'updated 更新完成状态===============》'</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>); </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message); </span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.group(<span class="string">'beforeDestroy 销毁前状态===============》'</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>); </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message); </span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.group(<span class="string">'destroyed 销毁完成状态===============》'</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(this.<span class="variable">$el</span>);</span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + this.<span class="variable">$data</span>); </span><br><span class="line">      console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + this.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h5 id="beforeCreate-和-created-钩子函数"><a href="#beforeCreate-和-created-钩子函数" class="headerlink" title="beforeCreate 和 created 钩子函数"></a>beforeCreate 和 created 钩子函数</h5><p>　　在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定（放在data中的属性当值发生改变的同时，视图也会改变）。</p><h5 id="create-和-mounted-相关"><a href="#create-和-mounted-相关" class="headerlink" title="create 和 mounted 相关"></a>create 和 mounted 相关</h5><p>咱们在chrome浏览器里打开，F12看console就能发现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">beforecreated：el 和 data 并未初始化 </span><br><span class="line">created:完成了 data 数据的初始化，el没有</span><br><span class="line">beforeMount：完成了 el 和 data 初始化 </span><br><span class="line">mounted ：完成挂载</span><br><span class="line">另外在标红处，我们能发现el还是 &#123;&#123;message&#125;&#125;，</span><br><span class="line">这里就是应用的 Virtual DOM（虚拟Dom）技术，先把坑占住了。</span><br><span class="line">到后面mounted挂载的时候再把值渲染进去。</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/vue03.png" alt="vue生命周期"></p><h5 id="update-相关"><a href="#update-相关" class="headerlink" title="update 相关"></a>update 相关</h5><p>这里我们在 chrome console里执行以下命令<code>app.message= &#39;yes !! I do&#39;</code>;<br>下面就能看到data里的值被修改后，将会触发update的操作。<br><img src="/assets/images/vue02.png" alt="vue生命周期"></p><h5 id="destroy-相关"><a href="#destroy-相关" class="headerlink" title="destroy 相关"></a>destroy 相关</h5><p>有关于销毁，暂时还不是很清楚。我们在console里执行下命令对 vue实例进行销毁。销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。<br><code>app.$destroy()</code>;<br><img src="/assets/images/vue01.png" alt="vue生命周期"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforecreate : 举个栗子：可以在这加个loading事件 </span><br><span class="line">created ：在这结束loading，还做一些初始化，实现函数自执行 </span><br><span class="line">mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情</span><br><span class="line">beforeDestroy： 你确认删除XX吗？ destroyed ：当前组件已被删除，清空相关内容</span><br></pre></td></tr></table></figure><p>转载：<br>　　<a href="https://segmentfault.com/a/1190000008010666?utm_source=tag-newest" target="_blank" rel="noopener">Vue2.0 探索之路——生命周期和钩子函数的一些理解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue知识点</title>
    <link href="http://yoursite.com/2019/04/01/Vue/Vue%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/01/Vue/Vue总结/</id>
    <published>2019-04-01T06:35:02.000Z</published>
    <updated>2019-04-02T13:26:37.353Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h3 id="Vue的优点是什么"><a href="#Vue的优点是什么" class="headerlink" title="Vue的优点是什么"></a>Vue的优点是什么</h3><p>　　低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。<br>　　可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。<br>　　独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。<br>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</p><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><p>beforeCreate<br>created<br>在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定（放在data中的属性当值发生改变的同时，视图也会改变）<br>beforeMount<br>mounted<br>beforeUpdate<br>updated<br>beforeDestroy钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。<br>destroyed钩子函数在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p><p>答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。<br>　　创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。<br>　　载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。<br>　　更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。<br>　　销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在</p><h3 id="路由之间跳转？"><a href="#路由之间跳转？" class="headerlink" title="路由之间跳转？"></a>路由之间跳转？</h3><p>声明式（标签跳转）<br>编程式（ js 跳转） router.push(‘index’)</p><h3 id="懒加载（按需加载路由）（常考）"><a href="#懒加载（按需加载路由）（常考）" class="headerlink" title="懒加载（按需加载路由）（常考）"></a>懒加载（按需加载路由）（常考）</h3><p>webpack 中提供了 require.ensure()来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。</p><p>不进行页面按需加载引入方式：<br><code>import  home   from &#39;../../common/home.vue&#39;</code><br>进行页面按需加载的引入方式：<br><code>const  home = r =&gt; require.ensure( [], () =&gt; r (require(&#39;../../common/home.vue&#39;)))</code></p><h3 id="vue-router-有哪几种导航钩子"><a href="#vue-router-有哪几种导航钩子" class="headerlink" title="vue-router 有哪几种导航钩子?"></a>vue-router 有哪几种导航钩子?</h3><p>三种<br>全局导航钩子<br>router.beforeEach(to, from, next),<br>router.beforeResolve(to, from, next),<br>router.afterEach(to, from ,next)<br>组件内钩子<br>beforeRouteEnter,<br>beforeRouteUpdate,<br>beforeRouteLeave<br>单独路由独享组件<br>beforeEnte</p><h3 id="说出至少-4-种-vue-当中的指令和它的用法"><a href="#说出至少-4-种-vue-当中的指令和它的用法" class="headerlink" title="说出至少 4 种 vue 当中的指令和它的用法"></a>说出至少 4 种 vue 当中的指令和它的用法</h3><p>v-if(判断是否隐藏)、v-for(把数据遍历出来)、v-bind(绑定属性)、v-model(实现双向绑定)</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><h4 id="vuex-是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex-是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex 是什么？怎么使用？哪种功能场景使用它？"></a>vuex 是什么？怎么使用？哪种功能场景使用它？</h4><p>vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p><h4 id="vuex-有哪几种属性"><a href="#vuex-有哪几种属性" class="headerlink" title="vuex 有哪几种属性"></a>vuex 有哪几种属性</h4><p>有 5 种，分别是 state、getter、mutation、action、module</p><h4 id="vuex-的-store-特性是什么"><a href="#vuex-的-store-特性是什么" class="headerlink" title="vuex 的 store 特性是什么"></a>vuex 的 store 特性是什么</h4><p>vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data<br>state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新<br>它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</p><h4 id="vuex-的-getter-特性是什么"><a href="#vuex-的-getter-特性是什么" class="headerlink" title="vuex 的 getter 特性是什么"></a>vuex 的 getter 特性是什么</h4><p>getter 可以对 state 进行计算操作，它就是 store 的计算属性<br>虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用<br>如果一个状态只在一个组件内使用，是可以不用 getters</p><h4 id="vuex-的-mutation-特性是什么"><a href="#vuex-的-mutation-特性是什么" class="headerlink" title="vuex 的 mutation 特性是什么"></a>vuex 的 mutation 特性是什么</h4><p>action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态<br>action 可以包含任意异步操作</p><h4 id="vue-中-ajax-请求代码应该写在组件的-methods-中还是-vuex-的-action-中"><a href="#vue-中-ajax-请求代码应该写在组件的-methods-中还是-vuex-的-action-中" class="headerlink" title="vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中"></a>vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中</h4><p>如果请求来的数据不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 vuex 的 state 里<br>如果被其他地方复用，请将请求放入 action 里，方便复用，并包装成 promise 返回</p><h4 id="不用-vuex-会带来什么问题"><a href="#不用-vuex-会带来什么问题" class="headerlink" title="不用 vuex 会带来什么问题"></a>不用 vuex 会带来什么问题</h4><p>可维护性会下降，你要修改数据，你得维护 3 个地方<br>可读性下降，因为一个组件里的数据，你根本就看不出来是从哪里来的<br>增加耦合，大量的上传派发，会让耦合性大大的增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背</p><h4 id="vuex-原理"><a href="#vuex-原理" class="headerlink" title="vuex 原理"></a>vuex 原理</h4><h4 id="使用-Vuex-只需执行-Vue-use-Vuex-，并在-Vue-的配置中传入一个-store-对象的示例，store-是如何实现注入的？"><a href="#使用-Vuex-只需执行-Vue-use-Vuex-，并在-Vue-的配置中传入一个-store-对象的示例，store-是如何实现注入的？" class="headerlink" title="使用 Vuex 只需执行 Vue.use(Vuex)，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？"></a>使用 Vuex 只需执行 Vue.use(Vuex)，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？</h4><p>Vue.use(Vuex) 方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的store中。因此在VueComponent任意地方都能够通过this.store 访问到该 store</p><h4 id="state-内部支持模块配置和模块嵌套，如何实现的？"><a href="#state-内部支持模块配置和模块嵌套，如何实现的？" class="headerlink" title="state 内部支持模块配置和模块嵌套，如何实现的？"></a>state 内部支持模块配置和模块嵌套，如何实现的？</h4><p>在 store 构造方法中有 makeLocalContext 方法，所有 module 都会有一个 local context，根据配置时的 path 进行匹配。所以执行如 dispatch(‘submitOrder’, payload)这类 action 时，默认的拿到都是 module 的 local state，如果要访问最外层或者是其他 module 的 state，只能从 rootState 按照 path 路径逐步进行访问。</p><h4 id="在执行-dispatch-触发-action-commit-同理-的时候，只需传入-type-payload-，action-执行函数中第一个参数-store-从哪里获取的？"><a href="#在执行-dispatch-触发-action-commit-同理-的时候，只需传入-type-payload-，action-执行函数中第一个参数-store-从哪里获取的？" class="headerlink" title="在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？"></a>在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？</h4><p>store 初始化时，所有配置的 action 和 mutation 以及 getters 均被封装过。在执行如 dispatch(‘submitOrder’, payload)的时候，actions 中 type 为 submitOrder 的所有处理方法都是被封装后的，其第一个参数为当前的 store 对象，所以能够获取到 { dispatch, commit, state, rootState } 等数据。</p><h4 id="Vuex-如何区分-state-是外部直接修改，还是通过-mutation-方法修改的？"><a href="#Vuex-如何区分-state-是外部直接修改，还是通过-mutation-方法修改的？" class="headerlink" title="Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？"></a>Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？</h4><p>Vuex 中修改 state 的唯一渠道就是执行 commit(‘xx’, payload) 方法，其底层通过执行 this._withCommit(fn) 设置_committing 标志变量为 true，然后才能修改 state，修改完毕还需要还原_committing 变量。外部修改虽然能够直接修改 state，但是并没有修改_committing 标志位，所以只要 watch 一下 state，state change 时判断是否_committing 值为 true，即可判断修改的合法性。</p><p>#### </p><p>#### </p><h4 id="vue基础"><a href="#vue基础" class="headerlink" title="vue基础"></a>vue基础</h4><p>计算属性，方法与侦听器<br>计算属性的setter和getter<br>样式绑定，条件与列表渲染<br>Vue中的set方法<br>事件与表单绑定</p><h4 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h4><p>组件使用的细节点<br>父子组件传值与组件参数校验<br>原生事件绑定与非Props特性<br>使用bus进行非父子组件间传值<br>插槽的使用<br>动态组件</p><p>多组件状态管理与数据传递技巧<br>组件混入机制大幅精简组件代码<br>组件插槽提升组件复用度<br>动态组件提升组件灵活性<br>异步组件+组件缓存提升访问性能<br>组件API化简化组件调用过程</p><h4 id="vue动画"><a href="#vue动画" class="headerlink" title="vue动画"></a>vue动画</h4><p>Vue transition过渡<br>Vue transition-group过渡<br>Vue交互touch+mouse事件<br>CSS3过渡和帧动画<br>css 预处理</p><p> event、v-model、slot、keep-alive、transition、transition-group</p><h4 id="说一下Vue的双向绑定数据的原理"><a href="#说一下Vue的双向绑定数据的原理" class="headerlink" title="说一下Vue的双向绑定数据的原理"></a>说一下Vue的双向绑定数据的原理</h4><p>vue 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调</p><h4 id="解释单向数据流和双向数据绑定"><a href="#解释单向数据流和双向数据绑定" class="headerlink" title="解释单向数据流和双向数据绑定"></a>解释单向数据流和双向数据绑定</h4><p>单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 action 来维护对应的 state<br>双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 debug 的难度</p><h4 id="Vue-如何去除url中的"><a href="#Vue-如何去除url中的" class="headerlink" title="Vue 如何去除url中的"></a>Vue 如何去除url中的</h4><p>vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 url 会自带 #。如果不想使用 #， 可以使用 vue-router 的另一种模式 history<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: [ ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 404 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面</p><h4 id="介绍虚拟DOM"><a href="#介绍虚拟DOM" class="headerlink" title="介绍虚拟DOM"></a>介绍虚拟DOM</h4><p><a href="https://www.jianshu.com/p/616999666920" target="_blank" rel="noopener">https://www.jianshu.com/p/616999666920</a></p><h4 id="http-www-ruanyifeng-com-blog-2015-02-mvcmvp-mvvm-html"><a href="#http-www-ruanyifeng-com-blog-2015-02-mvcmvp-mvvm-html" class="headerlink" title="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html"></a><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a></h4><p>#### </p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>优化DOM</title>
    <link href="http://yoursite.com/2019/03/31/JavaScript/%E4%BC%98%E5%8C%96DOM/"/>
    <id>http://yoursite.com/2019/03/31/JavaScript/优化DOM/</id>
    <published>2019-03-31T10:31:06.000Z</published>
    <updated>2019-03-31T10:35:26.741Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>DOM基本操作</title>
    <link href="http://yoursite.com/2019/03/31/JavaScript/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/03/31/JavaScript/DOM基本操作/</id>
    <published>2019-03-31T09:27:50.000Z</published>
    <updated>2019-03-31T11:53:13.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><ul><li>document<ul><li>getElementById<ul><li>语法： document.getElementById(元素ID)</li><li>功能： 通过元素ID获取节点</li></ul></li><li>getElementsByName<ul><li>语法： document.getElementsByName(元素name属性)</li><li>功能： 通过元素name属性获取节点</li></ul></li><li>getElementsByTagName<ul><li>语法： document.getElementsByTagName(元素标签)</li><li>功能： 通过元素标签获取节点</li></ul></li><li>getElementsByClassName<ul><li>语法： document.getElementsByClassName(“classname”)</li><li>功能： 根据class获取元素节点</li></ul></li></ul></li><li>CSS选择器<ul><li>querySelector()<ul><li>语法： document.querySelector()</li><li>功能： 根据CSS选择器的规则，返回第一个匹配到的元素</li></ul></li><li>querySelectorAll()<ul><li>语法： document.querySelectorAll()</li><li>功能： 根据CSS选择器的规则，返回所有匹配到的元素</li></ul></li></ul></li><li>节点指针<ul><li>firstChild<ul><li>语法： 父节点.firstChild</li><li>功能： 获取元素首个节点</li></ul></li><li>lastChild<ul><li>语法： 父节点.lastChild</li><li>功能： 获取元素最后一个节点</li></ul></li><li>childNodes<ul><li>语法： 父节点.childNodes</li><li>功能： 获取元素子节点列表</li></ul></li><li>previousSibling<ul><li>语法： 兄弟节点.previousSibling</li><li>功能： 获取已知节点前一个节点</li></ul></li><li>nextSibling<ul><li>语法： 兄弟节点.nextSibling</li><li>功能： 获取已知节点后一个节点</li></ul></li><li>parentNode<ul><li>语法： 子节点.parentNode</li><li>功能： 获取已知节点的父节点</li></ul></li></ul></li></ul><h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><ul><li>创建节点<ul><li>createElement<ul><li>语法： document.createElement(元素标签)</li><li>功能： 创造元素节点</li></ul></li><li>createAttribute<ul><li>语法： document.createAttribute(元素属性)</li><li>功能： 创建属性节点</li></ul></li><li>createTextNode<ul><li>语法： document.createTextNode(文本内容)</li><li>功能： 创建文本节点</li></ul></li></ul></li><li>插入节点<ul><li>appendChild<ul><li>语法： appendChild(所添加的新节点)</li><li>功能： 向节点的子节点列表的末尾添加新的子节点</li></ul></li><li>insertBefore<ul><li>语法： insertBefore(所要添加的新节点, 已知子节点)</li><li>功能： 向已知的子节点前插入一个新的子节点</li></ul></li></ul></li><li>替换节点<ul><li>replaceChild<ul><li>语法： replaceChild(要插入的新元素， 将被替换的老元素)</li><li>功能： 将子节点替换成另一个</li></ul></li></ul></li><li>复制节点<ul><li>cloneNode<ul><li>语法： 需要被复制的节点.cloneNode(true/false)</li><li>功能： 创建指定节点的副本</li><li>参数： <ul><li>true 复制当前节点以及其他所有子节点</li><li>false 仅复制当前节点</li></ul></li></ul></li></ul></li><li>删除节点<ul><li>removeChild<ul><li>语法： removeChild(要删除的节点)</li><li>功能： 删除指定的节点</li></ul></li></ul></li></ul><h4 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h4><ul><li>获取属性<ul><li>getAttribute<ul><li>语法： 元素节点.getAttribute(元素属性名)</li><li>功能： 获取元素节点中指定属性的属性值</li></ul></li></ul></li><li>设置属性<ul><li>setAttribute<ul><li>语法： 元素节点.setAttribute(属性名， 属性值)</li><li>功能： 创建或者改变元素的属性</li></ul></li></ul></li><li>删除属性<ul><li>removeAttribute<ul><li>语法： 元素节点.removeAttribute(属性名)</li><li>功能： 删除元素中的指定属性</li></ul></li></ul></li></ul><h4 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h4><ul><li>文本操作<ul><li>insterData(offset, string)<ul><li>从offset指定的位置插入string</li></ul></li><li>appendData(string)<ul><li>将string插入到文本节点的末尾处</li></ul></li><li>deleteData(offset, count)<ul><li>从offset起删除count个字符</li></ul></li><li>replaceData(off, count, string)<ul><li>从off将count个字符用string</li></ul></li><li>splitData(offset)<ul><li>从offset起将文本节点分成两个节点</li></ul></li><li>substring(offset, count)<ul><li>返回由offset起的count个节点</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue中使用Axios</title>
    <link href="http://yoursite.com/2019/03/30/Ajax/Axios/"/>
    <id>http://yoursite.com/2019/03/30/Ajax/Axios/</id>
    <published>2019-03-30T13:06:58.000Z</published>
    <updated>2019-03-31T05:47:28.659Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><a id="more"></a><p>转载：<br>　　<a href="https://www.jianshu.com/p/df464b26ae58" target="_blank" rel="noopener">axios</a><br>参考：<br>　　<a href="https://github.com/axios/axios/blob/master/README.md" target="_blank" rel="noopener">axio github</a><br>　　<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">Axios中文</a></p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>安装: <code>npm install axios --save</code><br>设置全局都可以使用axios<br>设置在 main.js 中引入 axios:<br>　　<code>import axios from &#39;axios&#39;</code><br>axios 改写为 Vue 的原型属性（不推荐这样用）<br>　　<code>Vue.prototype.$http= axios</code><br>在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $http命令<br>例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">    this.<span class="variable">$http</span>(&#123;</span><br><span class="line">      method: <span class="string">'get'</span>,</span><br><span class="line">      url: <span class="string">'/user'</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        name: <span class="string">'virus'</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><h5 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过给定的ID来发送请求</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(response)&#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="keyword">function</span>(err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment"># 以上请求也可以通过这种方式来发送</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>,&#123;</span><br><span class="line">  params:&#123;</span><br><span class="line">    ID:12345</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="keyword">function</span>(response)&#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="keyword">function</span>(err)&#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>,&#123;</span><br><span class="line">  firstName:<span class="string">'Fred'</span>,</span><br><span class="line">  lastName:<span class="string">'Flintstone'</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="keyword">function</span>(res)&#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="keyword">function</span>(err)&#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="一次性并发多个请求"><a href="#一次性并发多个请求" class="headerlink" title="一次性并发多个请求"></a>一次性并发多个请求</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getUserAccount</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getUserPermissions</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line">axios.all([getUserAccount(),getUserPermissions()])</span><br><span class="line">  .<span class="keyword">then</span>(axios.spread(<span class="keyword">function</span>(acct,perms)&#123;</span><br><span class="line">    <span class="comment"># 当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果</span></span><br><span class="line">  &#125;))</span><br></pre></td></tr></table></figure><h4 id="axios的API"><a href="#axios的API" class="headerlink" title="axios的API"></a>axios的API</h4><h5 id="axios可以通过配置（config）来发送请求"><a href="#axios可以通过配置（config）来发送请求" class="headerlink" title="axios可以通过配置（config）来发送请求"></a>axios可以通过配置（config）来发送请求</h5><h6 id="axios-config"><a href="#axios-config" class="headerlink" title="axios(config)"></a>axios(config)</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送一个`POST`请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">    method:<span class="string">"POST"</span>,</span><br><span class="line">    url:<span class="string">'/user/12345'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        firstName:<span class="string">"Fred"</span>,</span><br><span class="line">        lastName:<span class="string">"Flintstone"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="axios-url-config"><a href="#axios-url-config" class="headerlink" title="axios(url[,config])"></a>axios(url[,config])</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送一个`GET`请求（默认的请求方式）</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>);</span><br></pre></td></tr></table></figure><h5 id="请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名"><a href="#请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名" class="headerlink" title="请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名"></a>请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.request(config);</span><br><span class="line">axios.get(url[,config]);</span><br><span class="line">axios.delete(url[,config]);</span><br><span class="line">axios.head(url[,config]);</span><br><span class="line">axios.post(url[,data[,config]]);</span><br><span class="line">axios.put(url[,data[,config]])</span><br><span class="line">axios.patch(url[,data[,config]])</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明</p><h5 id="并发请求（concurrency）-即是帮助处理并发请求的辅助函数"><a href="#并发请求（concurrency）-即是帮助处理并发请求的辅助函数" class="headerlink" title="并发请求（concurrency）,即是帮助处理并发请求的辅助函数"></a>并发请求（concurrency）,即是帮助处理并发请求的辅助函数</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iterable是一个可以迭代的参数如数组等</span></span><br><span class="line">axios.all(iterable)</span><br><span class="line"><span class="comment"># callback要等到所有请求都完成才会执行</span></span><br><span class="line">axios.spread(callback)</span><br></pre></td></tr></table></figure><h5 id="创建一个axios实例，并且可以自定义其配置"><a href="#创建一个axios实例，并且可以自定义其配置" class="headerlink" title="创建一个axios实例，并且可以自定义其配置"></a>创建一个axios实例，并且可以自定义其配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># axios.create([config])</span></span><br><span class="line">var instance = axios.create(&#123;</span><br><span class="line">  baseURL:<span class="string">"https://some-domain.com/api/"</span>,</span><br><span class="line">  timeout:1000,</span><br><span class="line">  headers: &#123;<span class="string">'X-Custom-Header'</span>:<span class="string">'foobar'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例的方法</span></span><br><span class="line"><span class="comment"># 一下是实例方法，注意已经定义的配置将和利用create创建的实例的配置合并</span></span><br><span class="line">axios<span class="comment">#request(config)</span></span><br><span class="line">axios<span class="comment">#get(url[,config])</span></span><br><span class="line">axios<span class="comment">#delete(url[,config])</span></span><br><span class="line">axios<span class="comment">#head(url[,config])</span></span><br><span class="line">axios<span class="comment">#post(url[,data[,config]])</span></span><br><span class="line">axios<span class="comment">#put(url[,data[,config]])</span></span><br><span class="line">axios<span class="comment">#patch(url[,data[,config]])</span></span><br></pre></td></tr></table></figure><h4 id="请求的配置（request-config）"><a href="#请求的配置（request-config）" class="headerlink" title="请求的配置（request config）"></a>请求的配置（request config）</h4><p>　　以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment"># `url`是请求的服务器地址</span></span><br><span class="line">  url:<span class="string">'/user'</span>,</span><br><span class="line">  <span class="comment"># `method`是请求资源的方式</span></span><br><span class="line">  method:<span class="string">'get'</span><span class="comment"># default</span></span><br><span class="line">  <span class="comment"># 如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面</span></span><br><span class="line">  <span class="comment"># 当`url`是相对地址的时候，设置`baseURL`会非常的方便</span></span><br><span class="line">  baseURL:<span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line">  <span class="comment"># `transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动</span></span><br><span class="line">  <span class="comment"># 该选项只适用于以下请求方式：`put/post/patch`</span></span><br><span class="line">  <span class="comment"># 数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream`</span></span><br><span class="line">  transformRequest:[<span class="keyword">function</span>(data)&#123;</span><br><span class="line">    <span class="comment"># 在这里根据自己的需求改变数据</span></span><br><span class="line">    <span class="built_in">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="comment"># `transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动</span></span><br><span class="line">  transformResponse:[<span class="keyword">function</span>(data)&#123;</span><br><span class="line">    <span class="comment"># 在这里根据自己的需求改变数据</span></span><br><span class="line">    <span class="built_in">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="comment"># `headers`选项是需要被发送的自定义请求头信息</span></span><br><span class="line">  headers: &#123;<span class="string">'X-Requested-With'</span>:<span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line">  <span class="comment"># `params`选项是要随请求一起发送的请求参数----一般链接在URL后面</span></span><br><span class="line">  <span class="comment"># 他的类型必须是一个纯对象或者是URLSearchParams对象</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID:12345</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化</span></span><br><span class="line">  <span class="comment"># 例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param)</span></span><br><span class="line">  paramsSerializer: <span class="keyword">function</span>(params)&#123;</span><br><span class="line">    <span class="built_in">return</span> Qs.stringify(params,&#123;arrayFormat:<span class="string">'brackets'</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `data`选项是作为一个请求体而需要被发送的数据</span></span><br><span class="line">  <span class="comment"># 该选项只适用于方法：`put/post/patch`</span></span><br><span class="line">  <span class="comment"># 当没有设置`transformRequest`选项时dada必须是以下几种类型之一</span></span><br><span class="line">  <span class="comment"># string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams</span></span><br><span class="line">  <span class="comment"># 仅仅浏览器：FormData/File/Bold</span></span><br><span class="line">  <span class="comment"># 仅node:Stream</span></span><br><span class="line">  data &#123;</span><br><span class="line">    firstName:<span class="string">"Fred"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `timeout`选项定义了请求发出的延迟毫秒数</span></span><br><span class="line">  <span class="comment"># 如果请求花费的时间超过延迟的时间，那么请求会被终止</span></span><br><span class="line"></span><br><span class="line">  timeout:1000,</span><br><span class="line">  <span class="comment"># `withCredentails`选项表明了是否是跨域请求</span></span><br><span class="line">  </span><br><span class="line">  withCredentials:<span class="literal">false</span>,<span class="comment"># default</span></span><br><span class="line">  <span class="comment"># `adapter`适配器选项允许自定义处理请求，这会使得测试变得方便</span></span><br><span class="line">  <span class="comment"># 返回一个promise,并提供验证返回</span></span><br><span class="line">  adapter: <span class="keyword">function</span>(config)&#123;</span><br><span class="line">    /*..........*/</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `auth`表明HTTP基础的认证应该被使用，并提供证书</span></span><br><span class="line">  <span class="comment"># 这会设置一个authorization头（header）,并覆盖你在header</span></span><br><span class="line">  <span class="comment"># 设置的Authorization头信息</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username:<span class="string">"zhangsan"</span>,</span><br><span class="line">    password: <span class="string">"s00sdkf"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># 返回数据的格式</span></span><br><span class="line">  <span class="comment"># 其可选项是arraybuffer,blob,document,json,text,stream</span></span><br><span class="line">  responseType:<span class="string">'json'</span>,<span class="comment"># default</span></span><br><span class="line">  <span class="comment"># </span></span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>,<span class="comment"># default</span></span><br><span class="line">  xsrfHeaderName:<span class="string">'X-XSRF-TOKEN'</span>,<span class="comment"># default</span></span><br><span class="line">  <span class="comment"># `onUploadProgress`上传进度事件</span></span><br><span class="line">  onUploadProgress:<span class="keyword">function</span>(progressEvent)&#123;</span><br><span class="line">    <span class="comment"># 下载进度的事件</span></span><br><span class="line">onDownloadProgress:<span class="keyword">function</span>(progressEvent)&#123;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># 相应内容的最大值</span></span><br><span class="line">  maxContentLength:2000,</span><br><span class="line">  <span class="comment"># `validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise</span></span><br><span class="line">  <span class="comment"># 如果`validateStatus`返回true(或者设置为`null`或者`undefined`),</span></span><br><span class="line">  <span class="comment"># 那么promise的状态将会是resolved,否则其状态就是rejected</span></span><br><span class="line">  validateStatus:<span class="keyword">function</span>(status)&#123;</span><br><span class="line">    <span class="built_in">return</span> status &gt;= 200 &amp;&amp; status &lt;300;<span class="comment"># default</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `maxRedirects`定义了在nodejs中重定向的最大数量</span></span><br><span class="line">  maxRedirects: 5,<span class="comment"># default</span></span><br><span class="line">  <span class="comment"># `httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理</span></span><br><span class="line">  <span class="comment"># keeyAlive在选项中没有被默认激活</span></span><br><span class="line">  httpAgent: new http.Agent(&#123;keeyAlive:<span class="literal">true</span>&#125;),</span><br><span class="line">  httpsAgent: new https.Agent(&#123;keeyAlive:<span class="literal">true</span>&#125;),</span><br><span class="line">  <span class="comment"># proxy定义了主机名字和端口号，</span></span><br><span class="line">  <span class="comment"># `auth`表明http基本认证应该与proxy代理链接，并提供证书</span></span><br><span class="line">  <span class="comment"># 这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的</span></span><br><span class="line">  <span class="comment"># Proxy-Authorization  header</span></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host:<span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: 9000,</span><br><span class="line">    auth: &#123;</span><br><span class="line">      username:<span class="string">'skda'</span>,</span><br><span class="line">      password:<span class="string">'radsd'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># `cancelToken`定义了一个用于取消请求的cancel token</span></span><br><span class="line">  <span class="comment"># 详见cancelation部分</span></span><br><span class="line">  cancelToken: new cancelToken(<span class="keyword">function</span>(cancel)&#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="请求返回的内容"><a href="#请求返回的内容" class="headerlink" title="请求返回的内容"></a>请求返回的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  data:&#123;&#125;,</span><br><span class="line">  status:200,</span><br><span class="line">  <span class="comment"># 从服务器返回的http状态文本</span></span><br><span class="line">  statusText:<span class="string">'OK'</span>,</span><br><span class="line">  <span class="comment"># 响应头信息</span></span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line">  <span class="comment"># `config`是在请求的时候的一些配置信息</span></span><br><span class="line">  config: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你可以这样来获取响应信息</span></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(res)&#123;</span><br><span class="line">    console.log(res.data);</span><br><span class="line">    console.log(res.status);</span><br><span class="line">    console.log(res.statusText);</span><br><span class="line">    console.log(res.headers);</span><br><span class="line">    console.log(res.config);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><p>你可以设置默认配置，对所有请求都有效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、 全局默认配置</span><br><span class="line">axios.defaults.baseURL = <span class="string">'http://api.exmple.com'</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'content-Type'</span>] = <span class="string">'appliction/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure></p><p>2、 自定义的实例默认设置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当创建实例的时候配置默认配置</span></span><br><span class="line">var instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'https://api.example.com'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当实例创建时候修改配置</span></span><br><span class="line">instance.defaults.headers.common[<span class="string">"Authorization"</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure></p><p>3、 配置中的有优先级<br>　　config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个实例的时候会使用libray目录中的默认配置</span></span><br><span class="line"><span class="comment"># 在这里timeout配置的值为0，来自于libray的默认值</span></span><br><span class="line">var instance = axios.create();</span><br><span class="line"><span class="comment"># 回覆盖掉library的默认值</span></span><br><span class="line"><span class="comment"># 现在所有的请求都要等2.5S之后才会发出</span></span><br><span class="line">instance.defaults.timeout = 2500;</span><br><span class="line"><span class="comment"># 这里的timeout回覆盖之前的2.5S变成5s</span></span><br><span class="line">instance.get(<span class="string">'/longRequest'</span>,&#123;</span><br><span class="line">  timeout: 5000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>你可以在请求、响应在到达then/catch之前拦截他们<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加一个请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="keyword">function</span>(config)&#123;</span><br><span class="line">  <span class="comment"># 在请求发出之前进行一些操作</span></span><br><span class="line">  <span class="built_in">return</span> config;</span><br><span class="line">&#125;,<span class="keyword">function</span>(err)&#123;</span><br><span class="line">  <span class="comment"># Do something with request error</span></span><br><span class="line">  <span class="built_in">return</span> Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment"># 添加一个响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="keyword">function</span>(res)&#123;</span><br><span class="line">  <span class="comment"># 在这里对返回的数据进行处理</span></span><br><span class="line">  <span class="built_in">return</span> res;</span><br><span class="line">&#125;,<span class="keyword">function</span>(err)&#123;</span><br><span class="line">  <span class="comment"># Do something with response error</span></span><br><span class="line">  <span class="built_in">return</span> Promise.reject(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>2、取消拦截器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myInterceptor = axios.interceptor.request.use(<span class="function"><span class="title">function</span></span>()&#123;/*....*/&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure></p><p>3、 给自定义的axios实例添加拦截器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="title">function</span></span>()&#123;&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .catch(<span class="keyword">function</span>(error)&#123;</span><br><span class="line">    <span class="keyword">if</span>(error.response)&#123;</span><br><span class="line">      <span class="comment"># 请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内</span></span><br><span class="line">      console.log(error.response.data);</span><br><span class="line">      console.log(error.response.status);</span><br><span class="line">      console.log(error.response.header);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment"># 一些错误是在设置请求的时候触发</span></span><br><span class="line">      console.log(<span class="string">'Error'</span>,error.message);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(error.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h4><p>1、你可以通过一个cancel token来取消一个请求<br>你可以通过CancelToken.source工厂函数来创建一个cancel token<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var CancelToken = axios.CancelToken;</span><br><span class="line">var <span class="built_in">source</span> = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>,&#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(thrown)&#123;</span><br><span class="line">  <span class="keyword">if</span>(axios.isCancel(thrown))&#123;</span><br><span class="line">    console.log(<span class="string">'Request canceled'</span>,thrown.message);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment"># handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消请求（信息的参数可以设置的）</span></span><br><span class="line">source.cance(<span class="string">"操作被用户取消"</span>);</span><br></pre></td></tr></table></figure></p><p>2、你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var cancelToken = axios.CancelToken;</span><br><span class="line">var cance;</span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>,&#123;</span><br><span class="line">  cancelToken: new CancelToken(<span class="keyword">function</span>(c)&#123;</span><br><span class="line">    <span class="comment"># 这个executor函数接受一个cancel function作为参数</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment"># 取消请求</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure></p><h4 id="创建axios实例"><a href="#创建axios实例" class="headerlink" title="创建axios实例"></a>创建axios实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># helpers.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"># 定义常量ERR_OK</span><br><span class="line"><span class="keyword">const</span> ERR_OK = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 导出一个getDate方法</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getDate(url) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(url, &#123;</span><br><span class="line">      params</span><br><span class="line">      # 成功之后的.then方法</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      # 通过结构赋值的方法难道error和data的数值</span><br><span class="line">      <span class="keyword">const</span> &#123; error, data&#125; = res.data</span><br><span class="line">      # 如果成功的话，返回data数据</span><br><span class="line">      <span class="keyword">if</span>(error === ERR_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">      &#125;</span><br><span class="line">      # 如果失败的话打印失败的原因</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) =&gt; </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"error:"</span>, error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 出口文件</span><br><span class="line"># index.js</span><br><span class="line"><span class="keyword">import</span> &#123; getDate &#125; <span class="keyword">from</span> <span class="string">'./helpers'</span></span><br><span class="line"></span><br><span class="line"># 定义getSeller方法</span><br><span class="line"><span class="keyword">const</span> getSeller = getDate(<span class="string">'./api/seller'</span>)</span><br><span class="line"></span><br><span class="line"># 导出getSeller方法</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  getSeller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="AJAX" scheme="http://yoursite.com/categories/AJAX/"/>
    
    
      <category term="AJAX" scheme="http://yoursite.com/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>AJAX</title>
    <link href="http://yoursite.com/2019/03/30/Ajax/AJAX/"/>
    <id>http://yoursite.com/2019/03/30/Ajax/AJAX/</id>
    <published>2019-03-30T03:19:04.000Z</published>
    <updated>2019-03-30T12:13:42.107Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h3 id="AJAX简介"><a href="#AJAX简介" class="headerlink" title="AJAX简介"></a>AJAX简介</h3><p>　　AJAX全称为“Asynchronous Javascript And XML”， 即“异步JavaScript和XML”的意思。通过AJAX我们可以向服务器发送请求，在不阻塞页面的情况下进行数据交互，也可以理解为异步数据传输。在AJAX的帮助下我们的网页只需局部刷新即可更新数据的显示，减少了不必要的数据量，大大提高了用户体验，缩短了用户等待的时间，使得web应用程序更小、更快，更友好。<a id="more"></a></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>页面无刷新，用户体验好。<br>异步通信，更加快的响应能力。<br>减少冗余请求，减轻了服务器负担<br>基于标准化的并被广泛支持的技术，不需要下载插件或者小程序</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>ajax干掉了back按钮，即对浏览器后退机制的破坏。<br>存在一定的安全问题。<br>对搜索引擎的支持比较弱。<br>破坏了程序的异常机制。<br>无法用URL直接访问</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>场景 1. 数据验证<br>场景 2. 按需取数据<br>场景 3. 自动更新页面</p><h3 id="AJAX的核心-XMLHttpRequest对象"><a href="#AJAX的核心-XMLHttpRequest对象" class="headerlink" title="AJAX的核心 XMLHttpRequest对象"></a>AJAX的核心 XMLHttpRequest对象</h3><p>创建XML对象的实例：<code>const xhr = new XMLHttpRequest()</code></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备启动一个AJAX请求</span></span><br><span class="line">.open()</span><br><span class="line"><span class="comment"># 设置请求头部信息</span></span><br><span class="line">.setRequestHeader()</span><br><span class="line"><span class="comment"># 发送AJAX请求</span></span><br><span class="line">.send()</span><br><span class="line"><span class="comment"># 获得响应头部信息</span></span><br><span class="line">.getResponseHeader()</span><br><span class="line"><span class="comment"># 获得一个包含所有头部信息的长字符串</span></span><br><span class="line">.getAllResponseHeader()</span><br><span class="line"><span class="comment"># 取消异步请求</span></span><br><span class="line">.abort()</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含响应主体返回文本</span></span><br><span class="line">.responseText</span><br><span class="line"><span class="comment"># 如果响应的内容类型时text/xml或application/xml，</span></span><br><span class="line"><span class="comment"># 该属性将保存包含着相应数据的XML DOM文档</span></span><br><span class="line">.responseXML</span><br><span class="line"><span class="comment"># 响应的HTTP状态</span></span><br><span class="line">.status</span><br><span class="line"><span class="comment"># HTTP状态的说明</span></span><br><span class="line">.statusText</span><br><span class="line"><span class="comment"># 表示“请求”/“响应”过程的当前活动阶段</span></span><br><span class="line">.readyState</span><br></pre></td></tr></table></figure><h3 id="发送AJAX请求"><a href="#发送AJAX请求" class="headerlink" title="发送AJAX请求"></a>发送AJAX请求</h3><h4 id="设置请求头部信息"><a href="#设置请求头部信息" class="headerlink" title="设置请求头部信息"></a>设置请求头部信息</h4><p>　　每个HTTP请求和响应都会带有相应的头部信息，包含一些与数据，收发者网络环境与状态等相关信息。XMLHttpRequest对象提供的.setRequestHeader()方法为开发者提供了一个操作这两种头部信息的方法，并允许开发者自定义请求头的头部信息。<br>默认情况下，当发送AJAX请求时，会附带以下头部信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浏览器能够处理的内容类型</span></span><br><span class="line">Accept</span><br><span class="line"><span class="comment"># 浏览器能够显示的字符集</span></span><br><span class="line">Accept-Charset</span><br><span class="line"><span class="comment"># 浏览器能够处理的压缩编码</span></span><br><span class="line">Accept-Encoding</span><br><span class="line"><span class="comment"># 浏览器当前设置的语言</span></span><br><span class="line">Accept-Language</span><br><span class="line"><span class="comment"># 浏览器与服务器之间连接的类型</span></span><br><span class="line">Connection</span><br><span class="line"><span class="comment"># 当前页面设置的任何Cookie</span></span><br><span class="line">Cookie</span><br><span class="line"><span class="comment"># 发出请求的页面所在的域</span></span><br><span class="line">Host</span><br><span class="line"><span class="comment"># 发出请求的页面URI</span></span><br><span class="line">Referer</span><br><span class="line"><span class="comment"># 浏览器的用户代理字符串</span></span><br><span class="line">User-Agent</span><br></pre></td></tr></table></figure></p><p><strong>注意:</strong><br>　　部分浏览器不允许使用<code>.setRequestHeader()</code>方法重写默认请求头信息，因此自定义请求头信息是更加安全的方法：<br><code># 自定义请求头</code><br><code>xhr.setRequestHeader(&quot;myHeader&quot;, &quot;MyValue&quot;)</code></p><h4 id="发送AJAX请求-1"><a href="#发送AJAX请求-1" class="headerlink" title="发送AJAX请求"></a>发送AJAX请求</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送AJAX请求</span></span><br><span class="line"><span class="comment"># 使用get方法发送同步请求(false)</span></span><br><span class="line"><span class="built_in">let</span> xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.php'</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">'myHeader'</span>, <span class="string">'goodHeader'</span>)</span><br><span class="line">xhr.send(null)</span><br><span class="line"></span><br><span class="line"><span class="comment"># POST请求</span></span><br><span class="line"><span class="built_in">let</span> xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'example.php'</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">'myHeader'</span>, <span class="string">'goodHeader'</span>)</span><br><span class="line">shr.send(some_data)</span><br></pre></td></tr></table></figure><h4 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h4><p>同步的GET请求响应：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"example.php"</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">"myHeader"</span>, <span class="string">"goodHeader"</span>)</span><br><span class="line">xhr.send(null)</span><br><span class="line"><span class="comment"># 由于是同步的AJAX请求，因此只有当服务器响应后才会继续执行下面的代码</span></span><br><span class="line"><span class="comment"># 因此xhr.status的值一定不为默认值</span></span><br><span class="line"><span class="keyword">if</span>((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;</span><br><span class="line">  console.log(<span class="string">"xhr.responseText:"</span>, xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  console.log(<span class="string">"Request was unsuccessful:"</span>, xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　上面的代码不难理解，我们通过之前提到的<code>xhr.status</code>属性（如果你忘记了，它存储着响应的HTTP状态）判断请求是否成功，如果成功的话，我们将读取<code>xhr.responseText</code>属性中存储的返回值。但是，当我们的请求为异步时，问题就稍微变得复杂了，由于是异步的请求，在<code>xhr.send(null)</code>语句被执行后，<code>JavaScript</code>引擎会紧接着执行下面的判断语句，而这时由于尚未来得及响应，我们注定会得到一个默认的<code>xhr.status</code>值，因此，我们永远都不可能获取请求的资源了。<br>如何解决这个问题？答案是通过为<code>XMLHTTPRequest</code>实例添加<code>onreadystatechange</code>事件处理程序（当然你也可以直接使用DOM2级规范规定的<code>.addEventListener()</code>方法，但是注意，IE8是不支持该方法的）。<br>　　xhr实例的<code>readystatechange</code>事件会监听<code>xhr.readyState</code>属性的变化，你可以将这个属性想象为一个计数器，随着AJAX流程的推进而不断累加，其可取的值如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　0：未初始化 -- 尚未调用.open()方法</span><br><span class="line">　　1：启动 -- 已经调用.open()方法，但尚未调用.send()方法</span><br><span class="line">　　2：发送 -- 已经调用.send()方法，但尚未接收到响应</span><br><span class="line">　　3：接收 -- 已经接收到部分响应数据</span><br><span class="line">　　4：完成 -- 已经接收到全部响应数据，而且已经可以在客户端使用了</span><br></pre></td></tr></table></figure></p><p>有了这个时间处理程序对AJAX进程做监听，剩下的事就简单多了，一个<code>异步</code>的<code>GET</code>请求代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest()</span><br><span class="line"><span class="comment"># 等价于 xhr.onreadystatechange = function()&#123;&#125;</span></span><br><span class="line"><span class="comment"># 利用onreadystatechange监测状态</span></span><br><span class="line">xhr.onreadystatechange = () =&gt; &#123;</span><br><span class="line">  <span class="comment"># readyState为4表示请求响应完成</span></span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState == 4) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;</span><br><span class="line">      console.log(<span class="string">"xhr.responseText:"</span>, xhr.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      console.log(<span class="string">"Request was unsuccessful:"</span>, xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'example.php'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(null)</span><br></pre></td></tr></table></figure></p><h3 id="其他库框架中的AJAX"><a href="#其他库框架中的AJAX" class="headerlink" title="其他库框架中的AJAX"></a>其他库框架中的AJAX</h3><h4 id="jQuery中的AJAX"><a href="#jQuery中的AJAX" class="headerlink" title="jQuery中的AJAX"></a>jQuery中的AJAX</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    method: <span class="string">'GET'</span>, <span class="comment"># 1.9.0本版前用'type'</span></span><br><span class="line">    url: <span class="string">"/test/"</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">done</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'执行成功'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.fail(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'执行出错'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Vue-js中的AJAX"><a href="#Vue-js中的AJAX" class="headerlink" title="Vue.js中的AJAX"></a>Vue.js中的AJAX</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.get(<span class="string">'/test/'</span>).<span class="keyword">then</span>((response) =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'执行成功'</span>);</span><br><span class="line">&#125;, (response) =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'执行出错'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>转载：<br>　　<a href="https://juejin.im/post/5a20b1f1f265da432529179c" target="_blank" rel="noopener">使用AJAX</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h3 id=&quot;AJAX简介&quot;&gt;&lt;a href=&quot;#AJAX简介&quot; class=&quot;headerlink&quot; title=&quot;AJAX简介&quot;&gt;&lt;/a&gt;AJAX简介&lt;/h3&gt;&lt;p&gt;　　AJAX全称为“Asynchronous Javascript And XML”， 即“异步JavaScript和XML”的意思。通过AJAX我们可以向服务器发送请求，在不阻塞页面的情况下进行数据交互，也可以理解为异步数据传输。在AJAX的帮助下我们的网页只需局部刷新即可更新数据的显示，减少了不必要的数据量，大大提高了用户体验，缩短了用户等待的时间，使得web应用程序更小、更快，更友好。&lt;/p&gt;
    
    </summary>
    
      <category term="AJAX" scheme="http://yoursite.com/categories/AJAX/"/>
    
    
      <category term="AJAX" scheme="http://yoursite.com/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>DOM结构</title>
    <link href="http://yoursite.com/2019/03/30/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/DOM%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/30/前端性能优化/DOM结构/</id>
    <published>2019-03-30T01:12:02.000Z</published>
    <updated>2019-03-30T03:17:41.115Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>DOM是个缩写，全称是<code>Document Object Model</code>。<br>D表示Document，就是DOM将HTML页面解析为一个文档，同时提供了document对象。<br>O表示Object，就是DOM将HTML页面中每一个元素解析为一个对象。<br>M表示Model，就是DOM中表示各个对象之间的关系。<a id="more"></a></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于解析HTML页面文档，方便JavaScript语言通过DOM访问和操作HTML页面中的内容。</p><h4 id="DOM结构"><a href="#DOM结构" class="headerlink" title="DOM结构"></a>DOM结构</h4><h5 id="DOM树结构"><a href="#DOM树结构" class="headerlink" title="DOM树结构"></a>DOM树结构</h5><p>DOM可以访问和更新HTML中的内容、结构和样式，是因为DOM将HTML解析为一个树状结构。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">'en'</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">      &lt;meta charset=<span class="string">'UTF-8'</span>&gt;</span><br><span class="line">      &lt;title&gt;示例页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">       &lt;h2&gt;这是一个示例页面&lt;/h2&gt;</span><br><span class="line">       &lt;p id=<span class="string">"p"</span> title=<span class="string">"this is p."</span>&gt;这是一个段落内容。&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>将上面的 HTML 页面绘制成 DOM 树结构，如下效果:<br><img src="/assets/images/dom2.png" alt="DOM"><br>　　通过上面的 DOM 树结构，我们可以看到，Document 对象是作为 DOM树结构的入口。再根据 DOM 树结构的特点，我们就可以定位到 HTML 页面中任意一个元素、属性或文本内容。</p><p>　　浏览器加载并运行 HTML 页面时，会创建 DOM 树结构这个模型。并且 DOM 树结构模型会被存储在浏览器的内存中。<br><code>当 HTML 页面内容过于庞大和复杂时，生成的 DOM 树结构就越复杂。进而，浏览器加载 HTML 页面的耗时就越长。</code><br><img src="/assets/images/dom.png" alt="DOM"></p><h5 id="DOM树中的节点"><a href="#DOM树中的节点" class="headerlink" title="DOM树中的节点"></a>DOM树中的节点</h5><p>在 DOM 树结构中，主要由以下 4 种节点组成:</p><table><thead><tr><th>节点名称</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>文档节点</td><td>表示整个HTML页面(相当于document对象)</td><td>当需要访问任何标签、属性或文本时，都可以通过文档节点进行导航</td></tr><tr><td>元素节点</td><td>表示HTML页面中的标签(即HTML页面结构)</td><td>访问DOM树时，需要从查找元素节点开始</td></tr><tr><td>属性节点</td><td>表示HTML页面中的开始标签包含的属性</td><td></td></tr><tr><td>文本节点</td><td>表示整个HTML页面中的标签所包含的文本内容</td></tr></tbody></table><p>节点（Node）作为DOM树结构中的连接点，最终构成了完整的DOM树结构<br><img src="/assets/images/dom1.png" alt="DOM"></p><h5 id="节点树结构"><a href="#节点树结构" class="headerlink" title="节点树结构"></a>节点树结构</h5><p>通过节点概念，我们可以将原本的 DOM 树结构改成 DOM 节点树结构进行表示。<br><img src="/assets/images/dom3.jpg" alt="DOM"></p><h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><p>1、获取节点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、标准DOM API</span></span><br><span class="line">document.getElementById</span><br><span class="line">document.getElementsByTagName</span><br><span class="line">document.getElementsByName</span><br><span class="line">document.getElemensByClassName</span><br><span class="line"><span class="comment"># 功能强大，但是也许会有浏览器不兼容的情况存在</span></span><br><span class="line">document.querySelectorAll </span><br><span class="line"></span><br><span class="line">2、 亲属访问</span><br><span class="line"></span><br><span class="line">3、 属性获取</span><br><span class="line">getAttribute</span><br><span class="line">getAttributeNode</span><br></pre></td></tr></table></figure></p><p>2、 创建<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建元素</span></span><br><span class="line">document.createElement </span><br><span class="line"><span class="comment"># 创建文本节点</span></span><br><span class="line">document.createTesxtNode </span><br><span class="line"><span class="comment"># 属性节点</span></span><br><span class="line">document.createAttribute </span><br><span class="line">innerHTML</span><br><span class="line">innerText</span><br><span class="line">node.cloneNode()</span><br></pre></td></tr></table></figure></p><p>3、 加入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 追加到结尾处</span></span><br><span class="line">appendChild </span><br><span class="line">innerHTML</span><br><span class="line"><span class="comment"># 用法：将元素插入到某一个元素的前面 父元素.insertBefore(新元素, 旧元素);</span></span><br><span class="line">insertBefore</span><br></pre></td></tr></table></figure></p><p>4、 其他<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">style 的操作</span><br><span class="line">setAttribute(属性名， 属性值)</span><br></pre></td></tr></table></figure></p><p>5、 删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用法：父元素.removeChild()</span></span><br><span class="line">removeChild </span><br><span class="line">removeAttributeNode</span><br></pre></td></tr></table></figure></p><p>6、 修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.修改节点</span><br><span class="line">删除节点再加入</span><br><span class="line"></span><br><span class="line">2.修改样式</span><br><span class="line">style.xxx = vvv;</span><br><span class="line">setAttribute</span><br><span class="line"></span><br><span class="line">3.修改文本</span><br><span class="line">innerHTML</span><br><span class="line">innerText</span><br><span class="line">节点操作</span><br><span class="line">nodeValue</span><br><span class="line"></span><br><span class="line">4.修改属性</span><br><span class="line">.xxx = vvv</span><br><span class="line">setAttribute</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;DOM是个缩写，全称是&lt;code&gt;Document Object Model&lt;/code&gt;。&lt;br&gt;D表示Document，就是DOM将HTML页面解析为一个文档，同时提供了document对象。&lt;br&gt;O表示Object，就是DOM将HTML页面中每一个元素解析为一个对象。&lt;br&gt;M表示Model，就是DOM中表示各个对象之间的关系。&lt;/p&gt;
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器渲染流程" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
</feed>
