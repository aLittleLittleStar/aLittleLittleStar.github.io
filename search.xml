<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[项目的总结]]></title>
    <url>%2F2019%2F04%2F21%2FProject%2FBackstage%2F</url>
    <content type="text"><![CDATA[项目名： 森尚宅配全屋定制流程控制系统项目地址： https://github.com/aLittleLittleStar/Backstage项目技术：Asp.netMySQL8.0.13JQuery2.2.4BootStarp3.3.7负责功能：前端页面的设计与编写登录交互功能的编写（如何根据不同的用户权限对内容页面的展示进行修改。解决方法使用localStrong把用户类别放到本地前端读取之后进行相对应页面的显示和隐藏），时间组件bootstrap-datetimepicker的使用页面的布局 flex布局iframe 的使用： 点击侧边栏菜单内容页面进行相应的切换项目的难点：登录功能的实现 Travel去哪儿网 项目地址： https://github.com/aLittleLittleStar/Travel项目技术：node10.5.0npm 3.0.0axios 0.18.0better-scroll 6.26.0faskclick 1.0.6stylus 0.54.5vue 2.5.2vue-router 3.0.1vuex 3.0.1ESLint 4.15.0webpack 3.6.0 负责功能：页面的设计，功能分析，编译打包数据的传递共享（vuex）项目的难点：解决一像素边框问题 fastclick使用ajax获取数据 刷新页面是轮播图无法显示第一页解决方法123456789&lt;swiper :options=&quot;swiperOption&quot; v-if=&quot;showSwiper&quot;&gt;&lt;!-- 计算属性：计算list数组长度，刚开始没有加载数据所以数组长度为0，v-if为false页面不显示 --&gt;&lt;script&gt; computed: &#123; showSwiper () &#123; return this.list.length &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>项目总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程风格]]></title>
    <url>%2F2019%2F04%2F17%2FJavaScript%2F%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[块级作用域字符串解构赋值对象数组函数Map函数Class模板ESLint 使用 正则：两种模糊匹配横向模糊匹配横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。{m,n}，表示连续出现最少m次，最多n次。比如/ab{2,5}c/表示匹配这样一个字符串：第一个字符是“a”，接下来是2到5个字符“b”，最后是字符“c”。 纵向模糊匹配纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。 字符串量词分支结构案例分析]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蘑菇街面试准备]]></title>
    <url>%2F2019%2F04%2F15%2FJavaScript%2F%E8%98%91%E8%8F%87%E8%A1%97%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[constlet var 之间的区别4、es6中的const解释解释9.em和rem区别3.js部分，const，let和 var 的区别。4.js部分，数组遍历map和forEach的区别。123能用forEach()做到的，map()同样可以。反过来也是如此。map()会分配内存空间存储新数组并返回，forEach()不会返回数据。forEach()允许callback更改原始数组的元素。map()返回新的数组。 5.css部分，em和rem怎么做自适应。8.函数提升和变量提升优先级123456789函数提升 优于变量解析器在向执行环境中加载数据时会率先读取函数声明，并使其在执行任何代码之前可用(可访问)，即函数声明提升、JavaScript上卷中第40页提到函数声明是优于变量提升的。可见代码console.log(getName)var getName = 1;function getName() &#123; console.log(2)&#125;// 输出为函数getName注意:不要学了一点就忘记别的了啊，如果两个函数名一样，后面的会覆盖前面的(认为是在函数解析的时候覆盖，即提升的时候就覆盖了) JS深拷贝的用处，哪里会用到？ 浅拷贝深拷贝 7、闭包以及带来问题闭包知道吗？它可能出现的问题呢10、css有哪些布局（一开始理解错了说了一大堆，后来面试官带回来了，是关于position、float）11、flex实现水平垂直居中12、align-items:center是不是只针对垂直css布局都用过啥，flex布局，想让我说flex布局的原理的。。。想想还是算了，感觉面试官对原理情有独钟CSS布局技巧跨域的几种方式，有答jsonp，然后又问了 jsonp 的原理是啥？6.跨域问题6.常用的跨域方式。项目有没跨域问题5.作用域链JavaScript深入之作用域链深入理解JavaScript作用域和作用域链1234567作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 第一个问题是讲一下原型链，这个我先推了一下，讲了个小插曲，promise的状态和蘑菇街面试的状态吻合，只有pending、resolved、rejected三种状态，算是个破冰吧，今天看promise想到的。然后继续回答原型链。 2、Promise了解多少1234567891011121314151617181920212223242526272829303132333435363738394041Promise 是异步编程的一种解决方案：从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。promise有三种状态：pending(等待态)，fulfiled(成功态)，rejected(失败态)；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。pending，异步任务正在进行。resolved (也可以叫fulfilled)，异步任务执行成功。rejected，异步任务执行失败。回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象promise可以支持多个并发的请求，获取并发请求中的数据这个promise可以解决异步的问题，本身不能说promise是异步的Promise.resolve(value)类方法，该方法返回一个以 value 值解析后的 Promise 对象1、如果这个值是个 thenable（即带有 then 方法），返回的 Promise 对象会“跟随”这个 thenable 的对象，采用它的最终状态（指 resolved/rejected/pending/settled）2、如果传入的 value 本身就是 Promise 对象， 则该对象作为 Promise.resolve 方法的返回值返回。3、其他情况以该值为成功状态返回一个 Promise 对象。Promise.all的用法：谁跑的慢，以谁为准执行回调。 all接收一个数组参数，里面的值最终都算返回Promise对象 all方法可以说是Promise中很常用的方法了，它的作用就是将一个数组的Promise对象放在其中，当全部resolve的时候就会执行then方法，当有一个reject的时候就会执行catch，并且他们的结果也是按着数组中的顺序来排放的，那么我们来实现一下。Promise.race的用法：谁跑的快，以谁为准执行回调它的作用是将一个Promise数组放入race中，哪个先执行完，race就直接执行完，并从then中取值。Promise.prototype.catch 实例方法，捕获异常，函数形式：fn(err)&#123;&#125;, err 是 catch 注册 之前的回调抛出的异常信息。Promise.prototype.then 实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue)&#123;&#125;，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。Promise.reject类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。Promise的立即执行性Promise 三种状态Promise 状态的不可逆性then方法链式调用async/await promise有了解吗Promise.all promise.race 有了解吗（当时一直听成Promise.out ，我就纳闷了说哪儿来的这个方法。。） 3.React 生命周期，如果要合并 props 和 state 在哪进行4.React 组件想用函数调用的方式使用，怎么设计react如果更新了父组件，子组件没有更新，会都重新渲染吗？react的原理，他的内部是怎么构建DOM的，比如p标签的子元素放在哪个属性里。。。没看过源码着实不知道react相关的redux的原理？7.你印象比较深的项目或者代码我觉得是像 antd 里面的 message 模块，使用 ReactDOM.render挂载组件到指定节点，然后通过更新 props 使用html css js擅长哪部分？我回答擅长js，但他居然没有继续问下去了 3、es5和es6了解多少es5,es6哪个用的多点？3、es5和es6了解多少12345678910111213141516171819202122232425262728293031323334353637383940414243变量声明：let const字符串模板解构赋值 对象对对象 数组对数组扩展运算符箭头函数 不需要 function 关键字来创建函数 省略 return 关键字 继承当前上下文的 this 关键字import导入模块、export导出模块Promise数组常用方法：Array.isArraymapfilterforEacheveryreducespliceindexOfsliceconcatreverse()join()Array.from()Array.of()copyWitchfindfindIndexkeys()values()class 静态、私有、共有生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。可以暂停并重新开始执行的函数generators 可以扮演三种角色 迭代器(数据生产者) 观察者(数据消费者) 协作程序(数据生产者和消费者) es6 Generators详解 2.CSS sprite(雪碧图或者精灵图)CSS Sprite “精灵图”CSS Sprite雪碧图12345678910用CSS的"background-image"，"background-repeat"，"background-position"的组合进行背景定位，background-position可以用数字精确的定位出背景图片的位置。CSS Sprites 的优点：减少图片字节减少网页HTTP请求，提高网页性能减少命名难的问题缺点图片合并的时候要把图片合理的合并成一张图片，防止板块内出现不必要的背景在高分辨率下的自适应如果图片宽度不够，容易造成背景断裂维护的时候比较困难，如果背景图有少许改动，需要改动合并图片。 事件节流？刚看过，没印象了，哭。情景题，往下滚动，加载更多，有什么优化方案，图片懒加载？提示了可以滚轮事件是个比较频繁的操作，但是还是没想出来。防抖 vue和react差别，8、问了vue有没有做过项目，然后就没有了1.vue生命周期，没有问详细的，就是顺着生命周期说了一遍。英文捉急。2.vue源码部分，几个重要的部分，compile，数据劫持，依赖收集，虚拟DOM。问了一个异步加载组件，不用标签引入的方法。让你实现vue你怎么实现……说说vue的双向绑定（顺带把响应式说了）说说Vue的diff过程123456789101112131415161718192021222324252627如果不了解virtual dom，要理解diff的过程是比较困难的。虚拟dom对应的是真实dom， 使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点。我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。diff流程图当数据发生改变时，set方法会让调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点判断两节点是否值得比较，值得比较则执行patchVnode不值得比较则用Vnode替换oldVnode如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法这个函数做了以下事情： 找到对应的真实dom，称为el 判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。 如果oldVnode有子节点而Vnode没有，则删除el的子节点 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要updateChildren先说一下这个函数做了什么 将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来 oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。 v-model，v-bind 和v-click123456789101112131415161718192021222324252627282930313233v-bind 动态地绑定一个或多个特性、或一个组件 prop 到表达式。1:v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，在为了能够动态的给这些属性添加值，可以使用v-bind:你要动态变化的值="表达式"v-model 在表单控件或者组件上创建双向绑定。v-on 指令用于监听DOM事件 形式如：v-on:click 缩写为 @click;[VUE中的v-if与v-show](http://www.cnblogs.com/wmhuang/p/5420344.html)手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译(编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载)v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。 function a(){}，a的proto 指向哪，Function呢？Object呢？js异步都有哪些？答了onclick之类的、setTimeout/setInterval/requestAnimation、Generator、promise、async/await，讲了promise和async/await的优缺点。 1.就我这次面试表现而言，有哪方面需要提升或者欠缺的3.团队技术栈？然后项目……照着你简历上的问，技术选型，遇到的困难，解决思路， 面试中印象最深的问题场面试官自己先介绍了三分钟..然后让我也介绍一下基本情况，项目经历难点之类的。然后开始面试，很少技术问题项目难点，如何解决的有没有想过进入一个团队实习之后会有哪些压力大的事情？有没有了解前端的新技术有没有参加线下前端活动会去看哪些博客或者社区CSS动画和JS动画。后来说问点有难度的问题的吧。直接怼了好多原理。。。卡了好几下webpack的打包目录为啥是这样的，知道原理吗？大概目前只能想到这些了，最后问了面试官几个问题，面试官说有结果，顿了一下，通过或者不通过hr都会通知你的emmm，感觉有点凉，主要是原理着实卡了好几个地方，不过自我感觉面试官人还是很nice的，没有太难为我，看面相是个忠厚老实的小哥哥emmm，求offer啊啊啊啊啊啊啊啊啊啊啊啊7.项目印象深刻的部分和难点。二面我就不写面经了，就是问了些项目上的问题，解决问题的思路，技术栈，基本情况自我介绍项目介绍你说的你的项目里有个首屏加载特别慢的问题对吧？能说说怎么优化的吗？一个骰子，5个面，你怎么实现它（一个面你怎么布局）说说事件循环假如有个项目加载最开始特别快，后面越来越慢你知道是为什么吗？以及如何第一时间定位（内存泄漏）1、自我介绍 + 项目介绍（难点）5、事件委托6、任务队列9、一个场景题（关于使用调试工具的）13、bootstrap中的栅格式一面我上来就说的微信小程序，然后后边面试官几乎都没问别的（倒是考我几个问题啊，js css啥都不问，得嘞，白准备了），然后说到Vue，说了个v-model感觉不是很满意，自己也觉得虽然自己懂原理，但是没讲清楚。。。整个流程10来分钟，估计gg了 重绘&amp;&amp;回流vue differvue 生命周期跨域自我介绍 JavaScript 怎么实现 OOP原型继承与类继承的区别闭包的应用场景关系完整性约束 Cookie &amp; Session 的区别Session 的实现原理HTTP 请求方法中哪些是幂等性的跨域处理方案JSONP 的缺点以及安全隐患为什么要做单元测试黑盒测试与白盒测试的区别怎样实现测试覆盖率Async &amp; Await 的使用 块级元素、行内元素、inline-block 的区别水平居中的方法String、Array 常用的方法输入一个 URL 到呈现页面的过程Vue.js 组件的生命周期Git 怎么合并提交记录Linux 常用的命令HTTP2 新特性 常见的 Web 攻击手段以及防范措施对 Ajax 的理解对闭包的理解对事件机制的理解对 HTTP 的理解GET &amp; POST 的区别HTTP2 和 HTTP1 有什么不同对 JavaScript 各大框架的理解对 jQuery 的理解页面性能优化计算机网络分层输入 www.qq.com 到呈现页面的过程事件机制（W3C 标准）事件代理XSS、CSRF 的防范token 的实现原理熟练使用JS实现Json、XML格式的数据发送与数据解析；3、熟悉各种web标准，了解各主流浏览器特性，使页面兼容主浏览器； 自我介绍事件流koa有学过吗事件循环说一说vue nextTick原理vue react区别web优化移动端的优化有特别了解过吗css flex了解过吗有自己写过webpack插件吗webpack loader 和plugin区别如何前端监控错误，web新技术了解过哪些，最近有去学习哪些东西PWA你能详细说说吗service workerh5 worker非受控组件 与受控组件const let var区别三道题实现promise大数相加纯js写一个动画，5s由快到慢，速度自定义（这里特别感谢以前发过面筋的同学，前两道题因为碰到过，自己下去做了一下 10多分钟给做完了 然后又让我补了一道= =）自我介绍，说一下怎么学习前端的，以及做的项目的亮点web优化缓存（协商，强制说一说）CDNDNS如何查询域名的node中间件原理跨域作用域一个页面白屏，分析原因数据结构链表怎么判断链表有环（当时还问我是不是刷了很多题，我们都笑了笑）cookie了解吗cookie的属性，怎么存储web安全，xss csrfcss响应式布局token生成过程前端新技术PWA讲一讲serviceworkerh5 worker智商题3.45分夹角两个火车相对而行，知道彼此的速度，中间有一个小鸟来回飞 知道小鸟的速度 求相撞的时候的 小鸟飞行的距离10瓶药，每瓶药有10颗药片，每片10克，其中一瓶药里的所有药片是坏的 每片重量为11克，现在给你一个秤，如何一次性称出来 三面自我介绍web优化css动画csrf如何防御如何生成tokenVue的diff能详细说一说吗Vue子组件你的子组件方法是放在哪里的Vue自定义指令微信小程序接触过吗微信小程序原理TCP三次握手第三次失败了 客户端和服务端是如何处理的301，302状态码区别，以及什么时候会返回这些状态。node如何升级到webSoket如何添加header头DNS迭代和递归区别前端怎么设置cookie过期有看过源码吗看过哪些书能来实习的时间智商题一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球 求同时喜欢足球和篮球的算法 最大的回文字符北森一面面试官非常nice，善于引导自我介绍你的项目能说下vue如何收集依赖双向绑定的吗能说下vue如何更新节点的吗node如何打印时间与错误webpack构建流程webpack如何找到依赖关系的webpack如何配置vue和react区别react生命周期函数式组件，如何给状态（hook）原型链，原型知道多少es6了解哪些promise.resolve()http状态码post请求之前先发送Option条件get,post,put,delete区别（冥等）二面面试官是个女架构师，感觉非常好，还因为迟到了几分钟说道歉之类的vue,react，你更倾向于哪一个，为什么es6模块cmd amd 区别跨域深拷贝，浅拷贝post发送Option的条件输入URL到浏览器会发生什么TCP为什么三次握手TCP为什么四次挥手HTTP为什么基于TCP协议vue diff过程vue如果同一个数据，很短的时间内连续更新 会怎么样。算法题[0,0,1,1,1,2,3,4,5]，不借用辅助空间找到不重复项[2，3，4，5] 三面面试官是技术总监，问的问题都是基于场景来说的，面试体验还可以有这样一个数组，你如何扁平化如果用字符串形式会出现什么问题跨域你如何处理的能说说同源策略吗，那如果是直接请求ip会有同源策略吗，如果一个域名对应多个ip的情况呢。你以前做的项目，如果让你去完善你能说一说完善的细节吗，说三点 （我提到模块化，规范化，可扩展性）能具体一点说说吗，说一点就可以你觉得你相比其他实习生的优点和缺点在哪里 前天过了一面。问的有基础的知识和CSS、JS应用的知识，还问了OSI七层网络。其实自我感觉回答的不太好，面试官也说框架知识和项目经验不太足够，没想到过了。了项目难点，然后还考了osi网络层级，怎么用css实现表格奇偶行不同颜色，怎么根据表格行的颜色拿到行数，还问了vue的生命周期钩子函数，vue-cli不过我没答上来]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue双向绑定原理及实现]]></title>
    <url>%2F2019%2F04%2F15%2FVue%2FVue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[双向绑定方法发布者-订阅者模式（backbone.js）脏值检查（angular.js）数据劫持（vue.js）发布者-订阅者模式: 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(&#39;property&#39;, value)脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply()数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 Vue 响应系统，其核心有三点：observe、watcher、dep： observe：遍历 data 中的属性，使用 Object.defineProperty 的 get/set 方法对其进行数据劫持； dep：每个属性拥有自己的消息订阅器 dep，用于存放所有订阅了该属性的观察者对象； watcher：观察者（对象），通过 dep 实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。实现虚拟DOM包含以下三个步骤： 用JS对象模拟DOM树 比较两棵虚拟DOM树的差异, Diff算法 映射成真实DOM Vue 双向数据绑定的原理Object​.define​Property()属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。Object.defineProperty是ES5新增的一个API，其作用是给对象的属性增加更多的控制Object.defineProperty(obj, prop, descriptor)参数 : obj: 需要定义属性的对象（目标对象） prop: 需被定义或修改的属性名（对象上的属性或者方法）对于setter和getter，我的理解是它们是一对勾子（hook）函数，当你对一个对象的某个属性赋值时，则会自动调用相应的setter函数；而当获取属性时，则调用getter函数。这也是实现双向数据绑定的关键。 descriptor: 将被定义或修改的属性描述符。描述: 该方法允许精确添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，能够在属性枚举期间呈现出来（for...in 或 Object.keys 方法）， 这些属性的值可以被改变，也可以被删除。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改的。 整理思路实现mvvm的双向绑定，就必须要实现以下几点：1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图4、mvvm入口函数，整合以上三者observer用来实现对每个vue中的data中定义的属性循环用Object.defineProperty()实现数据劫持，以便利用其中的setter和getter，然后通知订阅者，订阅者会触发它的update方法，对视图进行更新。1234567我们介绍为什么要订阅者，在`vue`中`v-model`，`v-name`，`&#123;&#123;&#125;&#125;`等都可以对数据进行显示，也就是说假如一个属性都通过这三个指令了，那么每当这个属性改变的时候，相应的这个三个指令的html视图也必须改变，于是vue中就是每当有这样的可能用到双向绑定的指令，就在一个Dep中增加一个订阅者，其订阅者只是更新自己的指令对应的数据，也就是`v-model='name'`和`&#123;&#123;name&#125;&#125;`有两个对应的订阅者，各自管理自己的地方。每当属性的set方法触发，就循环更新Dep中的订阅者。 Object.defineProperty缺陷：只能对属性进行数据劫持，对于JS对象劫持需要深度遍历；对于数组不能监听到数据的变化，而是通过一些hack办法来实现，如push、pop、shift、unshift、splice、sort、reverse]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流与防抖]]></title>
    <url>%2F2019%2F04%2F15%2FJavaScript%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;防抖和节流&lt;/title&gt; &lt;style&gt; button &#123; width: 100px; height: 50px; &#125; .log &#123; width: 100%; height: 30px; border: 1px solid #ccc; margin-top: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="debounced"&gt;Debounced&lt;/button&gt; &lt;button id="throttled"&gt;Throttled&lt;/button&gt; &lt;div id="log1" class="log"&gt;&lt;/div&gt; &lt;div id="log2" class="log"&gt;&lt;/div&gt; &lt;script&gt; /* 节流说白了就是每ms执行一次函数， 防抖就是 我最后一次触发后ms后执行一次回调函数 */ /*debounced（防抖动）函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 fn 方法。*/ function debounce(fn, wait, options) &#123; // 等待时间 wait = wait || 0 // 点击次数 let timerId; console.log("timerId:", timerId); // 这个函数的功能是： // return function() &#123; if (timerId) &#123; clearTimeout(timerId); timerId = null; &#125; timerId = setTimeout(function() &#123; fn(); &#125;, wait); console.log("timerId:", timerId); &#125; &#125; // 节流函数，在 wait 秒内最多执行 fn 一次的函数。 function throttle(fn, wait, options) &#123; wait = wait || 0; let timerId; let lastTime = 0; return function() &#123; let currentTime = new Date(); if (currentTime &gt;= lastTime + wait) &#123; fn(); lastTime = currentTime; &#125; else &#123; if (timerId) &#123; clearTimeout(timerId); timerId = null; &#125; timerId = setTimeout(function() &#123; fn(); &#125;, wait); &#125; &#125; &#125; let debouncedBtn = document.getElementById('debounced'); let throttledBtn = document.getElementById('throttled'); let log1 = document.getElementById('log1'); let log2 = document.getElementById('log2'); function handleDebounce() &#123; log1.innerHTML += 'debounced'; console.log("debounced"); &#125; function handleThrottle() &#123; log2.innerHTML += 'throttle'; console.log("throttle"); &#125; debouncedBtn.addEventListener('click', debounce(handleDebounce, 2000)); throttledBtn.addEventListener('click', throttle(handleThrottle, 2000)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2019%2F04%2F11%2FAjax%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[正确面对跨域，别慌前端常见跨域解决方案（全）]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3选择器]]></title>
    <url>%2F2019%2F04%2F11%2FCSS3%2FCSS3%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[转载：CSS &gt; 选择器优先级与效率优化 选择器优先级 important声明 1,0,0,0 ID选择器 0,1,0,0 类选择器 0,0,1,0 伪类选择器 0,0,1,0 属性选择器 0,0,1,0 标签选择器 0,0,0,1 伪元素选择器 0,0,0,1 通配符选择器 0,0,0,0important &gt; 行内样式 选择器效率 读取选择器的原则是从右到左。因此，我们书写的右边的最后一个选择器，被称作关键选择器，对于效率有决定性影响。选择器效率： ID选择器 类选择器 标签选择器 相邻选择器 子选择器 后代选择器 通配符选择器 属性选择器 伪类选择器优先级高的不一定效率高举个例子：#id .class 与 div#id p.class前者效率高于后者，而后者优先级高于前者。我们需要在效率与优先级之间平衡取舍。 优化建议扼要摘其精要总结如下： 避免使用通配符 不使用标签名或类名修饰ID规则：如果规则使用ID选择器作为关键选择器，不要给规则添加标签名。因为ID本身就是唯一的，添加标签名会不必要地降低匹配效率。 不使用标签名修饰类：相较于标签，类更具独特性。 尽量选择最具体的方式：造成低效的最简单粗暴的原因就是在标签上使用太多规则。给元素添加类可以更快细分到类方式，可以减少规则去匹配标签的时间。 关于后代选择器和子选择器：避免使用后代选择器，非要用的话建议用子选择器代替，但子选择器也要慎用，标签规则永远不要包含子选择器。 利用可继承性：没必要在一般内容上声明样式。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组操作]]></title>
    <url>%2F2019%2F04%2F11%2FJavaScript%2F%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[数组的基本操作改变原始数组的操作方法123456789101112131415161718# 向数组末尾添加元素，并返回新的长度push# 删除最后一个并返回删除的元素pop# 向数组开头添加元素，并返回新的长度unshift# 将第一个元素删除并且返回删除元素，空即为undefinedshift# 颠倒数组顺序reverse# 对数组排序sort# 删，增，替换数组元素，返回被删除数组，无删除则不返回splice# 用于从数组的指定位置拷贝元素到数组的另一个指定位置中。copyWithin# 用于将一个固定值替换数组的元素。fill splice() 添加/删除数组元素定义： splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目array.splice(index,howmany,item1,.....,itemX)参数: index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, ..., itemX： 可选。向数组添加的新项目。删除元素123456let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0, 3); // [1,2,3]console.log(a); // [4,5,6,7]// 从数组下标0开始，删除3个元素let item = a.splice(-1, 3); // [7]// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7 删除并添加12345678let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,3,'添加'); // [1,2,3]console.log(a); // ['添加',4,5,6,7]// 从数组下标0开始，删除3个元素，并添加元素'添加'let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-2,3,'添加1','添加2'); // [6,7]console.log(b); // [1,2,3,4,5,'添加1','添加2']// 从数组最后第二个元素开始，删除3个元素，并添加两个元素'添加1'、'添加2' 添加元素123456789let a = [1, 2, 3, 4, 5, 6, 7];// [] 没有删除元素，返回空数组let item = a.splice(0,0,'添加1','添加2'); console.log(a); // ['添加1','添加2',1,2,3,4,5,6,7]let b = [1, 2, 3, 4, 5, 6, 7];// [] 没有删除元素，返回空数组let item = b.splice(-1,0,'添加1','添加2'); // [1,2,3,4,5,6,'添加1','添加2',7] 在最后一个元素的前面添加两个元素console.log(b); 数组如果元素不够，会删除到最后一个元素为止 操作的元素，包括开始的那个元素 可以添加很多个元素 添加是在开始的元素前面添加的 sort()pop()shift()push()unshift()reverse()copyWithin()fill()不改变原始数组的操作方法12345678910111213141516171819202122232425# 连接多个数组，返回新的数组concat# 将数组中所有元素以参数作为分隔符放入一个字符join# 返回选定元素slice# 数组映射为新的数组map(es6)# 数组过滤，返回所有通过方法判断后(判断为true时)生成的新数组filter(es6)# 数组遍历，没有返回值forEach# 对数组中的每一项运行给定函数，如每一项均为true时返回true，否则返回falseevery(es6)# 数组中的的元素运行给定函数，如其中有一项为true时返回true，# 此时剩余的元素不会再执行检测，如果所以都为false则返回falsesome(es6)# 寻找数组中符合测试方法（函数）条件的第一个元素，并且返回该元素find(es6)# 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduce(es6)# 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。indexOf# 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true，否则返回false。includes(es7) slice()join()toLocaleString() 数组转字符串toString() 数组转字符串 不推荐concat()ES6扩展运算符…合并数组indexOf() 查找数组是否存在某个元素，返回下标lastIndexOf() 查找指定元素在数组中的最后一个位置ES7 includes() 查找数组是否包含某个元素 返回布尔遍历方法(12个):关于forEach()你要知道：every 检测数组所有元素是否都符合判断条件some 数组中的是否有满足判断条件的元素filter 过滤原始数组，返回新数组map 对数组中的每个元素进行处理，返回新的数组reduce 为数组提供累加器，合并为一个值reduceRight 从右至左累加ES6 find()&amp; findIndex() 根据条件找到数组成员ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值1[【干货】js 数组详细操作方法及解析合集](https://juejin.im/post/5b0903b26fb9a07a9d70c7e0)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型&&原型链]]></title>
    <url>%2F2019%2F04%2F10%2FJavaScript%2F%E5%8E%9F%E5%9E%8B%26%26%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[概述摘自JavaScript高级程序设计: 继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: 接口继承 和 实现继承 .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 实现继承 主要是依靠原型链来实现的. 在 JavaScript 中，是一种面向对象的程序设计语言，但是 JS 本身是没有 “类” 的概念，JS 是靠原型和原型链实现对象属性的继承。 在理解原型前，需要先知道对象的构造函数是什么，构造函数都有什么特点？ 构造函数123456789101112// 构造函数 Person()function Person(name, gender) &#123; this.name = name; this.gender = gender;&#125;var person = new Person("周杰伦", "男");// 最后创建出来的对象实例 personperson&#123; name: "周杰伦", gender: "男"&#125; 以上代码，普通函数 Person()，加上 new 关键字后，就构造了一个对象 person所以构造函数的定义就是普通函数加上 new 关键字，并总会返回一个对象。 函数对象 同时，JS 中的对象分为一般对象和函数对象。那什么是一般对象，什么又是函数对象呢？ JavaScript 的类型分为基本数据类型和引用数据类型，基本数据类型目前有 6 种（null, undefined, string, number, boolean, Symbol）。 其余的数据类型都统称为 object 数据类型，其中，包括 Array, Date, Function等，所以函数可以称为函数对象。12345let foo = function()&#123;&#125;foo.name = "bar";foo.age = 24;console.log(foo instanceof Function) //trueconsole.log(foo.age) // 24 以上代码就说明了函数其实是一个对象，也可以具有属性。 原型链 JavaScript 中的对象，有一个特殊的 [[prototype]] 属性, 其实就是对于其他对象的引用（委托）。当我们在获取一个对象的属性时，如果这个对象上没有这个属性，那么 JS 会沿着对象的 [[prototype]]链 一层一层地去找，最后如果没找到就返回 undefined;这条一层一层的查找属性的方式，就叫做原型链。123var o1 = &#123; age: 6&#125; 那么，为什么一个对象要引用，或者说要委托另外一个对象来寻找属性呢？ 本文开篇的第一句话，就指出来的，JavaScript 中，和一般的 OOP 语言不同，它没有 ‘类’的概念，也就没有 ‘模板’ 来创建对象，而是通过字面量或者构造函数的方式直接创建对象。那么也就不存在所谓的类的复制继承。 原型 那什么又是原型呢？ 既然我们没有类，就用其他的方式实现类的行为吧，看下面这句话↓↓。 每个函数都有一个原型属性 prototype 对象123456789function Person() &#123;&#125;Person.prototype.name = 'JayChou';// person1 和 person2 都是空对象var person1 = new Person();var person2 = new Person();console.log(person1.name) // JayChouconsole.log(person2.name) // JayChou 通过构造函数创造的对象，对象在寻找 name 属性时，找到了 构造函数的 prototype 对象上。 这个构造函数的 prototype 对象，就是 原型用示意图来表示： 查找对象实例属性时，会沿着原型链向上找，在现代浏览器中，标准让每个对象都有一个 proto 属性，指向原型对象。那么，我们可以知道对象实例和函数原型对象之间的关系。 每个原型对象都有一个 constructor 属性指向关联的构造函数为了验证这一说话，举个例子。12function Person() &#123;&#125;Person === Person.prototype.constructor; // true 那么对象实例是构造函数构造而来，那么对象实例是不是也应该有一个 constructor 呢？1234function Person() &#123;&#125;const person = new Person();person.constructor === Person // true 但事实上，对象实例本身并没有 constructor 属性，对象实例的 constructor 属性来自于引用了原型对象的 constructor 属性person.constructor === Person.prototype.constructor // true 原型链顶层：Object.prototype.proto== null既然 JS 通过原型链查找属性，那么链的顶层是什么呢，答案就是 Object 对象，Object 对象其实也有 __proto__属性，比较特殊的是 Object.prototype.__proto__ 指向 null, 也就是空。Object.prototype.__proto__ === null我们回过头来看函数对象： 所有函数对象的proto都指向Function.prototype，它是一个空函数（Empty function） 123456789101112131415161718192021222324252627282930Number.__proto__ === Function.prototype // trueNumber.constructor == Function //trueBoolean.__proto__ === Function.prototype // trueBoolean.constructor == Function //trueString.__proto__ === Function.prototype // trueString.constructor == Function //true// 所有的构造器都来自于Function.prototype,// 甚至包括根构造器Object及Function自身Object.__proto__ === Function.prototype // trueObject.constructor == Function // true// 所有的构造器都来自于Function.prototype，// 甚至包括根构造器Object及Function自身Function.__proto__ === Function.prototype // trueFunction.constructor == Function //trueArray.__proto__ === Function.prototype // trueArray.constructor == Function //trueRegExp.__proto__ === Function.prototype // trueRegExp.constructor == Function //trueError.__proto__ === Function.prototype // trueError.constructor == Function //trueDate.__proto__ === Function.prototype // trueDate.constructor == Function //true 所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind 以图会友，这就是网上经常看到的 JS 原型和原型链关系图： 对于以上看似很复杂的关系图，只需要理解 5 点： 每个函数都有一个原型属性 prototype 对象 普通对象的构造函数是 Object()，所以 Person.prototype.__proto__ === Object.prototype 函数对象都来自于 Function.prototype 函数对象也是对象，所有 Function.prototype.__proto__ === Object.prototype 记住，所有函数原型的都是 Object() 的实例 Object.prototype.__proto__ 是 null 转载： JavaScript原型与原型链参考： 2019 面试准备 - JS 原型与原型链 JS原型链与继承别再被问倒了 三张图搞懂JavaScript的原型对象与原型链 JavaScript原型及原型链]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue知识点详解]]></title>
    <url>%2F2019%2F04%2F09%2FVue%2FVue%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Vue watch computed nexttick双向绑定 虚拟domVue双向绑定原理/组件通讯Vue 单双向绑定（dep watcher observer）]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宏任务&&微任务]]></title>
    <url>%2F2019%2F04%2F09%2FJavaScript%2F%E5%AE%8F%E4%BB%BB%E5%8A%A1%26%26%E5%BE%AE%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[定义JavaScript 是单线程、异步、非阻塞、解释型脚本语言。 微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。 (macrotask)宏任务 macrotask： 包括整体代码script、setTimeout、setInterval、setImmediate等（可以看到，事件队列中的每一个事件都是一个 macrotask，现在称之为宏任务队列） (microtask)微任务 microtask:原生Promise(有些实现的promise将then方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver 记住就行了。12345678910111213141516171819console.log('script start')setTimeout(function() &#123; console.log('timer over')&#125;, 0)Promise.resolve().then(function() &#123; console.log('promise1')&#125;).then(function() &#123; console.log('promise2')&#125;)console.log('script end')// script start// script end// promise1// promise2// timer over JS引擎线程首先执行主代码块。 每次执行栈执行的代码就是一个宏任务，包括任务队列(宏任务队列)中的，因为执行栈中的宏任务执行完会去取任务队列（宏任务队列）中的任务加入执行栈中，即同样是事件循环的机制。 在执行宏任务时遇到Promise等，会创建微任务（.then()里面的回调），并加入到微任务队列队尾。 microtask必然是在某个宏任务执行的时候创建的，而在下一个宏任务开始之前，浏览器会对页面重新渲染(task &gt;&gt; 渲染 &gt;&gt; 下一个task(从任务队列中取一个))。同时，在上一个宏任务执行完成后，渲染页面之前，会执行当前微任务队列中的所有微任务。 也就是说: 在某一个 macrotask 执行完后，在重新渲染与开始下一个宏任务之前，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。 这样就可以解释 “promise 1” “promise 2” 在 “timer over” 之前打印了。”promise 1” “promise 2” 做为微任务加入到微任务队列中，而 “timer over” 做为宏任务加入到宏任务队列中，它们同时在等待被执行，但是微任务队列中的所有微任务都会在开始下一个宏任务之前都被执行完。 在node环境下，process.nextTick的优先级高于Promise，也就是说：在宏任务结束后会先执行微任务队列中的nextTickQueue，然后才会执行微任务中的Promise。 执行机制： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取） 总结 JavaScript 是单线程语言，决定于它的设计最初是用来处理浏览器网页的交互。浏览器负责解释和执行 JavaScript 的线程只有一个（所有说是单线程），即JS引擎线程，但是浏览器同样提供其他线程，如：事件触发线程、定时器触发线程等。异步一般是指： 网络请求` 计时器` DOM事件监听`事件循环机制： JS引擎线程会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。 JS引擎线程遇到异步函数，会将异步函数交给相应的Webapi，而继续执行后面的任务。 Webapi会在条件满足的时候，将异步对应的回调加入到消息队列中，等待执行。 执行栈为空时，JS引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。 完成后出栈，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。 原文： 总结：JavaScript异步、事件循环与消息队列、微任务与宏任务 JS事件循环机制（event loop）之宏任务/微任务]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2019%2F04%2F08%2FHTTP%2FHTTP%2F</url>
    <content type="text"><![CDATA[转载&amp;&amp;参考: Pandaaa HTTP2和HTTPS来不来了解一下？ 深入理解 HTTP 协议 HTTP协议Header详解 一篇文章带你详解 HTTP 协议（网络协议篇一）天下无难试之HTTP协议面试刁难大全（上）通过HTTP的HEADER完成各种骚操作Http–Header前端缓存最佳实践浏览器缓存机制剖析缓存详解前端也要懂Http缓存机制 HTTPHTTP协议 超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。 HTTP Header前端也要懂Http缓存机制浏览器缓存机制剖析 通用首部指请求报文和响应报文都可以使用的字段 Cache-Control no-cache 指客户端不缓存过期资源 no-store 指不进行缓存 max-age 指缓存资源的缓存时间比指定的值小，那么客户端就接受缓存资源，且缓存服务器不对资源有效性进行再次确认 Connection 指控制不再转发给代理的首部字段（Hop-by-hop），管理持久连接 close 指服务器像明确断开连接 Keep-Alive 指保存持久连接，HTTP/1.1前默认连接是非持久性的，如需要保存持久连接，需要增加此字段 Upgrade可以用来指定一个完全不同的通信协议，对于这个字段，服务器可以返回101状态码 请求首部字段 Accept 指用户代理能够处理的媒体类型及媒体类型的相对优先级 Accept-Encoding 指用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序 Authorization 指用来告知服务器，用户代理的认证信息 Host 当一个 IP 下存在多个域名时，帮助服务器知道要请求的具体主机 User-Agent 会讲创建请求的浏览器和用户代理名称等信息传达给服务器 HTTP 缓存缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。缓存的好处： 缓解服务器压力(不用每次去请求资源)； 提升性能(打开本地资源速度当然比请求回来再打开要快得多)； 减少带宽消耗(我相信你可以理解)； 关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。 浏览器对于请求资源, 拥有一系列成熟的缓存策略. 按照发生的时间顺序分别为存储策略, 过期策略, 协商策略, 其中存储策略在收到响应后应用, 过期策略, 协商策略在发送请求前应用. 流程图如下所示. 1.http header中与缓存有关的key. key 描述 储存策略 过期策略 协商策略 Cache-Control 指定缓存机制,覆盖其它设置 ✔️ ✔️ Pragma http1.0字段,指定缓存机制 ✔️ Expires http1.0字段,指定缓存的过期时间 ✔️ Last-Modified 资源最后一次的修改时间 ✔️ ETag 唯一标识请求资源的字符串 ✔️ 2.缓存协商策略用于重新验证缓存资源是否有效, 有关的key如下. key 描述 If-Modified-Since 缓存校验字段, 值为资源最后一次的修改时间, 即上次收到的Last-Modified值 If-Unmodified-Since 同上, 处理方式与之相反 If-Match 缓存校验字段, 值为唯一标识请求资源的字符串, 即上次收到的ETag值 If-None-Match 同上, 处理方式与之相反 Http缓存可以分为两大类，强制缓存（也称强缓存）和协商缓存。两类缓存规则不同，强制缓存在缓存数据未失效的情况下，不需要再和服务器发生交互；而协商缓存，顾名思义，需要进行比较判断是否可以使用缓存。 两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。 强缓存 强制缓存分为两种情况，Expires 和 Cache-Control。一旦资源命中强缓存, 浏览器便不会向服务器发送请求, 而是直接读取缓存.对于常规请求, 只要存在该资源的缓存, 且Cache-Control:max-age 或者expires没有过期, 那么就能命中强缓存. Cache-Control 针对浏览器和服务器时间不同步，加入了新的缓存方案；这次服务器不是直接告诉浏览器过期时间，而是告诉一个相对时间Cache-Control=10秒，意思是10秒内，直接使用浏览器缓存。 浏览器缓存里, Cache-Control是金字塔顶尖的规则, 它藐视一切其他设置, 只要其他设置与其抵触, 一律覆盖之. 不仅如此, 它还是一个复合规则, 包含多种值, 横跨 存储策略, 过期策略 两种, 同时在请求头和响应头都可设置. Expires Expires的值是服务器告诉浏览器的缓存过期时间（值为GMT时间，即格林尼治时间），即下一次请求时，如果浏览器端的当前时间还没有到达过期时间，则直接使用缓存数据。 协商缓存 强制缓存的弊端很明显，即每次都是根据时间来判断缓存是否过期；但是当到达过期时间后，如果文件没有改动，再次去获取文件就有点浪费服务器的资源了。协商缓存有两组报文结合使用： Last-Modified 和 If-Modified-Since ETag 和 If-None-Match Last-Modified 语法: Last-Modified: 星期,日期 月份 年份 时:分:秒 GMT Last-Modified: Tue, 04 Apr 2017 10:01:15 GMT 用于标记请求资源的最后一次修改时间, 格式为GMT(格林尼治标准时间). 如可用 new Date().toGMTString()获取当前GMT时间. Last-Modified 是 ETag 的fallback机制, 优先级比 ETag 低, 且只能精确到秒, 因此不太适合短时间内频繁改动的资源. 不仅如此, 服务器端的静态资源, 通常需要编译打包, 可能出现资源内容没有改变, 而Last-Modified却改变的情况. If-Modified-SinceIf-Modified-Since: Tue, 04 Apr 2017 10:12:27 GMT 缓存校验字段, 其值为上次响应头的Last-Modified值, 若与请求资源当前的Last-Modified值相同, 那么将返回304状态码的响应, 反之, 将返回200状态码响应. ETagETag:&quot;fcb82312d92970bdf0d18a4eca08ebc7efede4fe&quot; 实体标签, 服务器资源的唯一标识符, 浏览器可以根据ETag值缓存数据, 节省带宽. 如果资源已经改变, etag可以帮助防止同步更新资源的相互覆盖. ETag 优先级比 Last-Modified 高. If-None-Match语法: If-None-Match: ETag_value 或者 If-None-Match: ETag_value, ETag_value, 缓存校验字段, 结合ETag字段, 常用于判断缓存资源是否有效, 优先级比If-Modified-Since高. 对于 GET 或 HEAD 请求, 如果其etags列表均不匹配, 服务器将返回200状态码的响应, 反之, 将返回304(Not Modified)状态码的响应. 无论是200还是304响应, 都至少返回 Cache-Control,Content-Location,Date,ETag,Expires,and Vary中之一的字段. 对于其他更新服务器资源的请求, 如果其etags列表匹配, 服务器将执行更新, 反之, 将返回412(Precondition Failed`)状态码的响应. 不缓存(Pragma) 当该字段值为no-cache的时候，会告诉浏览器不要对该资源缓存，即每次都得向服务器发一次请求才行。1234//禁止缓存res.setHeader('Pragma', 'no-cache')//2分钟res.setHeader('Cache-Control', 'public,max-age=120') 通过Pragma来禁止缓存，通过Cache-Control设置两分钟缓存，但是重新访问我们会发现浏览器会再次发起一次请求，说明了Pragma的优先级高于Cache-Control。 缓存优先级Pragma &gt; Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified HTTP的请求方法 GET: 获取URL指定的资源；POST：传输实体信息PUT：上传文件DELETE：删除文件HEAD：获取报文首部，与GET相比，不返回报文主体部分OPTIONS：询问支持的方法TRACE：追踪请求的路径；CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信。主要使用SSL和TLS将数据加密后通过网络隧道进行传输。 HTTP1.1 新改动持久连接请求管道化增加缓存处理(新的字段如cache-control)增加Host字段、支持断点传输HTTP2.0 新特性 HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点 HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE 新的二进制格式/ 二进制分帧(Binary Format) HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 多路复用(MultiPlexing) 即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。。 header 压缩 如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 服务端推送(server push) 同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0。例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。例如YouTuBe，淘宝网等网站，利用chrome控制台可以查看是否启用H2：chrome=&gt;Network=&gt;Name栏右键=&gt;√Protocol HTTP1.0 和 HTPP1.1 区别HTTP1.0和HTTP1.1最主要的区别就是： HTTP1.1默认是持久化连接！ 在HTTP1.0默认是短连接简单来说就是：每次与服务器交互，都需要新开一个连接！在HTTP1.1中默认就使用持久化连接来解决：建立一次连接，多次请求均由这个连接完成！(如果阻塞了，还是会开新的TCP连接的) HTTP1.0 和 HTTP1.1 比较重要的区别：相对于持久化连接还有另外比较重要的改动： HTTP 1.1增加host字段 HTTP 1.1增加host字段 HTTP 1.1中引入了Chunked transfer-coding，范围请求，实现断点续传(实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输) HTTP 1.1管线化(pipelining)理论，客户端可以同时发出多个HTTP请求，而不用一个个等待响应之后再请求 注意：这个pipelining仅仅是限于理论场景下，大部分桌面浏览器仍然会选择默认关闭HTTP pipelining！ 所以现在使用HTTP1.1协议的应用，都是有可能会开多个TCP连接的！ 管线化(pipelining)和非管线化的区别： 在HTTP1.0中，发送一次请求时，需要等待服务端响应了才可以继续发送请求。 在HTTP1.1中，发送一次请求时，不需要等待服务端响应了就可以发送请求了，但是回送数据给客户端的时候，客户端还是需要按照响应的顺序来一一接收 所以说，无论是HTTP1.0还是HTTP1.1提出了Pipelining理论，还是会出现阻塞的情况。从专业的名词上说这种情况，叫做线头阻塞（Head of line blocking）简称：HOLB HTTP1.1 和 HTTP2 区别 HTTP2与HTTP1.1最重要的区别就是解决了线头阻塞的问题！其中最重要的改动是：多路复用 (Multiplexing) 多路复用意味着线头阻塞将不在是一个问题，允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息，合并多个请求为一个的优化将不再适用。 (我们知道：HTTP1.1中的Pipelining是没有付诸于实际的)，之前为了减少HTTP请求，有很多操作将多个请求合并，比如：Spriting(多个图片合成一个图片)，内联Inlining(将图片的原始数据嵌入在CSS文件里面的URL里)，拼接Concatenation(一个请求就将其下载完多个JS文件)，分片Sharding(将请求分配到各个主机上)……]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件代理(事件委托)]]></title>
    <url>%2F2019%2F04%2F08%2FJavaScript%2F%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[转载： javascript事件代理（事件委托）原理是怎么实现的 概念 那什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象，我仔细揣摩了一下，这个例子还真是恰当，我就不去想别的例子来解释了，借花献佛，我摘过来，大家认真领会一下事件委托到底是一个什么原理： 有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。这里其实还有2层意思的： 第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的； 第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。 优点1、可以大量节省内存的使用，减少注册事件，例如给table中的td事件，就添加到table上2、实现新增子对象时无需再次对其绑定事件。对于动态部分尤为适合 缺点仅是上述1中类似的需求才会使用，使用场景比较少。 原理事件委托的原理： 事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。 实现一般方法的例子：子节点实现相同的功能：123456&lt;ul id="ul1"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt; 实现功能是点击li，弹出123：123456789window.onload = function()&#123; var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); for(var i=0;i&lt;aLi.length;i++)&#123; aLi[i].onclick = function()&#123; alert(123); &#125; &#125;&#125; 事件委托方式：123456window.onload = function()&#123; var oUl = document.getElementById("ul1"); oUl.onclick = function()&#123; alert(123); &#125;&#125; 这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招： Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）： 1234567891011window.onload = function()&#123; var oUl = document.getElementById("ul1"); oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; alert(123); alert(target.innerHTML); &#125; &#125;&#125; 这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！ 上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？123456&lt;div id="box"&gt; &lt;input type="button" id="add" value="添加" /&gt; &lt;input type="button" id="remove" value="删除" /&gt; &lt;input type="button" id="move" value="移动" /&gt; &lt;input type="button" id="select" value="选择" /&gt;&lt;/div&gt; 12345678910111213141516171819window.onload = function()&#123; var Add = document.getElementById("add"); var Remove = document.getElementById("remove"); var Move = document.getElementById("move"); var Select = document.getElementById("select"); Add.onclick = function()&#123; alert('添加'); &#125;; Remove.onclick = function()&#123; alert('删除'); &#125;; Move.onclick = function()&#123; alert('移动'); &#125;; Select.onclick = function()&#123; alert('选择'); &#125;&#125; 上面实现的效果我就不多说了，很简单，4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？1234567891011121314151617181920212223window.onload = function()&#123; var oBox = document.getElementById("box"); oBox.onclick = function (ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLocaleLowerCase() == 'input')&#123; switch(target.id)&#123; case 'add' : alert('添加'); break; case 'remove' : alert('删除'); break; case 'move' : alert('移动'); break; case 'select' : alert('选择'); break; &#125; &#125; &#125;&#125; 现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？1234567&lt;input type="button" name="" id="btn" value="添加" /&gt;&lt;ul id="ul1"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627282930window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; //事件委托，添加的子元素也有事件 oUl.onmouseover = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; target.style.background = "red"; &#125; &#125;; oUl.onmouseout = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; target.style.background = "#fff"; &#125; &#125;; //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); &#125;;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题详解]]></title>
    <url>%2F2019%2F04%2F07%2FJavaScript%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[闭包闭包作用域 this声明提升(变量提升)声明提升盒模型盒模型布局(all) flex 圣杯布局(JS实现左右高度为窗口高度)+ 双飞翼布局布局 get postJS 跨域HTTP状态码HTTP状态码position 垂直居中 定宽 不定宽css布局 浮动HTTP协议absolute &amp;&amp; relative 区别 块级元素&amp;&amp;行内元素代理事件的原理JS promise原理及实现float手撕promise （解决回调地狱回调代码难以维护的问题）js数组类型instanceof浅谈 instanceof 和 typeof 的实现原理settimeout 、 setinterval彻底理解setTimeout()123456789# settimeoutsettimeout(callback, time)# setintervalsetinterval(callback, time)setTimeout含义是定时器，到达一定的时间触发一次，但是setInterval含义是计时器，到达一定时间触发一次，并且会持续触发 伪元素/伪类的区别伪元素/伪类的区别form表单当前页面无刷新提交(target iframe)form表单提交方式表单可实现无刷新页面提交，无需页面跳转，如下，通过一个隐藏的iframe实现，form表单的target设置为iframe的name名称，form提交目标位当前页面iframe则不会刷新页面1234&lt;form action="/url.do" method="post" target="targetIfr"&gt;&lt;input type="text" name="name"/&gt;&lt;/form&gt; &lt;iframe name="targetIfr" style="display:none"&gt;&lt;/iframe&gt; 清除浮动 原理(使用clear:both 会把浮动元素的边界拉下来到标准流，从而把对应标准流的位置撑开)清除浮动deBounce 防抖 实现http &amp;&amp; https ssl 证书验证 加密算法ES6、ES7 新特性JS ES6let const class声明类 promise 模板字符串 对象数组 解构赋值 箭头函数(this指向外层作用域)队列里的优先级问题（微任务(promise)宏任务(xhr请求、settimeout、setInterval)）当前同步操作完成后优先执行微任务队列任务前端性能优化xsshttp 协议 header 缓存：（强缓存、协商缓存）margin 坍塌， 水平方向会不会坍塌 1、当两个对象为上下关系时，而且都具备margin属性时，上面的margin-bottom与下面的margin-top会发生塌陷 当margin-bottom和margin都为正数时，结果为两者之间的最大值 当margin-bottom和margin-top都为负时，结果为两者绝对最较大的那个值。 当margin-bottom和margin-top为一正一负时，结果为两者之和。2、当两个对象为上下包含关系 父元素无填充内容，且没有设置border时，子元素的margin-top不会起作用 父元素设置border属性，子元素的margin-top起作用 父元素有填充内容，子元素的margin-top会起作用，当margin-top小于填充内容时，距离为填充内容的高度 CSS及浏览器的设计者们希望我们在布局时，如果遇到上下两个并排内容块的安排，最好只设置其中每个块上或下margin的一处即可。 但对于父块DIV内含子块DIV的情况，就会按另一条CSS惯例来解释了，那就是：对于有块级子元素的元素计算高度的方式,如果元素没有垂直边框和填充,那其高度就是其子元素顶部和底部边框边缘之间的距离。解决父元素塌陷的方法有，（应该给父类元素添加BFC）1、为父元素添加overflow:hidden;2、为父元素float非none属性，也可为子元素添加float非none属性3、需要给父div设置：边框，当然可以设置边框为透明;4、为父DIV添加padding，或者至少添加padding-top;5，如果遇到上下两个并排内容块的安排，最好只设置其中每个块上或下margin的一处即可。 如何判断一个数组/datainstanceof、typeof、 constructor、 Object.prototype.toSting.call() 三栏布局 float position flexfloat 布局对后续元素的影响 数组去重123456双重循环去重indexOf排序后去重(存疑)利用对象属性Set去重(return [...new Set(arr)])Set和from(Array.from(new Set(arr))) 链接123 原型链1[](https://juejin.im/post/5835853f570c35005e413b19#heading-0) 面向对象哪些数组方法不能改变数组本身(concat、slice)12改变原始数组的操作方法：不会改变原始数组的操作方法： 选择器标签 判断一个变量是整数数组去重 set for循环实现数组reduce字符串数组操作方法1[javascript 下常用的字符串操作](http://f10.moe/2014/10/15/javascript-%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/) 123456789101112# 字符串charAt()charCodeAt()fromCharCode()concat()indexOf()lastIndexOf()match()replace()search()slice()split() 设计模式MVC mvvm简书掘金 原生js 封装 ajax 方法 get 、 post Vue watch computed nexttick双向绑定 虚拟domVue双向绑定原理/组件通讯Vue 单双向绑定（dep watcher observer） 数组和链表的数据结构的区别underscore once 实现方法框架选择如何避免多重回调 promise，如何在外部进行resolve()express 中间件数据结构算法栈模拟队列二分插入进数组选择框实现原理异步执行的原理IE兼容继承方法原生 js实现jsonp跨域、深度克隆、模板引擎、正则表达式]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容性]]></title>
    <url>%2F2019%2F04%2F05%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[转载： 如何机智地回答浏览器兼容性问题 浏览器兼容性 浏览器的兼容性无非还是样式兼容性（css），交互兼容性（javascript），浏览器 hack三个方面。 样式兼容(CSS)方面 1、因为历史原因，不同的浏览器样式存在差异，可以通过 Normalize.css 抹平差异，也可以定制自己的 reset.css，例如通过通配符选择器，全局重置样式:* { margin: 0; padding: 0; } 2、在CSS3还没有成为真正的标准时，浏览器厂商就开始支持这些属性的使用了。CSS3样式语法还存在波动时，浏览器厂商提供了针对浏览器的前缀，直到现在还是有部分的属性需要加上浏览器前缀。在开发过程中我们一般通过IDE开发插件、css 预处理器以及前端自动化构建工程帮我们处理。浏览器内核与前缀的对应关系如下: 内核 主要代表的浏览器 前缀 Trident IE浏览器 -ms Gecko Firefox -moz Presto Opera -o Webkit Chrome(blink)、Safari -webkit 3、在还原设计稿的时候我们常常会需要用到透明属性，所以解决 IE9 以下浏览器不能使用 opacity。12345opacity: 0.5;//IE6-IE8我们习惯使用filter滤镜属性来进行实现filter: alpha(opacity = 50); //IE4-IE9都支持滤镜写法progid:DXImageTransform.Microsoft.Alpha(Opacity=xx)filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50); 交互兼容(javascript) 1、事件兼容的问题，我们通常需要会封装一个适配器的方法，过滤事件句柄绑定、移除、冒泡阻止以及默认事件行为处理1234567891011121314151617181920212223var helper = &#123;&#125;//绑定事件helper.on = function(target, type, handler) &#123; if(target.addEventListener) &#123; target.addEventListener(type, handler, false); &#125; else &#123; target.attachEvent("on" + type, function(event) &#123; return handler.call(target, event); &#125;, false); &#125;&#125;;//取消事件监听helper.remove = function(target, type, handler) &#123; if(target.removeEventListener) &#123; target.removeEventListener(type, handler); &#125; else &#123; target.detachEvent("on" + type, function(event) &#123; return handler.call(target, event); &#125;, true); &#125;&#125;; 2、new Date()构造函数使用，’2018-07-05’是无法被各个浏览器中，使用new Date(str)来正确生成日期对象的。 正确的用法是’2018/07/05’. 3、获取 scrollTop 通过 document.documentElement.scrollTop 兼容非chrome浏览器var scrollTop = document.documentElement.scrollTop||document.body.scrollTop; 浏览器 hack(CSS hack) 由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack! 1、快速判断 IE 浏览器版本12&lt;!--[if IE 8]&gt; ie8 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt; 骚气的 ie9 浏览器 &lt;![endif]--&gt; 2、判断是否是 Safari 浏览器12/* Safari */var isSafari = /a/.__proto__=='//'; 3、判断是否是 Chrome 浏览器12/* Chrome */var isChrome = Boolean(window.chrome); 关于 浏览器hack: 英文：BROWSERHACKS 中文：主流浏览器的Hack写法 史上最全的CSS hack方式一览]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6新特性]]></title>
    <url>%2F2019%2F04%2F05%2FJavaScript%2FES6%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[转载： 带你一起敲敲ES6的新特性 变量声明1、常量(const， 不会变量提升，块级作用域，作用域内值不能改，const 对象仍然可以被改变的)1234const aa = &#123;a: '12'&#125;;aa.a // 12aa.a = "123456";console.log(aa); // a: '123456' 2、块级作用域(let，不会变量提升)12345678910for (let i = 0; i&lt;5; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) //0 1 2 3 4 &#125;,30)&#125;for (var i = 0; i&lt;5; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) //5 5 5 5 5 &#125;,30)&#125; 注意：12345678let 关键词声明的变量不具备变量提升（hoisting）特性let 和 const 声明只在最靠近的一个块中（花括号内）有效当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASINGconst 在声明时必须被赋值let const：块级作用域不可重复声明不存在变量提升 特别要说明一点的是对于const和let都有暂存死区，所谓暂存死区就是:如果作用域内有这样一个变量那么这个作用域内就会绑定这个变量,不会继续向上查找了,以下代码运行会报错。 123456const a = 1;&#123; console.log(a); const a = 2;&#125;console.log(a) 结构赋值 所谓解构赋值就是 声明和赋值都放到了一起一般都是数组 对 数组, 对象 对 对象, 数组能够设置默认值，对象也能够设置默认值，默认值必须采用等号的方式。12345let [zhan, si, xl = 5] = [3, 4];console.log(zhan, si, xl) //3, 4, 5let &#123;name, age = 23&#125; = &#123;name: 'xl', bigAge: 24&#125;console.log(name, age) //xl, 23 特别的，可能有时会有关键字的情况可以通过:的形式来更改名字，看下面代码12let &#123; name, age: xl, default: d &#125; = &#123; name: 'xlei', age: 9, default: 'xxx' &#125;;console.log(name, xl, d); 来一个默认值的具体应用吧：1234567891011function ajax(&#123; url = new Error('url without'), type = 'get', data = xxx&#125;)&#123; console.log(data, type) //&#123;a: 5&#125;, get&#125;ajax(&#123; url: '/test', data: &#123;a:5&#125;&#125;) 字符串1、模板字符串（拼接方便，可以换行）12基本的字符串格式化。将表达式嵌入字符串中进行拼接。用$&#123;&#125;来界定；ES6反引号(``)直接搞定； 12let exe1 = '张三'let exe2 = `我的名字是：$&#123;exe1&#125;` 2、startWith, endWith 返回一个布尔值12345let str1 = 'www.bsym.online'let str2 = 'http://www.bsym.online'console.log(str1.startsWith('http://')) //falseconsole.log(str2.startsWith('http://')) //trueconsole.log(str2.endsWith('online')) //true 3、padStart, padEnd补全 – 不会删除原有内容12345// padStart padEnd 补全(记住只能增加，不能减少)let str1 = 'nihao'let newStr = str1.padStart(8,'xl')let newStr2 = str1.padEnd(8,'xl')console.log(newStr, newStr2) //xlxnihao, nihaoxlx 箭头函数(解决this问题，书写起来更简单) 传统函数内的this是定义时所在的环境，而箭头函数内的this是使用时上下文的环境。 ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =&gt;，紧接着是函数体；123不需要 function 关键字来创建函数省略 return 关键字继承当前上下文的 this 关键字 12345678910var add = (a, b) =&gt; a + b;[1,2,3].map(x =&gt; x + 1);let aa = (arg1, arg2) =&gt; &#123; console.log(arg1, arg2)&#125;aa(1, 2) //1, 2;((arg1, arg2) =&gt; &#123; console.log(arg1, arg2)&#125;)(3, 4); 注意： 这里顺带提一下，像上面的自执行匿名函数前后都要加分号，这样既不会被坑，也不会坑别人。另外不要使用箭头函数的argeuments细节： 当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{} 和 return Spread / Rest 操作符Spread / Rest 操作符指的是 ...，具体是 Spread 还是 Rest 需要看上下文语境。 当被用于迭代器中时，它是一个 Spread 操作符：12345function foo(x,y,z) &#123; console.log(x,y,z);&#125;let arr = [1,2,3];foo(...arr); // 1 2 3 当被用于函数传参时，是一个 Rest 操作符：当被用于函数传参时，是一个 Rest 操作符：1234function foo(...args) &#123; console.log(args);&#125;foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5] 要点1、数组的扩展运算符：将一个数组转为用逗号分隔的参数序列123let arr = [...[1, 2, 3], ...[4, 5, 6]]console.log(arr) // 1, 2, 3, 4, 5, 6console.log(Math.min(...arr)) // 1 2、对象的解构赋值 对象的 Rest 解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面,注意Rest 解构赋值必须是最后一个参数，否则会报错。Rest解构赋值所在的对象，拷贝了对象obj的属性，Rest解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么Rest解构赋值拷贝的是这个值的引用，而不是这个值的副本，解构赋值不会拷贝继承自原型对象的属性1234567let obj = &#123;name: 'xl', age: 23, say:'ok', eat: &#123;xl: 'okok'&#125;&#125;//尚未被读取的属性，分配到指定的对象上面,浅拷贝了对象obj的属性let &#123;name, age, ...z&#125; = objobj.say = 'oo'obj.eat.xl = 'o?o?'console.log(name, age, z) //xl 23 &#123; say: 'ok', eat: &#123; xl: 'o?o?' &#125; &#125; 123456789let z = &#123;a: 3, b: 4, c:&#123; eat:'ok'&#125;&#125;// 注意这个地方和直接赋值的区别 let n = z; // 一个是浅拷贝对象属性，一个是浅拷贝对象let n = &#123;...z&#125;z.a = 5z.c.eat = 'ok?'console.log(n) //&#123; a: 3, b: 4, c: &#123; eat: 'ok?' &#125; &#125; 那么要是想实现一个深拷贝，怎么实现呢？其实就是遍历属性如果属性是一个普通值就赋值，不是普通值就递归知道是普通值为止，然后赋值，代码如下：123456789101112131415161718192021222324// 实现深拷贝 保留继承关系 可以实现各种类型的拷贝 实现递归拷贝 function deepClone(obj) &#123; if (typeof obj !== 'object') return obj; if (obj == null) return null; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); let o = new obj.constructor(); // 保留类的继承关系 Object.keys(obj).forEach((key, index) =&gt; &#123; if(typeof (obj[key]) == 'object')&#123; o[key] = deepClone(obj[key]) &#125;else&#123; // console.log(obj[key]) o[key] = obj[key] &#125; &#125;) return o; &#125; let o = &#123; a: &#123; a: 1 &#125;, b: function()&#123; console.log(this.a) &#125; &#125; let newObj = deepClone(o); o.a.a = 2; console.log( newObj.b()); 数组常用方式1234567891011121314151617181920212223242526272829303132// (1)map返回值 返回值是一个新数组 Array.prototype.map = function (fn) &#123; let arr = []; for (let i = 0; i &lt; this.length; i++) &#123; arr.push(fn(this[i], i)); &#125; return arr; &#125;; let arr = [1, 2, 3].map(item =&gt; &#123; return item * 2; &#125;); console.log(arr); // (2)filter 过滤 如果返回true表示留下 返回false表示删除 let arr = [1, 2, 3]; let filterArr = arr.filter(item =&gt; &#123; return item &gt; 2; &#125;); console.log(filterArr); // (3)some找到后返回true,找false可以用every let r = [2, 1, 3].some(item =&gt; &#123; return item &gt; 2; &#125;); console.log(r); //true // (4)every 检测数组 ages 的所有元素是否都符合条件 : var ages = [2, 1, 3]; let r = ages.every((item) =&gt; &#123; return item &gt; 2 &#125;) console.log(r) //false // (5)Array.from(); 将类数组转为数组 ES6的Class先复习一下es5中的几个名词：1234成员属性（方法）| 实例属性（方法） ：在构造函数中通过this.属性声明的静态属性（方法）：通过类来声明的 类.xxx私有属性（方法）：只有在类的内部可以使用，其他任何地方都不可以使用的公有属性（方法）|原型属性（方法）：在原型上声明的属性或者方法 xx.prototype.xxx 123456789101112function Parent(name) &#123; this.name = name; //成员属性|实例属性 this.say = function() &#123; //成员方法 console.log(this.name) &#125;&#125;//静态属性Parent.smoking = 'no'//公有方法|原型方法Parent.prototype.up = function() &#123; console.log('ok')&#125; 再来说说es6中的class(es6中不考虑私有属性和方法):ES6 中支持 class 语法，不过，ES6的class不是新的对象继承模型，它只是原型链的语法糖表现形式。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Parent&#123; constructor(x, y)&#123; this.x = x; //成员属性|实例属性 可遍历 打印实例可直接打印出来, // 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上）， // 否则都是定义在原型上（即定义在class上）。 this.y = y; //如果不返回 默认返回实例对象 this return this.x &#125; static b()&#123; // 属于类上的方法 也称静态方法 return 2; &#125; eat()&#123; //原型上的方法 | 公有方法 并且都是不可枚举的 // 打印实例不能显示的打印出来 console.log(this.x); return this.x &#125;&#125;class Child extends Parent&#123; // constructor(x, y, z)&#123; // Parent.call(this);返回的是子类的实例， super(x, y); this.age = z; // 成员属性|实例属性 &#125; static a()&#123; // 属于类上的方法 return 1; &#125; smoking()&#123; // 原型上的方法 return super.eat() + this.age //需要说明的是 super不仅可以调用父类的原型方法 // 还可以调用父类的静态方法，方法内部的this指向当前的子类， // 而不是子类的实例 // console.log(this.age) &#125;&#125;let child = new Child(2, 3, 4);// console.log(child);console.log(child.smoking())class Foo &#123; constructor() &#123; //constructor函数默认返回this, //这里返回一个全新的对象，结果导致实例对象不是Foo类的实例 return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);console.log(point)point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // trueclass A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 迭代器(Iterators)生成器(Generators)对象和数组解构123456789101112131415161718// 对象const student = &#123; name: 'Sam', age: 22, sex: '男'&#125;// 数组// const student = ['Sam', 22, '男'];// ES5；const name = student.name;const age = student.age;const sex = student.sex;console.log(name + ' --- ' + age + ' --- ' + sex);// ES6const &#123; name, age, sex &#125; = student;console.log(name + ' --- ' + age + ' --- ' + sex);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的设计模式]]></title>
    <url>%2F2019%2F04%2F05%2FJavaScript%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[转载： 前端常用的设计模式 常用的 JavaScript 设计模式 设计模式 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 工程模式 定义： 将其成员对象的实例化推迟到子类来实现的类 需求： 创建对象的流程赋值的时候，比如依赖很多设置文件等；处理大量具有相同属性的小对象，注：不能滥用 优点： 不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中 缺点： 当工厂增加到一定程度的时候，提升了代码的复杂度，可读性下降。而且没有解决对象的识别问题，即怎么知道一个对象的类型。 简单工厂模式(创建单一对象，需要的类比较少) 使用一个类，通常为单体，来生成实例。12345678910111213141516171819202122232425262728let UserFactory = function (role) &#123; function SuperAdmin() &#123; this.name = "超级管理员", this.viewPage = ['首页', '通讯录', '发现页', '应用数据', '权限管理'] &#125; function Admin() &#123; this.name = "管理员", this.viewPage = ['首页', '通讯录', '发现页', '应用数据'] &#125; function NormalUser() &#123; this.name = '普通用户', this.viewPage = ['首页', '通讯录', '发现页'] &#125; switch (role) &#123; case 'superAdmin': return new SuperAdmin(); break; case 'admin': return new Admin(); break; case 'user': return new NormalUser(); break; default: throw new Error('参数错误, 可选参数:superAdmin、admin、user'); &#125;&#125; 工厂方法模式(创建多类对象，需要的类比较多) 为方便后续新增类方便，只需改一处代码，封装了工厂方法而已。并且把类都放在工厂类原型中实现。 将其成员对象的实列化推到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型。 父类只对创建过程中的一般性问题进行处理，这些处理会被子类继承，子类之间是相互独立的，具体的业务逻辑会放在子类中进行编写。123456789101112131415161718192021222324252627282930//安全模式创建的工厂方法函数let UserFactory = function(role) &#123; if(this instanceof UserFactory) &#123; var s = new this[role](); return s; &#125; else &#123; return new UserFactory(role); &#125;&#125;//工厂方法函数的原型中设置所有对象的构造函数UserFactory.prototype = &#123; SuperAdmin: function() &#123; this.name = "超级管理员", this.viewPage = ['首页', '通讯录', '发现页', '应用数据', '权限管理'] &#125;, Admin: function() &#123; this.name = "管理员", this.viewPage = ['首页', '通讯录', '发现页', '应用数据'] &#125;, NormalUser: function() &#123; this.name = '普通用户', this.viewPage = ['首页', '通讯录', '发现页'] &#125;&#125;//调用let superAdmin = UserFactory('SuperAdmin');let admin = UserFactory('Admin') let normalUser = UserFactory('NormalUser') 抽象工厂模式(创建父类，子类继承父类，具体实现在子类) 抽象工厂其实是实现子类继承父类的方法，只是一个方法。 抽象工厂模式一般用在多人协作的超大型项目中，并且严格的要求项目以面向对象的思想进行完成。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 抽象工厂方法var VehicleFatory = function(subType, superType) &#123; // 判断抽象工厂中是否有该抽象类 if(typeof VehicleFactory[superType] === 'function') &#123; // 缓存类 function F() &#123;&#125;; // 继承父类属性和方法 F.prototype = new VehicleFactory[superType] (); // 将子类constructor 指向子类 subType.constructor = subType; // 子类原型继承'父类' subType.prototype = new F(); &#125; else &#123; // 不存在该抽象类抛出错误 throw new Error('未创建该抽象类'); &#125;&#125;;// 小汽车抽象类VehicleFactory.Car = function() &#123; this.type = 'car';&#125;;VehicleFactory.Car.prototype = &#123; getPrice: function() &#123; return new Error('抽象方法不能调用'); &#125;, getSpeed: function() &#123; return new Error('抽象方法不能调用'); &#125;&#125;;// 公交车抽象类VehicleFactory.Bus = function() &#123; this.type = 'bus';&#125;;VehicleFactory.Bus.prototype = &#123; getPrice: function() &#123; return new Error('抽象方法不能调用'); &#125;, getSpeed: function() &#123; return new Error('抽象方法不能调用'); &#125;&#125;;// 货车抽象类VehicleFactory.Truck = function() &#123; this.type = 'truck';&#125;;VehicleFactory.Truck.prototype = &#123; getPrice: function() &#123; return new Error('抽象方法不能调用'); &#125;, getSpeed: function() &#123; return new Error('抽象方法不能调用'); &#125;&#125;;// 创建产品子类继承相应的产品簇抽象类// 宝马汽车子类var BMW = function(price, speed) &#123; this.price = price; this.speed = speed;&#125;//抽象工厂实现对Car抽象类的继承VehicleFactory(BMW, 'Car');BMW.prototype.getPrice = function() &#123; return this.price &#125;;BMW.prototype.getSpeed = function() &#123; return this.speed &#125;;// 公交车...// 货车... 单例模式 定义：是保证一个类只有一个实例，并且提供一个访问它的全局访问点。 需求：一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象、登录浮窗等。 实现：用一个变量标识当前是否已经为某个类创建过对象，如果是，则在下一次获取这个类的实例时，直接返回之前创建的对象。 优点： 可以用来划分命名空间，减少全局变量的数量 可以被实例化，且实例化一次，再次实例化生成的也是第一个实例 基础例子1234567891011121314151617181920// 单例模式var Singleton = function(name)&#123; this.name = name; this.instance = null;&#125;;Singleton.prototype.getName = function()&#123; return this.name;&#125;;// 获取实例对象Singleton.getInstance = function(name) &#123; if(!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;;// 测试单例模式的实例var a = Singleton.getInstance("aa");var b = Singleton.getInstance("bb");console.log(a===b) // true 实践例子12345678910111213141516171819202122232425(function () &#123; //管理单例的逻辑代码，如果没有数据则创建，有数据则返回 var getSingle = function(fn)&#123; //参数为创建对象的方法 var result; return function()&#123; //判断是Null或赋值 return result || (result = fn.apply(this,arguments)); &#125;; &#125;; //创建登录窗口方法 var createLoginLayer = function()&#123; var div = document.createElement('div'); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild(div); return div; &#125;; //单例方法 var createSingleLoginLayer = getSingle(createLoginLayer); //使用惰性单例，进行创建 document.getElementById('loginBtn').onclick = function()&#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block'; &#125;;&#125;)() 观察者模式(发布-订阅模式) 定义：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。 需求：当一个对象的状态发生变化时，所有依赖于他的对象都将得到通知。 优点：时间上的解耦，对象之间的解耦。当我们需要维护相关对象的一致性的时候，使用观察者模式，，就可以避免对象之间的紧密耦合。例如，一个对象可以通知另外一个对象，而不需要知道这个对象的信息。 缺点：在发布/订阅模式中，如果我们需要将发布者同订阅者上解耦，将会在一些情况下，导致很难确保我们应用中的特定部分按照我们预期的那样正常工作。也就是说它的优点也可能是它的缺点 实现： 首先，指定好谁充当发布者； 然后，给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者； 最后，发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数。 退订（比如不想再接收到这些订阅的信息了，就可以取消掉） 基础例子12345678910111213141516var salesOffices = &#123;&#125;; // 定义售楼处salesOffices.clientList = []; // 缓存列表，存放订阅者的回调函数salesOffices.listen = function( fn )&#123; // 增加订阅者 this.clientList.push( fn ); // 订阅的消息添加进缓存列表&#125;;salesOffices.trigger = function()&#123; // 发布消息 for( var i = 0, fn; fn = this.clientList[ i++ ]; )&#123; fn.apply( this, arguments ); // arguments 是发布消息时带上的参数 &#125;&#125;;//调用salesOffices.listen( function( price, squareMeter )&#123;//订阅消息 console.log( '价格= ' + price ); console.log( 'squareMeter= ' + squareMeter );&#125;);salesOffices.trigger( 2000000, 88 ); // 输出：200 万，88 平方米 实践例子 登录页面登录后，会需要刷新各个模块的信息（头像、nav）这类。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var ObserverEvent = (function () &#123; var clientList = [], listen, trigger, remove; listen = function (key, fn) &#123; if (!clientList[key]) &#123; clientList[key] = []; &#125; clientList[key].push(fn); &#125;; trigger = function () &#123; var key = Array.prototype.shift.call(arguments), fns = clientList[key]; if (!fns || fns.length === 0) &#123; return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125;; remove = function (key, fn) &#123; var fns = clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125; else &#123; for (var l = fns.length - 1; l &gt;= 0; l--) &#123; var _fn = fns[l]; if (_fn === fn) &#123; fns.splice(l, 1); &#125; &#125; &#125; &#125;; return &#123; listen:listen, trigger:trigger, remove:remove &#125; &#125;)(); ObserverEvent.listen('squareMeter88', fn1 = function (price) &#123; console.log('价格=' + price); &#125;); ObserverEvent.listen('squareMeter100', function (price) &#123; console.log('价格=' + price); &#125;); ObserverEvent.trigger('squareMeter88', 200000);//刷新模块信息var header = (function () &#123; ObserverEvent.listen('loginSucc', function (data) &#123; header.setAvatar(data.avatar); &#125;); return &#123; setAvatar: function (data) &#123; console.log(data + "设置header成功"); &#125; &#125; &#125;)(); var nav = (function () &#123; ObserverEvent.listen('loginSucc', function (data) &#123; nav.setAvatar(data.avatar) &#125;); return &#123; setAvatar: function (data) &#123; console.log(data + '设置nav成功'); &#125; &#125; &#125;)(); var data = &#123;&#125;; data.avatar = "参数"; ObserverEvent.trigger('loginSucc', data); 策略模式 策略模式指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。 代码实现 代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额。 没有使用策略模式的情况：1234567891011function Price(personType, price) &#123; //vip 5 折 if (personType == 'vip') &#123; return price * 0.5; &#125; else if (personType == 'old')&#123; //老客户 3 折 return price * 0.3; &#125; else &#123; return price; //其他都全价 &#125;&#125; 不足之处：不好的地方，当我有其他方面的折扣时，又或者我活动的折扣时经常变化的，这样就要不断的修改if..else里面的条件了。而且也违背了设计模式的一个原则：对修改关闭，对扩展开放的原则； 使用策略模式之后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 对于vip客户function vipPrice() &#123; this.discount = 0.5;&#125;vipPrice.prototype.getPrice = function(price) &#123; return price * this.discount;&#125;// 对于老客户function oldPrice() &#123; this.discount = 0.3;&#125;oldPrice.prototype.getPrice = function(price) &#123; return price * this.discount;&#125;// 对于普通客户function Price() &#123; this.discount = 1;&#125;Price.prototype.getPrice = function(price) &#123; return price ;&#125;// 上下文，对于客户端的使用function Context() &#123; this.name = ''; this.strategy = null; this.price = 0;&#125;Context.prototype.set = function(name, strategy, price) &#123; this.name = name; this.strategy = strategy; this.price = price;&#125;Context.prototype.getResult = function() &#123; console.log(this.name + ' 的结账价为: ' + this.strategy.getPrice(this.price));&#125;var context = new Context();var vip = new vipPrice();context.set ('vip客户', vip, 200);context.getResult(); // vip客户 的结账价为: 100var old = new oldPrice();context.set ('老客户', old, 200);context.getResult(); // 老客户 的结账价为: 60var Price = new Price();context.set ('普通客户', Price, 200);context.getResult(); // 普通客户 的结账价为: 200 通过策略模式，使得客户的折扣与算法解藕，又使得修改跟扩展能独立的进行，不影到客户端或其他算法的使用； 模板模式 定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 通俗的讲，就是将一些公共方法封装到父类，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。 代码实现 比如前端面试，基本包括笔试，技术面试，领导面试，HR面试等，但是每个公司的笔试题，技术面可能不一样，也可能一样，一样的就继承父类的方法，不一样的就重写父类的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var Interview = function()&#123;&#125;;// 笔试Interview.prototype.writtenTest = function()&#123; console.log("这里是前端笔试题");&#125;;// 技术面试Interview.prototype.technicalInterview = function()&#123; console.log("这里是技术面试");&#125;; // 领导面试Interview.prototype.leader = function()&#123; console.log("领导面试");&#125;;// 领导面试Interview.prototype.HR = function()&#123; console.log("HR面试");&#125;;// 等通知Interview.prototype.waitNotice = function()&#123; console.log("等通知啊，不知道过了没有哦");&#125;;// 代码初始化Interview.prototype.init = function()&#123; this.writtenTest(); this.technicalInterview(); this.leader(); this.HR(); this.waitNotice();&#125;;// 阿里巴巴的笔试和技术面不同，重写父类方法，其他继承父类方法。var AliInterview = function()&#123;&#125;;AliInterview.prototype = new Interview();// 子类重写方法 实现自己的业务逻辑AliInterview.prototype.writtenTest = function()&#123; console.log("阿里的技术题就是难啊");&#125;AliInterview.prototype.technicalInterview = function()&#123; console.log("阿里的技术面就是叼啊");&#125;var AliInterview = new AliInterview();AliInterview.init();// 阿里的技术题就是难啊// 阿里的技术面就是叼啊// 领导面试// HR面试// 等通知啊，不知道过了没有哦 应用场景： 模板模式主要应用在一些代码刚开要一次性实现不变的部分。但是将来页面有修改，需要更改业务逻辑的部分或者重新添加新业务的情况。主要是通过子类来改写父类的情况，其他不需要改变的部分继承父类。 代理模式概念： 代理模式的中文含义就是帮别人做事，javascript的解释为：把对一个对象的访问, 交给另一个代理对象来操作.代码实现： 比如我们公司的补打卡是最后是要交给大boss来审批的，但是公司那么多人，每天都那么多补打卡，那大boss岂不是被这些琐事累死。所以大boss下会有一个助理，来帮忙做这个审批，最后再将每个月的补打卡统一交给大boss看看就行。12345678910111213141516171819202122232425// 补打卡事件var fillOut = function (lateDate) &#123; this.lateDate = lateDate;&#125;;// 这是bigBossvar bigBoss = function (fillOut) &#123; this.state = function (isSuccess) &#123; console.log("忘记打卡的日期为：" + fillOut.lateDate + ", 补打卡状态：" + isSuccess); &#125;&#125;;// 助理代理大boss 完成补打卡审批var proxyAssis = function (fillOut) &#123; this.state = function (isSuccess) &#123; (new bigBoss(fillOut)).state(isSuccess); // 替bigBoss审批 &#125;&#125;;// 调用方法：var proxyAssis = new proxyAssis(new fillOut("2016-9-11"));proxyAssis.state("补打卡成功");// 忘记打卡的日期为：2016-9-11, 补打卡状态：补打卡成功 应用场景： 比如图片的懒加载，我们就可以运用这种技术。在图片未加载完成之前，给个loading图片，加载完成后再替换成实体路径。12345678910111213141516171819202122var myImage = (function()&#123; var imgNode = document.createElement("img"); document.body.appendChild(imgNode); return function(src)&#123; imgNode.src = src; &#125;&#125;)();// 代理模式var ProxyImage = (function()&#123; var img = new Image(); img.onload = function()&#123; myImage(this.src); &#125;; return function(src) &#123; // 占位图片loading myImage("http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif"); img.src = src; &#125;&#125;)();// 调用方式ProxyImage("https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png"); // 真实要展示的图片 当然，这种懒加载方法不用代理模式也是可以实现的，只是用代理模式。我们可以让 myImage 只做一件事，只负责将实际图片加入到页面中，而loading图片交给ProxyImage去做。从而降低代码的耦合度。因为当我不想用loading的时候，可以直接调用myImage 方法。也即是说假如我门不需要代理对象的话，直接可以换成本体对象调用该方法即可。 外观模式 概念： 外观模式是很常见。其实它就是通过编写一个单独的函数，来简化对一个或多个更大型的，可能更为复杂的函数的访问。也就是说可以视外观模式为一种简化某些内容的手段。 说白了，外观模式就是一个函数，封装了复杂的操作。代码实现： 比如一个跨浏览器的ajax调用12345678910111213141516171819202122232425262728293031323334353637383940414243function ajaxCall(type,url,callback,data)&#123; // 根据当前浏览器获取对ajax连接对象的引用 var xhr=(function()&#123; try &#123; // 所有现代浏览器所使用的标准方法 return new XMLHttpRequest(); &#125;catch(e)&#123;&#125; // 较老版本的internet Explorer兼容 try&#123; return new ActiveXObject("Msxml2.XMLHTTP.6.0"); &#125;catch(e)&#123;&#125; try&#123; return new ActiveXObject("Msxml2.XMLHTTP.3.0"); &#125;catch(e)&#123;&#125; try&#123; return new ActiveXObject("Microsoft.XMLHTTP"); &#125;catch(e)&#123;&#125; // 如果没能找到相关的ajax连接对象，则跑出一个错误。 throw new Error("Ajax not support in this browser.") &#125;()), STATE_LOADED=4, STATUS_OK=200; // 一但从服务器收到表示成功的相应消息，则执行所给定的回调方法 xhr.onreadystatechange=function&#123; if(xhr.readyState !==STATE_LOADED)&#123; return; &#125; if(xhr.state==STATUS_OK)&#123; callback(xhr.responseText); &#125; &#125; // 使用浏览器的ajax连接对象来向所给定的URL发出相关的调用 xhr.open(type.toUpperCase(),url); xhr.send(data);&#125;// 使用方法ajaxCall("get","/user/12345",function(rs)&#123; alert('收到的数据为：'+rs);&#125;) 应用场景： 当需要通过一个单独的函数或方法来访问一系列的函数或方法调用，以简化代码库的其余内容，使得代码更容易跟踪管理或者更好的维护时，可以使用外观模式。其实我们平时代码中这种模式应该是用的比较多的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP的区别]]></title>
    <url>%2F2019%2F04%2F05%2FHTTP%2FTCP%26%26UDP%2F</url>
    <content type="text"><![CDATA[转载： TCP和UDP比较 TCP/IP网络模型 计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。 TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。 TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。1234链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。网络层：负责路由以及把分组报文发送给目标网络或主机。传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。 详情图片: 在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。 TCP 当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。 TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。 TCP连接过程三次握手:第一次握手 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。第二次握手 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。第三次握手 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。 这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。 TCP断开连接 TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。第一次挥手 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。第二次挥手 B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。第三次挥手 B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。第四次挥手 A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。 TCP协议的特点面向连接 面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。 仅支持单播传输 每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。 面向字节流 TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。 可靠传输 对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。 提供拥塞控制 当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞 TCP提供双工通信 TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS） UDP UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。 UDP的特点面向无连接 首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。具体来说就是： 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作 有单播、多播、广播的功能 UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。 UDP是面向报文的 发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文 不可靠性 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。 并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。 再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。 头部开销小，传输数据报文时是很高效的。UDP 头部包含了以下几个数据： 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的 TCP和UDP的比较 对比项 TCP UDP 是否连接 面向连接 无连接 是否可靠 可靠传输，使用流量控制和拥塞控制 不可靠传输，不使用流量控制和拥塞控制 连接对象个数 只能是一对一通信 支持一对一，一对多，多对一和多对多交互通信 传输方式 面向字节流 面向报文 首部开销 首部最小20字节，最大60字节 首部开销小，仅8字节 使用场景 适用于要求可靠传输的应用，例如文件传输 适用于实时应用（IP电话、视频会议、直播等） 总结 TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为 对数据准确性要求高，速度可以相对较慢的，可以选用TCP]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM操作和BOM操作]]></title>
    <url>%2F2019%2F04%2F02%2FJavaScript%2FDOM%E6%93%8D%E4%BD%9C%E5%92%8CBOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[DOM操作 当网页被加载时，浏览器会创建页面的文档对象模型(DOM),我们可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。接下来我们介绍常见DOM操作：DOM基本操作 DOM事件模型和事件流 DOM事件模型分为捕获和冒泡。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。 （1）捕获阶段：事件从window对象自上而下向目标节点传播的阶段,捕获阶段不会响应任何事件； （2）目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上； （3）冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；详情： 冒泡和捕获 事件代理(事件委托) 由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。 我们设定一种场景，如下代码，一个&lt;div&gt;中包含了若干个&lt;a&gt;，而且还能继续增加。那如何快捷方便地为所有&lt;a&gt;绑定事件呢？1234567&lt;div id="div1"&gt; &lt;a href="#"&gt;a1&lt;/a&gt; &lt;a href="#"&gt;a2&lt;/a&gt; &lt;a href="#"&gt;a3&lt;/a&gt; &lt;a href="#"&gt;a4&lt;/a&gt;&lt;/div&gt;&lt;button&gt;点击增加一个 a 标签&lt;/button&gt; 如果给每个&lt;a&gt;标签一一都绑定一个事件，那对于内存消耗是非常大的。借助事件代理，我们只需要给父容器div绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把父容器的click行为触发，然后把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而完成不同的事。123456789var div1 = document.getElementById('div1')div1.addEventListener('click', function (e) &#123; // e.target 可以监听到触发点击事件的元素是哪一个 var target = e.target if (e.nodeName === 'A') &#123; // 点击的是 &lt;a&gt; 元素 alert(target.innerHTML) &#125;&#125;) 最后，使用代理的优点如下： 使代码简洁 减少浏览器的内存占用 动态昂定事件 BOM操作定义 BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。12345678# 包含有关用户屏幕的信息window.screen对象# 用于获得当前页面的地址(URL)，并把浏览器重定向到新的页面window.location对象# 浏览历史的前进后退等window.history对象# 常常用来获取浏览器信息、是否移动端访问等等window.navigator对象 获取屏幕的宽度和高度12console.log(screen.width)console.log(screen.height) 获取网址、协议、path、参数、hash 等1234567891011121314151617181920# 例如当前网址是 https://juejin.im/timeline/frontend?a=10&amp;b=10#some# 返回（当前页面的）整个 URL# https://juejin.im/timeline/frontend?a=10&amp;b=10#someconsole.log(location.href) # 返回所使用的 web 协议（http:// 或 https://）# https:console.log(location.protocol) # 属性返回 URL 的路径名# /timeline/frontendconsole.log(location.pathname) # ?a=10&amp;b=10console.log(location.search) # #someconsole.log(location.hash) 另外，还有调用浏览器的前进、后退功能等12history.back()history.forward() 获取浏览器特性（即俗称的UA）然后识别客户端，例如判断是不是 Chrome 浏览器123var ua = navigator.userAgentvar isChrome = ua.indexOf('Chrome')console.log(isChrome) 转载： 思否]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域和闭包]]></title>
    <url>%2F2019%2F04%2F02%2FJavaScript%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[执行上下文和执行栈 执行上下文就是当前 JavaScript代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。 执行上下文的类型执行上下文总共有三种类型： 全局执行上下文： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事： 1、 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。 2、 将this指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。 函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。 Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。 执行上下文：创建阶段 执行上下文的生命周期包括三个阶段：创建阶段→执行阶段→回收阶段，我们重点介绍创建阶段。创建阶段（当函数被调用，但未执行任何其内部代码之前）会做以下三件事：123创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。创建作用域链：下文会介绍确定this指向：下文会介绍 1234567891011121314151617function test(arg)&#123; // 1. 形参 arg 是 "hi" // 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 function console.log(arg); var arg = 'hello'; // 3.var arg 变量声明被忽略， arg = 'hello'被执行 function arg()&#123; console.log('hello world') &#125; console.log(arg); &#125;test('hi');/* 输出：function arg() &#123; console.log('hello world'); &#125;hello */ 这是因为当函数执行的时候,首先会形成一个新的私有的作用域，然后依次按照如下的步骤执行：123如果有形参，先给形参赋值进行私有作用域中的预解释，函数声明优先级比变量声明高，最后后者会被前者所覆盖，但是可以重新赋值私有作用域中的代码从上到下执行 执行栈 函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？ JavaScript 引擎创建了执行栈来管理执行上下文。可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。 执行栈，在其他编程语言中也被叫做调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。 当 JavaScript 引擎首次读取你的脚本时，它会创建一个全局执行上下文并将其推入当前的执行栈。每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈的顶端。 引擎会运行执行上下文在执行栈顶端的函数，当此函数运行完成后，其对应的执行上下文将会从执行栈中弹出，上下文控制权将移到当前执行栈的下一个执行上下文。从上面的流程图，我们需要记住几个关键点：123456JavaScript执行在单线程上，所有的代码都是排队执行。一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。浏览器的JS执行引擎总是访问栈顶的执行上下文。全局上下文只有唯一的一个，它在浏览器关闭时出栈。 作用域和作用域链 ES6 到来JavaScript 有全局作用域、函数作用域和块级作用域（ES6新增）。我们可以这样理解：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。 在介绍作用域链之前，先要了解下自由变量，如下代码中，console.log(a)要得到a变量，但是在当前的作用域中没有定义a（可对比一下b）。当前作用域没有定义的变量，这成为 自由变量。1234567var a = 100function fn() &#123; var b = 200 console.log(a) // 这里的a在这里就是一个自由变量 console.log(b)&#125;fn() 自由变量的值如何得到 —— 向父级作用域(创建该函数的那个父级作用域)寻找。如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链 。123456789101112function F1() &#123; var a = 100 return function () &#123; console.log(a) &#125;&#125;function F2(f1) &#123; var a = 200 console.log(f1())&#125;var f1 = F1()F2(f1) // 100 上述代码中，自由变量a的值，从函数F1中查找而不是F2,这是因为当自由变量从作用域链中去寻找，依据的是函数定义时的作用域链，而不是函数执行时。 闭包是什么 闭包这个概念也是JavaScript中比较抽象的概念，我个人理解，闭包是就是函数中的函数(其他语言不能这样),里面的函数可以访问外面函数的变量，外面的变量的是这个内部函数的一部分。闭包让我们能够从一个函数内部访问其外部函数的作用域。闭包的优点： （1）逻辑连续，当闭包作为另一个函数调用参数时，避免脱离当前逻辑而单独编写额外逻辑 （2）方便调用上下文的局部变量。 （3）加强封装性，是第2点的延伸，可以达到对变量的保护作用。使用闭包的注意点（缺点）： （1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 （2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。闭包的特性: （1）作为函数变量的一个引用。当函数返回时，其处于激活状态。 （2）闭包就是当一个函数返回时，并没有释放资源的栈区。闭包的作用： 使用闭包可以访问函数中的变量。 可以使变量长期保存在内存中，生命周期比较长。闭包主要有两个应用场景： 闭包的应用比较典型是定义模块，我们将操作函数暴露给外部，而细节隐藏在模块内部 函数作为参数传递（见作用域部分例子） 函数作为返回值（如下例）1234567891011121314function outer() &#123; var num = 0 //内部变量 return function add() &#123; //通过return返回add函数，就可以在outer函数外访问了。 num++ //内部函数有引用，作为add函数的一部分了 console.log(num) &#125;&#125;var func1 = outer() //func1() //实际上是调用add函数， 输出1func1() //输出2var func2 = outer()func2() // 输出1func2() // 输出2 12345678for(var i = 1; i &lt;= 10; i++) &#123; (function () &#123; var j = i; setTimeout(function() &#123; console.log(j); &#125;, 1000); &#125;)();&#125; 123456789for(var i =0; i&lt;= 10; i++) &#123; function timeId () &#123; var j = i; setTimeout(function() &#123; console.log('j:', j); &#125;, 1000); &#125; timeId(); &#125; this全面解析先搞明白一个很重要的概念 —— this的值是在执行的时候才能确认，定义的时候不能确认！ 为什么呢 —— 因为this是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子：123456// 情况1function foo() &#123; console.log(this.a) //1&#125;var a = 1foo() 123456// 情况2function fn()&#123; console.log(this);&#125;var obj=&#123;fn:fn&#125;;obj.fn(); //this-&gt;obj 1234567// 情况3function CreateJsPerson(name,age)&#123;//this是当前类的一个实例p1this.name=name; //=&gt;p1.name=namethis.age=age; //=&gt;p1.age=age&#125;var p1=new CreateJsPerson("尹华芝",48); 1234567// 情况4function add(c, d)&#123; return this.a + this.b + c + d;&#125;var o = &#123;a:1, b:3&#125;;add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 123456789101112131415// 情况5&lt;button id="btn1"&gt;箭头函数this&lt;/button&gt;&lt;script type="text/javascript"&gt; let btn1 = document.getElementById('btn1'); let obj = &#123; name: 'kobe', age: 39, getName: function () &#123; btn1.onclick = () =&gt; &#123; console.log(this);//obj &#125;; &#125; &#125;; obj.getName();&lt;/script&gt; 接下来我们逐一解释上面几种情况: 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象 在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例 call、apply和bind：this 是第一个参数 箭头函数this指向:箭头函数没有自己的this，看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex]]></title>
    <url>%2F2019%2F04%2F01%2FVue%2FVuex%2F</url>
    <content type="text"><![CDATA[Vuex定义 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 每一个 Vuex 应用的核心就是store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同： 1、Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 2、你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 应用场景场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车 安装下载: &lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/path/to/vuex.js&quot;&gt;&lt;/script&gt;CND: https://unpkg.com/vuex也可以通过 https://unpkg.com/vuex@2.0.0 这样的方式指定特定的版本。npm: npm install vuex --save在一个模块化的打包系统中，您必须显式地通过 Vue.use() 来安装 Vuex：1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 当使用全局 script 标签引用 Vuex 时，不需要以上安装过程。 方法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue生命周期和钩子函数]]></title>
    <url>%2F2019%2F04%2F01%2FVue%2FVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Vue生命周期和钩子函数12345678beforeCreatecreatedbeforeMountmountedbeforeUpdateupdatedbeforeDestroydestroyed 创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。 载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。 更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。 销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在 生命周期探究 对于执行顺序和什么时候执行，看上面两个图基本有个了解了。下面我们将结合代码去看看钩子函数的执行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test&lt;/title&gt; &lt;script type="text/javascript" src="https://cdn.jsdelivr.net/vue/2.1.3/vue.js"&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el: '#app', data: &#123; message : "xuxiao is boy" &#125;, beforeCreate: function () &#123; console.group('beforeCreate 创建前状态===============》'); //undefined console.log("%c%s", "color:red" , "el : " + this.$el); //undefined console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message) &#125;, created: function () &#123; console.group('created 创建完毕状态===============》'); //undefined console.log("%c%s", "color:red","el : " + this.$el); //已被初始化 console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); &#125;, beforeMount: function () &#123; console.group('beforeMount 挂载前状态===============》'); //已被初始化 console.log("%c%s", "color:red","el : " + (this.$el)); console.log(this.$el); //已被初始化 console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); &#125;, mounted: function () &#123; console.group('mounted 挂载结束状态===============》'); //已被初始化 console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); //已被初始化 console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); &#125;, beforeUpdate: function () &#123; console.group('beforeUpdate 更新前状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); &#125;, updated: function () &#123; console.group('updated 更新完成状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); &#125;, beforeDestroy: function () &#123; console.group('beforeDestroy 销毁前状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); &#125;, destroyed: function () &#123; console.group('destroyed 销毁完成状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message) &#125;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; beforeCreate 和 created 钩子函数 在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定（放在data中的属性当值发生改变的同时，视图也会改变）。 create 和 mounted 相关咱们在chrome浏览器里打开，F12看console就能发现1234567beforecreated：el 和 data 并未初始化 created:完成了 data 数据的初始化，el没有beforeMount：完成了 el 和 data 初始化 mounted ：完成挂载另外在标红处，我们能发现el还是 &#123;&#123;message&#125;&#125;，这里就是应用的 Virtual DOM（虚拟Dom）技术，先把坑占住了。到后面mounted挂载的时候再把值渲染进去。 update 相关这里我们在 chrome console里执行以下命令app.message= &#39;yes !! I do&#39;;下面就能看到data里的值被修改后，将会触发update的操作。 destroy 相关有关于销毁，暂时还不是很清楚。我们在console里执行下命令对 vue实例进行销毁。销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。app.$destroy(); 总结1234beforecreate : 举个栗子：可以在这加个loading事件 created ：在这结束loading，还做一些初始化，实现函数自执行 mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情beforeDestroy： 你确认删除XX吗？ destroyed ：当前组件已被删除，清空相关内容 转载： Vue2.0 探索之路——生命周期和钩子函数的一些理解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue知识点]]></title>
    <url>%2F2019%2F04%2F01%2FVue%2FVue%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Vue的优点是什么 低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。 可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。 Vue生命周期beforeCreatecreated在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定（放在data中的属性当值发生改变的同时，视图也会改变）beforeMountmountedbeforeUpdateupdatedbeforeDestroy钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。destroyed钩子函数在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。 创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。 载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。 更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。 销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在 路由之间跳转？声明式（标签跳转）编程式（ js 跳转） router.push(‘index’) 懒加载（按需加载路由）（常考）webpack 中提供了 require.ensure()来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。 不进行页面按需加载引入方式：import home from &#39;../../common/home.vue&#39;进行页面按需加载的引入方式：const home = r =&gt; require.ensure( [], () =&gt; r (require(&#39;../../common/home.vue&#39;))) vue-router 有哪几种导航钩子?三种全局导航钩子123router.beforeEach(to, from, next),router.beforeResolve(to, from, next),router.afterEach(to, from ,next) 组件内钩子123beforeRouteEnter,beforeRouteUpdate,beforeRouteLeave 单独路由独享组件beforeEnte 说出至少 4 种 vue 当中的指令和它的用法v-if(判断是否隐藏)、v-for(把数据遍历出来)、v-bind(绑定属性)、v-model(实现双向绑定) Vuexvuex 是什么？怎么使用？哪种功能场景使用它？vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车 vuex 有哪几种属性有 5 种，分别是 state、getter、mutation、action、module vuex 的 store 特性是什么vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 datastate 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性 vuex 的 getter 特性是什么getter 可以对 state 进行计算操作，它就是 store 的计算属性虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 getters vuex 的 mutation 特性是什么action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态action 可以包含任意异步操作 vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中如果请求来的数据不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 vuex 的 state 里如果被其他地方复用，请将请求放入 action 里，方便复用，并包装成 promise 返回 不用 vuex 会带来什么问题可维护性会下降，你要修改数据，你得维护 3 个地方可读性下降，因为一个组件里的数据，你根本就看不出来是从哪里来的增加耦合，大量的上传派发，会让耦合性大大的增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背 vuex 原理使用 Vuex 只需执行 Vue.use(Vuex)，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？Vue.use(Vuex) 方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的store中。因此在VueComponent任意地方都能够通过this.store 访问到该 store state 内部支持模块配置和模块嵌套，如何实现的？在 store 构造方法中有 makeLocalContext 方法，所有 module 都会有一个 local context，根据配置时的 path 进行匹配。所以执行如 dispatch(‘submitOrder’, payload)这类 action 时，默认的拿到都是 module 的 local state，如果要访问最外层或者是其他 module 的 state，只能从 rootState 按照 path 路径逐步进行访问。 在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？store 初始化时，所有配置的 action 和 mutation 以及 getters 均被封装过。在执行如 dispatch(‘submitOrder’, payload)的时候，actions 中 type 为 submitOrder 的所有处理方法都是被封装后的，其第一个参数为当前的 store 对象，所以能够获取到 { dispatch, commit, state, rootState } 等数据。 Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？Vuex 中修改 state 的唯一渠道就是执行 commit(‘xx’, payload) 方法，其底层通过执行 this._withCommit(fn) 设置_committing 标志变量为 true，然后才能修改 state，修改完毕还需要还原_committing 变量。外部修改虽然能够直接修改 state，但是并没有修改_committing 标志位，所以只要 watch 一下 state，state change 时判断是否_committing 值为 true，即可判断修改的合法性。 #### #### vue基础计算属性，方法与侦听器计算属性的setter和getter样式绑定，条件与列表渲染Vue中的set方法事件与表单绑定 vue组件组件使用的细节点父子组件传值与组件参数校验原生事件绑定与非Props特性使用bus进行非父子组件间传值插槽的使用动态组件 多组件状态管理与数据传递技巧组件混入机制大幅精简组件代码组件插槽提升组件复用度动态组件提升组件灵活性异步组件+组件缓存提升访问性能组件API化简化组件调用过程 vue动画Vue transition过渡Vue transition-group过渡Vue交互touch+mouse事件CSS3过渡和帧动画css 预处理 event、v-model、slot、keep-alive、transition、transition-group 说一下Vue的双向绑定数据的原理vue 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调 解释单向数据流和双向数据绑定单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 action 来维护对应的 state双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 debug 的难度 Vue 如何去除url中的vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 url 会自带 #。如果不想使用 #， 可以使用 vue-router 的另一种模式 history1234new Router(&#123; mode: 'history', routes: [ ]&#125;) 需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 404 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面 介绍虚拟DOMhttps://www.jianshu.com/p/616999666920 http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html####]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化DOM]]></title>
    <url>%2F2019%2F03%2F31%2FJavaScript%2F%E4%BC%98%E5%8C%96DOM%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM基本操作]]></title>
    <url>%2F2019%2F03%2F31%2FJavaScript%2FDOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[获取节点 document getElementById 语法： document.getElementById(元素ID) 功能： 通过元素ID获取节点 getElementsByName 语法： document.getElementsByName(元素name属性) 功能： 通过元素name属性获取节点 getElementsByTagName 语法： document.getElementsByTagName(元素标签) 功能： 通过元素标签获取节点 getElementsByClassName 语法： document.getElementsByClassName(“classname”) 功能： 根据class获取元素节点 CSS选择器 querySelector() 语法： document.querySelector() 功能： 根据CSS选择器的规则，返回第一个匹配到的元素 querySelectorAll() 语法： document.querySelectorAll() 功能： 根据CSS选择器的规则，返回所有匹配到的元素 节点指针 firstChild 语法： 父节点.firstChild 功能： 获取元素首个节点 lastChild 语法： 父节点.lastChild 功能： 获取元素最后一个节点 childNodes 语法： 父节点.childNodes 功能： 获取元素子节点列表 previousSibling 语法： 兄弟节点.previousSibling 功能： 获取已知节点前一个节点 nextSibling 语法： 兄弟节点.nextSibling 功能： 获取已知节点后一个节点 parentNode 语法： 子节点.parentNode 功能： 获取已知节点的父节点 节点操作 创建节点 createElement 语法： document.createElement(元素标签) 功能： 创造元素节点 createAttribute 语法： document.createAttribute(元素属性) 功能： 创建属性节点 createTextNode 语法： document.createTextNode(文本内容) 功能： 创建文本节点 插入节点 appendChild 语法： appendChild(所添加的新节点) 功能： 向节点的子节点列表的末尾添加新的子节点 insertBefore 语法： insertBefore(所要添加的新节点, 已知子节点) 功能： 向已知的子节点前插入一个新的子节点 替换节点 replaceChild 语法： replaceChild(要插入的新元素， 将被替换的老元素) 功能： 将子节点替换成另一个 复制节点 cloneNode 语法： 需要被复制的节点.cloneNode(true/false) 功能： 创建指定节点的副本 参数： true 复制当前节点以及其他所有子节点 false 仅复制当前节点 删除节点 removeChild 语法： removeChild(要删除的节点) 功能： 删除指定的节点 属性操作 获取属性 getAttribute 语法： 元素节点.getAttribute(元素属性名) 功能： 获取元素节点中指定属性的属性值 设置属性 setAttribute 语法： 元素节点.setAttribute(属性名， 属性值) 功能： 创建或者改变元素的属性 删除属性 removeAttribute 语法： 元素节点.removeAttribute(属性名) 功能： 删除元素中的指定属性 文本操作 文本操作 insterData(offset, string) 从offset指定的位置插入string appendData(string) 将string插入到文本节点的末尾处 deleteData(offset, count) 从offset起删除count个字符 replaceData(off, count, string) 从off将count个字符用string splitData(offset) 从offset起将文本节点分成两个节点 substring(offset, count) 返回由offset起的count个节点]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中使用Axios]]></title>
    <url>%2F2019%2F03%2F30%2FAjax%2FAxios%2F</url>
    <content type="text"><![CDATA[转载： axios参考： axio github Axios中文 基本流程安装: npm install axios --save设置全局都可以使用axios设置在 main.js 中引入 axios: import axios from &#39;axios&#39;axios 改写为 Vue 的原型属性（不推荐这样用） Vue.prototype.$http= axios在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $http命令例如1234567891011methods: &#123; show() &#123; this.$http(&#123; method: 'get', url: '/user', data: &#123; name: 'virus' &#125; &#125;)&#125;&#125; 发送请求GET请求1234567891011121314151617181920# 通过给定的ID来发送请求axios.get('/user?ID=12345') .then(function(response)&#123; console.log(response); &#125;) .catch(function(err)&#123; console.log(err); &#125;);# 以上请求也可以通过这种方式来发送axios.get('/user',&#123; params:&#123; ID:12345 &#125;&#125;).then(function(response)&#123; console.log(response);&#125;).catch(function(err)&#123; console.log(err);&#125;); POST请求12345678910axios.post('/user',&#123; firstName:'Fred', lastName:'Flintstone'&#125;).then(function(res)&#123; console.log(res);&#125;).catch(function(err)&#123; console.log(err);&#125;); 一次性并发多个请求12345678910function getUserAccount()&#123; return axios.get('/user/12345');&#125;function getUserPermissions()&#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(),getUserPermissions()]) .then(axios.spread(function(acct,perms)&#123; # 当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果 &#125;)) axios的APIaxios可以通过配置（config）来发送请求axios(config)123456789# 发送一个`POST`请求axios(&#123; method:"POST", url:'/user/12345', data:&#123; firstName:"Fred", lastName:"Flintstone" &#125;&#125;); axios(url[,config])12# 发送一个`GET`请求（默认的请求方式）axios('/user/12345'); 请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名1234567axios.request(config);axios.get(url[,config]);axios.delete(url[,config]);axios.head(url[,config]);axios.post(url[,data[,config]]);axios.put(url[,data[,config]])axios.patch(url[,data[,config]]) 注意：当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明 并发请求（concurrency）,即是帮助处理并发请求的辅助函数1234# iterable是一个可以迭代的参数如数组等axios.all(iterable)# callback要等到所有请求都完成才会执行axios.spread(callback) 创建一个axios实例，并且可以自定义其配置123456# axios.create([config])var instance = axios.create(&#123; baseURL:"https://some-domain.com/api/", timeout:1000, headers: &#123;'X-Custom-Header':'foobar'&#125;&#125;); 123456789# 实例的方法# 一下是实例方法，注意已经定义的配置将和利用create创建的实例的配置合并axios#request(config)axios#get(url[,config])axios#delete(url[,config])axios#head(url[,config])axios#post(url[,data[,config]])axios#put(url[,data[,config]])axios#patch(url[,data[,config]]) 请求的配置（request config） 以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&#123; # `url`是请求的服务器地址 url:'/user', # `method`是请求资源的方式 method:'get'# default # 如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面 # 当`url`是相对地址的时候，设置`baseURL`会非常的方便 baseURL:'https://some-domain.com/api/', # `transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动 # 该选项只适用于以下请求方式：`put/post/patch` # 数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream` transformRequest:[function(data)&#123; # 在这里根据自己的需求改变数据 return data; &#125;], # `transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动 transformResponse:[function(data)&#123; # 在这里根据自己的需求改变数据 return data; &#125;], # `headers`选项是需要被发送的自定义请求头信息 headers: &#123;'X-Requested-With':'XMLHttpRequest'&#125;, # `params`选项是要随请求一起发送的请求参数----一般链接在URL后面 # 他的类型必须是一个纯对象或者是URLSearchParams对象 params: &#123; ID:12345 &#125;, # `paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化 # 例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param) paramsSerializer: function(params)&#123; return Qs.stringify(params,&#123;arrayFormat:'brackets'&#125;) &#125;, # `data`选项是作为一个请求体而需要被发送的数据 # 该选项只适用于方法：`put/post/patch` # 当没有设置`transformRequest`选项时dada必须是以下几种类型之一 # string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams # 仅仅浏览器：FormData/File/Bold # 仅node:Stream data &#123; firstName:"Fred" &#125;, # `timeout`选项定义了请求发出的延迟毫秒数 # 如果请求花费的时间超过延迟的时间，那么请求会被终止 timeout:1000, # `withCredentails`选项表明了是否是跨域请求 withCredentials:false,# default # `adapter`适配器选项允许自定义处理请求，这会使得测试变得方便 # 返回一个promise,并提供验证返回 adapter: function(config)&#123; /*..........*/ &#125;, # `auth`表明HTTP基础的认证应该被使用，并提供证书 # 这会设置一个authorization头（header）,并覆盖你在header # 设置的Authorization头信息 auth: &#123; username:"zhangsan", password: "s00sdkf" &#125;, # 返回数据的格式 # 其可选项是arraybuffer,blob,document,json,text,stream responseType:'json',# default # xsrfCookieName: 'XSRF-TOKEN',# default xsrfHeaderName:'X-XSRF-TOKEN',# default # `onUploadProgress`上传进度事件 onUploadProgress:function(progressEvent)&#123; # 下载进度的事件onDownloadProgress:function(progressEvent)&#123;&#125; &#125;, # 相应内容的最大值 maxContentLength:2000, # `validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise # 如果`validateStatus`返回true(或者设置为`null`或者`undefined`), # 那么promise的状态将会是resolved,否则其状态就是rejected validateStatus:function(status)&#123; return status &gt;= 200 &amp;&amp; status &lt;300;# default &#125;, # `maxRedirects`定义了在nodejs中重定向的最大数量 maxRedirects: 5,# default # `httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理 # keeyAlive在选项中没有被默认激活 httpAgent: new http.Agent(&#123;keeyAlive:true&#125;), httpsAgent: new https.Agent(&#123;keeyAlive:true&#125;), # proxy定义了主机名字和端口号， # `auth`表明http基本认证应该与proxy代理链接，并提供证书 # 这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的 # Proxy-Authorization header proxy: &#123; host:'127.0.0.1', port: 9000, auth: &#123; username:'skda', password:'radsd' &#125; &#125;, # `cancelToken`定义了一个用于取消请求的cancel token # 详见cancelation部分 cancelToken: new cancelToken(function(cancel)&#123; &#125;)&#125; 请求返回的内容1234567891011&#123; data:&#123;&#125;, status:200, # 从服务器返回的http状态文本 statusText:'OK', # 响应头信息 headers: &#123;&#125;, # `config`是在请求的时候的一些配置信息 config: &#123;&#125;&#125; 123456789# 你可以这样来获取响应信息axios.get('/user/12345') .then(function(res)&#123; console.log(res.data); console.log(res.status); console.log(res.statusText); console.log(res.headers); console.log(res.config); &#125;) 默认配置你可以设置默认配置，对所有请求都有效12341、 全局默认配置axios.defaults.baseURL = 'http://api.exmple.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['content-Type'] = 'appliction/x-www-form-urlencoded'; 2、 自定义的实例默认设置1234567# 当创建实例的时候配置默认配置var instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);# 当实例创建时候修改配置instance.defaults.headers.common["Authorization"] = AUTH_TOKEN; 3、 配置中的有优先级 config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。12345678910# 创建一个实例的时候会使用libray目录中的默认配置# 在这里timeout配置的值为0，来自于libray的默认值var instance = axios.create();# 回覆盖掉library的默认值# 现在所有的请求都要等2.5S之后才会发出instance.defaults.timeout = 2500;# 这里的timeout回覆盖之前的2.5S变成5sinstance.get('/longRequest',&#123; timeout: 5000&#125;); 拦截器你可以在请求、响应在到达then/catch之前拦截他们12345678910111213141516# 添加一个请求拦截器axios.interceptors.request.use(function(config)&#123; # 在请求发出之前进行一些操作 return config;&#125;,function(err)&#123; # Do something with request error return Promise.reject(error);&#125;);# 添加一个响应拦截器axios.interceptors.response.use(function(res)&#123; # 在这里对返回的数据进行处理 return res;&#125;,function(err)&#123; # Do something with response error return Promise.reject(error);&#125;) 2、取消拦截器12var myInterceptor = axios.interceptor.request.use(function()&#123;/*....*/&#125;);axios.interceptors.request.eject(myInterceptor); 3、 给自定义的axios实例添加拦截器12var instance = axios.create();instance.interceptors.request.use(function()&#123;&#125;) 错误处理12345678910111213axios.get('/user/12345') .catch(function(error)&#123; if(error.response)&#123; # 请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.header); &#125;else &#123; # 一些错误是在设置请求的时候触发 console.log('Error',error.message); &#125; console.log(error.config); &#125;); 取消1、你可以通过一个cancel token来取消一个请求你可以通过CancelToken.source工厂函数来创建一个cancel token123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345',&#123; cancelToken: source.token&#125;).catch(function(thrown)&#123; if(axios.isCancel(thrown))&#123; console.log('Request canceled',thrown.message); &#125;else &#123; # handle error &#125;&#125;);# 取消请求（信息的参数可以设置的）source.cance("操作被用户取消"); 2、你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:12345678910var cancelToken = axios.CancelToken;var cance;axios.get('/user/12345',&#123; cancelToken: new CancelToken(function(c)&#123; # 这个executor函数接受一个cancel function作为参数 cancel = c; &#125;)&#125;)# 取消请求cancel(); 创建axios实例123456789101112131415161718192021222324252627282930313233343536# helpers.jsimport axios from 'axios'# 定义常量ERR_OKconst ERR_OK = 0# 导出一个getDate方法export default getDate(url) &#123; return function(params) &#123; return axios.get(url, &#123; params # 成功之后的.then方法 &#125;).then((res) =&gt; &#123; # 通过结构赋值的方法难道error和data的数值 const &#123; error, data&#125; = res.data # 如果成功的话，返回data数据 if(error === ERR_OK) &#123; return data &#125; # 如果失败的话打印失败的原因 &#125;).catch(function(error) =&gt; &#123; console.log("error:", error) &#125;) &#125;&#125;# 出口文件# index.jsimport &#123; getDate &#125; from './helpers'# 定义getSeller方法const getSeller = getDate('./api/seller')# 导出getSeller方法export &#123; getSeller&#125;]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2F2019%2F03%2F30%2FAjax%2FAJAX%2F</url>
    <content type="text"><![CDATA[AJAX简介 AJAX全称为“Asynchronous Javascript And XML”， 即“异步JavaScript和XML”的意思。通过AJAX我们可以向服务器发送请求，在不阻塞页面的情况下进行数据交互，也可以理解为异步数据传输。在AJAX的帮助下我们的网页只需局部刷新即可更新数据的显示，减少了不必要的数据量，大大提高了用户体验，缩短了用户等待的时间，使得web应用程序更小、更快，更友好。 优点 页面无刷新，用户体验好。 异步通信，更加快的响应能力。 减少冗余请求，减轻了服务器负担 基于标准化的并被广泛支持的技术，不需要下载插件或者小程序 缺点 ajax干掉了back按钮，即对浏览器后退机制的破坏。 存在一定的安全问题。 对搜索引擎的支持比较弱。 破坏了程序的异常机制。 无法用URL直接访问 使用场景 场景 1. 数据验证 场景 2. 按需取数据 场景 3. 自动更新页面 AJAX的核心 XMLHttpRequest对象创建XML对象的实例：const xhr = new XMLHttpRequest() 方法123456789101112# 准备启动一个AJAX请求.open()# 设置请求头部信息.setRequestHeader()# 发送AJAX请求.send()# 获得响应头部信息.getResponseHeader()# 获得一个包含所有头部信息的长字符串.getAllResponseHeader()# 取消异步请求.abort() 属性123456789101112131415161718192021222324252627282930313233# 一个JavaScript函数对象，当readyState属性改变时会调用它。# 回调函数会在user interface线程中调用。onreadystatechange# 表示“请求”/“响应”过程的当前活动阶段# HTTP 请求的状态.当一个 XMLHttpRequest 初次创建时，# 这个属性的值从 0 开始，直到接收到完整的 HTTP 响应，这个值增加到 4。# 0 Uninitialized 初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。# 1 Open open() 方法已调用，但是 send() 方法未调用。请求还没有被发送。# 2 Sent Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。# 3 Receiving 所有响应头部都已经接收到。响应体开始接收但未完成。# 4 Loaded HTTP 响应已经完全接收。# readyState 的值不会递减，除非当一个请求在处理过程中的时候调用了# abort() 或 open() 方法。每次这个属性的值增加的时候，都会触发 # onreadystatechange 事件句柄。.readyState# 目前为止为服务器接收到的响应体（不包括头部），或者如果还没有接收到数据的话，# 就是空字符串。# 如果 readyState 小于 3，这个属性就是一个空字符串。当 readyState 为 3，# 这个属性返回目前已经接收的响应部分。如果 readyState 为 4，这个属性保存# 了完整的响应体。.responseText# 如果响应的内容类型时text/xml或application/xml，# 该属性将保存包含着相应数据的XML DOM文档.responseXML# 响应的HTTP状态.status# HTTP状态的说明.statusText XMLHttpRequest 方法abort()取消当前响应，关闭连接并且结束任何未决的网络活动。 这个方法把 XMLHttpRequest 对象重置为 readyState为 0 的状态，并且取消所有未决的网络活动。例如，如果请求用了太长时间，而且响应不再必要的时候，可以调用这个方法。 getAllResponseHeaders()把 HTTP 响应头部作为未解析的字符串返回。 如果 readyState 小于 3，这个方法返回 null。否则，它返回服务器发送的所有 HTTP 响应的头部。头部作为单个的字符串返回，一行一个头部。每行用换行符 &quot;\r\n&quot; 隔开。 getResponseHeader() 返回指定的 HTTP 响应头部的值。其参数是要返回的 HTTP 响应头部的名称。可以使用任何大小写来制定这个头部名字，和响应头部的比较是不区分大小写的。 该方法的返回值是指定的 HTTP 响应头部的值，如果没有接收到这个头部或者 readyState 小于 3 则为空字符串。如果接收到多个有指定名称的头部，这个头部的值被连接起来并返回，使用逗号和空格分隔开各个头部的值。 open()初始化一个请求. 该方法用于JavaScript代码中;如果是本地代码, 使用 openRequest())方法代替. 注意: 在一个已经激活的request下（已经调用open()或者openRequest()方法的request）再次调用这个方法相当于调用了abort（）方法。 参数：method 请求所使用的HTTP方法; 例如 “GET”, “POST”, “PUT”, “DELETE”等. 如果下个参数是非HTTP(S)的URL,则忽略该参数.url 该请求所要访问的URLasync 一个可选的布尔值参数，默认为true,意味着是否执行异步操作，如果值为false,则send()方法不会返回任何东西，直到接受到了服务器的返回数据。如果为值为true，一个对开发者透明的通知会发送到相关的事件监听者。这个值必须是true,如果multipart 属性是true，否则将会出现一个意外。user 用户名,可选参数,为授权使用;默认参数为空string.password 密码,可选参数,为授权使用;默认参数为空string. sned()发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体。 setRequestHeader()向一个打开但未发送的请求设置或添加一个 HTTP 请求(设置请求头)。参数：header 将要被赋值的请求头名称value 给指定的请求头赋的值 发送AJAX请求设置请求头部信息 每个HTTP请求和响应都会带有相应的头部信息，包含一些与数据，收发者网络环境与状态等相关信息。XMLHttpRequest对象提供的.setRequestHeader()方法为开发者提供了一个操作这两种头部信息的方法，并允许开发者自定义请求头的头部信息。默认情况下，当发送AJAX请求时，会附带以下头部信息：123456789101112131415161718# 浏览器能够处理的内容类型Accept# 浏览器能够显示的字符集Accept-Charset# 浏览器能够处理的压缩编码Accept-Encoding# 浏览器当前设置的语言Accept-Language# 浏览器与服务器之间连接的类型Connection# 当前页面设置的任何CookieCookie# 发出请求的页面所在的域Host# 发出请求的页面URIReferer# 浏览器的用户代理字符串User-Agent 注意: 部分浏览器不允许使用.setRequestHeader()方法重写默认请求头信息，因此自定义请求头信息是更加安全的方法：# 自定义请求头xhr.setRequestHeader(&quot;myHeader&quot;, &quot;MyValue&quot;) 发送AJAX请求123456789101112# 发送AJAX请求# 使用get方法发送同步请求(false)let xhr = new XMLHttpRequest()xhr.open('get', 'example.php', false)xhr.setRequestHeader('myHeader', 'goodHeader')xhr.send(null)# POST请求let xhr = new XMLHttpRequest()xhr.open('post', 'example.php', false)xhr.setRequestHeader('myHeader', 'goodHeader')shr.send(some_data) 处理响应同步的GET请求响应：1234567891011const xhr = new XMLHttpRequest()xhr.open("get", "example.php", false)xhr.setRequestHeader("myHeader", "goodHeader")xhr.send(null)# 由于是同步的AJAX请求，因此只有当服务器响应后才会继续执行下面的代码# 因此xhr.status的值一定不为默认值if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log("xhr.responseText:", xhr.responseText);&#125; else &#123; console.log("Request was unsuccessful:", xhr.status);&#125; 上面的代码不难理解，我们通过之前提到的xhr.status属性（如果你忘记了，它存储着响应的HTTP状态）判断请求是否成功，如果成功的话，我们将读取xhr.responseText属性中存储的返回值。但是，当我们的请求为异步时，问题就稍微变得复杂了，由于是异步的请求，在xhr.send(null)语句被执行后，JavaScript引擎会紧接着执行下面的判断语句，而这时由于尚未来得及响应，我们注定会得到一个默认的xhr.status值，因此，我们永远都不可能获取请求的资源了。如何解决这个问题？答案是通过为XMLHTTPRequest实例添加onreadystatechange事件处理程序（当然你也可以直接使用DOM2级规范规定的.addEventListener()方法，但是注意，IE8是不支持该方法的）。 xhr实例的readystatechange事件会监听xhr.readyState属性的变化，你可以将这个属性想象为一个计数器，随着AJAX流程的推进而不断累加，其可取的值如下：12345 0：未初始化 -- 尚未调用.open()方法 1：启动 -- 已经调用.open()方法，但尚未调用.send()方法 2：发送 -- 已经调用.send()方法，但尚未接收到响应 3：接收 -- 已经接收到部分响应数据 4：完成 -- 已经接收到全部响应数据，而且已经可以在客户端使用了 有了这个时间处理程序对AJAX进程做监听，剩下的事就简单多了，一个异步的GET请求代码如下：12345678910111213141516const xhr = new XMLHttpRequest()# 等价于 xhr.onreadystatechange = function()&#123;&#125;# 利用onreadystatechange监测状态xhr.onreadystatechange = () =&gt; &#123; # readyState为4表示请求响应完成 if(xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log("xhr.responseText:", xhr.responseText); &#125; else &#123; console.log("Request was unsuccessful:", xhr.status); &#125; &#125;&#125;xhr.open('GET', 'example.php', true)xhr.send(null) 其他库框架中的AJAXjQuery中的AJAX1234567891011$.ajax(&#123; method: 'GET', # 1.9.0本版前用'type' url: "/test/", dataType: 'json'&#125;).done(function() &#123; console.log('执行成功');&#125;).fail(function() &#123; console.log('执行出错');&#125;) Vue.js中的AJAX12345Vue.http.get('/test/').then((response) =&gt; &#123; console.log('执行成功');&#125;, (response) =&gt; &#123; console.log('执行出错');&#125;); 转载： 使用AJAX]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM结构]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2FDOM%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[定义DOM是个缩写，全称是Document Object Model。D表示Document，就是DOM将HTML页面解析为一个文档，同时提供了document对象。O表示Object，就是DOM将HTML页面中每一个元素解析为一个对象。M表示Model，就是DOM中表示各个对象之间的关系。 作用用于解析HTML页面文档，方便JavaScript语言通过DOM访问和操作HTML页面中的内容。 DOM结构DOM树结构DOM可以访问和更新HTML中的内容、结构和样式，是因为DOM将HTML解析为一个树状结构。1234567891011&lt;!DOCTYPE html&gt;&lt;html lang='en'&gt;&lt;head&gt; &lt;meta charset='UTF-8'&gt; &lt;title&gt;示例页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;这是一个示例页面&lt;/h2&gt; &lt;p id="p" title="this is p."&gt;这是一个段落内容。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 将上面的 HTML 页面绘制成 DOM 树结构，如下效果: 通过上面的 DOM 树结构，我们可以看到，Document 对象是作为 DOM树结构的入口。再根据 DOM 树结构的特点，我们就可以定位到 HTML 页面中任意一个元素、属性或文本内容。 浏览器加载并运行 HTML 页面时，会创建 DOM 树结构这个模型。并且 DOM 树结构模型会被存储在浏览器的内存中。当 HTML 页面内容过于庞大和复杂时，生成的 DOM 树结构就越复杂。进而，浏览器加载 HTML 页面的耗时就越长。 DOM树中的节点在 DOM 树结构中，主要由以下 4 种节点组成: 节点名称 含义 描述 文档节点 表示整个HTML页面(相当于document对象) 当需要访问任何标签、属性或文本时，都可以通过文档节点进行导航 元素节点 表示HTML页面中的标签(即HTML页面结构) 访问DOM树时，需要从查找元素节点开始 属性节点 表示HTML页面中的开始标签包含的属性 文本节点 表示整个HTML页面中的标签所包含的文本内容 节点（Node）作为DOM树结构中的连接点，最终构成了完整的DOM树结构 节点树结构通过节点概念，我们可以将原本的 DOM 树结构改成 DOM 节点树结构进行表示。 操作节点1、获取节点12345678910111213# 1、标准DOM APIdocument.getElementByIddocument.getElementsByTagNamedocument.getElementsByNamedocument.getElemensByClassName# 功能强大，但是也许会有浏览器不兼容的情况存在document.querySelectorAll 2、 亲属访问3、 属性获取getAttributegetAttributeNode 2、 创建123456789# 创建元素document.createElement # 创建文本节点document.createTesxtNode # 属性节点document.createAttribute innerHTMLinnerTextnode.cloneNode() 3、 加入12345# 追加到结尾处appendChild innerHTML# 用法：将元素插入到某一个元素的前面 父元素.insertBefore(新元素, 旧元素);insertBefore 4、 其他12style 的操作setAttribute(属性名， 属性值) 5、 删除123# 用法：父元素.removeChild()removeChild removeAttributeNode 6、 修改123456789101112131415161.修改节点删除节点再加入2.修改样式style.xxx = vvv;setAttribute3.修改文本innerHTMLinnerText节点操作nodeValue4.修改属性.xxx = vvvsetAttribute]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器渲染流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染流程]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[转载： 浏览器加载、解析、渲染的过程 【干货】十分钟读懂浏览器渲染流程 为什么要了解浏览器加载、解析、渲染这个过程 了解浏览器如何进行加载，可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。 了解浏览器如何进行解析，可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。 了解浏览器如何进行渲染，明白渲染的过程，在设置元素属性，编写js文件时，可以减少”reflow“”repaint“的消耗。 浏览器的主要功能 浏览器的主要功能是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式。用户用URI（Uniform Resource Identifier统一资源标识符）来指定所请求资源的位置，通过DNS查询，将网址转换为IP地址。整个浏览器工作的流程为： 1、 输入网址。 2、 浏览器查找域名的IP地址。 3、 浏览器给web服务器发送一个HTTP请求 4、 网站服务的永久重定向响应 5、 浏览器跟踪重定向地址。现在，浏览器知道了要访问的正确地址，所以它会发送另一个获取请求。 6、 服务器“处理”请求，服务器接收到获取请求，然后处理并返回一个响应。 7、 服务器发回一个HTML响应 8、 浏览器开始显示HTML 9、 浏览器发送请求，以获取嵌入在HTML中的对象。在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。这些文件就包括CSS/JS/图片等资源，这些资源的地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等… 那么，一个页面，究竟是如何从我们输入一个网址到最后完整的呈现在我们面前的呢？还需要了解一下浏览器是如何渲染的： 浏览器的渲染渲染引擎在取得内容之后的基本流程：解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树所以，浏览器会解析三个东西：（1） HTML/SVG/XHTML，解析这三种文件会产生一个 DOM Tree。（2） CSS，解析 CSS 会产生 CSS 规则树。（3） Javascript脚本，主要是通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree. 关键渲染路径 关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。 当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。解析： 1、 DOM Tree: 浏览器会将HTML解析成一个DOM树。DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 2、 CSS Rule Tree: 将CSS解析成 CSS Rule Tree 。 3、 Render Tree: 根据DOM树和CSSOM来构造 Rendering Tree。 注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。 4、 layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。 （遍历渲染树开始布局，计算每个节点的位置大小信息） 5、 painting: 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。 (将渲染树每个节点绘制到屏幕。) 构建DOM树 当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。需要注意的是，DOM树的生成过程中可能会被CSS和JS的加载执行阻塞。渲染阻塞问题下文会讲。 构建CSSOM规则树 浏览器解析CSS文件并生成CSS规则树，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。 渲染阻塞 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建DOM。每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。 所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：CSS 优先：引入顺序上，CSS 资源先于 JavaScript资源。JS置后：我们通常把JS代码放到页面底部，且JavaScript 应尽量少影响 DOM 的构建。当解析html的时候，会把新来的元素插入dom树里面，同时去查找css，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。例如： div p {font-size: 16px}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染）。所以，我们平时写CSS时，尽量用id和class，千万不要过渡层叠。 构建渲染树 通过DOM树和CSS规则树我们便可以构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的CSS样式规则并应用。渲染树构建完成后，每个节点都是可见节点并且都含有其内容和对应规则的样式。这也是渲染树与DOM树的最大区别所在。渲染树是用于显示，那些不可见的元素当然就不会在这棵树中出现了，譬如。除此之外，display等于none的也不会被显示在这棵树里头，但是visibility等于hidden的元素是会显示在这棵树里头的。 渲染树布局 布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。 渲染树绘制 在绘制阶段，遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。 重点 上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。几个概念： （1）Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。 （2）Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。Reflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。 reflow （1）页面初始化的时候； （2）操作DOM时； （3）某些元素的尺寸变了； （4）如果 CSS 的属性发生变化了。 减少reflow/repaint （1）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。 （2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。 （3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。 （4）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。 注意注意： (1)display:none 的节点不会被加入Render Tree，而visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。 (2)display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。 (3)有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步reflow 或增量异步 reflow。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。 HTML页面加载和解析流程 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件； 浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件； 浏览器又发出CSS文件的请求，服务器返回这个CSS文件； 浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了； 浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； 浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它； Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码； 终于等到了＜/html＞的到来，浏览器泪流满面…… 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径； 浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。 编写CSS时应该注意 CSS选择符是从右到左进行匹配的。从右到左！所以，#nav li 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的li，然后再去确定它的父元素是不是#nav。，因此，写css的时候需要注意： 1、dom深度尽量浅。 2、减少inline javascript、css的数量。 3、使用现代合法的css属性。 4、不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。 5、避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;#tp p{}子选择符：#tp&gt;p{}` 6、避免使用通配符，举一个例子，.mod .hd *{font-size:14px;}根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知. 关于Script标签位置Javascript的加载和执行的特点： （1）载入后马上执行； （2）执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）。原因：因为浏览器需要一个稳定的DOM树结构，而JS中很有可能有 代码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修 改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现。 减少JavaScript对性能的影响 （1）将所有的script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染。 （2）尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。 （3）采用无阻塞下载 JavaScript 脚本的方法： （1）使用script标签的 defer 属性（仅适用于 IE 和 Firefox 3.5 以上版本）； （2）使用动态创建的script元素来下载并执行代码；]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器渲染流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC&IFC&GFC&FFC]]></title>
    <url>%2F2019%2F03%2F29%2F%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%2FBFC%26IFC%2F</url>
    <content type="text"><![CDATA[BFC理解 对CSS有了解的道友们肯定都知道盒式模型这个概念，对一个元素设置CSS，首先需要知道这个元素是block还是inline类型。而BFC就是用来格式化块级盒子，同样管理inline类型的盒子还有IFC，以及其他的FC。那首先我们就来看一下FC的概念。 Formatting Context：指页面中的一个渲染区域，并且拥有一套渲染规则，他决定了其子元素如何定位，以及与其他元素的相互关系和作用。 BFC：块级格式化上下文，它是指一个独立的块级渲染区域，只有Block-level BOX参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 BFC生成BFC(Block Formatting Context)是Web页面中盒模型布局的CSS渲染模式。它属于常规文档流。CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC:（1）float的值不为none（2）position的值为absolute或者fixed（3）display的值为table-cell、table-caption、inline-block、flex或者inline-flex的其中一个（4）overflow的值不为visible BFC的约束规则浏览器对于BFC这块区域的约束规则如下： 生成BFC元素的子元素会一个接一个的放置。垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的margin特性。在BFC中相邻的块级元素外边距会折叠。 生成BFC元素的子元素中，每一个子元素做外边距与包含块的左边界相接触，（对于从右到左的格式化，右外边距接触右边界），即使浮动元素也是如此（尽管子元素的内容区域会由于浮动而压缩），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。有道友对它做了分解，我们直接拿来： （1）内部的Box会在垂直方向上一个接一个的放置 （2）垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关。） （3）每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界） （4）BFC的区域不会与float box的元素区域重叠 （5）计算BFC的高度时，浮动子元素也参与计算 （6）BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然 BFC的用处防止发生因浮动导致的高度塌陷防止margin重叠 同一个BFC中的两个相邻Box才会发生重叠与方向无关，不过由于上文提到的第一条限制，我们甚少看到水平方向的margin重叠。这在IE中是个例外，IE可以设置write-mode123456789101112131415161718# html&lt;div class="first-block"&gt;&lt;/div&gt;&lt;div class="second-block"&gt; &lt;h2&gt;DDFE&lt;/h2&gt;&lt;/div&gt;# css.first-block &#123; background: #F44336; width: 200px; height: 200px;&#125;.second-block &#123; background: #00BCD4; width: 200px; height: 200px; overflow: hidden; //添加溢出隐藏&#125; first-block和second-block之间存在间距，这个间距是 h2 的上外边距引起的通过把 overflow 把 second-block 元素形成一个 BFC，完美解决！ CSS 里面关于折叠的条件：两个块元素要产生折叠现象，必须满足一个必备条件：这两个元素的 margin 必须是 相邻 的；那么如果定义相邻呢，w3c 规范，两个 margin 是邻接的必须满足以下条件：必须是处于常规文档流（非float和绝对定位）的块级盒子,并且处于同一个 BFC 当中。没有inline盒子，没有空隙，没有 padding 和 border 将他们分隔开。折叠的结果按照如下规则计算：123两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。两个外边距一正一负时，折叠结果是两者的相加的和。 IFC 在一个IFC中，从父级元素的顶部开始，盒子一个接一个横向排列。此时，横向的margin、borders、padding在这些盒子中都是有效的。这些盒子有可能通过不同的方式垂直对齐：1、他们底部或者顶部可以对齐，2、或者可以他们内部的文字基线可以对齐。如果一个矩形区域，包含着一些排成一条线的盒子，称为line box。 什么是IFC IFC(Inline Formatting Contexts)直译为”行内格式化上下文“，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来(不受到竖直方向的 padding/margin 影响) IFC特性 IFC中的linebox一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。 IFC的应用 水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。 垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。 参考文章： 我对BFC的理解 细说CSS中的BFC]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>页面布局</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F29%2F%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%2F%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端知识点]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[HTML+CSS布局 内容+样式 基础 重点了解布局、流 less、sass、stylus CSS px、em、rem、vw、vh 设置html的font-size大小，统一标准 小程序单位rpx 布局 相对、绝对 流式、响应式布局 flex布局 CSS3 透明度、文字阴影、圆角、渐变色 盒阴影、边框图片、媒体查询 transition过渡、transform变形、animation动画 CSS优化 选择器原理: 从右向左 避免后台、链式、重复 避免!important BFC &amp; IFC float不是none，绝对定位，表格，overflow不是visable，flex盒子 创建BFC后，元素会一个个的摆放 外边距折叠 最常见的：overflow:hidden、 float:left/right、 position: absolut、 ES6 &amp; ES7 let、const、解构(结构)、 箭头函数、SymboL、Set Proxy、Class、generator、模块化 函数 默认参数、返回值、原型链 箭头函数、this、作用域、闭包、bind、apply 高阶函数、递归、Decorator、Compose、Currying… 面向对象 class、实例方法、静态属性和方法 构造函数、super 继承 JS异步 解决回调 Promise Generator Async + await 模块化 最早期AMD、CMD、commonjs import export ES6加载原理和node加载原理 面试题 Promise相当于一个状态机 pending、rejected、fulfilled状态 维护callback队列 掘金 Vue Vue-cli3.0+ 组件化通讯 父子组件 props $emit 兄弟组件可以让父母代理中转 祖先后代关系eventbus 或者自己实现dispath&amp;boardcast 没关系eventbus或者Vuex 生命周期 组件化设计 源码 全家桶、服务端渲染 复用.Vue组件 props、event、slot 手动挂载的组件$emit 递归组件和动态组件 双向绑定 Object.defineProperty 依赖机制 异步更新队列 Vuex + vue-router 单页应用 依赖加载模块 vue单行数据流 数据交给专门的store管理，全局数据中心、 服务端渲染 服务端解析vue组件成html渲染首屏 速度 SEO nuxt.js Typescript+ Webpack 基础配置 性能优化，缩小搜索范围，DllPlugin，多进程、tree-shaking，代码抽取，按需加载 定制loader和plugin loader定义自己的转换规则 plugin 整个webpack工作流程定义，有一个apply方法获取compiler对象 loader单一职责，链式组合，模块化，无状态 plugin 修改输出资源 读取模块和依赖 监听文件变化 异步 浏览器 性能优化 抛开场景谈优化，就是耍流氓 常见性能优化策略,文件少加载，代码少执行，多用缓存，少计算， 性能如何分析 devtools代码打包压缩，图片压缩，gzip，缓存，cdn，SSR，框架对应的优化策略，lazy-load,节流防抖 服务端渲染 安全 常见漏洞，如何防御 XSS、CSRF、Cookie劫持、点击劫持 传输安全、接入层 Oauth 多端（Node，小程序，App） 微信小程序 测试 微服务 Node.js 监控 部署 自动化 云开发 RN flutter 小程序生态 nodejs Node核心概念 events，fs，stream，buffer IO，event-loop，线程池 libuv，V8 Node应用场景 Express、Koa等web开方 自动化，微服务 express/koa网站 前端工具 webpack/ gulp API/hapi 跨平台/ electron 区块链/ ipfs 命令行工具/ shell.js Express/koa代理 硬件/ ruff 微服务 企业级框架eggj 实时/socket.io Event-loop 代码到底咋执行的 执行微任务 比如promise 同步代码，完事之后查询是否有异步 执行宏任务，setTimeout,SetImmediate,等 自动化测试 代码的健壮性，改代码不再胆战心惊 E2E测试Puppeteer，代码覆盖率istanbul 单元测试，mocha，jest ，jasmine 测试驱动开发TDD，先写测试，再写代码 前端监控 对运行状况了然于胸 前端错误监控 onerror Sentry 前端性能监控 性能参数 berserkJS 屏幕补货，网络监控 上报 img 的src 浏览器 最重要的一端 缓存机制 性能优化重要策略 memory cache，disk cache 网络请求，强缓存弱缓存 如何渲染的 收到html=》解析dom树 css =&gt; css 树 和dom结合 形成render tree 开始渲染 少操作dom，重绘回流 输入url发生了啥 部署 项目总要上线 Nginx Pm2 Docker + 自动化 特殊场景 不算通用能力，但是特殊业务需求 可视化 echarts (canvas)，d3(svg)，three.js(webgl) 小游戏 PS切图 软件工程师 算法 排序 搜索 遍历 贪婪 动态规划 编译原理 设计模式 网络协议 数据库 数据结构 数组、字符串、队列、堆、链表 二叉树 图 软件工程 数学基础 编码 网络协议 IP TCP/UDP HTTP / HTTPS / SSH / FTP 设计模式 常见设计模式，单例，装饰器，代理，观察者，发布订阅 前端常用的设计模式 如何使用、不要滥用 数据库 Mysql 关系型数据库，多表join Mongodb json数据库 Redis 内存数据库 速度快 面试题 跨域方案 强缓存弱缓存 输入url发生啥 DNS解析 ， 三次握手，建立链接 接受相应，查库查文件，等待数据返回，拼接响应报文 浏览器接受报文，解析html 渲染页面 渲染原理 业余干啥 可访问性 箭头函数优点 前后端分离JWT 垃圾回收 基础vuejs 组件通讯 prop 父组件通过 Prop 往子组件传递数据 Prop 让组件更加灵活 不要直接修改 Prop event 子组件往当前实例上派发事件 子组件在父组件中使用，可以监听到该事件，并做出响应 golbal event bus 非父子组件通讯 可以基于新的 Vue 实例实现 Vuex 非父子组件通讯（数据共享） 数据状态管理 插槽 普通插槽 组件的实现更加灵活 内容分发 插槽访问的数据作用域是父组件 作用域插槽 插槽可以访问到子组件中的数据 过度动画 触发条件 Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡： 条件渲染 (使用 v-if) 动态组件 条件展示 (使用 v-show) 组件根节点 过渡类名 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 &lt;transition&gt;，则 v- 是这些类名的默认前缀。如果你使用了 &lt;transition name=&quot;my-transition&quot;&gt;，那么 v-enter 会替换为 my-transition-enter v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时v-enter 被移除)，在过渡/动画完成之后移除。 v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to：定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除 JavaScript 钩子 可以在属性中声明JavaScript 当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用done 进行回调。否则，它们将被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=&quot;false&quot;，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 DOM操作 操作CSS 某些交互可以通过手动操作CSS 做精细的控制 配合原生JS库使用 与原生 JS 库配合使用，再做一层 Vue 化的封装 cube-ui 对 better-scroll 的封装 element-ui 对 popper.js 的封装 组件封装 就近管理 单文件开发 依赖的静态资源放在同级目录 相关联组件也放在同级目录 分层设计 通过分层设计的思想设计复杂组件 高度复用 页面级别的复用（基础组件） 项目级别的复用 —私有组件库（业务组件） 公司级别的复用 —开源组件库（element-ui、cube-ui） 灵活扩展 组件设计要尽量灵活可扩展，除了提供丰富的 Props，还可以利用 slot插槽完成用户个性化定制需求） Keep-alive 使用场景 保留组件状态或避免重新渲染 可以配合路由组件使用 生命周期 activated：组件激活时触发 deactivate：组件失活时触发 内存泄漏 产生的原因 未清理的定时器 未清理的全局注册的自定义事件 未清理的全局注册的 DOM 事件 如何避免 编写组件要有相关意识 检查是否有上述造成内存泄漏的可能 利用 beforeDestroy 生命周期函数，做对应的内存清理工作 错误回调 常见的错误 深层对象数据访问问题 对计算属性赋值 对 Prop 直接修改 使用了未注册的组件 调试工具 Chrome 开发者工具，学会查找错误堆栈 vue-devtools https://github.com/vuejs/vue-devtools vConsole https://github.com/Tencent/vConsole 性能优化 数据定义 不需要把所有的数据都定义在 data 上，可以直接挂载到实例上 按需加载 对于首次渲染，我们只需要加载首屏渲染所需的资源，其他资源可以异步按需加载。这样可以减少首屏加载的资源包大小，加速渲染 异步组件 异步组件——比如我们使用一些图标库，如 echart，我们可以考虑做成异步组件，单独打包 异步路由 异步路由——比如单页应用，我们的导航切换是基于路由切换，那么其他页面可以考虑做成异步路由 预渲染 由于基于 Vue.js 的单页应用是由 Vue.js 渲染页面，所以页面下载后到渲染会有一定白屏时间 我们可以不依赖 JS，在页面下载后先渲染一张 Loading图片或者是骨架屏结构 当主页面渲染时，把这张占位图片或者结构隐藏 用户看到的不是白屏，有等待预期 后编译 编译代码冗余？ 依赖包本身不编译，它的编译交给应用来做。通过修改 webpack 配置 rules 中的 include 后编译依赖嵌套？ webpack-post-compile-plugin需要后编译的依赖包在 package.json 中声明&quot;postCompile&quot;: true 性能优化 一份编译代码 主题定制 一份 ployfill rem布局 NPM包无需编译发布 深入理解Vue.js Vue.js渲染原理 响应式实现原理 组件化实现原理 前端工程 脚手架 Vue-cli 3.0 是一个基于 Vue.js 进行快速开发的完整系统 通过 @vue/cli 搭建交互式的项目脚手架 通过 @vue/cli + @vue/cli-service-global 快速开始零配置原型开发 一个运行时依赖 (@vue/cli-service) 一个丰富的官方插件集合，集成了前端生态中最好的工具。 一套完全图形化的创建和管理 Vue.js 项目的用户界面 插件化机制 Vue CLI 使用了一套基于插件的架构。在项目创建的过程中，绝大部分列出的特性都是通过插件来实现的 插件可以帮助我们生成初始化代码， 安装指定的依赖包 webpack 配置 调整 webpack 配置最简单的方式就是在 vue.config.js中的 configureWebpack 选项提供一个对象 因为 @vue/cli-service 对 webpack 配置进行了抽象，所以理解配置中包含的东西会比较困难，可以通过下面命令查看 webpack 配置vue inspect &gt; output.js webpack 现代 JavaScript 应用程序的静态模块打包器 module 开发者将程序分解成离散功能块（discrete chunks offunctionality），并称之为模块 每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的 前端模块化面对的挑战 —处理JS之外的静态资源、资源的依赖关系加载顺序、资源的请求和加载是异步的 ES2015 import 语句 CommonJS require() 语句 AMD define 和 require 语句 css/sass/less 文件中的 @import 语句 样式(url(...))或 HTML 文件(&lt;img src=...&gt;)中的图片链接(image url) entry 入口起点(entry point)指示 webpack应该使用哪个模块，来作为构建其内部依赖图的开始，webpack会找出有哪些模块和 library是入口起点（直接和间接）依赖的 多入口：数组结构 多入口：对象结构 多页面应用程序 output 配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。即使可以存在多个入口起点，也只指定一个输出配置 如果配置创建了多个单独的 “chunk”，则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 线上运行时需要通过设置 public path 指向 CDN 地址 loader loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件 Typescript -&gt; JavaScript Image -&gt; data URL JavaScript import CSS loader 支持链式传递 loader 可以是同步的，也可以是异步的 loader 运行在 Node.js 中，并且能够执行任何可能的操作 loader 能够使用options 对象进行配置 babel-loader 加载ES2015+ 代码，然后使用 Babel 转译为 ES5 style-loader 将模块的导出作为样式添加到 DOM 中 css-loader 解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码 less-loader 加载和转译 LESS 文件 file-loader 将文件发送到输出文件夹，并返回（相对）URL url-loader 像 file loader 一样工作，但如果文件小于限制，可以返回 data URL vue-loader 加载和转译 Vue 组件 plugins 插件比 loader 更加强大，可以帮助用户直接触及到编译过程。 插件可以将处理函数注册到编译过程中的不同时间点上运行的生命周期钩子函数上。 打包优化 资源管理 注入环境变量 CommonsChunkPlugin 提取 chunks 之间共享的通用模块 DefinePlugin 允许在编译时(compile time)配置的全局常量 ExtractTextWebpackPlugin 从 bundle 中提取文本（CSS）到单独的文件 UglifyjsWebpackPlugin 使用 UglifyJS 压缩 JS HtmlWebpackPlugin 创建HTML文件来服务打包文件 开发&amp;部署 开发阶段 需求阶段 前后端共同参与产品需求评审，并做一轮技术评审 技术评审过程中，梳理所有交互通讯的接口 把接口落地成文档，并约定好所有字段 开发阶段 前后端独立开发 前端伪造 mock 数据 可以使用 mock webpack 插件 联调阶段 预留联调的时间 前后端开发完成后开始联调 前端把接口请求指向后端的联调地址（可自动完成） 上线阶段 前端把接口请求指向后端的线上地址（可自动完成） 一定要后端先上线 部署流程 预留联调的时间后端先上线 API 接口（若需要） 前端项目最终编译生成静态资源文件（HTML、JS、CSS 等） 增量发布，前端先全量上线 JS、CSS 等静态资源 前端接着上线模板 HTML，先发布到一台 pre 机器，QA 回归 回归通过后，逐步放量模板直至全量 知识点 HTPP相关 常见 HTTP 状态码 浏览器缓存原理 抓包工具（fiddler、charles） 跨域 CORS JSONP 性能优化 性能监测：https://github.com/GoogleChrome/lighthouse 数据埋点 雅虎军规：https://developer.yahoo.com/performance/rules.html、https://juejin.im/post/5b73ef38f265da281e048e51 Web安全 XSS CSRF HTTPS https://zhuanlan.zhihu.com/p/561228 数据结构&amp;算法 栈/队列/树/ 图 排序/递归 算法设计技巧 浏览器渲染原理 https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/ 正则表达式 匹配原理 基本语法 实用技巧 设计模式 订阅发布模式 工厂模式 适配器模式 后端语言 PHP JAVA Node.js]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[参考： 类型检测 浅谈 instanceof 和 typeof 的实现原理 在JavaScript中，如何判断数组是数组？ 分类基本数据类型Number、String、Boolean、Undefined、NullNumber Number类型包含整数和浮点数（浮点数数值必须包含一个小数点，且小数点后面至少有一位数字）两种值。NaN: 非数字类型。特点：① 涉及到的任何关于NaN的操作，都会返回NaN ②NaN不等于自身。isNaN() 函数用于检查其参数是否是非数字值。isNaN(123) //false isNaN(&quot;hello&quot;) //trueString 字符串有length属性。字符串转换：转型函数String(),适用于任何数据类型（null,undefined 转换后为null和undefined）；toString()方法（null,defined没有toString()方法）。Boolean 该类型只有两个值，true和falseUndefined 只有一个值，即undefined值。使用var声明了变量，但未给变量初始化值，那么这个变量的值就是undefined。Null null类型被看做空对象指针，前文说到null类型也是空的对象引用。 复杂数据类型Object Object本质上是由一组无序的名值对组成的。 js中对象是一组属性与方法的集合。这里就要说到引用类型了，引用类型是一种数据结构，用于将数据和功能组织在一起。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。 引用类型Object、Array、Function、Date、RegExp等 基本类型与引用类型基本类型又叫原始类型（primitive type）栈：原始数据类型（Undefined，Null，Boolean，Number、String）堆：引用数据类型（Object、Array、Function）两种类型的区别是 存储位置不同： 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 变量 ECMAScript中用var关键字来定义变量，因为js是弱类型的，所以无法确定变量一定会存储什么值，也就不知道变量到底会是什么类型，而且变量的类型可以随时改变。这就是ECMAScript是松散类型的来由，所谓松散类型就是可以用来保存任何类型的数据。ps:es6中新增了let命令来声明变量、const命令声明一个只读的常量。let的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。const一旦声明，常量的值就不能改变。 类型检测typeof、Object.prototype.toString() typeof typeof返回一个表示数据类型的字符串，返回结果包括：number、boolean、string、symbol、object、undefined、function等7种数据类型，但不能判断null、array等。12345678910typeof Symbol(); // symbol 有效typeof ''; // string 有效typeof 1; // number 有效typeof true; //boolean 有效typeof undefined; //undefined 有效typeof new Function(); // function 有效typeof null; //object 无效typeof [] ; //object 无效typeof new Date(); //object 无效typeof new RegExp(); //object 无效 instanceof instanceof 主要的作用就是判断一个实例是否属于某种类型。是用来判断A是否为B的实例，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，但它不能检测null 和 undefined。 12345678[] instanceof Array; //true# 在数组的原型链上也能找到Object构造函数[] instanceof Object;//true&#123;&#125; instanceof Object;//truenew Date() instanceof Date;//truenew RegExp() instanceof RegExp//truenull instanceof Null//报错undefined instanceof undefined//报错 123let person = function () &#123;&#125;let nicole = new person()nicole instanceof person // true instanceof 实现原理123456789101112131415function new_instance_of(leftVaule, rightVaule) &#123; // 取右表达式的 prototype 值 let rightProto = rightVaule.prototype; // 取左表达式的__proto__值 leftVaule = leftVaule.__proto__; while (true) &#123; if (leftVaule === null) &#123; return false; &#125; if (leftVaule === rightProto) &#123; return true; &#125; leftVaule = leftVaule.__proto__ &#125;&#125; 其实 instanceof 主要的实现原理就是只要右边变量的prototype在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。 constructor constructor作用和instanceof非常相似。但constructor检测 Object与instanceof不一样，还可以处理基本数据类型的检测。123let a = []console.log(a.constructor);// ƒ Array() &#123; [native code] &#125; 不过函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写，在重写的过程中很有可能出现把之前的constructor给覆盖了，这样检测出来的结果就是不准确的。12345678910//定义一个数组const a = [];//作死将constructor属性改成了别的a.contrtuctor = Object;console.log(a.constructor == Array);//false (哭脸)console.log(a.constructor == Object);//true (哭脸)console.log(a instanceof Array);//true (instanceof火眼金睛) 可以看出，constructor属性被修改之后，就无法用这个方法判断数组是数组了，除非你能保证不会发生constructor属性被改写的情况，否则用这种方法来判断数组也是不靠谱的。 Object.prototype.toString.call() toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]]。这是一个内部属性，其格式为 [object xxx] ，其中 xxx 就是对象的类型。12345678910var gettype=Object.prototype.toString;gettype.call('aaaa') 输出 [object String]gettype.call(2222) 输出 [object Number]gettype.call(true) 输出 [object Boolean]gettype.call(undefined) 输出 [object Undefined]gettype.call(null) 输出 [object Null]gettype.call(&#123;&#125;) 输出 [object Object]gettype.call([]) 输出 [object Array]gettype.call(function()&#123;&#125;) 输出 [object Function] 用Array对象的isArray方法判断 当参数为数组的时候，isArray方法返回true，当参数不为数组的时候，isArray方法返回false。1234const a = [];const b = &#123;&#125;;Array.isArray(a);//trueArray.isArray(b);//false 我试着在调用这个方法之前重写了Object.prototype.toString方法：12345Object.prototype.toString = ()=&gt;&#123; console.log('Hello Howard');&#125;const a = [];Array.isArray(a);//true 并不影响判断的结果。我又试着修改了constructor对象：1234const a = [];const b = &#123;&#125;;a.constructor = b.constructor;Array.isArray(a);//true OK，还是不影响判断的结果。 可见，它与instance运算符判断的方法以及Object.prototype.toString法并不相同，一些列的修改并没有影响到判断的结果。 Array.isArray是ES5标准中增加的方法，部分比较老的浏览器可能会有兼容问题，所以为了增强健壮性，建议还是给Array.isArray方法进行判断，增强兼容性，重新封装的方法如下：12345if (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === '[object Array]'; &#125;;&#125; 封装可以分辨所有数据类型的方法123456789101112131415161718192021222324252627var typeName = &#123; '[object Function]': 'function', '[object Boolean]': 'boolean - object', '[object Number]': 'number - object', '[object String]': 'string - object', '[object Object]': 'object', '[object RegExp]': 'regExp', '[object Array]': 'array', '[object Error]': 'error', '[object Date]' : 'date' &#125;;//获取Object的toString方法，通过call调用var toStringFn = Object.prototype.toString;function checkType(obj)&#123; if( obj == null )&#123; //js自带的的String方法，用于检测null和undefined return String( obj ); &#125; //safari5及之前版本，Chrome7, typeof RegExp返回的是function return typeof obj === 'object' || typeof obj === 'function' ? typeName[toStringFn.call(obj)]:typeof obj;&#125;// 调用函数checkType("123")]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[媒体查询]]></title>
    <url>%2F2019%2F03%2F26%2FCSS3%2F%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[css的媒体查询允许通过@media标签为特定媒体的浏览器设定样式，其中包含众多筛选，功能强大。 定义 HTML4和CSS2支持为不同的媒体类型指定专用的样式表，screen和print, projection是已定义的媒体类型媒体查询由 媒体类型 和 一个或多个检测媒体特性的的条件表达式组成。相对于CSS2只支持对媒体类型进行判断，媒体查询增加了媒体特性的判断，能够更准确地根据设备特性指定专用的样式。 语法逻辑123456789# 和and# 也就是 or 的逻辑,# 对查询结果取反not# only操作符仅在媒体查询匹配成功的情况下被用于应用一个样式，# 这对于防止让选中的样式在老式浏览器中被应用到。only 使用语法 媒体查询包含一个可选的媒体类型和媒体特性表达式(0或多个)最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示文档所使用的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。1234567891011# link元素中的CSS媒体查询&lt;link rel="stylesheet" media="(max-width: 800px)" href="example.css" /&gt;# 样式表中的CSS媒体查询&lt;style&gt;@media (max-width: 600px) &#123; .facet_sidebar &#123; display: none; &#125;&#125;&lt;/style&gt; 使用媒体类型12&lt;link rel="stylesheet" type="text/css" href="site.css" media="screen" /&gt;&lt;link rel="stylesheet" type="text/css" href="print.css" media="print" /&gt; media 属性定义了应该用于指定每种媒体类型的样式表： screen 适用于计算机彩色屏幕。 print 适用于打印预览模式下查看的内容或者打印机打印的内容。 作为 CSS v3 规范的一部分，可以扩展媒体类型函数，并允许在样式表中使用更精确的显示规则。媒体查询 是评估 True 或 False 的一种表达。如果为 True，则继续使用样式表。如果为 False，则不能使用样式表。这种简单逻辑通过表达式变得更加强大，使您能够更灵活地对特定的设计场景使用自定义的显示规则。 媒体查询规则@media all and (min-width: 800px) { ... }@media all 是媒体类型，也就是说，将此 CSS 应用于所有媒体类型(min-width:800px) 是包含媒体查询的表达式，如果浏览器的最小宽度为 800 像素，则会告诉浏览器只运用下列 CSS。请注意:可以省略关键词 all 和 and。在将某个媒体查询应用于所有媒体类型时，会省略all。后面的 and 也是可选的。使用简写语法重新编写媒体查询 简写语法@media (min-width:800px) { ... } 复杂表达式创建一个仅在最小宽度为 800 像素且最大宽度为 1200 像素时应用的样式@media (min-width:800px) and (max-width:1200px) { ... } and 条件在您的表达式中，您可以根据自己的喜好使用任意数量的 and 条件。如果您想要增加其他条件来检查特定的屏幕方向，只需添加另一个 and 关键词，后跟 orientation 媒体查询.@media (min-width:800px) and (max-width:1200px) and (orientation:portrait) { ... }仅在宽度为 800 到 1200 像素且方向是纵向时才能激活. or 关键词and 关键词的反义词是 or 关键词。和 and 一样，这些条件组合在一起会构成复杂表达式。如果其中有一个条件为 True，那么整个表达式或分离的两个条件都会为 True，如清单 6 所示。@media (min-width:800px) or (orientation:portrait) { ... }如果宽度至少是 800 像素或方向是纵向的，则会应用该规则。 使用 not@media not all and (min-width: 800px) { ... }@media not (all and (min-width: 800px)) { ... }当最小宽度不是 800 像素时，会应用下列 CSS 规则。这些示例只是将像素作为媒体查询中的测量单位，但是测量单位并不仅限于像素。您可以使用任何有效的 CSS 测量单位，比如厘米 (cm)、英寸 (in)、毫米 (mm) 等。 only@media only (min-width: 300px) { ... } 有用的媒体特性orientation 媒体查询方向： orientation值为：横排方向（ landscape）竖排方向（portrait）@media (orientation: portrait) { ... }高度和宽度行为十分相似，都支持以 min- 和 max- 为前缀 高度和宽度媒体查询@media (min-width:800px) and (min-height:400px) { ... } 不带 min- 和 max- 前缀@media (width:800px) and (height:400px) { ... } 媒体属性特征12前缀`min-`表示“至少”，即“大于等于”的意思。前缀`max-`表示“至多”，即“小于等于”的意思。 12345678910111213width: 视口宽度height: 视口高度device-width: 渲染表面的高度(设备高度)device-height: 渲染表面的宽度(设备宽度)orientation: 检测设备是处于横向(landscape)还是纵向(portrait)aspect-ratio: 基于视口宽度和高度的宽高比device-aspect-ratio: 基于设备渲染表面的宽度和高度的宽高比color: 每种颜色的位数color-index: 设备的颜色索引表中的颜色数monochrome: 检测单色帧缓冲区中每像素所使用的位数resoluion: 用来检测屏幕和打印机的分辨率,dpi/dpcmscan: 电视机的扫描方式,逐行扫描(progressive)或隔行扫描(interlace)grid: 用来检测输出设备是网格设备还是位图设备 参考： 使用 CSS 媒体查询创建响应式网站 CSS媒体查询]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mate标签]]></title>
    <url>%2F2019%2F03%2F26%2FH5%2Fmate%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[转载: 2018前端面试总结，看完弄懂，工资少说加3K | 掘金技术征文参考: 移动前端开发之viewport的深入理解&lt;mate&gt;标签: 提供页面的元信息但和内容无关，元数据可以被浏览器、搜索引擎和其他web服务器使用。 mate两种属性：http-equiv和name http-equiv 相当于HTTP头 content-type 定义文档的字符集 &lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; expires网页到期时间 &lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri, 12 Jan 2001 18:18:18 GMT&quot;&gt; X-UA-Compatible 浏览器采取何种版本渲染当前页面 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; 指定IE和Chrome使用最新版本渲染当前页面 cache-control 指定请求和响应遵循的缓存机制 refresh 自动刷新，病指向某个页面 &lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2; URL=http://www.root.net&quot;&gt; set-cookie 设置cookie &lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx; expires=Friday, 12-Jan-2001 18:18:18 GMT; path=/&quot;&gt; cleartype只对IE有用，用于平滑字体,不推荐使用 &lt;!--[if IEMobile]&gt;&lt;meta http-equiv=&quot;cleartype&quot; content=&quot;on&quot;&gt;&lt;![endif]--&gt;`name 描述网页 author 作者 &lt;meta name=&quot;author&quot; content=&quot;xx@xx&quot;&gt; description 描述，网站主要内容 &lt;meta name=&quot;description&quot; content=&quot;This page is about&quot;&gt; keywords 关键字，搜索引擎会使用这些关键字分类 &lt;meta name =&quot;keywords&quot; content=&quot;science, education&quot;&gt; renderer 双核浏览器渲染方式，指定以哪种渲染方式 &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; viewport视口，定义设备的大小 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; HandheldFriendly针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;True&quot;&gt; MobileOptimized 微软为IE Mobile版设置的定义宽度标记 &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt; apple-mobile-web-app-capable 是否启动webapp功能（全屏），会删除默认的苹果工具栏和菜单栏。 apple-mobile-web-app-capable &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; apple-mobile-web-app-status-bar-style 当启动webapp功能时，手机顶部导航栏的颜色 &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt; apple-mobile-web-app-title 添加到主屏后的标题 &lt;meta name=&quot;apple-mobile-we-app-title&quot; content=&quot;&quot;&gt; format-detection 格式检测，识别页面中的电话号码 &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; format-detection 格式检测，识别页面中的email &lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;&gt; viewPort|属性|作用||—-|—–||width| 设置layout viewport 的宽度，为一个正整数，或字符串”width-device”||initial-scale| 设置页面的初始缩放值，为一个数字，可以带小数||minimum-scale| 允许用户的最小缩放值，为一个数字，可以带小数||maximum-scale| 允许用户的最大缩放值，为一个数字，可以带小数||height | 设置layout viewport 的高度，这个属性对我们并不重要，很少使用||user-scalable | 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许| 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# H5标准声明，使用 HTML5 doctype，不区分大小写&lt;!DOCTYPE html&gt;# 标准的 lang 属性写法&lt;head lang=”en”&gt;# 声明文档使用的字符编码&lt;meta charset=’utf-8′&gt;# 优先使用 IE 最新版本和 Chrome&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; # 页面描述&lt;meta name=”description” content=”不超过150个字符”/&gt;# 页面关键词&lt;meta name=”keywords” content=””/&gt;# 网页作者&lt;meta name=”author” content=”name, email@gmail.com”/&gt;# 搜索引擎抓取&lt;meta name=”robots” content=”index,follow”/&gt;# 为移动设备添加 viewport&lt;meta name=”viewport” content=”initial-scale=1,maximum-scale=3, minimum-scale=1, user-scalable=no”&gt;# iOS 设备 begin&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt;# 添加到主屏后的标题（iOS 6 新增）&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt;# 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, 1affiliate-data=myAffiliateData, app-argument=myURL”&gt;# 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;# 设置苹果工具栏颜色&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt; # 启用360浏览器的极速模式(webkit)&lt;meta name=”renderer” content=”webkit”&gt; # 避免IE使用兼容模式&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt;# 不让百度转码&lt;meta name=”HandheldFriendly” content=”true”&gt;# 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt;# 微软的老式浏览器&lt;meta name=”MobileOptimized” content=”320″&gt;# uc强制竖屏&lt;meta name=”screen-orientation” content=”portrait”&gt;# QQ强制竖屏&lt;meta name=”x5-orientation” content=”portrait”&gt;# UC强制全屏&lt;meta name=”full-screen” content=”yes”&gt;# QQ强制全屏&lt;meta name=”x5-fullscreen” content=”true”&gt;# UC应用模式&lt;meta name=”browsermode” content=”application”&gt;# QQ应用模式&lt;meta name=”x5-page-mode” content=”app”&gt;# windows phone 点击无高光&lt;meta name=”msapplication-tap-highlight” content=”no”&gt;设置页面不缓存&lt;meta http-equiv=”pragma” content=”no-cache”&gt;&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;&lt;meta http-equiv=”expires” content=”0″&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F25%2FHTTP%2FTCP%E3%80%81UDP%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E3%80%81DNS%2F</url>
    <content type="text"><![CDATA[转载： 一篇文章搞定前端面试 TCPUDP套接字socketHTTP协议DNS解HTTP请求发起和响应页面渲染的过程页面的性能优化]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F25%2FJavaScript%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一行代码实现数组去重？[...new Set([1,2,3,1,&#39;a&#39;,1,&#39;a&#39;])]怎么判断两个对象相等？12345678910111213141516obj=&#123; a:1, b:2&#125;obj2=&#123; a:1, b:2&#125;obj3=&#123; a:1, b:&apos;2&apos;&#125;JSON.stringify(obj)==JSON.stringify(obj2);//trueJSON.stringify(obj)==JSON.stringify(obj3);//false CommonJS 中的 require/exports 和 ES6 中的 import/export 区别？ CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。import/export 最终都是编译为 require/exports 来执行的。CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 浏览器缓存浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下： 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；区别是，强缓存不对发送请求到服务器，但协商缓存会。当协商缓存也没命中时，服务器就会将资源发送回客户端。当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存； 强缓存 Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒） 协商缓存 Last-Modified（值为资源最后更新时间，随服务器response返回）If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）ETag（表示资源内容的唯一标识，随服务器response返回）If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存） 页面渲染的完整流程是怎样的？ 图片里的 alt 属性是做什么的？查看答案如果用户看不到图像，alt 属性可以提供替代信息。alt 属性应该用于描述，而那些仅仅是装饰目的图像，可以为空 小贴士装饰性的图像应该有一个空的 alt 属性web 爬虫可以通过 alt 属性理解图像的信息，因此认为它对于搜索引擎优化（SEO）非常重要在 alt 末尾加 . 可以提高访问性 不采用缓存的目的是什么，你如何实现它？查看答案浏览器有一个临时的存储网站文件的缓存，所以他们不需要在切换或重新加载同一个页面时再次重新下载。服务器设置发送头信息告诉浏览器在给定的一段时间内使用存储文件。这极大加快了网站的速度和节省了带宽 然而，当开发人员网站更新时，因为用户的缓存依然指向旧的文件，这会造成问题。如果缓存的 CSS 和 JavaScript 文件引用的元素不再存在，已移除或已重命名时，它会保留原有功能或破坏网站 禁用缓存是一个强制浏览器下载新文件的过程。通过命名来区分于旧文件 一个常用的强制浏览器重新下载文件的技术是在文件的结尾处增加一个查询字符串 src=”js/script.js” =&gt; src=”js/script.js?v=2”浏览器认为这是一个不同的文件但是避免了修改文件名的必要 一个页面里是否可以包含多个 元素， 元素呢？查看答案都可以。W3C 文档声明这些标签代表离它们最近祖先区域的页眉（）和页脚（）。因此，不只是可以在页面的 里包含页眉和页脚，而且每一个 和 元素都可以包含 小贴士W3C 推荐你想用多少就用多少，但是每一个页面的区域只能有一个，即，body，section 等等 &lt;script&gt; 标签的 defer 和 async 是什么？查看答案如果两个属性都没有的话，脚本将同步下载和执行，并且会阻塞 document 解析，直到脚本执行完成（默认行为）。脚本下载和执行按它们书写的顺序进行 defer 属性在 document 解析的过程中下载脚本，但是在 document 解析完成之前执行，等价于执行了一个内置的事件监听器 DOMContentLoaded。defer 脚本顺序执行 async 属性在 document 解析过程中下载脚本，但是会暂停解析器，直到脚本解析执行完成。async 不一定按顺序执行 注意：两个属性必须在脚本拥有 src 属性时才起作用（即，在内联脚本不起作用） 小贴士请用 中放置一个 defer，允许浏览器在页面还在解析过程中下载脚本，因此把脚本放到 body 之前是更好的选择如果脚本之间相互依赖，请用 defer.如果脚本是独立的，请用 async.如果 DOM 必须加载完并且内容还未放置到 DOMContentLoaded 监听器中时，请用 defer 相比 HTML，XHTML 有哪些不同？查看答案有一些关键区别： 一个 XHTML 元素必须要有一个 XHTML 属性值必须用引号包裹禁止属性简写（例如，checked=”checked” 不能简写为 checked）元素必须正确的被嵌套元素必须闭合特殊字符必须被转义小贴士任何被标签都是自闭合标签和属性区分大小写，通常小写 你能说出 @media 属性的四种类型吗？查看答案all，适用于所有媒体设备print，仅适用于打印机screen，仅适用于屏幕设备（台式电脑、平板电脑、移动设备等）speech，仅适用于屏幕阅读器 如何统计网页里出现多少种html标签12345678910111213141516171819# 获取所有标签var doms = document.getElementsByTagName("*")#去重var obj = &#123;&#125;var ret = []for (var j = 0; j &lt; doms.length; i++) &#123; var name = doms[j].nodeName if(!obj[name]) &#123; ret.push(name) obj[name] = true &#125;&#125;console.log(ret.length);# ES6方法const names = [...document.getElementsByTagName("*")].map(v=&gt;v.nodeName)console.log(new Set(names).size); 手写bind call1234567891011121314151617181920Function.prototype.call = function(context) &#123; context = context || window context.fn = this const args = [...arguments].slice(1) const result = context.fn(...args) delete context.fn return result&#125;Function.prototype.bind = function(context) &#123; const _this = this const args = [...arguments].slice(1) // 返回一个高阶函数 return function F() &#123; if(this instanceof F) &#123; return new _this(...args, ...arguments) &#125; return _this.apply(context, args.concat(...arguments)) &#125;&#125; 如何提升渲染性能服务端渲染为什么要进行服务端渲染 JS回收机制String、Array类型的方法使用原型与原型链构造函数模型/原型模型闭包/递归BOM操作BOM结构事件冒泡/捕获AJAX请求]]></content>
  </entry>
  <entry>
    <title><![CDATA[定位]]></title>
    <url>%2F2019%2F03%2F22%2FCSS3%2F%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[positionstatic表示没有定位，元素出现在正常的文档流中。为静态定位的元素设置 top|bottom|left|right 不起作用。fixed元素的位置相对于浏览器窗口是固定位置。即使浏览器的窗口是滚动的它也不会移动。fixed定位使得元素脱离了文档流，因而不占据空间。设置了固定定位的元素宽高由其内部元素撑起。relative相对定位的元素是相对其正常位置。1.使用了相对定位元素的元素，其参照物是其本身，其偏移量由TRBL(top，right,bottom,left)的值确定。2.使用了相对定位的元素，仍然会在标准流中占据原来的位置，它对父元素和兄弟元素没有影响。3.相对定位的使用场景往往是作为绝对定位元素的参照物。absolute绝对定位的元素的位置是相对其最近的已定位父元素（也就是除static之外），如果找不到已定位的父元素，那么就相对于&lt;html&gt;元素。absolute定位使得元素脱离了文档流，因而不占据空间。设置了绝对定位的元素宽高由其内部元素撑起。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F22%2FVue%2FVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[vue 生命周期 详解]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络安全(SQL、XSS、CSRF)]]></title>
    <url>%2F2019%2F03%2F21%2FJavaScript%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[转载： 3大Web安全漏洞防御详解：XSS、CSRF、以及SQL注入解决方案参考： 前端安全（XSS、CSRF防御） 用大白话谈谈XSS与CSRF常见的Web安全分为两种前端安全(XSS攻击、CSRF攻击)和后端安全(SQL注入) XSS攻击定义 XSS：中译是跨站脚本攻击（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码。 XSS攻击的危害 1. 盗取用户资料，比如：登录帐号、网银帐号等 2. 利用用户身份，读取、篡改、添加、删除数据等 3. 盗窃重要的具有商业价值的资料 4. 非法转账 5. 强制发送电子邮件 6. 网站挂马 7. 控制受害者机器向其它网站发起攻击 防止XSS的解决方法XSS的根源主要是没完全过滤客户端提交的数据 ，所以重点是要过滤用户提交的信息。 1. 将重要的cookie标记为http only, 这样的话js 中的document.cookie语句就不能获取到cookie了. 2. 只允许用户输入我们期望的数据。 例如：age用户年龄只允许用户输入数字，而数字之外的字符都过滤掉。 3. 对数据进行Html Encode处理：用户将数据提交上来的时候进行HTML编码，将相应的符号转换为实体名称再进行下一步的处理。 4. 过滤或移除特殊的Html标签。 5. 过滤js事件的标签。例如 &quot;onclick=&quot;, &quot;onfocus&quot;等等。 CSRF攻击定义 CSRF:跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 XSS主要是利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求，来利用受信任的网站。与XSS攻击相比，CSRF更具危险性。 CSRF攻击危害 主要的危害来自于，攻击者盗用用户身份，发送恶意请求。比如：模拟用户发送邮件，发消息，以及支付、转账等。 防止CSRF的解决方法 1. 重要数据交互采用POST进行接收，当然是用POST也不是万能的，伪造一个form表单即可破解。 2. 使用验证码，只要是涉及到数据交互就先进行验证码验证，这个方法可以完全解决CSRF。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。 3. 验证HTTP Referer字段，该字段记录了此次HTTP请求的来源地址，最常见的应用是图片防盗链。 4. 为每个表单添加令牌token并验证。 SQL注入定义 SQL注入是比较常见的网络攻击方式之一，主要是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，实现无帐号登录，甚至篡改数据库。 SQL注入的危害 1. 数据库信息泄漏：数据库中存放的用户的隐私信息的泄露 2. 网页篡改：通过操作数据库对特定网页进行篡改 3. 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改 4. 服务器被远程控制，被安装后门 5. 删除和修改数据库表信息 SQL注入的方式通常情况下，SQL注入的位置包括： 1. 表单提交，主要是POST请求，也包括GET请求; 2. URL参数提交，主要为GET请求参数; 3. Cookie参数提交; 4. HTTP请求头部的一些可修改的值，比如Referer、User_Agent等; 防止SQL注入的解决方法 1. 对用户的输入进行校验，使用正则表达式过滤传入的参数 2. 使用参数化语句，不要拼接sql，也可以使用安全的存储过程 3. 不要使用管理员权限的数据库连接，为每个应用使用权限有限的数据库连接 4. 检查数据存储类型 5. 重要的信息一定要加密]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F21%2FJavaScript%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Mvvm响应式原理？原型链？闭包？应用场景？Es6的新特性？Html大纲？Js数据类型，堆和栈的区别？Vue的diff算法？怎么样才算samenode（源码相关）？比较子节点的时候顺序比较行不行？用defineProperty进行数据劫持的缺点？怎么办（考察vue3.0数据劫持的方式proxy）？手写二分查找Css盒子模型？Express中间件？Symbol？作用？三面约的19：10，结果前面面试的同学太多了，到19：45才面上腾讯三面（电话，20min左右）： 从输入url到显示页面的过程？dns域名解析建立连接 三次握手发送 http请求服务器处理请求返回相应结果页面渲染 这个过程中有哪些会影响性能？ Es6有哪些了解？2.做过什么项目？3.了解es6吗4.promise原理5.了解什么算法？6.堆排序过程，时间复杂度（nlogn,他还让我再想一下？？），应用场景（没答出来，哭）。7.用过的技术栈8.怎么学习前端9.问题：公司主要用react，vue哪个，为什么用它呢？ 什么时候开始学习的前端？==和===的区别JS 继承（ES6 extends、ES5 各种继承）怎么判断参数是数组还是对象？（Array.isArray、toString、instanceOf）问项目，技术方案，话题转 VueVue 生命周期有哪些？（Create、Mount、Active、Update、Deactive、Destory）DOM 结点在什么时候挂载？Vue 能不能挂载到body或html标签上，为什么？项目开发联调方式？ 写一个两边定宽，中间自适应的布局（dispaly: flex、双飞翼/圣杯、position: absolute）垂直居中方案（line-height、transform）JS 怎么对象的属性是数组还是对象（参考一面第 8 问），解释下每个方法怎么判断（数组 Object.prototype.toString.call之后是[object, Array]，对象toString之后是[object, object]，instanceOf就是返回true还是false）JS 继承（ES6 extends、原型链、构造），解释下原型链和构造哪个好，好在哪里，原型链继承的时候，可不可以直接A.prototype = B()，而不是A.prototype = new B()，为什么构造继承为什么用call，而不是apply？（参数不同，一个数组，一个不定参数），追问哪个参数是数组？（apply）实现一个数组去重（Array.from(new Set(arr))），不用 ES6 实现一个对所有数组有可以调用的去重（forindexOf，添加到Array.prototype），面试官说i 跨域的方式websocket和Http的区别长轮询cookie和session，没有cookie的话session能不能使用浏览器缓存机制，304是协商缓存还是强缓存类数组变成数组let和var的区别CSRF以及Token验证的Token放在哪里TCP三次握手，如果没有三次握手会怎样Vue用watch实现数据双向绑定重绘和重排，什么操作会造成重排LESS怎么遍历一个列表await语法JS继承有哪几种，具体的实现及原理常见的HTTP状态码各个是什么意思介绍浏览器缓存？各个响应头优先级？以及之间的区别，可以取的值，分别是什么意思介绍浏览器时间介绍一下跨域，各个跨域的具体实现方法？以及JSONP实现方式中服务器是怎样交互的介绍一下网络安全（xss以及csrf具体防范方法） 行内元素和块级元素二者区别css选择器有哪些，怎么样计算JS面向对象的理解盒子模型，box-sizing常用的设计模式，封装一个函数判断数据类型，数组还是对象状态码404 400 502 304http底层协议http协议用在tcp还是udp三次握手，四次握手，两次握手，time wait 2ml 的原因浏览器缓存，硬盘（持久化）数据结构，快速排序，稳定的还是不稳定的。最差的时间复杂度内存存不下，很多个数据，找出最大的10个或者100个哈希操作系统 nio, i/o操作计算机组成原理，数据用什么码储存的，正负数的储存，负数的源码补码基址寻址和变址寻址get，post请求最本质的区别多路复用事件代理。常规做法的优势体现在哪里session。分布式集群，如何保障session可以保持相同浏览器cookie禁掉session是哪一端session特别多怎么办 进程和线层的区别内存分配闭包、作用域链vue生命周期css3动画，怎么做单行文本溢出，多行文本溢出代码实现bfc布局js类型，封装一个类型鉴定函数闭包，哪里用到立即执行函数解决闭包中访问变量的问题时间轮询机制原生js实现bind函数一个函数，然后让你说他们的值是多少，为什么预编译、严格模式、作用域链算法 快排 选择排序浏览器渲染原理 实现一个构造函数new的时候每次加一css性能优化 js作用域链怎么来的thiscdn有存在的必要吗]]></content>
  </entry>
  <entry>
    <title><![CDATA[主流浏览器内核]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[浏览器内核 浏览器内核可以分为两部分：渲染引擎(layout engineer 或者 Rendering Engine)和JS引擎 浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 渲染引擎 渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等）、以及计算网页的显示方式，然后会输出至显示器或打印机。 JS引擎 JS 引擎则是解析Javascript语言，执行javascript语言来实现网页的动态效果。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS引擎越来越独立，内核就倾向于只指渲染引擎。 主流浏览器内核Trident内核：IEGecko内核：NETSCAPE6及以上版本，火狐(Mozilla FireFox)Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink;]Webkit内核：Safari，Chrome等。Chrome的：Blink（WebKit的分支） 移动端移动端的浏览器内核主要说的是系统内置浏览器的内核。目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 。1、iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit。2、Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink。3、Windows Phone 8 系统浏览器内核是 Trident。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3新特性]]></title>
    <url>%2F2019%2F03%2F18%2FCSS3%2FCSS3%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[实现圆角border-radius，阴影box-shadow，边框图片border-image对文字加特效text-shadow，强制文本换行word-wrap，线性渐变linear-gradient实现旋转transform:rotate(90deg),缩放scale(0.85,0.90),定位translate(0px,-30px),倾斜skew(-9deg,0deg);增加了更多的CSS选择器、多背景、rgba()唯一引入的伪元素是::selection；实现媒体查询@media，多栏布局flex过渡transition动画animationtext-overflow(文本溢出隐藏)CSS3中，text-shadow可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。CSS3新增了几个关于背景的属性，分别是background-clip、background-origin、background-size和background-break。text-decoration:CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置： text-fill-color: 设置文字内部填充颜色 text-stroke-color: 设置文字边界填充颜色 text-stroke-width: 设置文字边界宽度]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Url、Href、Src、Link详解]]></title>
    <url>%2F2019%2F03%2F18%2FCSS3%2FUrl%E3%80%81Href%E3%80%81Src%E3%80%81Link%2F</url>
    <content type="text"><![CDATA[转载： url、href、src 详解 Url定义 URL(Uniform Resource Locator)统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 Url格式标准格式 协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名?查询完整格式 协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名?查询 Url语法规则 比如网址http://segmentfault.com/html/index.asp必须遵守以下的语法规则:scheme://host.domain:port/path/filename说明 scheme - 定义因特网服务的类型。最常见的类型是 http host - 定义域主机（http 的默认主机是 www） domain - 定义因特网域名，比如 w3school.com.cn :port - 定义主机上的端口号（http 的默认端口号是 80） path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称 URL Schemes Scheme 访问 用于 http 超文本传输协议 以 http:// 开头的普通网页。不加密。 https 安全超文本传输协议 安全网页。加密所有信息交换。 ftp 文件传输协议 用于将文件下载或上传至网站。 file 您计算机上的文件。 URL的类型绝对URL 绝对URL（absolute URL）显示文件的完整路径，这意味着绝对URL本身所在的位置与被引用的实际文件的位置无关。相对URL 相对URL（relative URL）以包含URL本身的文件夹的位置为参考点，描述目标文件夹的位置。 一般来说，对于同一服务器上的文件，应该总是使用相对URL，它们更容易输入，而且在将页面从本地系统转移到服务器上时更方便，只要每个文件的相对位置保持不变，链接就仍然是有效地。.：代表目前所在的目录，相对路径。例： &lt;a href=&quot;./abc&quot;&gt;文本&lt;/a&gt; 或 &lt;img src=&quot;./abc&quot; /&gt;..：代表上一层目录，相对路径。例： &lt;a href=&quot;../abc&quot;&gt;文本&lt;/a&gt;或 &lt;img src=&quot;../abc&quot; /&gt;../../：代表的是上一层目录的上一层目录，相对路径。例： &lt;img src=&quot;../../abc&quot; /&gt;/：代表根目录，绝对路径。例： &lt;a href=&quot;/abc&quot;&gt;文本&lt;/a&gt; 或 &lt;img src=&quot;/abc&quot; /&gt; Href定义 href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。 通俗理解 href: 目的不是为了引用资源，而是为了建立这个标签与外部资源之间的关系，让当前标签能够链接到目标地址。&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;浏览器加载到这里的时候，html的渲染和解析不会暂停，css文件的加载是同时进行的 Src src用于替代这个元素: &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个js文件 Href和Src的区别请求资源类型不同 href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。 在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；作用结果不同 href 用于在当前文档和引用资源之间确立联系； src 用于替换当前内容；浏览器解析方式不同 若在文档中添加 &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;/&gt;，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用@import 方式。 当浏览器解析到 &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。 Link和@import的区别两者都是外部引用 CSS 的方式，但是存在一定的区别：（1）link是XHTML标签，除了能够加载CSS，还可以定义RSS等其他事务；而@import属于CSS范畴，只可以加载CSS。（2）link引用CSS时，在页面载入时同时加载；@import需要页面完全载入以后再加载。（3）link是XHTML标签，无兼容问题；@import则是在CSS2.1提出的，低版本的浏览器不支持。（4）link支持使用Javascript控制DOM改变样式；而@import不支持。 为什么尽量不要使用@import加载css使用@import会导致和预期不一致的下载顺 序。我们确实要避免使用css @import，但原因却不是什么相当于放在了页面底部，而是这样做会导致css无法并行下载，因为使用@import引用的文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。 浏览器在页面所有css下载并解析完成后才会开始渲染页面（Before a browser can begin to render a web page, it mustdownload and parse any stylesheets that are required to lay out thepage. Even if a stylesheet is in an external file that is cached,rendering is blocked until the browser loads the stylesheet from disk.），因此css @import引起的css解析延迟会加长页面留白期。 所以，要尽量避免使用css @import而尽量采用link标签的方式引入。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源策略和跨域]]></title>
    <url>%2F2019%2F03%2F17%2FAjax%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[转载: ajax跨域，这应该是最全的解决方案了参考: 浏览器同源政策及其规避方法 跨域资源共享 CORS 详解 同源策略概念同源即指：协议相同、域名相同、端口号相同。举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。1234http://www.example.com/dir2/other.html：同源http://example.com/dir/other.html：不同源（域名不同）http://v2.www.example.com/dir/other.html：不同源（域名不同）http://www.example.com:81/dir/other.html：不同源（端口不同） 目的 同源政策的目的，是为了为了保证使用者信息的安全，防止恶意网站篡改用户数据。 设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的Cookie，会发生什么？ 很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。 由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 限制范围 随着互联网的发展，”同源政策”越来越严格。目前，非同源的网站之间，共有四种行为受到限制。1234（1） Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。（4）无法通过 flash 发送 http 请求 跨域 同源策略做了很严格的限制，但是在实际的场景中，又确实有很多地方需要突破同源策略的限制，也就是我们常说的跨域。 Cookie 同源策略最早被提出的时候，为的就是防止不同域名的网页之间共享 cookie。Cookie是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享Cookie。举个例子，https://market.douban.com和https://book.douban.com，这两个网页的一级域名都是 douban.com，如果我在 market.douban.com中执行了12345678#A、B页面设置相同的document.domaindocument.domain = 'douban.com'# A页面通过脚本设置一个Cookiedocument.cookie = 'cross=yes'或document.cookie = 'cross=yes;path=/;domain=douban.com'# B页面就可以读取到Cookievar allCookie = document.cookie 这样设置了 cookie之后，在book.douban.com中是可以取到这个cookie的。除了在前端设置之外，也可以直接在response里将cookie的domain设置成 .douban.com。 Ajax什么是Ajax跨域ajax跨域的原理 ajax出现请求跨域错误问题,主要原因就是因为浏览器的“同源策略”,可以参考 ajax跨域的表现 ajax请求时,如果存在跨域现象,并且没有进行解决,会有如下表现:(注意，是ajax请求，请不要说为什么http请求可以，而ajax不行，因为ajax是伴随着跨域的，所以仅仅是http请求ok是不行的)第一种现象:No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且The response had HTTP status code 404出现这种情况的原因如下： 本次ajax请求是“非简单请求”,所以请求前会发送一次预检请求(OPTIONS) 服务器端后台接口没有允许OPTIONS请求,导致无法找到对应接口地址解决方案: 后端允许options请求第二种现象:No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且The response had HTTP status code 405这种现象和第一种有区别,这种情况下，后台方法允许OPTIONS请求,但是一些配置文件中(如安全配置),阻止了OPTIONS请求,才会导致这个现象解决方案: 后端关闭对应的安全配置第三种现象:No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且status 200这种现象和第一种和第二种有区别,这种情况下，服务器端后台允许OPTIONS请求,并且接口也允许OPTIONS请求,但是头部匹配时出现不匹配现象比如origin头部检查不匹配,比如少了一些头部的支持(如常见的X-Requested-With头部),然后服务端就会将response返回给前端,前端检测到这个后就触发XHR.onerror,导致前端控制台报错解决方案: 后端增加对应的头部支持第四种现象:heade contains multiple values &#39;*,*&#39;表现现象是，后台响应的http头部信息有两个Access-Control-Allow-Origin:*说实话，这种问题出现的主要原因就是进行跨域配置的人不了解原理，导致了重复配置，如:常见于.net后台(一般在web.config中配置了一次origin,然后代码中又手动添加了一次origin(比如代码手动设置了返回*))常见于.net后台(在IIS和项目的webconfig中同时设置Origin:*)解决方案(一一对应): 建议删除代码中手动添加的*，只用项目配置中的即可 建议删除IIS下的配置*，只用项目配置中的即可 如何解决ajax跨域 一般ajax跨域解决就是通过JSONP解决或者CORS解决,如以下:(注意，现在已经几乎不会再使用JSONP了，所以JSONP了解下即可) JSONPjsonp 其实算是一种 hack 形式的请求。jsonp 的本质其实是请求一段 js 代码，是对静态文件资源的请求，所以并不遵循同源策略。但是因为是对静态文件资源的请求，所以只能支持 GET 请求，对于其他方法没有办法支持。 设置CORS CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。本文详细介绍CORS的内部机制。 CORS简介 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 CORS两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。12345678910111213（1）请求方法是以下三种方法之一： HEAD GET POST（2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、 multipart/form-data、 text/plain 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 CORS简单请求对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin(protocal + host + path + port)字段,来标明这个请求是来自哪里。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。1234567GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...` 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。（1）Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。（2）Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。（3）Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。Access-Control-Allow-Credentials: true另一方面，开发者必须在AJAX请求中打开withCredentials属性。12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 CORS非简单请求与简单请求最大的不同在于，非简单请求实际上是发送了两个请求。预请求首先，在正式请求之前，会先发送一个预请求(preflight-request)，这个请求的作用是尽可能少的携带信息，供服务端判断是否响应该请求。浏览器浏览器发送预请求，请求的 Request Method 会设置为 options。另外，还会带上这几个字段：123Origin: 同简单请求的originAccess-Control-Request-Method: 请求将要使用的方法Access-Control-Request-Headers: 浏览器会额外发送哪些头信息 服务端服务端收到预请求之后会根据request中的origin,Access-Control-Request-Method和Access-Control-Request-Headers判断是否响应该请求。如果判断响应这个请求，返回的response中将会携带：123Access-Control-Allow-Origin: originAccess-Control-Allow-Methods: like requestAccess-Control-Allow-Headers: like request 如果否定这个请求，直接返回不带这三个字段的response就可以，浏览器将会把这种返回判断为失败的返回，触发onerror方法正式响应如果预请求被正确响应，接下来就会发送正式请求，正式请求的request和正常的 ajax 请求基本没有区别，只是会携带 origin 字段；response和简单请求一样，会携带上Access-Control-*这些字段 WebScoketwebsocket 不遵循同源策略。 但是在 websocket 请求头中会带上 origin 这个字段，服务端可以通过这个字段来判断是否需要响应，在浏览器端并没有做任何限制。 iframe代理请求方式]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F15%2FJavaScript%2Findex%2F</url>
    <content type="text"><![CDATA[test #app { /* background: orange; width: 100%; height: 400px; display: flex; align-items: center;*/ /*position: relative;*/ /*text-align: center;*/ /*margin: auto;*/ } .box { background: yellow; width: 100px; height: 100px; /* position: absolute; top: 50%; left: 50%;*/ /* margin-top: -50px; margin-left: -50px;*/ /*transform: translate(-50px, -50px);*/ } .layout{ /* width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/ max-width: 960px; margin: 0 auto; } 头部 内容 尾部 var app = new Vue({ el: '#app', data: { message : "xuxiao is boy", text: 'hello word' }, beforeCreate: function () { console.group('beforeCreate 创建前状态===============》'); //undefined console.log("%c%s", "color:red" , "el : " + this.$el); //undefined console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message) }, created: function () { console.group('created 创建完毕状态===============》'); //undefined console.log("%c%s", "color:red","el : " + this.$el); //已被初始化 console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); }, beforeMount: function () { console.group('beforeMount 挂载前状态===============》'); //已被初始化 console.log("%c%s", "color:red","el : " + (this.$el)); console.log(this.$el); //已被初始化 console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); }, mounted: function () { console.group('mounted 挂载结束状态===============》'); //已被初始化 console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); //已被初始化 console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); }, beforeUpdate: function () { console.group('beforeUpdate 更新前状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); }, updated: function () { console.group('updated 更新完成状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); }, beforeDestroy: function () { console.group('beforeDestroy 销毁前状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); }, destroyed: function () { console.group('destroyed 销毁完成状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message) } }) /* for(var i =0; i< 5; i++) { setTimeout(function() { console.log("new Date", new Date, i); }, 1000) } console.log(new Date, i); */ function outer() { var num = 0; return function add() { num++; console.log("num:", num); } } var func1 = outer() func1() func1() var func2 = outer() func2() func2()]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F15%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4%2Fvue%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[简单自我介绍, 做过哪些项目, 使用哪些技术栈 ?如何看待前端框架选型 ?vue的如何实现双向绑定的 ？react 虚拟DOM 是什么? 如何实现? 说一下diff算法 ?工作中最出色的点, 和你最头疼的问题 如何解决的 ?平时如何学习, 最近接触了解了哪些新的知识 ?技术一面简单自我介绍, 介绍一下你的项目, 技术栈 ?react和vue的比较 ?React Diff 算法 ?观察者模式实现 ?http报文头部有哪些字段? 有什么意义 ?移动端高清方案如何解决 ?webpack的原理, loader 和 plugin 是干什么的? 有自己手写过么 ?简述从网页输入url到网页展示的过程发生了哪些事情 ?SSR 和 客户端渲染有什么区别 , vue是如何实现绑定事件的 ?简述公司node架构中容灾的实现 ?浏览器事件有哪些过程? 为什么一般在冒泡阶段, 而不是在捕获阶段注册监听? addEventListener 参数分别是什么 ?面向对象如何实现? 需要复用的变量 怎么处理 ?移动端300ms延时的原因? 如何处理?主流框架的数据单向/双向绑定实现原理 ?简述转行经历, 如何学习 ?你觉得自己在前端工作的最大的优点是什么 拿实际工作的内容举例?技术二面和一面前3问基本一致,简述项目,React vue区别 virsualDOM实现DIFF算法为什么是O(n)复杂度而不是O(n^3)http code码?移动端rem布局如何实现? 简述原理?JSbridge原理, js和native是如何通信的?Rollup和webpack区别, treeshaking是什么?TCP三次握手的过程, get post请求的区别 ?静态文件的浏览器缓存如何实现?前端跨域方案http 请求包含哪些字段 分别是什么意思js 有哪些数据类型 如何判断? null 和 undefined区别 应用场景?new String(‘a’) 和 ‘a’ 是一样的么?移动端如何实现下拉到底部 跟随移动 结束后回弹的动画?移动端如何优化首页白屏时间过长 ?ES6 generator函数简述数组去重实现?js浮点数运算不精确 如何解决?工作中最得意和出色的点, 头疼的点, 问题如何解决的为何换工作?聊了下阿里的压力,文化技术三面公司的前端工程化实践转行之后是如何自学前端的, 学习途径 有没有一些自己的代码DOM基础知识,添加元素,删除元素等等…DOM节点类型正则表达式如何匹配一段url ?在正则表达式中有哪几种作用?移动端优化方式? 离线包是如何实现的? https://ustbhuangyi.github.io/vue-analysis/ 我的手机 2019/3/14 10:04:34https://www.jianshu.com/p/a804606ad8e9 我的手机 2019/3/14 10:04:50https://www.cnblogs.com/chinabin1993/p/9115396.html 我的手机 2019/3/14 10:05:03https://segmentfault.com/a/1190000012996217 我的手机 2019/3/14 10:05:20https://blog.csdn.net/qq_35430000/article/details/79291287 我的手机 2019/3/14 10:05:37https://m.jb51.net/article/140581.htm https://yukwan.cn/fronttech/front-end/2019/3/8 16:31:10我的手机 2019/3/8 16:31:10https://mp.weixin.qq.com/s/L8P0RIXym4myfknzM5Nsog2019/3/9 16:28:42我的手机 2019/3/9 16:28:42https://campushr.hikvision.com/JobDetails.html?id=057c01652bb444b597345337c7b8c14f&amp;type=0 https://wx2.sinaimg.cn/mw690/005NaMhPly1g0nayy8lbij30hs59p7wh.jpg?from=singlemessage]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F15%2FJavaScript%2F%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[JavaScript简介在HTML中使用JavaScript混杂模式与标准模式基本概念语法变量、函数名和操作符都区分大小写 标识符，就是指变量、函数、属性的名字，或者函数的参数。ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写 严格模式： “use strict”; 数据类型 简单数据类型(基本数据类型)：Undefined、Null、Boolean、Number、String 复杂数据类型：Object typeof 操作符来区分函数和其他对象是有必要的 Undefind 即便未初始化的变量会自动被赋予 undefined 值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当 typeof 操作符返回”undefined”值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。 NullBooleanNumber整数浮点数NaN即非数值（Not a Number）ECMAScript 定义了 isNaN()函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。 数值转换把非数值转换为数值：Number()、parseInt()和 parseFloat()。 String流控制语句函数变量、作用域和内存问题基本类型和引用类型基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象 复制变量值如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上.当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量1234var obj1 = new Object(); var obj2 = obj1; obj1.name = "Nicholas"; alert(obj2.name); //"Nicholas" 检测类型typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具 虽然在检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了 instanceof 操作符，其语法如下所示：result = variable instanceof constructor 执行环境垃圾收集标记清除引用计数小结 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中； 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本； 引用类型的值是对象，保存在堆内存中； 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针； 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象； 确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用instanceof 操作符。 所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。 以下是关于执行环境的几点总结： 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分； 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境； 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据； 变量的执行环境有助于确定应该何时释放内存。 JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。 可以对 JavaScript 的垃圾收集例程作如下总结： 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题。 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。 引用类型使用对象Object类型 Array类型 检测数组 value instanceof Array、 Array.isArray()方 转换方法 toLocaleString()、toString()和 valueOf() 栈方法 后进先出 push()、pop() 队列方法 后进先出 shift()、unshift() 重排序方法 reverse()、sort() 操作方法 concat() 连接数组、splice() 位置方法 indexOf()、lastIndexOf() 迭代方法 every() 全部 filter() 筛选 forEach() map() some() 存在 归并方法 reduce() reduceRight() Date类型 new Date()、Date.parse() 、Date.UTC() 继承的方法 日期格式化方法 toDateString()——以特定于实现的格式显示星期几、月、日和年 toTimeString()——以特定于实现的格式显示时、分、秒和时区； toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年 toLocaleTimeString()——以特定于实现的格式显示时、分、秒 toUTCString()——以特定于实现的格式完整的 UTC 日期 日期/时间组件 getTime() 返回表示日期的毫秒数；与valueOf()方法返回的值相同 setTime(毫秒) 以毫秒数设置日期，会改变整个日期 getFullYear() 取得4位数的年份（如2007而非仅07） getUTCFullYear() 返回UTC日期的4位数年份 RegExp()类型 Function类型 没有重载 函数声明与函数表达式 解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问） 至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。 作为值的函数 函数内部属性 arguments this callee 函数属性和方法 length prototype apply() call() 基本包装类型 Boolean类型 Number toFixed()方法会按照指定的小数位返回数值的字符串表示 toExponential() String trim()方法： 这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果 字符串大小写转换方法 toLowerCase() toLocaleLowerCase() toUpperCase() toLocaleUpperCase()。 字符串的模式匹配方法 localeCompare() localeCompare() fromCharCode() 单体内置对象 Global对象 Math对象 Math对象的属性 min()、max() 舍入方法 Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数 Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数 Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数 random() Math.radom() 160 创建并操作数组基本的JavaScript类型基本类型和基本包装类型面向对象的程序设计对象属性创建对象继承函数表达式BOM客户端检测DOMDOM扩展DOM2和DOM3事件表单脚本使用Canvas绘图HTML5脚本编程错误处理与调试JavaScript与XMLE4XJSONAjax与Comet高级技巧离线应用和客户端储存最佳实战新兴的API]]></content>
  </entry>
  <entry>
    <title><![CDATA[客户端渲染和服务端渲染详细执行流程]]></title>
    <url>%2F2019%2F03%2F14%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2FSSR%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[客户端渲染：CSR (client side render)在服务端放了一个html 页面，里面有//发请求，拿数据，模版引擎渲染等，$.ajax ,客户端发起请求，服务端把页面（响应的是字符串）发送过去，客户端从上到下依次解析，如果在解析的过程中，发现ajax请求，再次像服务器发送新的请求，客户端拿到ajax 响应结果，模板引擎渲染。过程至少和服务端发起两次请求 服务端渲染：SSR (server side render)sever 端页面+数据，服务端过程：1.读取index.html2.模版进行渲染，在发送给客户端之前，在服务端已经把index.html 渲染处理了。var 渲染结果 = tempeter.render(模板字符串，｛解析替换对象｝) response.end(渲染结果)，服务端响应的就是最总的结果服务端只请求一次多数网站既有服务端渲染又有客户端渲染 服务端渲染和客户端渲染的区别 客户端渲染不利于 SEO 搜索引擎优化 服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的 所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的 而是两者结合来做的 例如京东的商品列表就采用的是服务端渲染，目的了为了 SEO 搜索引擎优化 而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染]]></content>
      <categories>
        <category>前端优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件间通信&传值]]></title>
    <url>%2F2019%2F03%2F14%2FVue%2FVue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%26%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[转载： vue通信、传值的多种方式（详细） Vue.js——十分钟入门Vuex 通过路由带参数进行传值 两个组件 A和B,A组件通过query把orderId传递给B组件（触发事件可以是点击事件、钩子函数等）this.$router.push({ path: &#39;/conponentsB&#39;, query: { orderId: 123 } }) // 跳转到B 在B组件中获取A组件传递过来的参数this.$route.query.orderId 通过设置 Session Storage缓存的形式进行传递 两个组件A和B，在A组件中设置缓存orderData 123const orderData = &#123; 'orderId': 123, 'price': 88 &#125; sessionStorage.setItem('缓存名称', JSON.stringify(orderData)) B组件就可以获取在A中设置的缓存了const dataB = JSON.parse(sessionStorage.getItem(&#39;缓存名称&#39;))此时 dataB 就是数据 orderData 父子组件之间的传值父组件往子组件传值props①定义父组件，父组件传递 number这个数值给子组件，如果传递的参数很多，推荐使用json数组{}的形式 1234567891011121314# parent.vue&lt;template&gt; &lt;div class="parent"&gt; # 例如：传递数组88给子组件 &lt;children number=888&gt;&lt;/children&gt; &lt;/div&gt;&lt;/template&gt;import Children from 'components/children' # 引入子组件export default &#123; components: &#123; Children &#125;&#125; ②定义子组件，子组件通过 props方法获取父组件传递过来的值。props中可以定义能接收的数据类型，如果不符合会报错。12345678910111213# children.vue&lt;template&gt; &lt;div class="children"&gt; &#123;&#123;number&#125;&#125; # 显示父组件传递过来的值，显示88 &lt;/div&gt;&lt;/template&gt;export default &#123; props: &#123; # 限制父组件传递过来的数据类型，如果不符合就报错 'number': [Number, String, Object], 'string': [String] #可以传递多个值，逗号隔开 &#125;&#125; 当然也可以简单一点，如果不考虑数据类型，直接 props:[&quot;number&quot;,&quot;string&quot;]就可以了,中括号包裹，多个值使用，分隔。③假如接收的参数 是动态的，比如 input输入的内容 v-model的形式注意：传递的参数名称 支持驼峰命名，下面示例描述不正确（1.0是不支持的）1234567891011121314# parent.vue&lt;template&gt; &lt;div class="parent"&gt; &lt;input type="text" v-model="inputText"&gt; &lt;children :input-val = 'inputText'&gt;&lt;/children&gt; # 注意 :input-val 不支持驼峰命名，建议 - 分割 &lt;/div&gt;&lt;/template&gt;import Children from 'components/children'export default &#123; components: &#123; Children &#125;&#125; 1234567891011&lt;template&gt; &lt;div class="children"&gt; &#123;&#123;inputVal&#125;&#125; &lt;/div&gt;&lt;/template&gt;export default &#123; props: &#123; 'input-val': [String] &#125;&#125; ④父子组件传值，数据是异步请求，有可能数据渲染时报错原因：异步请求时，数据还没有获取到但是此时已经渲染节点了解决方案：可以在 父组件需要传递数据的节点加上v-if = false,异步请求获取数据后,v-if = true 子组件往父组件传值，通过emit事件123456789101112131415# children.vue&lt;template&gt; &lt;div class="children"&gt; &lt;button @click="emitToParent"&gt;按钮点击传值给父组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; methods: &#123; emitToParent() &#123; this.$emit('child-event', '我是子组件往父组件传递的内容') # child-event 不支持驼峰命名 # 子组件通过emit事件给父组件传递内容 &#125; &#125;&#125; 1234567891011121314151617181920# parent.vue&lt;template&gt; &lt;div class="parent"&gt; # 触发父组件的一个方法，然后进行相应的操作 &lt;children @child-event="parentEvent"&gt;&lt;/children&gt; # @child-event 这是子组件自定义的方法 &lt;/div&gt;&lt;/template&gt;import Children from 'components/children'export default &#123; methods: &#123; parentEvent(data) &#123; # data 就是子组件传递过来的数据 console.log(data) # 我是子组件往父组件传递的内容 &#125; &#125;, components: &#123; Children &#125;&#125; 不同组件之间传值，通过eventBus（小项目少页面用eventBus，大项目多页面使用 vuex）①定义一个新的vue实例专门用于传递数据，并导出就是定义一个公共的传值用的组件进行数据的交互123# 新建文佳eventBus.jsimport Vue from 'vue'export default new Vue() ②定义传递的方法名和传输内容，点击事件或钩子函数触发eventBus.emit事件12345678910111213141516# componentA.vue&lt;template&gt; &lt;div class="componentsA"&gt; &lt;button @click="emitToB"&gt;按钮点击传递数据给兄弟组件B&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from 'common/js/eventBus.js'export default &#123; methods: &#123; emitToB() &#123; eventBus.$emit('eventFromA', '我是组件A传递给组件B的数据') &#125; &#125;&#125;&lt;/script&gt; ③接收传递过来的数据注意：enentBus是一个另一个新的Vue实例，区分两个this所代表得vue实例123456789101112131415161718192021222324252627282930componentB.vue&lt;template&gt; &lt;div class="componentsB"&gt; &#123;&#123;title&#125;&#125; # 显示传递过来的值 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from 'common/js/eventBus.js'export default &#123; data() &#123; return &#123; title: '' &#125; &#125;, mounted() &#123; this.getEventData() &#125;, methods: &#123; getEventData() &#123; const that = this #this是项目vue的实例，用that接收，与eventBus的vue区分 eventBus.$on('eventFormA', function(val) &#123; that.title = val # this.title = val # 这个this指的是eventBus的vue实例 &#125;) &#125; &#125;&#125; &lt;/script&gt; Vuex进行传值什么是Vuex Vuex是一个专门为Vue.js应用程序开发的状态管理模式, 它采用集中式存储管理所有组件的公共状态, 并以相应的规则保证状态以一种可预测的方式发生变化. 上图中绿色虚线包裹起来的部分就是Vuex的核心, state中保存的就是公共状态, 改变state的唯一方式就是通过mutations进行更改. 可能你现在看这张图有点不明白, 等经过本文的解释和案例演示, 再回来看这张图, 相信你会有更好的理解. 为什么要使用Vuex 试想这样的场景, 比如一个Vue的根实例下面有一个根组件名为App.vue, 它下面有两个子组件A.vue和B.vue, App.vue想要与A.vue或者B.vue通讯可以通过props传值的方式, 但是如果A.vue和B.vue之间的通讯就很麻烦了, 他们需要共有的父组件通过自定义事件进行实现, A组件想要和B组件通讯往往是这样的: A组件说: “报告老大, 能否帮我托个信给小弟B” =&gt; dispatch一个事件给App App老大说: “包在我身上, 它需要监听A组件的dispatch的时间, 同时需要broadcast一个事件给B组件” B小弟说: “信息已收到”, 它需要on监听App组件分发的事件 这只是一条通讯路径, 如果父组件下有多个子组件, 子组件之间通讯的路径就会变的很繁琐, 父组件需要监听大量的事件, 还需要负责分发给不同的子组件, 很显然这并不是我们想要的组件化的开发体验.Vuex就是为了解决这一问题出现的 如何引入Vuex下载vuex: npm install vuex --save 在main.js添加:12345678910111213import Vuex from 'vuex'# 使用vuexVue.use( Vuex );const store = new Vuex.Store(&#123; //待添加&#125;)new Vue(&#123; el: '#app', store, render: h =&gt; h(App)&#125;) Vuex的核心概念 在介绍Vuex的核心概念之前, 我使用vue-cli初始化了一个demo, 准备以代码的形式来说明Vuex的核心概念,这个demo分别有两个组件ProductListOne.vue和ProductListTwo.vue, 在App.vue的datat中保存着共有的商品列表, 代码和初始化的效果如下图所示:1234567891011121314151617181920212223242526272829303132333435363738//App.vue中的初始化代码&lt;template&gt;&lt;div id="app"&gt; &lt;product-list-one v-bind:products="products"&gt;&lt;/product-list-one&gt; &lt;product-list-two v-bind:products="products"&gt;&lt;/product-list-two&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ProductListOne from './components/ProductListOne.vue'import ProductListTwo from './components/ProductListTwo.vue'export default &#123; name: 'app', components: &#123; 'product-list-one': ProductListOne, 'product-list-two': ProductListTwo &#125;, data () &#123; return &#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;body&#123; font-family: Ubuntu; color: #555;&#125;&lt;/style&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//ProductListOne.vue&lt;template&gt; &lt;div id="product-list-one"&gt; &lt;h2&gt;Product List One&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="product in products"&gt; &lt;span class="name"&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class="price"&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['products'], data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;#product-list-one&#123; background: #FFF8B1; box-shadow: 1px 2px 3px rgba(0,0,0,0.2); margin-bottom: 30px; padding: 10px 20px;&#125;#product-list-one ul&#123; padding: 0;&#125;#product-list-one li&#123; display: inline-block; margin-right: 10px; margin-top: 10px; padding: 20px; background: rgba(255,255,255,0.7);&#125;.price&#123; font-weight: bold; color: #E8800C;&#125;&lt;/style&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//ProductListTwo.vue&lt;template&gt; &lt;div id="product-list-two"&gt; &lt;h2&gt;Product List Two&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="product in products"&gt; &lt;span class="name"&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class="price"&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['products'], data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;#product-list-two&#123; background: #D1E4FF; box-shadow: 1px 2px 3px rgba(0,0,0,0.2); margin-bottom: 30px; padding: 10px 20px;&#125;#product-list-two ul&#123; padding: 0; list-style-type: none;&#125;#product-list-two li&#123; margin-right: 10px; margin-top: 10px; padding: 20px; background: rgba(255,255,255,0.7);&#125;.price&#123; font-weight: bold; color: #860CE8; display: block;&#125;&lt;/style&gt; State state就是Vuex中的公共的状态, 我是将state看作是所有组件的data, 用于保存所有组件的公共数据. 此时我们就可以把App.vue中的两个组件共同使用的data抽离出来, 放到state中,代码如下:1234567891011121314151617181920212223# main.jsimport Vue from 'vue'import App from './App.vue'import Vuex from 'vuex'Vue.use( Vuex )const store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125;&#125;)new Vue(&#123; el: '#app', store, render: h =&gt; h(App)&#125;) 此时,ProductListOne.vue和ProductListTwo.vue也需要做相应的更改12345678# ProductListOne.vueexport default &#123; data () &#123; return &#123; products : this.$store.state.products //获取store中state的数据 &#125; &#125;&#125; 12345678# ProductListTwo.vueexport default &#123; data () &#123; return &#123; products: this.$store.state.products //获取store中state的数据 &#125; &#125;&#125; 此时的页面如下图所示, 可以看到, 将公共数据抽离出来后, 页面没有发生变化. Getters 我将getters属性理解为所有组件的computed属性, 也就是计算属性. vuex的官方文档也是说到可以将getter理解为store的计算属性, getters的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 此时,我们可以在main.js中添加一个getters属性, 其中的saleProducts对象将state中的价格减少一半(除以2)12345678910111213141516171819202122# main.jsconst store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125;, getters:&#123; //添加getters saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map( product =&gt; &#123; return &#123; name: product.name, price: product.price / 2 &#125; &#125;) return saleProducts; &#125; &#125; &#125;) 将productListOne.vue中的products的值更换为this.$store.getters.saleProducts1234567export default &#123; data () &#123; return &#123; products : this.$store.getters.saleProducts &#125; &#125;&#125; 现在的页面中,Product List One中的每项商品的价格都减少了一半 123456789101112131415161718192021222324252627282930313233343536```###### Mutations 我将mutaions理解为store中的methods, mutations对象中保存着更改数据的回调函数,该函数名官方规定叫type, 第一个参数是state, 第二参数是payload, 也就是自定义的参数.下面,我们在main.js中添加mutations属性,其中minusPrice这个回调函数用于将商品的价格减少payload这么多, 代码如下:```bash//main.jsconst store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125;, getters:&#123; saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map( product =&gt; &#123; return &#123; name: product.name, price: product.price / 2 &#125; &#125;) return saleProducts; &#125; &#125;, mutations:&#123; //添加mutations minusPrice (state, payload ) &#123; let newPrice = state.products.forEach( product =&gt; &#123; product.price -= payload &#125;) &#125; &#125;&#125;) 在ProductListTwo.vue中添加一个按钮,为其添加一个点击事件, 给点击事件触发minusPrice方法12345678910111213# ProductListTwo.vue&lt;template&gt; &lt;div id="product-list-two"&gt; &lt;h2&gt;Product List Two&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="product in products"&gt; &lt;span class="name"&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class="price"&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;button @click="minusPrice"&gt;减少价格&lt;/button&gt; //添加按钮 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 在ProductListTwo.vue中注册minusPrice方法, 在该方法中commitmutations中的minusPrice这个回调函数注意:调用mutaions中回调函数, 只能使用store.commit(type, payload)12345678910111213# ProductListTwo.vueexport default &#123; data () &#123; return &#123; products: this.$store.state.products &#125; &#125;, methods: &#123; minusPrice() &#123; this.$store.commit('minusPrice', 2); //提交`minusPrice,payload为2 &#125; &#125;&#125; 添加按钮, 可以发现,Product List Two中的价格减少了2, 当然你可以自定义payload,以此自定义减少对应的价格. Actionsactions 类似于 mutations，不同在于：actions提交的是mutations而不是直接变更状态actions中可以包含异步操作, mutations中绝对不允许出现异步actions中的回调函数的第一个参数是context, 是一个与store实例具有相同属性和方法的对象 此时,我们在store中添加actions属性, 其中minusPriceAsync采用setTimeout来模拟异步操作,延迟2s执行 该方法用于异步改变我们刚才在mutaions中定义的minusPrice123456789101112131415161718192021222324252627282930313233343536//main.jsconst store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: '鼠标', price: 20&#125;, &#123;name: '键盘', price: 40&#125;, &#123;name: '耳机', price: 60&#125;, &#123;name: '显示屏', price: 80&#125; ] &#125;, getters:&#123; saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map( product =&gt; &#123; return &#123; name: product.name, price: product.price / 2 &#125; &#125;) return saleProducts; &#125; &#125;, mutations:&#123; minusPrice (state, payload ) &#123; let newPrice = state.products.forEach( product =&gt; &#123; product.price -= payload &#125;) &#125; &#125;, actions:&#123; //添加actions minusPriceAsync( context, payload ) &#123; setTimeout( () =&gt; &#123; context.commit( 'minusPrice', payload ); //context提交 &#125;, 2000) &#125; &#125;&#125;) 在ProductListTwo.vue中添加一个按钮,为其添加一个点击事件, 给点击事件触发minusPriceAsync方法 12345678910111213&lt;template&gt; &lt;div id="product-list-two"&gt; &lt;h2&gt;Product List Two&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="product in products"&gt; &lt;span class="name"&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class="price"&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;button @click="minusPrice"&gt;减少价格&lt;/button&gt; &lt;button @click="minusPriceAsync"&gt;异步减少价格&lt;/button&gt; //添加按钮 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 在ProductListTwo.vue中注册minusPriceAsync方法, 在该方法中dispatchactions中的minusPriceAsync这个回调函数123456789101112131415export default &#123; data () &#123; return &#123; products: this.$store.state.products &#125; &#125;, methods: &#123; minusPrice() &#123; this.$store.commit('minusPrice', 2); &#125;, minusPriceAsync() &#123; this.$store.dispatch('minusPriceAsync', 5); //分发actions中的minusPriceAsync这个异步函数 &#125; &#125;&#125; 添加按钮, 可以发现, Product List Two中的价格延迟2s后减少了5 Modules由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 ..mapactions&amp;&amp; …mapgetters]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局]]></title>
    <url>%2F2019%2F03%2F08%2F%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[转载： 阮一峰：Flex 布局教程：语法篇 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex布局是什么？ Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。123.box&#123; display: felx;&#125; 行内元素也可以使用 Flex 布局。123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。基本概念 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性 以下6个属性设置在容器上。123456flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content flex-direction属性 flex-direction属性决定主轴的方向（即项目的排列方向）123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。1234row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。 flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性 justify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。12345flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性 align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 建立在主轴为水平方向时测试，即 flex-direction: row默认值为 stretch 即如果项目未设置高度或者设为 auto，将占满整个容器的高度。假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。12345flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。123456flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。123456orderflex-growflex-shrinkflex-basisflexalign-self order属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis属性 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: | auto; / default auto /}它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto)` 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>页面布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页从输入网址到渲染完成经历了哪些过程]]></title>
    <url>%2F2019%2F02%2F23%2FHTTP%2F%E7%BD%91%E9%A1%B5%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[过程概述 从输入域名到网页打开的简单过程如下：1. DNS域名解析 客户端输入域名后，由DNS服务器来将域名解析成对应服务器的IP地址 若未在缓存中找到，则不停的向上一级级请求DNS服务器2. 建立TCP连接 客户端得到IP地址以后,会根据所获得的IP地址以及要访问的端口号发起网络连接， 即tcp三次握手连接， 建立起TCP/IP网络连接， 具体过程如下： 第一次握手： 主机向服务器发送一个建立连接的请求（您好，我想认识您） 建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认 第二次握手： 服务器接到请求后发送同意连接的信号（好的，很高兴认识您） 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器 进入SYN_RECV状态； 第三次握手： 主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。 解释： SYN:synchronous 建立联机 ACK:acknowledgement 确认 SYN_SENT:请求连接 SYN_RECV:服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态。 tcp在握手过程中并不携带数据，(就像你打电话给酒店订房时，在确认对方是酒店客服人员之前，你也不会马上把身份证号码报给他吧？)，而是在三次握手完成之后，才会进行数据传送。 补充说明: TCP 协议：三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号。3. 发送HTTP请求 与服务器建立连接之后，就可以向服务器发送请求了，请求需要遵循http协议 添加一些HTTP首部 根据同源政策添加cookie4.服务器处理HTTP请求报文 被请求的服务器解析用户请求的有哪些资源，通过服务器返回数据给客户端5.返回响应HTTP响应报文 给客户端返回请求的状态码，通过状态码可以知道服务器端的处理是否正常6.浏览器渲染： 返回成功之后，浏览器拿到请求页面的代码，将其解析渲染出来。解析和渲染的过程主要由浏览器的渲染引擎实现。 浏览器处理服务器返回的HTTP响应报文，若为HTML则渲染页面，不包括脚本的简单渲染流程如下： 1、解析DOM、CSSOM 2、根据DOM、CSSOM计算render tree 3、根据render tree进行layout 4、paint，至此，用户可以看到页面了 根据域名查找 IP 地址概念解释 IP 地址：IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址； 域名(DN)：IP 地址由四个数字组成，中间用点号连接，在使用过程中难记忆且易输入错误，所以用我们熟悉的字母和数字组合来代替纯数字的 IP 地址，比如我们只会记住 www.baidu.com（百度域名） 而不是 220.181.112.244（百度的其中一个 IP 地址）； DNS： 每个域名都对应一个或多个提供相同服务服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。 知道了上面的概念，大概就知道了想要获得服务器的门牌号码，需要先将域名转换成 IP 地址。转换过程如下（以查询 www.baidu.com 的 IP 地址为例，其中2、3、4步均在上一步未查询成功的情况下进行）： 查找过程 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）； 操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求； LDNS 向 Root Name Server（根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server返回 com 域的顶级域名服务器的地址； LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com域名服务器地址； LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com的 IP 地址； LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来； 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来； 至此，浏览器已经得到了域名对应的 IP 地址。 补充说明 域名与 URL 是两个概念：域名是一台或一组服务器的名称，用来确定服务器在 Internet 上的位置；URL 是统一资源定位符，用来确定某一个文件的具体位置，例如，zhihu.com 是 知乎的域名，根据这个域名可以找到知乎的服务器，zhihu.com/people/CompileYouth 是 URL ，可以根据这个 URL 定位我的知乎主页； IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限； 网页请求与显示 当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件； 服务器将得到的 HTML 文件发送给浏览器； 在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页； 在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML 断开连接–四次挥手 主机向服务器发送一个断开连接的请求（不早了，我该走了）； 服务器接到请求后发送确认收到请求的信号（知道了）； 服务器向主机发送断开通知（我也该走了）； 主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接； 注意：URL 一个完整的URL地址由：协议、服务器地址(主机)、端口、资源路径(文件)。其中网络地址指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；协议是从 该计算机获取资源的方式，常见的是HTTP、FTP，不同协议有不同的通讯内容格式；资源路径指示从服务器上获取哪一项资源。例如：http://www.guokr.com/question/554991/超文本传输协议：http服务器地址：www.guokr.com端口： http协议的默认端口为80资源路径：是指要活的的文件的路径 -&gt;/question/554991/ TCP为什么要三次握手而不是两次握手TCP 采用三次握手的原因： 为了实现可靠数据传输，TCP 协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的。三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。 如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认。 三次握手主要是为了防止已失效的连接请求报文突然到达服务器，造成服务器的等待和资源的浪费。举例： 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。 TCP 四次挥手能不能变成三次挥手呢？可以的 TCP是全双工通信，Client 在自己已经不会在有新的数据要发送给 Server 后，可以发送 FIN 信号告知 Server，这边已经终止 Client 到对端 Server 那边的数据传输。但是，这个时候对端 Server 可以继续往 Client 这边发送数据包。于是，两端数据传输的终止在时序上是独立并且可能会相隔比较长的时间，这个时候就必须最少需要2+2 = 4 次挥手来完全终止这个连接。但是，如果Server在收到Client的FIN包后，在也没数据需要发送给Client了，那么对Client的ACK包和Server自己的FIN包就可以合并成为一个包发送过去，这样四次挥手就可以变成三次了(似乎linux协议栈就是这样实现的)。转载： 一个页面从输入url,到页面显示加载完成,这个过程中都发生了什么? 从输入 URL 到页面加载完成的过程中都发生了什么参考文章： 从键入网址到页面显示经历了那些过程]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM开发模式的理解]]></title>
    <url>%2F2019%2F02%2F23%2FVue%2FMVVM%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[MVVM MVVM（模型视图ViewModel 是一种基于MVC和MVP的架构模式，它试图更清楚地将用户界面（UI）的开发与应用程序中的业务逻辑和行为的开发分开。为此，此模式的许多实现都使用声明性数据绑定，以允许将视图上的工作与其他层分离。 Model、View、ViewModel MVVM分为Model、View、ViewModel三者。 Model 代表数据模型，数据和业务逻辑都在Model层中定义； View 代表UI视图，负责数据的展示，是用户在屏幕上看到的结构； ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作； Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom。 MVVM的实现原理：核心 响应式：vue如何监听data的属性变化 模板解析：vue的模板是如何被解析的 渲染：vue模板是如何被渲染成HTML的 响应式模板解析渲染设计模式编辑 因为WPF技术出现，从而使MVC架构模式有所改进，MVVM模式便是使用的是数据绑定基础架构。它们可以轻松构建UI的必要元素。可以参考The Composite Application Guidance for WPF(prism)View绑定到ViewModel，然后执行一些命令在向它请求一个动作。而反过来，ViewModel跟Model通讯，告诉它更新来响应UI。这样便使得为应用构建UI非常的容易。往一个应用程序上贴一个界面越容易，外观设计师就越容易使用Blend来创建一个漂亮的界面。同时，当UI和功能越来越松耦合的时候，功能的可测试性就越来越强。在MVP模式中，为了让UI层能够从逻辑层上分离下来，设计师们在UI层与逻辑层之间加了一层interface。无论是UI开发人员还是数据开发人员，都要尊重这个契约、按照它进行设计和开发。这样，理想状态下无论是Web UI还是Window UI就都可以使用同一套数据逻辑了。借鉴MVP的IView层，养成习惯。View Model听起来比Presenter要贴切得多；会把一些跟事件、命令相关的东西放在MVC的’C’,或者是MVVM的’Vm’。 优点和缺点优点 MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点: 低耦合: 视图（View）可以独立于 Model 变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可重用性: 你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 独立开发:开发人员可以专注于业务逻辑和数据的开发(ViewModel), 设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。 可测试:界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。 MVVM有助于更轻松地并行开发UI以及为其提供支持的构建块 抽象视图，从而减少其背后的代码所需的业务逻辑（或粘合剂）的数量 ViewModel比事件驱动的代码更容易进行单元测试 可以在不关心UI自动化和交互的情况下测试ViewModel（比View更多的模型） 缺点 对于更简单的UI，MVVM可能过度 虽然数据绑定可以是声明性的并且很好用，但它们比我们简单设置断点的命令式代码更难调试 非平凡应用程序中的数据绑定可以创建大量的簿记。您也不希望在绑定比绑定的对象更重的情况下结束 在较大的应用程序中，预先设计ViewModel以获得必要的泛化量可能更加困难 参考文章： 前后端分手大师——MVVM 模式 简单理解MVVM–实现Vue的MVVM模式 了解MVVM - JavaScript开发人员指南]]></content>
      <categories>
        <category>开发模式</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis基础]]></title>
    <url>%2F2019%2F02%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fredis%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stylus基础]]></title>
    <url>%2F2019%2F02%2F22%2FCSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%2Fstylus%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>stylus</category>
      </categories>
      <tags>
        <tag>stylus基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoose]]></title>
    <url>%2F2019%2F02%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmongoose%2F</url>
    <content type="text"><![CDATA[mongoosemongodb 的概念 &amp; 安装mongod mongodb 可视化工具 RoRo 3T 安装及应用mongoose 的作用mongoose 的应用]]></content>
      <categories>
        <category>mongoose</category>
      </categories>
      <tags>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa2基础]]></title>
    <url>%2F2019%2F02%2F21%2FKoa2%2FKoa2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Koa官网《Koa2进阶学习笔记》已完结 使用koa-generator生成koa2项目全局安装koa-generator: npm install -g koa-generator使用koa-generator生成koa2项目: koa2 -e koa2-learn -e 添加ejs模板引擎支持(默认是jade) koa2-learn 项目名123456789101112131415161718192021222324$ koa2 -e koa2-learning create : koa2-learning create : koa2-learning/package.json create : koa2-learning/app.js create : koa2-learning/public/javascripts create : koa2-learning/routes create : koa2-learning/routes/index.js create : koa2-learning/routes/users.js create : koa2-learning/public/images create : koa2-learning/public/stylesheets create : koa2-learning/public/stylesheets/style.css create : koa2-learning/public create : koa2-learning/views create : koa2-learning/views/index.ejs create : koa2-learning/views/error.ejs create : koa2-learning/bin create : koa2-learning/bin/www install dependencies: $ cd koa2-learning &amp;&amp; npm install run the app: $ DEBUG=koa2-learning:* npm start PS: 如果出现 npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.7: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;}) 不用担心。出现原因：fsevents 不在 package.json里，但是仍然安装了，是因为你的系统是Windows系统，fsevents是苹果系统的可选依赖,你的项目有可能是团队项目，别人在他的mac上安装了fsevents相关依赖库，所以到这边你也就安装到你的windows上边了。你可以检查你的package.json 文件中是不是有fsevents相关依赖，删除即好！如果没有，其他的npm包也会有依赖fsevents的！！！这是warning错误，是因为mac下需要fsevents，这里是在windows环境，所以可以忽略这个警告，对你没什么影响的。运行: DEBUG=koa2-learning:* npm start || npm run dev效果： 出现 node bin/www 访问 http://localhost:3000/注意： npm start 、 npm test 、 npm run dev 、 npm run prd async 和 await 语法异步概念 是指一个进程在执行某个请求的时候，如果这个请求没有执行完毕，进程不会等待，而是继续执行下面的请求。 理解async 和 awaitKoa2 中间件koa2 中间件的原理 自定义 koa2 中间件koa2 路由路由写法接口举例cookie 和 sessioncookie 和 session 的定义cookie 和 session 的作用推荐： 从头实现一个koa框架 浅析koa的洋葱模型实现]]></content>
      <categories>
        <category>Koa2</category>
      </categories>
      <tags>
        <tag>Koa2基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2019%2F02%2F15%2FVue%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Vue.js基础，模块化，单文件组件，路由，与服务器通信，状态管理，单元测试与生产发布，服务端渲染SSR与Nuxt.js，基于Vue.js企业级项目开发(Mint UI, Element UI)等 v-if 和 v-show 区别使用了 v-if 的时候，如果值为 false ，那么页面将不会有这个 html 标签生成。v-show 则是不管值为 true 还是 false ，html 元素都会存在，只是 CSS 中的 display 显示或隐藏 $route和$router的区别$router 为 VueRouter 实例，想要导航到不同 URL，则使用 $router.push 方法$route 为当前 router 跳转对象里面可以获取 name 、 path 、 query 、 params 等 NextTick 是做什么的$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM Vue 组件 data 为什么必须是函数因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了 计算属性computed 和事件 methods 有什么区别我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的 不同点： computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值对于 method ，只要发生重新渲染，method 调用总会执行该函数 Vue 中怎么自定义过滤器可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值Vue.filter(‘reverse’, function (value) { return value.split(‘’).reverse().join(‘’)})过滤器也同样接受全局注册和局部注册 对 keep-alive 的了解keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染 可以使用API提供的props，实现组件的动态缓存 Vue 中 key 的作用key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误 vue 等单页面应用的优缺点优点：良好的交互体验良好的前后端工作分离模式减轻服务器压力缺点：SEO难度较高前进、后退管理初次加载耗时多 Doctype作用，HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;doctype是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档.&lt;!DOCTYPE&gt;声明必须是HTML文档的第一行，位于html标签之前HTML5不基于SGML，所以不需要引用DTD。在HTML5中&lt;!DOCTYPE&gt;只有一种 SGML: 标准通用标记语言,是现时常用的超文本格式的最高层次标准 ###]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局]]></title>
    <url>%2F2019%2F02%2F15%2F%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%2FCSS3%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[转载： 知乎专栏：CSS布局十八般武艺都在这里了参考： CSS 常见布局方式 CSS水平居中+垂直居中+水平/垂直居中的方法总结 常用居中方法 居中在布局中很常见，我们假设DOM文档结构如下，子元素要在父元素中居中：123&lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt;&lt;/div&gt; 水平居中 子元素为行内元素还是块状元素，宽度一定还是宽度未定，采取的布局方案不同。子元素为: 行内元素：对父元素设置text-align:center; 定宽块状元素: 设置左右margin值为auto; 不定宽块状元素: 设置子元素为display:inline,然后在父元素上设置text-align:center; 通用方案: flex布局，对父元素设置display:flex;justify-content:center;例子：固定宽度 这种方式是绝对定位居中，除了使用 margin，我们还可以使用 transform（注意浏览器兼容性，只适用于 ie9+，移动开发请忽略）1234567891011121314151617.container&#123; width: 300px; height: 200px; background: pink; position: relative;&#125;.inner&#123; width: 100px; height: 50px; position: absolute; top: 50%; left: 50%; margin-top: -25px; margin-left: -50px; background: #fff; text-align: center;&#125; 1234567891011121314151617.container&#123; width: 300px; height: 200px; background: pink; position: relative;&#125;.inner&#123; width: 100px; height: 50px; position: absolute; top: 50%; left: 50%; /* transform: translate(-50%, -50%); */ transform: translate(-50px, -25px); background: #fff; text-align: center;&#125; 宽度未知 将子元素设置为行内元素，然后父元素设置 text-align: center。12345678910.container&#123; width: 300px; height: 200px; background: pink; position: relative; text-align: center;&#125;.inner&#123; display: inline-block;&#125; 多个块状元素 上面的方式即使子元素不止一个也想实现水平居中也是有效的，（宽度固定不固定都可，不固定的话就不需要设置宽度，会被自动撑开，但是要考虑到撑爆的情况）例如：12345678910111213141516.container&#123; width: 250px; height: 200px; background: pink; position: relative; text-align: center; padding: 20px;&#125;.inner&#123; display: inline-block; width: 50px; height: 150px; margin: 0 auto; background: #fff; text-align: center;&#125; 当然也可以使用我们刚刚介绍的 flex，我们只需要让子元素在主轴上的对齐方式设置为居中就可以1234567891011121314.container&#123; width: 250px; height: 200px; background: pink; display: flex; justify-content: center; padding: 20px;&#125;.inner&#123; background: #fff; width: 50px; height: 150px; margin-left: 10px;&#125; 垂直居中 垂直居中对于子元素是单行内联文本、多行内联文本以及块状元素采用的方案是不同的。父元素一定，子元素为单行内联文本:设置父元素的height等于行高line-height父元素一定，子元素为多行内联文本:设置父元素的display:table-cell或inline-block，再设置vertical-align:middle;块状元素:设置子元素position:absolute并设置top、bottom为0，父元素要设置定位为static以外的值，margin:auto;通用方案:flex布局，给父元素设置{display:flex; align-items:center;}。 单列布局 特征：定宽、水平居中常见的单列布局有两种： 一种是header、content、footer宽度都相同，其一般不会占满浏览器的最宽宽度，但当浏览器宽度缩小低于其最大宽度时，宽度会自适应。 一种是header、footer宽度为浏览器宽度，但content以及header和footer里的内容却不会占满浏览器宽度。对于第一种，对header、content、footer统一设置width或max-width，并通过margin:auto实现居中。DOM文档:12345&lt;div class="layout"&gt; &lt;div id="header"&gt;头部&lt;/div&gt; &lt;div id="content"&gt;内容&lt;/div&gt; &lt;div id="footer"&gt;尾部&lt;/div&gt;&lt;/div&gt; CSS清单:12345.layout&#123;/* width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/ max-width: 960px; margin: 0 auto;&#125; 对于第二种，header、footer的内容宽度为100%，但header、footer的内容区以及content统一设置width 或 max-width，并通过margin:auto实现居中。DOM文档:1234567&lt;div id="header"&gt; &lt;div class="layout"&gt;头部&lt;/div&gt;&lt;/div&gt;&lt;div id="content" class="layout"&gt;内容&lt;/div&gt;&lt;div id="footer"&gt; &lt;div class="layout"&gt;尾部&lt;/div&gt;&lt;/div&gt; CSS清单:12345.layout&#123;/* width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/ max-width: 960px; margin: 0 auto;&#125; 二列&amp;三列布局 二列布局的特征是侧栏固定宽度，主栏自适应宽度。三列布局的特征是两侧两列固定宽度，中间列自适应宽度。 之所以将二列布局和三列布局写在一起，是因为二列布局可以看做去掉一个侧栏的三列布局，其布局的思想有异曲同工之妙。对于传统的实现方法，主要讨论上图中前三种布局，经典的带有侧栏的二栏布局以及带有左右侧栏的三栏布局，对于flex布局，实现了上图的五种布局。 float + margin 原理说明：设置两个侧栏分别向左向右浮动，中间列通过外边距给两个侧栏腾出空间，中间列的宽度根据浏览器窗口自适应。DOM文档:12345&lt;div id="content"&gt; &lt;div class="sub"&gt;sub&lt;/div&gt; &lt;div class="extra"&gt;extra&lt;/div&gt; &lt;div class="main"&gt;main&lt;/div&gt;&lt;/div&gt; 布局步骤: 对两边侧栏分别设置宽度，并对左侧栏添加左浮动，对右侧栏添加有浮动。对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。CSS清单:123456789101112.sub&#123; width: 100px; float: left;&#125;.extra&#123; width: 200px; float: right;&#125;.main&#123; margin-left: 100px; margin-right: 200px;&#125; 一些说明: 注意DOM文档的书写顺序，先写两侧栏，再写主面板，更换后则侧栏会被挤到下一列（圣杯布局和双飞翼布局都会用到）。 这种布局方式比较简单明了，但缺点是渲染时先渲染了侧边栏，而不是比较重要的主面板。 二列的实现方法 如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。 position + margin 原理说明：通过绝对定位将两个侧栏固定，同样通过外边距给两个侧栏腾出空间，中间列自适应。DOM文档:123&lt;div class="sub"&gt;left&lt;/div&gt;&lt;div class="main"&gt;main&lt;/div&gt;&lt;div class="extra"&gt;right&lt;/div&gt; 布局步骤: 对两边侧栏分别设置宽度，设置定位方式为绝对定位。 设置两侧栏的top值都为0，设置左侧栏的left值为0， 右侧栏的right值为0。 对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。CSS清单:1234567891011121314.sub, .extra &#123; position: absolute; top: 0; width: 200px;&#125;.sub &#123; left: 0;&#125;.extra &#123; right: 0; &#125;.main &#123; margin: 0 200px;&#125; 一些说明: 本方法不限制DOM书写顺序，先写主面板会使主面板部分优先渲染（一般主面板会比侧栏内容重要）。与上一种方法相比，本种方法是通过定位来实现侧栏的位置固定。如果中间栏含有最小宽度限制，或是含有宽度的内部元素，则浏览器窗口小到一定程度，主面板与侧栏会发生重叠。二列的实现方法 如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。 圣杯布局 (float + 负margin)原理说明： 主面板设置宽度为100%，主面板与两个侧栏都设置浮动，常见为左浮动，这时两个侧栏会被主面板挤下去。通过负边距将浮动的侧栏拉上来，左侧栏的负边距为100%，刚好是窗口的宽度，因此会从主面板下面的左边跑到与主面板对齐的左边，右侧栏此时浮动在主面板下面的左边，设置负边距为负的自身宽度刚好浮动到主面板对齐的右边。为了避免侧栏遮挡主面板内容，在外层设置左右padding值为左右侧栏的宽度，给侧栏腾出空间，此时主面板的宽度减小。由于侧栏的负margin都是相对主面板的，两个侧栏并不会像我们理想中的停靠在左右两边，而是跟着缩小的主面板一起向中间靠拢。此时使用相对布局，调整两个侧栏到相应的位置。 DOM文档:12345 &lt;div id="bd"&gt; &lt;div class="main"&gt;center&lt;/div&gt; &lt;div class="sub"&gt;left&lt;/div&gt; &lt;div class="extra"&gt;right&lt;/div&gt; &lt;/div&gt; 布局步骤: 三者都设置向左浮动。 设置main宽度为100%，设置两侧栏的宽度。 设置 负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。 设置main的padding值给左右两个子面板留出空间。 设置两个子面板为相对定位，sub的left值为负的sub宽度，extra的right值为负的extra宽度。CSS清单:123456789101112131415161718192021.main &#123; float: left; width: 100%; &#125; .sub &#123; float: left; width: 190px; margin-left: -100%; position: relative; left: -190px; &#125; .extra &#123; float: left; width: 230px; margin-left: -230px; position: relative; right: -230px; &#125;#bd &#123; padding: 0 230px 0 190px; &#125; 一些说明 DOM元素的书写顺序不得更改。 主面板部分优先渲染（一般主面板会比侧栏内容重要）。 当面板的main内容部分比两边的子面板宽度小的时候，布局就会乱掉。可以通过设置main的min-width属性或使用双飞翼布局避免问题。二列的实现方法 如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的padding-right值，其他操作相同。反之亦然。 双飞翼布局 (float + 负margin)原理说明： 双飞翼布局和圣杯布局的思想有些相似，都利用了浮动和负边距，但双飞翼布局在圣杯布局上做了改进，在main元素上加了一层div, 并设置margin,由于两侧栏的负边距都是相对于main-wrap而言，main的margin值变化便不会影响两个侧栏，因此省掉了对两侧栏设置相对布局的步骤。 DOM文档:12345&lt;div class="main-wrap"&gt; &lt;div class="main"&gt;#main&lt;/div&gt;&lt;/div&gt;&lt;div class="sub"&gt;left&lt;/div&gt;&lt;div class="extra"&gt;right&lt;/div&gt; 布局步骤: 三者都设置向左浮动。设置main-wrap宽度为100%，设置两个侧栏的宽度。设置负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。设置main的margin值给左右两个子面板留出空间。CSS清单:1234567891011121314151617.main-wrap &#123; float: left; width: 100%; &#125; .sub &#123; float: left; width: 190px; margin-left: -100%; &#125; .extra &#123; float: left; width: 230px; margin-left: -230px; &#125;.main &#123; margin: 0 230px 0 190px;&#125; 一些说明 主面板部分优先渲染（一般主面板会比侧栏内容重要）。圣杯采用的是padding，而双飞翼采用的margin，解决了圣杯布局main的最小宽度不能小于左侧栏的缺点。双飞翼布局不用设置相对布局，以及对应的left和right值。 通过引入相对布局，可以实现三栏布局的各种组合，例如对右侧栏设置position: relative; left: 190px;,可以实现sub+extra+main的布局。二列的实现方法 如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置main-wrap的margin-right值，其他操作相同。反之亦然。 flex布局 以下是五种布局的flex布局代码：DOM文档：1234567891011121314151617181920212223&lt;div class="layout"&gt; &lt;aside class="aside"&gt;侧边栏宽度固定&lt;/aside&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="aside"&gt;侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;aside class="aside"&gt;左侧边栏宽度固定&lt;/aside&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="aside"&gt;右侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;aside class="aside"&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class="aside"&gt;第2个侧边栏宽度固定&lt;/aside&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="aside"&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class="aside"&gt;第2个侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt; CSS清单123456789.layout &#123; display: flex;&#125;.main &#123; flex: 1;&#125;.aside &#123; width: 200px;&#125; 与之前所讲的几种传统布局方案相比，flex布局的代码可谓异常简洁，而且非常通用，利用简单的三行CSS即实现了常见的五种布局。 总结 传统的布局方法基于盒状模型，依赖 display属性 + position属性 + float属性，逻辑相对复杂，对于实现一些特殊效果，例如垂直居中，尤其复杂繁琐。而flex布局中的flex容器可以根据实际可用空间动态调整子元素的宽高比和顺序，使元素能够尽可能地利用可用空间，同时也能通过缩小来避免超出。flex布局提供了一套简便、完整、响应式的布局方案。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>页面布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[像素：(px、pt、em、rem、rpx)]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%83%8F%E7%B4%A0%2F%E5%83%8F%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[参考资料：px、em、rem区别介绍字体大小之px、em、rem、pt,字号详解px: px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。 PX特点: 1、 IE无法调整那些使用px作为单位的字体大小； 2、 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位； 3、 Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。pt: pt(point，磅)：是一个物理长度单位，指的是72分之一英寸。表示绝对长度。em: em是相对长度单位，相对于父元素的font-size。如当前对行内文本的字体尺寸未被人为设置，则相对浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。 em特点： 1、 em的值并不是固定的； 2、 em会继承父级元素的字体大小。 注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。所以我们在写CSS的时候，需要注意两点： 1、 body选择器中声明Font-size=62.5%； 2、 将你的原来的px数值除以10，然后换上em作为单位； 3、 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。也就是避免1.2 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。rem: rem（root em，根em）：是CSS3新增的一个相对单位，相对的是HTML根元素，可以只修改根元素就可以成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。兼容性IE9+都可以兼容，对于不兼容的浏览器写一个绝对单位的声明就可以了。rpx: rpx单位是微信小程序中css的尺寸单位，rpx可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。vw vh:vw,vh是css3的新单位，是相对于viewport视窗的宽高进行计算的单位。12341vw=1/100浏览器宽度1vh=1/100浏览器高度vmin：当前 vw 和 vh 中较小的一个值vmax：当前 vw 和 vh 中较大的一个值 vmin、vmax用处做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>像素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重绘(repaint)与回流(reflow)]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E9%87%8D%E7%BB%98(repaint)%E4%B8%8E%E5%9B%9E%E6%B5%81(reflow)%2F</url>
    <content type="text"><![CDATA[文章转载： 浏览器重绘和重排文章参考： 重构与回流 浏览器的重绘与重排 探讨css中repaint和reflow 前言： 页面设计中，不可避免的需要浏览器进行repaint和reflow。那到底什么是repaint和reflow呢。下面谈谈自己对repaint和reflow的理解，以及结合其他技术牛的讲解，谈谈如何优化repaint和reflow。 概述： 重排(回流), 顾名思义就是重新排版的意思; 重绘, 就是浏览器重新绘制。理解重排和重绘的含义十分重要, 因为在评审页面交互效果的时候, 重绘和重排是必须考虑的因素。并不是说交互效果实现了就可以了, 必须同时考虑到这样做会引发什么性能问题。也就是说, 浏览器在进行重绘和重排的时候是要付出高昂的性能代价的。 只有静态页面才会不存在repaint和reflow。repaint主要是针对某一个DOM元素进行的重绘，reflow则是回流，针对整个页面的重排。字面意思来说：repaint就是重绘，reflow就是回流。回流必将引起重绘，而重绘不一定会引起回流，repaint和reflow的目的是：展示一个新的页面样貌。 浏览器执行流： 浏览器每次从服务器下载完页面后就会对页面进行渲染(Render), 这里面就包含了重绘以及重排。每种浏览器虽然工作原理略有差别, 但也遵循以下流程: 览器引擎会解析HTML文档来构建DOM树。树的每个节点都是标签, 有大小边距等等的属性, 这是因为每个HTML元素都遵循盒子模型(隐藏元素不包括在文档树中, 浏览器不会将其渲染)。 渲染树构建完毕后, 浏览器就能够确定每个元素的位置并将元素放到正确的位置上, 再根据树节点的样式属性绘制出页面元素。 由于浏览器的流布局的方式, 对渲染树的计算通常只需要遍历一遍即可。但table及其内部元素除外, 可能需要执行多次计算才能确定好在渲染树中的属性,这个过程通常要耗费3倍以上的时间。 这也是我们要避免使用table标签的其中一个原因。 简言之浏览器执行顺序为： 1. 首先获取html，然后构建dom树 ，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。 2. 浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。 3. DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，render tree不包含隐藏的节点 (比如display:none的节点，还有head节点)，因为这些节点不会用于呈现。 4. 一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。 严重性： 在性能优先的前提下，性能消耗 重排(reflow)大于重绘(repaint)。 体现： repaint是某个DOM元素进行重绘；reflow是整个页面进行重排，也就是页面所有DOM元素渲染。 如何触发： style变动造成repaint和reflow。 不涉及任何DOM元素的排版问题的变动为repaint，例如元素的color/text-align/text-decoration等等属性的变动。 除上面所提到的DOM元素style的修改基本为reflow。例如元素的任何涉及长、宽、行高、边框、display等style的修改。 常见触发场景： 重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。重排(回流)是更明显的一种改变，可以理解为渲染树需要重新计算。 触发repaint: color的修改，如color=#ddd； text-align的修改，如text-align=center； a:hover也会造成重绘。 :hover引起的颜色等不导致页面回流的style变动。 触发reflow： width/height/border/margin/padding的修改，如width=778px； 动画，:hover等伪类引起的元素表现改动，display=none等造成页面回流； appendChild等DOM元素操作； font类style的修改； background的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分background的修改只触发repaint，当然IE不用考虑； scroll页面，这个不可避免； resize页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize程序窗口大小的多窗口操作系统。 读取元素的属性(这个无法理解，但是技术达人是这么说的，那就把它当做定理吧)：读取元素的某些属性(offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE)) 如何避免： 说避免那是不可能的，不然就是以前古老的静态页面了，没有交互，那在现在看来，就是一个失败的作品。所以，在我们进行网页设计的时候，就必须尽量减少页面的repaint和reflow。repaint和reflow的目的是为了展示一个新的页面，那么我们在进行页面交互时，尽量通过各种方法减少repaint和reflow但又能展示一个新的页面的目的。所以下面将结合其他技术达人的建议，通过自己的理解，给大家讲解如何避免和优化repaint和reflow： 尽可能在DOM末梢通过改变class来修改元素的style属性： 将多次改变样式属性的操作合并成一次操作，尽可能的减少受影响的DOM元素。 避免设置多项内联样式：使用常用的class的方式进行设置样式，以避免设置样式时访问DOM的低效率。 设置动画元素position属性为fixed或者absolute：由于当前元素从DOM流中独立出来，因此受影响的只有当前元素，元素repaint。 牺牲平滑度满足性能：动画精度太强，会造成更多次的repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。 避免使用table进行布局：table的每个元素的大小以及内容的改动，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以进行针对性的repaint和避免不必要的reflow。 避免在CSS中使用运算式：学习CSS的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。]]></content>
      <categories>
        <category>前端优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[转载：前端性能优化–yahoo前端性能团队总结的35条黄金定律参考文章：Web前端应该从哪些方面来优化网站? - 斯迪的回答 - 知乎WEB前端性能优化常见方法 前端是庞大的，包括 HTML、 CSS、 Javascript、Image 、Flash等等各种各样的资源。前端优化是复杂的，针对方方面面的资源都有不同的方式。那么，为什么要进行前端性能优化？ 怎么进行优化？ 优化到达的效果是什么？ 为什么需要前端性能优化[优化的好处/目的]好处： 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。 前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。 怎么进行优化 内容优化 减少Http请求次数 原因: 这条策略是最重要最有效的，因为一个完整的请求要经过DNS寻址，与服务器建立连接，发送数据，等待服务器响应，接收数据这样一个消耗时间成本和资源成本的复杂的过程。 使用方法： 从设计实现层面简化页面 合并多个CSS文件和js文件 利用CSS Sprites整合图像 Inline Images(使用 data：URL scheme在实际的页面嵌入图像数据 ) 合理设置HTTP缓存等。 使用懒加载进行图片的加载 减少DNS查询 原因: DNS查询也消耗响应时间，如果我们的网页内容来自各个不同的domain (比如嵌入了开放广告，引用了外部图片或脚本)，那么客户端首次解析这些domain也需要消耗一定的时间。DNS查询结果缓存在本地系统和浏览器中一段时间，所以DNS查询一般是对首次访问响应速度有所影响。 使用方法: 优化网站设计（九）：减少DNS查找的次数 减少DNS查找次数，最理想的方法就是将所有的内容资源都放在同一个域(Domain)下面，这样访问整个网站就只需要进行一次DNS查找，这样可以提高性能。 但理想总归是理想，上面的理想做法会带来另外一个问题，就是由于这些资源都在同一个域，而HTTP /1.1 中推荐客户端针对每个域只有一定数量的并行度（它的建议是2），那么就会出现下载资源时的排队现象，这样就会降低性能。 所以，折衷的做法是：建议在一个网站里面使用至少2个域，但不多于4个域来提供资源。我认为这条建议是很合理的，也值得我们在项目实践中去应用。 避免重定向 当客户端收到服务器的跳转回复时，客户端再次根据服务器回复中的location指定的地址再次发送请求，例如以下跳转回复: 123HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html 当客户端遇到这种回复的时候，用户只能等待客户端再次发送请求，有的网站甚至会一直跳n次，跳到他想带你去的地方…当然在这个时候用户看不到任何页面内容，只有浏览器的进度条一直在刷新。 使用Ajax缓存 Ajax可以帮助我们异步的下载网页内容，但是有些网页内容即使是异步的，用户还是在等待它的返回结果，例如ajax的返回是用户联系人的下拉列表。所以我们还是要注意尽量应用以下规则提高ajax的响应速度。 使用方法： 添加Expires 或 Cache-Control报文头使回复可以被客户端缓存 压缩回复内容 减少dns查询 精简javascript 避免跳转 配置Etags 延迟加载组件,预加载组件 延迟加载 这里讨论延迟加载需要我们知道我们的网页最初加载需要的最小内容集是什么。剩下的内容就可以推到延迟加载的集合中。 Javascript是典型的可以延迟加载内容。一个比较激进的做法是开发网页时先确保网页在没有Javascript的时候也可以基本工作，然后通过延迟加载脚本来完成一些高级的功能。 预加载 与延迟加载目的相反，提前加载的是为了提前加载接下来网页中访问的资源，下面是提前加载的类型 无条件提前加载：当前网页加载完成后，马上去下载一些其他的内容。例如google会在页面加载成功之后马上去下载一个所有结果中会用到的image sprite。 有预期的的加载：这种情况一般发生在网页重新设计时，由于用户经常访问旧网页，本地对旧的网页内容缓存充分从而显得旧网页速度很快，而新的网页内容却没有缓存，设计者可以在旧网页的内容中预先加载一些新网页中可能用到的内容，这样新的网页就会生下来一些需要下载的资源。 减少DOM元素数量: 页面中存在大量DOM元素,会导致javascript遍历DOM的效率变慢。 网页中元素过多对网页的加载和脚本的执行都是沉重的负担，500个元素和5000个元素在加载速度上会有很大差别。 想知道你的网页中有多少元素，通过在浏览器中的一条简单命令就可以算出document.getElementsByTagName(&#39;*&#39;).length 最小化iframe的数量： iframes 提供了一个简单的方式把一个网站的内容嵌入到另一个网站中。但其创建速度比其他包括JavaScript和CSS的DOM元素的创建慢了1-2个数量级。 优点 可以用来加载速度较慢的内容，例如广告。 安全沙箱保护。浏览器会对iframe中的内容进行安全控制。 脚本可以并行下载 缺点 即使iframe内容为空也消耗加载时间 会阻止页面加载 没有语义 避免404：HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。 404我们都不陌生，代表服务器没有找到资源，我们要特别要注意404的情况不要在我们提供的网页资源上，客户端发送一个请求但是服务器却返回一个无用的结果，时间浪费掉了。更糟糕的是我们网页中需要加载一个外部脚本，结果返回一个404，不仅阻塞了其他脚本下载，下载回来的内容(404)客户端还会将其当成Javascript去解析。 服务器优化 (1)使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。 再次强调第一条黄金定律，减少网页内容的下载时间。提高下载速度还可以通过CDN(内容分发网络)来提升。CDN通过部署在不同地区的服务器来提高客户的下载速度。如果你的网站上有大量的静态内容，世界各地的用户都在访问，我说的是youtube么？那CDN是必不可少的。事实上大多数互联网中的巨头们都有自己的CDN。我们自己的网站可以先通过免费的CDN供应商来分发网页资源。 添加Expires 或Cache-Control报文头(这条规则分为两个方面) 对于静态内容添加Expires，将静态内容设为永不过期，或者很长时间以后。在IIS中设置Expires可以看Configure the HTTP Expires Response Header (IIS 7)。 对于动态内容应用合适的Cache-Control，让浏览器根据条件来发送请求。关于asp.net的caching，可以看asp.net cache feature和asp.net caching best practices。 (2)GZIP压缩 Gzip通常可以减少70%网页内容的大小，包括脚本、样式表、图片等文件。Gzip比deflate更高效，主流服务器都有相应的压缩支持模块。 (3)设置ETag：ETags（Entity tags，实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。 虽然标题叫配制ETags，但是这里你要根据具体情况进行一些判断。首先Etag简单来说是通过一个文件版本标识使得服务器可以轻松判断该请求的内容是否有所更新，如果没有就回复304 (not modified)，从而避免下载整个文件。 (4)提前刷新缓冲区+ (5)对Ajax请求使用GET方法 浏览器在实现XMLHttpRequest POST的时候分成两步，先发header，然后发送数据。而GET却可以用一个TCP报文完成请求。另外GET从语义上来讲是去服务器取数据，而POST则是向服务器发送数据，所以我们使用Ajax请求数据的时候尽量通过GET来完成。 (6)避免空的图像src 空的图片src仍然会使浏览器发送请求到服务器，这样完全是浪费时间，而且浪费服务器的资源。尤其是你的网站每天被很多人访问的时候，这种空请求造成的伤害不容忽略。 Cookie优化 (1)减小Cookie大小 去除没有必要的cookie，如果网页不需要cookie就完全禁掉 将cookie的大小减到最小 注意cookie设置的domain级别，没有必要情况下不要影响到sub-domain 设置合适的过期时间，比较长的过期时间可以提高响应速度。 (2)针对Web组件使用域名无关的Cookie 大多数网站的静态资源都没必要cookie，我们可以采用不同的domain来单独存放这些静态文件，这样做不仅可以减少cookie大小从而提高响应速度，还有一个好处是有些proxy拒绝缓存带有cookie的内容，如果能将这些静态资源cookie去除，那就可以得到这些proxy的缓存支持。 常见的划分domain的方式是将静态文件放在static.example.com，动态内容放在www.example.com。 也有一些网站需要在二级域名上应用cookie，所有的子域都会继承，这种情况下一般会再购买一个专门的域名来存放cookie-free的静态资源。例如Yahoo!的yimg.com，YouTube的ytimg.com等。 CSS优化 (1)将CSS代码放在HTML页面的顶部 经样式表(css)放在网页的HEAD中会让网页显得加载速度更快，因为这样做可以使浏览器逐步加载已将下载的网页内容。这对内容比较多的网页尤其重要，用户不用一直等待在一个白屏上，而是可以先看已经下载的内容。 如果将样式表放在底部，浏览器会拒绝渲染已经下载的网页，因为大多数浏览器在实现时都努力避免重绘，样式表中的内容是绘制网页的关键信息，没有下载下来之前只好对不起观众了。 (2)避免使用CSS表达式 CSS表达式可以动态的设置CSS属性，在IE5-IE8中支持，其他浏览器中表达式会被忽略。例如下面表达式在不同时间设置不同的背景颜色。 CSS表达式的问题在于它被重新计算的次数远比我们想象的要多，不仅在网页绘制或大小改变时计算，即使我们滚动屏幕或者移动鼠标的时候也在计算，因此我们还是尽量避免使用它来防止使用不当而造成的性能损耗。 (3)使用来代替@import 避免使用@import的原因很简单，因为它相当于将css放在网页内容底部。 (4)避免使用Filters AlphaImageLoad也是IE5.5 - IE8中支持，这种滤镜的使用会导致图片在下载的时候阻塞网页绘制，另外使用这种滤镜会导致内存使用量的问题。IE9中已经不再支持。 JS优化 (1)将JavaScript脚本放在页面的底部。 HTTP/1.1 specification建议浏览器对同一个hostname不要超过两个并行下载连接， 所以当你从多个domain下载图片的时候可以提高并行下载连接数量。但是当脚本在下载的时候，即使是来自不同的hostname浏览器也不会下载其他资源，因为浏览器要在脚本下载之后依次解析和执行。 因此对于脚本提速，我们可以考虑以下方式， 把脚本置底，这样可以让网页渲染所需要的内容尽快加载显示给用户。 现在主流浏览器都支持defer关键字，可以指定脚本在文档加载后执行。 HTML5中新加了async关键字，可以让脚本异步执行。 (2)将JavaScript和CSS作为外部文件来引用： 使用外部Javascript和CSS文件可以使这些文件被浏览器缓存，从而在不同的请求内容之间重用。 同时将Javascript和CSS从inline变为external也减小了网页内容的大小。 使用外部Javascript和CSS文件的决定因素在于这些外部文件的重用率，如果用户在浏览我们的页面时会访问多次相同页面或者可以重用脚本的不同页面，那么外部文件形式可以为你带来很大的好处。但对于用户通常只会访问一次的页面，例如microsoft.com首页，那inline的javascript和css相对来说可以提供更高的效率。 (3)缩小JavaScript和CSS 精简就是将Javascript或CSS中的空格和注释全去掉， (4)删除重复的脚本 重复的脚本不仅浪费浏览器的下载时间，而且浪费解析和执行时间。一般用来避免引入重复脚本的做法是使用统一的脚本管理模块，这样不仅可以避免重复脚本引入，还可以兼顾脚本依赖管理和版本管理。 (5)最小化DOM的访问：使用JavaScript访问DOM元素比较慢。 通过Javascript访问DOM元素没有我们想象中快，元素多的网页尤其慢，对于Javascript对DOM的访问我们要注意 缓存已经访问过的元素 Offline更新节点然后再加回DOM Tree 避免通过Javascript修复layout (6)开发智能的事件处理程序 这里说智能的事件处理需要开发者对事件处理有更深入的了解，通过不同的方式尽量少去触发事件，如果必要就尽早的去处理事件。 比如一个div中10个按钮都需要事件句柄，那么我们可以将事件放在div上，在事件冒泡过程中捕获该事件然后判断事件来源。 (7)javascript代码注意： 谨慎使用with,避免使用eval Function函数,减少作用域链查找。 with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的 执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。 因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。 图像优化 (1)优化图片大小 检查GIF图片中图像颜色的数量是否和调色板规格一致。如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。可以使用imagemagick检查：identify -verbose image.gif 尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。下面这条简单的命令可以安全地把GIF格式转换为PNG格式： convert image.gif image.png 在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如： pngcrush image.png -rem alla -reduce -brute result.png 在所有的JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息 jpegtran -copy none -optimize -perfect src.jpg dest.jpg (2)通过CSS Sprites优化图片 Spirite中水平排列图片，垂直排列会增加文件大小； Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式； 不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小,但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100×100的图片为1万像素，1000×1000就是100万像素。 (3)不要在HTML中使用缩放图片 不要通过图片缩放来适应页面，如果你需要小图片，就直接使用小图片吧。 (4)favicon.ico要小而且可缓存 网站图标文件favicon.ico，不管你服务器有还是没有，浏览器都会去尝试请求这个图标。所以我们要确保这个图标 存在 文件尽量小，最好小于1k 设置一个长的过期时间 移动客户端 保持单个内容小于25KB 这限制是因为iphone，他只能缓存小于25K，注意这是解压后的大小。所以单纯gzip不一定够用，精简文件工具要用上了。 打包组建成符合文档 把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组建。当你使用这条规则时，首先要确定用户代理是否支持（iPhone不支持）。 待解决的方面 转载别人，如有错误请指出。]]></content>
      <categories>
        <category>前端优化</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2019%2F01%2F01%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[定义二分查找又称折半查找，它是一种效率较高的查找方法。二分查找要求：线性表是有序表，即表中结点按关键字有序，并且要用向量作为表的存储结构。不妨设有序表是递增有序的。 基本思想二分查找的基本思想是：设R[low..high]是当前的查找区间（1）首先确定该区间的中点位置：mid = [(low+hight)/2]（2）然后将待查的K值与R[mid].key比较：若相等，则查找成功并返回此位置，否则须确定新的查找区间，继续二分查找，具体方法如下：① 若R[mid].key&gt;K，则由表的有序性可知R[mid..n].keys均大于K，因此若表中存在关键字等于K的结点，则该结点必定是在位置mid左边的子表R[1..mid-1]中，故新的查找区间是左子表R[1..mid-1]。② 若R[mid].key&lt;K，则要查找的K必在mid的右子表R[mid+1..n]中，即新的查找区间是右子表R[mid+1..n]。下一次查找是针对新的查找区间进行的。 因此，从初始的查找区间R[1..n]开始，每经过一次与当前查找区间的中点位置上的结点关键字的比较，就可确定查找是否成功，不成功则当前的查找区间就缩小一半。这一过程重复直至找到关键字为K的结点，或者直至当前的查找区间为空(即查找失败)时为止。 优缺点二分查找(折半查找)优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。时间复杂度可以表示O(h)=O(log2n)，以2为底，n的对数。比如数组长度为10，最多找4次。 储存结构二分查找只适用于顺序储存结构]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪元素和伪类]]></title>
    <url>%2F2018%2F11%2F16%2FCSS3%2F%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[伪元素和伪类伪类包含两种：状态伪类和结构性伪类。 状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。 当元素处于某状态时会呈现该样式，而进入另一状态后，该样式也会失去。常见的状态伪类主要包括： :link 应用于未被访问过的链接； :hover 应用于鼠标悬停到的元素； :active 应用于被激活的元素； :visited 应用于被访问过的链接，与:link互斥。 :focus 应用于拥有键盘输入焦点的元素。 结构性伪类是css3新增选择器，利用dom树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少class和id属性的定义，使文档结构更简洁。常见的包括： :first-child 选择某个元素的第一个子元素； :last-child 选择某个元素的最后一个子元素； :nth-child() 选择某个元素的一个或多个特定的子元素； :nth-last-child() 选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算； :nth-of-type() 选择指定的元素； :nth-last-of-type() 选择指定的元素，从元素的最后一个开始计算； :first-of-type 选择一个上级元素下的第一个同类子元素； :last-of-type 选择一个上级元素的最后一个同类子元素； :only-child 选择的元素是它的父元素的唯一一个子元素； :only-of-type 选择一个元素是它的上级元素的唯一一个相同类型的子元素； :empty 选择的元素里面没有任何内容。 伪元素是对元素中的特定内容进行操作，而不是描述状态。它的操作层次比伪类更深一层，因此动态性比伪类低很多。实际上，伪元素就是选取某些元素前面或后面这种普通选择器无法完成的工作。控制的内容和元素是相同的，但它本身是基于元素的抽象，并不存在于文档结构中！常见的伪元素选择器包括： :first-letter 选择元素文本的第一个字（母）。 :first-line 选择元素文本的第一行。 :before 在元素内容的最前面添加新内容。 :after 在元素内容的最后面添加新内容。 注意事项 有时你会发现伪类元素使用了两个冒号 (::) 而不是一个冒号 (:)，这是 CSS3 规范中的一部分要求，目的是为了区分伪类和伪元素，大多数浏览器都支持这两种表示方式。单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。对于 CSS2 中已经有的伪元素，例如 :before，单冒号和双冒号的写法 ::before 作用是一样的。 所以，如果你的网站只需要兼容 webkit、firefox、opera 等浏览器，建议对于伪元素采用双冒号的写法，如果不得不兼容 IE 浏览器，还是用 CSS2 的单冒号写法比较安全。 参考文章： 谈谈css伪类与伪元素]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5新特性]]></title>
    <url>%2F2018%2F11%2F06%2FH5%2FHTML5%2F</url>
    <content type="text"><![CDATA[语义化标签: header footer nav section article aside 等增强型表单：HTML4: text、checkbox、password、radio、submit、reset、FileHTML5： date(从一个日期选择器选择一个日期) email(包含 e-mail 地址的输入域) number(数值的输入域) range(一定范围内数字值的输入域) search(用于搜索域) tel(定义输入电话号码字段) url、 color、 month、week等 视频和音频：audiovideoCanvas绘图SVG绘图 地理定位：Geolocation拖放API：dragweb worker：是运行在后台的JavaScript,独立于其他脚本，不会影响页面的性能web storage:localStorage sessionStorageWebSocket:HTML5开始提供的一种在单个TCP` 连接上进行全双工通讯的协议]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒子模型]]></title>
    <url>%2F2018%2F11%2F06%2FCSS3%2F%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[盒子样式介绍 width和height：内容的宽度、高度（不是盒子的宽度、高度） padding：内边距。 border：边框。 margin：外边距。 盒子模型的分类与概念 盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是IE盒子模型和标准 w3c 盒子模型。他们对盒子模型的解释各不相同: IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 padding。 标准 W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。 ps: 1. ie8以上都是w3c标准盒模型 2. ie5极其以下都是ie盒子模型，ie6、ie7、ie8在混杂模式下ie盒模型， 3. 在标准模式下是w3c标准盒模型 4. 注意：ie6在混杂模式下一定是Ie盒模型，而ie7、ie8在混杂模式下不一定是ie盒模型 border-box width 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。注意，填充和边框将在盒子内 。例如, .box {width: 350px; border: 10px solid black;} 导致在浏览器中呈现的宽度为350px的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。这里的维度计算为：width = border + padding + 内容的 width，height = border + padding + 内容的 height。 box-sizing：content-box（默认）content-box 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。border-boxborder-box 告诉浏览器去理解你设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px,那么这100px会包含其border和padding，内容区的实际宽度会是width减去(border + padding)的计算值。大多数情况下这使得我们更容易的去设定一个元素的宽高。inherit]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[块级元素行内元素]]></title>
    <url>%2F2018%2F11%2F06%2FCSS3%2F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[定义块级元素(display: block): 1. 每个块级元素都从新的一行开始，并且其后的元素也另起一行。 2. 元素的高度、宽度、行高以及顶和底边距都可设置。 3. 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致）。默认高度等于子元素高度。父子均是块级元素时，子块的高度可能冲破父级的限制 内联元素(display: inline) 1. 指的是书写完成后不会自动换行，并且元素没有宽和高。 2. 和其他内联元素都在一行上； 3. 可以通过margin、padding来改变左右的距离，但不可以改变上下的距离，导致width、height、line-height失效或。可以使用border。 4. 内联元素之间有空白区域，空白区域的形成是因为&lt;span&gt;之间有回车，在html中，空格、制表符、回车都属于空白符，多个空白符都会视为一个空格，空格的大小由父级&lt;div&gt;的font-size决定。注意：只有内联(内联块)与内联(内联块)之间的空白符才会形成一个空格，文本元素(除空白符)也是属于内联元素。常用解决方法，给&lt;div&gt;设置font-size: 0;，在&lt;span&gt;上把font-size设置回去 内联块状元素(display: inline-block) 1. 和其他元素都在一行上； 2. 元素的高度、宽度、行高以及顶和底边距都可设置。 3. 它也会有元素间出现空白区域的问题 空元素没有内容的HTML元素&lt;br&gt;、&lt;hr&gt;、&lt;img&gt;、&lt;input&gt;、&lt;link&gt;、&lt;meta&gt; 分类内联元素有：span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button（默认display：inline-block）块级元素有：div、p、h1~h6、ul、ol、dl、li、dd、table、hr、blockquote、address、menu、pre，HTML5新增的header、section、aside、footer内联块状元素： a, br, em, font, img, input, label, select, small, span, textarea]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[README]]></title>
    <url>%2F2018%2F10%2F22%2FREADME%2FREADME%2F</url>
    <content type="text"><![CDATA[It just a test music, but i like it var ap = new APlayer({ element: document.getElementById("aplayer-veZLYhwd"), narrow: false, autoplay: true, showlrc: false, music: { title: "起风了", author: "买辣椒也用券", url: "/assets/music/music.mp3", pic: "/assets/music/music.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深浅拷贝]]></title>
    <url>%2F2018%2F10%2F16%2FJavaScript%2F%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[转载： js 深浅拷贝 笔记总结 [JS]深拷贝与浅拷贝的区别，实现深拷贝的几种方法 JS 数据类型JavaScript的数据类型有： 数值类型(number) 、 字符串类型(string) 、 布尔类型(boolean) 、 null 、undefined 、对象(数组、正则表达式、日期、函数)大致分为两种： 基本数据类型 和 引用数据类型基本数据类型： 数字类型(number)、字符串类型(string)、布尔类型(boolean)、null、undefined引用数据类型： 常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等 深浅拷贝区别 如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。 浅拷贝浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存 浅拷贝只是拷贝基本类型的数据，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，因此存在父对象被篡改的可能，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 深拷贝深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。 深拷贝就是能够实现真正意义上的数组和对象的拷贝。递归调用”浅拷贝”。（深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象） 实现深浅拷贝浅拷贝例子：12345let a=[0,1,2,3,4], b=a;console.log(a===b);a[0]=1;console.log(a,b); 运行结果：嗯？明明b复制了a，为啥修改数组a，数组b也跟着变了，这里我不禁陷入了沉思。那么这里，就得引入基本数据类型与引用数据类型的概念了。 a.基本类型–名值存储在栈内存中，例如let a=1;当你b=a复制时，栈内存会新开辟一个内存，例如这样：所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。 b.引用数据类型–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，起步就达到深拷贝的效果了 1.我们怎么去实现深拷贝呢，这里可以递归递归去复制所有层级属性。这么我们封装一个深拷贝的函数 123456789101112131415161718192021function deepClone(obj)&#123; let objClone = Array.isArray(obj)?[]:&#123;&#125;; if(obj &amp;&amp; typeof obj==="object")&#123; for(key in obj)&#123; if(obj.hasOwnProperty(key))&#123; //判断ojb子元素是否为对象，如果是，递归复制 if(obj[key] &amp;&amp; typeof obj[key] ==="object")&#123; objClone[key] = deepClone(obj[key]); &#125;else&#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125;let a=[1,2,3,4], b=deepClone(a);a[0]=2;console.log(a,b); 运行结果:跟之前想象的一样，现在b脱离了a的控制，不再受a影响了。这里再次强调，深拷贝，是拷贝对象各个层级的属性，可以看个例子。JQ里有一个extend方法也可以拷贝对象，我们来看看1234let a=[1,2,3,4], b=a.slice();a[0]=2;console.log(a,b); 运行结果：那是不是说slice方法也是深拷贝了，毕竟b也没受a的影响，上面说了，深拷贝是会拷贝所有层级的属性，还是这个例子，我们把a改改12345let a=[0,1,[2,3],4], b=a.slice();a[0]=1;a[2][0]=1;console.log(a,b); 运行结果：拷贝的不彻底啊，b对象的一级属性确实不受影响了，但是二级属性还是没能拷贝成功，仍然脱离不了a的控制，说明slice根本不是真正的深拷贝。这里引用知乎问答里面的一张图 第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。 同理，concat方法与slice也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。 2.除了递归，我们还可以借用JSON对象的parse和stringify 12345678910function deepClone(obj)&#123; let _obj = JSON.stringify(obj), objClone = JSON.parse(_obj); return objClone&#125; let a=[0,1,[2,3],4], b=deepClone(a);a[0]=1;a[2][0]=1;console.log(a,b); 运行结果：可以看到，这下b是完全不受a的影响了。 附带说下，JSON.stringify与JSON.parse除了实现深拷贝，还能结合localStorage实现对象数组存储 3.除了上面两种方法之外，我们还可以借用JQ的extend方法。$.extend( [deep ], target, object1 [, objectN ] )deep表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。object1 objectN可选。 Object类型 第一个以及第N个被合并的对象。12345let a=[0,1,[2,3],4], b=$.extend(true,[],a);a[0]=1;a[2][0]=1;console.log(a,b); 可以看到，效果与上面方法一样，只是需要依赖JQ库。 说了这么多，了解深拷贝也不仅仅是为了应付面试题，在实际开发中也是非常有用的。例如后台返回了一堆数据，你需要对这堆数据做操作，但多人开发情况下，你是没办法明确这堆数据是否有其它功能也需要使用，直接修改可能会造成隐性问题，深拷贝能帮你更安全安心的去操作数据，根据实际情况来使用深拷贝，大概就是这个意思。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-思维]]></title>
    <url>%2F2018%2F10%2F16%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[题目： 给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值方法一：123a = a + b;b = a - b;a = a - b; 方法二：123a = a^b;b = a^b;a = a^b; 题目： 给两个杯子，一个5升，一个6升，水随便用，最后取出3升水方法： 6升装满倒入5升杯子，6升杯子里剩1升水； 6升杯子中的1升倒入5升杯子； 6升杯子装满水倒入5升杯子，6升杯子里剩2升水；把5升杯子水倒掉； 6升杯子中的2升倒入5升杯子； 6升杯子装满水倒入5升杯子，6升杯子里剩3升水，完成。 题目： 给10个箱子，有一个比其他得要轻，用最少的比较次数找出这个箱子方法：二分法：用天平左右各五个进行称量，10 =&gt; 5较轻的一组留下一个，继续进行分开称量，如果左右相等，则剩余的那一个为最轻的，否则剩下的两个继续进行比较5 =&gt; 1 || 5 =&gt; 2最后一次比较 2 =&gt; 1]]></content>
      <categories>
        <category>思维能力</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP和HTTPS的区别]]></title>
    <url>%2F2018%2F10%2F15%2FHTTP%2FHTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPHTTP的基本概念 HTTP: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTP: 是超文本传输协议，信息是明文传输 HTTP的缺点 通信使用明文，可能被窃听不验证通信方的身份，可能遭遇伪装无法证明报文的完整性，有可能遭遇篡改 HTTPSHTTPS的基本概念 HTTPS(Secure Hypertext Transfer Protocol)是安全超文本传输协议,简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 https: 是具有安全性的ssl加密传输协议 HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。注意： 凡是用过网银的用户一定见过类似的网址 https://bank.xxxx.com ，这个就是传输层加密，报文格式：IP + TCP + SSL + HTTP SSL负责加密/解密工作，由于SSL工作在传输层与应用层之间，一般称之为传输层加密。 通常来说，加密代理服务器，还有Cisco Anyconnect 都属于传输层加密，都是基于SSL/TLS加密。 HTTPS的工作原理 客户端发起HTTPS请求 用户在浏览器里输入一个https网址，然后连接到server的443端口。 服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。 这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等 客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。 HTTPS的优点 SEO方面谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 安全性 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本1234567891、HTTPS具有更好的加密性能，避免用户信息泄露;2、HTTPS复杂的传输方式，降低网站被劫持的风险;3、搜索引擎已经全面支持HTTPS抓取、收录，并且会优先展示HTTPS结果;4、从安全角度来说个人觉得要做HTTPS，不过HTTPS可以采用登录后展示;5、HTTPS绿锁表示可以提升用户对网站信任程度;6、基础成本可控，证书及服务器已经有了成型的支持方案;7、网站加载速度可以通过cdn等方式进行弥补，但是安全不能忽略;8、HTTPS是网络的发展趋势，早晚都要做;9、可以有效防止山寨、镜像网站; HTTPS的缺点 SEO方面 据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。 而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。 最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 经济方面 SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。 HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。 HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去。 HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。1234567891、HTTPS会降低用户访问速度，增加网站服务器的计算资源消耗;2、目前搜索引擎只是收录了小部分HTTPS内容，应该保持观望制度;3、HTTPS需要申请加密协议，增加了运营成本;4、百度目前对HTTPS的优先展现效果不明显，谷歌较为明显;5、技术门槛较高，无从下手;6、目前站点不涉及私密信息，无需HTTPS;7、兼容性有待提升，如robots不支持/联盟广告不支持等;8、HTTPS网站的安全程度有限，该被黑还是被黑;9、HTTPS维护比较麻烦，在搜索引擎支持HTTP的情况，没必要做HTTPS; HTTP和HTTPS的区别 区别 HTTP HTTPS 端口号 80 443 安全性 http是超文本传输协议，信息是明文传输，因此使用HTTP协议传输隐私信息非常不安全 https 是具有安全性的ssl加密传输协议 连接 http的连接很简单，是无状态的 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全 证书 https协议需要到ca申请证书，一般免费证书很少，需要交费。 参考文章： HTTP和HTTPS的区别 HTTP与HTTPS的区别 HTTP详解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP连接性能优化]]></title>
    <url>%2F2018%2F10%2F14%2FHTTP%2FHTTP%E8%BF%9E%E6%8E%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[HTTP和TCP/IP的关系HTTP—&gt;(TSL/SSL)—&gt;TCP—&gt;IPHTTP处于应用层、TCP处于传输层、IP处于网络层 HTTP将所需要传输的数据以流的形式传递给TCP程序 TCP解析数据中的IP地址和端口号，将数据流分割成数据段，并添加上TCP段首部，如TCP握手（ACK、SYNC等），源端口，目的端口、TCP校验和等 TCP程序将包装好的TCP数据段叫给IP程序，IP程序在此基础上封装进去IP分组首部，如源IP地址、目的IP地址，数据报总长度、分组ID、首部长度、首部校验和等等 最后交给数据链路层去发送这个IP分组数据段 TCP性能的考虑HTTP紧挨着TCP，所以TCP的链接性能考虑直接影响的HTTP事务的性能。 HTTP事务时延一次HTTP请求可分为 DNS查询、连接、请求、事务处理、响应、关闭连接。每一步都会产生时延。其中，相对于连接、请求所消耗的时间，事务处理的时间是很短的。 对HTTP程序员产生影响的时延 TCP握手建立链接 TCP慢启动拥塞控制 数据聚集的Nagle算法 用于捎带确认的TCP延迟确认算法 TIME_WAIT 时延和端口耗尽 HTTP连接处理Connection首部真正用途HTTP允许客户端和源服务器之间存在多个代理服务器或高速缓存服务器，进行HTTP连接通信时，可以将HTTP首部逐跳的经过这些设备。这个时候，怎么在相邻的HTTP应用程序之间的连接应用一些特殊的选项呢？— Connection首部，可以承载3种不同类型的标签，这些标签不会传播到其它连接中去。a、HTTP首部字段名，列出了只与此连接有关的选项b、任意标签，用于描述此连接的非标准选项c、值close，说明操作完成之后需关闭这条持久连接由于添加Connection首部的其它首部字段，不能随着报文转发出去。因此将逐跳首部放入Connection首部，就可以达到对首部的保护。例：1234HTTP/1.1 200 OKCache-control: max-age=3600Connection: meter,close,bill-my-credit-cardMeter: max-uses=3,max-refuses=6,dont-report 实例说明：不应该转发Meter首部，要应用假想的bill-my-credit-card选项，且本次事务后应关闭持久连接。 串行事务处理延迟如果只对HTTP事务进行简单管理，TCP的性能时延可能会叠加起来，包括多次的建立连接和断开连接。 提高HTTP连接性能的四个方法：并行连接通过多条TCP连接发起并发的HTTP请求并行连接从理论上回提高页面的加载速度，因为多个请求同时发出，时延可以重叠起来。但并行连接并不是一点更快，原因可能是：客户端带宽限制、消耗更多的内存和计算资源。现代浏览器确实使用并行连接，但会限制连接数在一个较小的值（通常是4），并且服务器可以关闭来自特定客户端的超量连接。 持久连接重用TCP连接，以消除连接及关闭的时延重用连接：HTTP/1.1(HTTP/1.0增强版)允许HTTP设备在事务处理结束后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接。 持久连接+并行连接持久的连接的管理很重要，不小心会累积出大量的空闲连接 HTTP/1.0 + Keep-alive连接Connection： Keep-alive属性出现在1996年HTTP/1.0版本中，当初也是被当做实验型持久连接。 可以用通用首部Keep-Alive属性指定由逗号分隔的选项来调节keep-alive的行为。例：12Connection：Keep-aliveKeep-Alive: max=5,timeout=120 说明：服务器还会为另外5个事务保持连接的打开状态，或者将打开状态保持到连接空闲后2分钟。 Connection属于逐跳首部，只适用于单条传输链路。 现在HTTP/1.1不再需要此属性，默认开启持久连接的。 HTTP/1.1 持久连接HTTP/1.1逐渐停止了对keep-alive连接的支持，用一种名为持久连接(persistentconnection)的改进型设计取代了它。 必须显示指定Connection: close才会指定TCP连接在响应后立即关闭。当客户端发送了Connection: close请求首部之后，客户端就无法在那条连接上发送更多请求了。只有当连接上所有的报文都有正确的、自定义报文长度时，连接才能持久保持。 管道化连接通过共享的TCP连接发起并发的HTTP请求 HTTP/1.1 允许在持久连接上可选的使用请求管道。在响应到达之前，可以将多条请求放入队列，降低网络回环时间。 注：HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST），因为出错时，无法安全的重试POST这样的非幂请求。 复用的连接交替传送请求和相应报文（实验阶段） HTTP1.1 的特点持久连接每个TCP连接开始都有三次握手，要经历一次客户端与服务器间完整的往返，而开启了持久连接就不需要每次都要握手在连接中有这个属性的就是打开了持久化连接。下图展示了通过持久 TCP 连接取得 HTML 和 CSS 文件： HTTP2.0 的特点HTTP 长连接与短连接HTTP 是无状态的也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话.http1.0中默认是关闭的，需要在http头加入”Connection: Keep-Alive”，才能启用Keep-Alivehttp 1.1中默认启用Keep-Alive，如果加入”Connection: close”才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。下图是普通模式和长连接模式的请求对比： 开启Keep-Alive的优缺点优点： Keep-Alive模式更加高效，因为避免了连接建立和释放的开销缺点： 长时间的Tcp连接容易导致资源无效占用，浪费系统资源 当保持长连接时，如何判断一次请求已经完成？当保持长连接时，如何判断一次请求已经完成？ Content-LengthContent-Length表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。所以，当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置Content-Length来控制请求的结束。但当服务器并不知道请求结果的长度时，如一个动态的页面或者数据，Content-Length就无法解决上面的问题，这个时候就需要用到Transfer-Encoding字段。 Transfer-EncodingTransfer-Encoding是指传输编码，在上面的问题中，当服务端无法知道实体内容的长度时，就可以通过指定Transfer-Encoding: chunked来告知浏览器当前的编码是将数据分成一块一块传递的。当然, 还可以指定Transfer-Encoding: gzip, chunked表明实体内容不仅是gzip压缩的，还是分块传递的。最后，当浏览器接收到一个长度为0的chunked时， 知道当前请求内容已全部接收。 Keep-Alive timeout：Httpd守护进程，一般都提供了keep-alive timeout时间设置参数。比如nginx的keepalive_timeout，和Apache的KeepAliveTimeout。这个keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住keepalive_timeout秒后，才开始关闭这个连接。当httpd守护进程发送完一个响应后，理应马上主动关闭相应的tcp连接，设置 keepalive_timeout后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到浏览器发过来http请求，则关闭这个http连接。 Tcp的Keepalive：连接建立之后，如果客户端一直不发送数据，或者隔很长时间才发送一次数据，当连接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，连接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文（侦测包）给对方，如果对方回应了这个报文，说明对方还在线，连接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持连接。 tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。tcp keep-alive保鲜定时器，支持三个系统内核配置参数：net.ipv4.tcp_keepalive_intvl = 15net.ipv4.tcp_keepalive_probes = 5net.ipv4.tcp_keepalive_time = 1800keepalive是TCP保鲜定时器，当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）了tcp_keepalive_time后，服务器就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 tcp_keepalive_intvl后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试tcp_keepalive_probes,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。 参考文章： 浅谈Http长连接和Keep-Alive以及Tcp的Keepalive、http性能优化]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F10%2F12%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git 常用命令个人学习经历 从认识到使用git命令已有两年多的时间了，记得刚刚认识它的时候很是害怕，害怕那看不懂的命令，以至于每次提交代码都要用github客户端进行提交。当然了，那是的我对客户端也是晦涩难懂（现在也是），以至于要彻底放弃。有时每次提交代码都要把文件拉到网页上面进行提交，很是麻烦。后来跟着老师的课程渐渐地认识了git，才发现是如此的好用，慢慢的发现自己已经离不开它了。虽然以前已经整理过一些关于git的命令，但却凌乱不堪，以至于自己常常自惭形秽。今天我根据阮一峰老师的博客对自己的这篇文章进行重构，让自己的博客文章慢慢的有自己的思想和见解。 –2019-3-8 GIT命令1.新建代码库12345678910# 在当前目录新建一个Git代码库git init# 新建一个目录，将其初始化为Git代码库git init [project-name]# 下载一个项目和它的整个代码历史git clone [url]# 例： git clone git@github.com:aLittleLittleStar/Travel.git 2.配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置git config --list# 编辑Git配置文件git config -e [--global]# 设置提交代码时的用户信息git config [--global] user.name "[name]"git config [--global] user.email "[email address]" 3.增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 4.代码提交123456789101112131415161718192021# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -a# 提交并添加注释git commit -am "init"# 提交时显示所有diff信息git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 5.分支123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 查看本地所有分支，当前分支会被星号标示出git branch# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 可以看见每一个分支的最后一次提交git branch -v# 可以查看本地分支对应的远程分支git branch -vv# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到dev分支git checkout dev# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支git merge [branch]# 将分支dev与当前分支进行合并git merge origin/dev# 选择一个commit，合并进当前分支git cherry-pick [commit]# 给分支重命名git branch -m oldName newName# 删除分支，如果在分支中有一些未merge的提交，那么会删除分支失败git branch -d [branch-name]# 强制删除dev分支git branch -D dev# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 6.标签1234567891011121314151617181920212223242526# 列出所有taggit tag# 新建一个tag在当前commitgit tag [tag]# 新建一个tag在指定commitgit tag [tag] [commit]# 删除本地taggit tag -d [tag]# 删除远程taggit push origin :refs/tags/[tagName]# 查看tag信息git show [tag]# 提交指定taggit push [remote] [tag]# 提交所有taggit push [remote] --tags# 新建一个分支，指向某个taggit checkout -b [branch] [tag] 7.查看信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 显示有变更的文件git status# 查询repo的状态. -s表示short, -s的输出标记会有两列,# 第一列是对staging区域而言,第二列是对working目录而言.git status -s# 显示当前分支的版本历史git log# 显示commit历史，以及每次commit发生变更的文件git log --stat# 搜索提交历史，根据关键词git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]# 显示指定文件相关的每一次diffgit log -p [file]# 显示过去5次提交git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序git shortlog -sn# 显示指定文件是什么人在什么时间修改过git blame [file]# 显示暂存区和工作区的差异git diff# 显示暂存区和上一个commit的差异git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异git diff HEAD# 显示两次提交之间的差异git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码git diff --shortstat "@&#123;0 day ago&#125;"# 显示某次提交的元数据和内容变化git show [commit]# 显示某次提交发生变化的文件git show --name-only [commit]# 显示某次提交时，某个文件的内容git show [commit]:[filename]# 显示当前分支的最近几次提交git reflog 8.远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force# 推送所有分支到远程仓库git push [remote] --all 9撤销123456789101112131415161718192021222324252627282930313233343536373839# git撤销本地所有未提交的更改# 第一个命令只删除所有untracked的文件，如果文件已经被tracked,# 修改过的文件不会被回退。而第二个命令把tracked的文件revert到# 前一个版本，对于untracked的文件(比如编译的临时文件)都不会被删除。git clean -dfgit reset --hard# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop 10.其他1234567891011121314151617181920# 生成一个可供发布的压缩包git archive# 看你commit的日志git log --oneline# 查看帮助git checkout --help# 查看目录ls# 查看所有目录ls -al# 查看文件内容cat git.md# 查看git的版本信息git --version Git fetch &amp;&amp; Git pull 详解123456789101112```__git fetch__是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。__git pull__ 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。__分支的概念：__分支是用来标记特定代码的提交，每一个分支通过SHA1sum值来标识，所以对分支的操作是轻量级的，你改变的仅仅是SHA1sum值。如下图所示，当前有2个分支，A,C,E属于master分支，而A,B，D,F属于dev分支``` jsA----C----E（master） \ B---D---F(dev) 它们的head指针分别指向E和F，对上述做如下操作：12git checkout master //选择or切换到master分支git merge dev //将dev分支合并到当前分支(master)中 之后的情形是这样的：123A---C---E---G(master) \ / B---D---F（dev） 现在A，B,C,D,E,F,G属于master，G是一次合并后的结果，是将E和Ｆ的代码合并后的结果，可能会出现冲突。而A,B，D,F依然属于dev分支。可以继续在dev的分支上进行开发:123A---C---E---G---H(master) \ / B---D---F---I（dev） 理解gitfetch,关键是理解FETCH_HEAD，FETCH_HEAD指的是：某个branch在服务器上的最新状态。 git fetch 用法1git fetch &lt;远程主机名&gt; //这个命令将某个远程主机的更新全部取回本地 如果只想取回特定分支的更新，可以指定分支名：1git fetch &lt;远程主机名&gt; &lt;分支名&gt; //注意之间有空格 最常见的命令如取回origin 主机的master 分支：1git fetch origin master 取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息： 1git log -p FETCH_HEAD git pull 用法前面提到，git pull 的过程可以理解为：12git fetch origin master //从远程主机的master分支拉取最新内容 git merge FETCH_HEAD //将拉取下来的最新内容合并到当前所在的分支中 即将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为：1git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程分支是与当前分支合并，则冒号后面的部分可以省略：1git pull origin next git fetch 更新远程代码到本地仓库 理解 fetch 的关键, 是理解 FETCH_HEAD，FETCH_HEAD指的是: 某个branch在服务器上的最新状态’。 这个列表保存在 .Git/FETCH_HEAD 文件中, 其中每一行对应于远程服务器的一个分支。当前分支指向的FETCH_HEAD, 就是这个文件第一行对应的那个分支.一般来说, 存在两种情况:如果没有显式的指定远程分支, 则远程分支的master将作为默认的FETCH_HEAD.如果指定了远程分支, 就将这个远程分支作为FETCH_HEAD.git fetch origin branch1这个操作是git pull origin branch1的第一步, 而对应的pull操作,并不会在本地创建新的branch。设定当前分支的 FETCH_HEAD’ 为远程服务器的branch1分支`。 这个命令可以用来测试远程主机的远程分支branch1是否存在, 如果存在, 返回0, 如果不存在, 返回128, 抛出一个异常.git fetch origin branch1:branch2首先执行上面的fetch操作，使用远程branch1分支在本地创建branch2(但不会切换到该分支),如果本地不存在branch2分支, 则会自动创建一个新的branch2分支, 如果本地存在branch2分支, 并且是`fast forward’, 则自动合并两个分支, 否则, 会阻止以上操作.fetch更新本地仓库两种方式： 123456789101112131415//方法一$ git fetch origin master //从远程的origin仓库的master分支下载代码到本地的origin master$ git log -p master.. origin/master//比较本地的仓库和远程参考的区别$ git merge origin/master//把远程下载下来的代码合并到本地仓库，远程的和本地的合并//方法二$ git fetch origin master:temp //从远程的origin仓库的master分支下载到本地并新建一个分支temp$ git diff temp//比较master分支和temp分支的不同$ git merge temp//合并temp分支到master分支$ git branch -d temp//删除temp 1、git reset 没有push，这种情况发生在你的本地代码仓库,可能你add ,commit 以后发现代码有点问题. 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交commit_id(79f673d631b08907496ce792f429e1f00da25b73)，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard 79f673d631b08907496ce792f429e1f00da25b73。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。2、git revert已经push，对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令 git revert用一个新提交来消除一个历史提交所做的任何修改. revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题) revert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看. git revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c613、两者区别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit看似达到的效果是一样的,其实完全不同. 第一:上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突（或git push -f强制推送）.但是revert 并不会. 第二:如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里. 第三:reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的. 转载： 常用 Git 命令清单参考文章: git fetch 更新远程代码到本地仓库 Git 常用命令总结 git常用命令大全 Git常用命令解说 Git fetch &amp; pull 详解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的状态响应码]]></title>
    <url>%2F2018%2F10%2F10%2FHTTP%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码大类 状态码 说明 解释 1XX 响应中——表示请求已经接受，继续处理 消息：一般是告诉客户端请求已经收到了，正在处理，别急 2XX 成功——表示请求已经被成功接收、理解、接受。 处理成功：一般表示请求收悉、我明白你要的、请求已受理、已经处理完成等信息 3XX 重定向——要完成请求必须进行更进一步的操作 重定向到其它地方：它让客户端再发起一个请求以完成整个处理 4XX 客户端错误——请求有语法错误或请求无法实现 处理发生错误，责任在客户端：如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。 5XX 服务器端错误——服务器未能实现合法的请求。 处理发生错误，责任在服务端：如服务端抛出异常，路由出错，HTTP版本不支持等 HTTP响应状态码有很多，但是实际经常使用的大概只有14个。 状态码 200 OK //表示从客户端发来的请求在服务器端被正常处理了。 204 No Content该状态码表示服务器接收的请求已成功处理 ，但在返回的响应报文中不含实体的主体部分。 比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。 206 Partial Content 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。 301 Moved Permanently 永久性重定向。该状态码表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。 像下方给出的请求URI，当指定的资源路径的最后忘记添加斜杠”/“，就会产生301状态码 302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户(本次)能使用新的URI访问。 303 Other //我把你redirect到其它的页面，目标的URL通过响应报文头的Location告诉你。 See Other 该状态码表示由于请求对应的资源存在另外一个URI，应使用GET方法定向获取请求的资源。 303状态码和302状态码有着相同的功能，但303状态码明确表明客户端应当采用GET方法获取资源。 当301，302，303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文的主体，之后请求会自动再次发送。 301，302标准是禁止将POST方法改变成GET方法的，但实际上使用时大家都会这么做。 304 Not Modified // 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。 304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。 307 Temporary Redirect 临时重定向。该状态码与302 Found有着相同的含义。307会遵照浏览器标准，不会从POST变成GET 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 该状态码表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过1此请求，则表示用户认证失败。 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 500 Internal Server Error //该状态码表明服务器端在执行请求时发生了错误。 503 Server Unavailable //该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 参考文章 常见的HTTP响应状态码解析、常见的响应状态码]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡和捕获]]></title>
    <url>%2F2018%2F10%2F10%2FJavaScript%2F%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[事件冒泡和事件捕获 事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。123&lt;div id="outer"&gt; &lt;p id="inner"&gt;Click me!&lt;/p&gt;&lt;/div&gt; 上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？ 事件冒泡 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。 因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是: p -&gt; div -&gt; body -&gt; html -&gt; document 事件捕获 捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定) 上面的例子在事件捕获的概念下发生click事件的顺序应该是: document -&gt; html -&gt; body -&gt; div -&gt; p IE只支持事件冒泡，Chrome,Mozilla, Opera 7 和 Konqueror两种都支持，旧版本的Opera’s 和 iCab两种都不支持 。 捕获和冒泡过程图 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;event&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="obj1"&gt; welcome &lt;h5 id="obj2"&gt;hello&lt;/h5&gt; &lt;h5 id="obj3"&gt;world&lt;/h5&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var obj1=document.getElementById('obj1'); var obj2=document.getElementById('obj2'); obj1.addEventListener('click',function()&#123; alert('hello'); &#125;,false); obj2.addEventListener('click',function()&#123; alert('world'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 并且分别在obj1,obj2上绑定了一个点击事件，由于addEventListener的第三个参数为false,所以页面是在冒泡阶段处理绑定事件。此时整个页面可以有三种行为出现: 点击文字welcome时，弹出hello。此时就只触发了绑定在obj1上的点击事件。具体冒泡实现过程如下：welcome 属于文本节点，点击后，开始从文本节点查找，当前文本节点没有绑定点击事件，继续向上找，找到父级（id为obj1的div），有绑定的点击事件，执行，再向上找，body，没有绑定点击事件，再到html,document,都没再有绑定的点击事件，好，整个冒泡过程结束。 点击文字hello时，先弹出world，再弹出hello 点击world时，弹出hello。 addEventListener的第三个参数lement.addEventListener(event, function, useCapture) 第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。 我们想要在点击每个h5标签时，弹出对应的innerHTML 。常规做法是遍历每个h5,然后在每个h5上绑定一个点击事件，这种做法在h5较少的时候可以使用，但如果有一万个h5，那就会导致性能降低。这时就需要事件代理出场了。 事件代理 使用事件代理的好处不仅在于将多个事件处理函数减为一个，而且对于不同的元素可以有不同的处理方法 123456obj1.addEventListener('click',function(e)&#123; var e=e||window.event; if(e.target.nodeName.toLowerCase()=='h5')&#123; alert(e.target.innerHTML); &#125;&#125;,false); 由于事件冒泡机制，点击了h5后会冒泡到div,此时就会触发绑定在div上的点击事件，再利用target找到事件实际发生的元素，就可以达到预期的效果。 阻止冒泡的方法，阻止默认事件的方法(兼容IE)w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true阻止事件的传播兼容 123456789101112131415function(e)&#123; var e=e||window.event; // window.event 这是IE浏览器 e.stopPropagation();//阻止事件的传播(包括捕获也包括冒泡) // 兼容处理 if (e &amp;&amp; e.stopPropagation) &#123; //这是其他浏览器 e.stopPropagation(); //阻止冒泡事件 e.preventDefault();//阻止默认事件 &#125;else&#123; // IE浏览器 e.cancelBubble=true; //阻止冒泡事件 e.returnValue=false;//阻止默认事件 &#125;&#125; 阻止冒泡事件的兼容性处理1234567function stopBubble(e) &#123; if(e &amp;&amp; e.stopPropagation) &#123; //非IE e.stopPropagation(); &#125; else &#123; //IE window.event.cancelBubble = true; &#125; &#125; 阻止默认事件 w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false; 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，会执行几次事件，会先执行冒泡还是捕获？首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段 参考文章 终于弄懂了事件冒泡和事件捕获浅谈事件冒泡与事件捕获]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GET和POST请求]]></title>
    <url>%2F2018%2F10%2F10%2FHTTP%2Fget%E5%92%8Cpost%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[关于HTTP协议 HTTP（即超文本传输协议）是现代网络中最常见和常用的协议之一，设计它的目的是保证客户机和服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的 “请求-应答” 协议。 在HTTP中，与服务器交互的方法，最常用的有4种：即Put（增）、Delete（删）、Post（改）、Get（查）。get是获取数据，post是修改数据。 两种常见的HTTP请求：GET 和 POST在客户机和服务器之间进行请求-响应时，两种最常被用到的请求方式是：GET和 POST。GET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据 GET请求get把请求的数据放在url上，即HTTP协议头上，其格式为： 以?分割URL和传输数据，参数之间以&amp;相连。 数据如果是英文字母/数字，原样发送， 如果是空格，转换为+， 如果是中文/其他字符，则直接把字符串用BASE64加密，及“%”加上“字符串的16进制ASCII码”。特点 GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 POST 请求post把数据放在HTTP的包体内（requrest body）。特点 POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 POST 请求对数据长度没有要求 比较 GET 和 POST get提交的数据最大是2k（原则上url长度无限制，那么get提交的数据也没有限制咯？限制实际上取决于浏览器，(大多数)浏览器通常都会限制url长度在2K个字节，即使(大多数)服务器最多处理64K大小的url。也没有卵用。）。 post理论上没有限制。实际上IIS4中最大量为80KB，IIS5中为100KB。 GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 GET在浏览器回退时是无害的，POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET只接受ASCII字符的参数的数据类型，而POST没有限制那么，post那么好为什么还用get？get效率高！。 其他 HTTP 请求方法转载： HTTP 方法：GET 对比 POST参考文章: HTTP 方法：GET 对比 POST get和post的区别–面试经常被问到！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语义化标签]]></title>
    <url>%2F2018%2F10%2F10%2FH5%2F%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[H5中关于语义化的标签定义 语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。 为什么要语义化 1. 有利于SEO，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重。 2. 语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构 3. 方便其他设备解析（如移动设备、盲人阅读器等） 4. 比div标签有更加丰富的含义，便于团队开发和维护 关于语义化的标签有哪些title 简短、描述性、唯一（提升搜索引擎排名）header 页眉通常包括网站标志、主导航、全站链接以及搜索框。section 具有相似主题的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。footer 页脚，只有当父级是body时，才是整个页面的页脚。article 包含像报纸一样的内容，表示文档、页面、应用或一个独立的容器aahgroup 标签用于对网页或区段（section）的标题进行组合nav 标记导航，仅对文档中重要的链接群使用。aside 指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。address 作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）mark 突出显示文本（yellow），提醒读者。time 标记时间。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式figure 创建图（默认有40px左右margin）figcaption figure的标题，必须是figure内嵌的第一个或者最后一个元素。datailstdetailssummarydialogddprogress 完成进度。可通过js动态更新valuekeygensmall 指定细则，输入免责声明、注解、署名、版权。 H5新增的语义化标签header 是一种具有引导和导航作用的结构元素，通常用来放置整个页面或页面内的一个内容区块的标题，但也可以包含搜索表单或logo。footer footer通常包括其相关区块的脚注信息，如作者，相关阅读连接以及版权信息等。article 代表文档，页面或应用程序中独立的，完整的，可以独自被外部引用的内容，也可以嵌套使用。可以是一篇博客或者报刊中的文章，一篇论坛帖子，一段用户评论或者独立的插件，或其他任和独立的内容。aside 定义页面的侧边栏内容address 用来在文档中呈现联系信息，包括文档作者或文档维护者名字，他们的网站链接，电子邮箱，真实地址，电话号码，以及跟文档相关的联系人的所有联系信息。timedetails 用于描述文档或者文档某一部分细节，summary是details元素的标题ruby 加注释，ruby标签有两个子元素，rt注释的内容，rp是该标签不显示时显示的文字mark 定义带有几号的文本，它会给你想要突出显示的文本加个 背景色nav 是一个可以用作页面导航的链接组，其中导航元素链接到其他页面或当前页面的其他部分。progresssection 作为Html文档独立的功能。video 定义视频，属性src引入资源，controls视频的控制控件audio该标签可定义声音，及其他的音频文件，不加controls不显示音频的控制界面datalist 提示可能的值，datalist及其选项不会被显示出来，它仅仅是合法输入值的列表使用input元素的list属性来邦定datalistembed 定义插入的内容，如插件，flash，标签中间不要加内容会显现出来canvas canvas画布只是个容器，你可以通过控制坐标在canvas上绘制图形，一般配合js可以实现非常复杂的动画效果。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渐进增强和优雅降级]]></title>
    <url>%2F2018%2F10%2F10%2FCSS3%2F%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[渐进增强 一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。 123456.transition &#123; /*渐进增强写法*/ -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s;&#125; 优雅降级 一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。 123456.transition &#123; /*优雅降级写法*/ transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; 渐进增强和优雅降级的区别 渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的 常见问题 渐进增强和优雅降级如何抉择 如果你采用渐进增强的开发流程，先做一个基本功能版，然后针对各个浏览器进行渐进增加，增加各种功能。相对于优雅降级来说，开发周期长，初期投入资金大。 那采用优雅降级呢，这样可以在较短时间内开发出一个只用于一个浏览器的完整功能版，然后就可以拿给PM找客户谈呀，可以拿去测试，市场试水呀，对于功能尚未确定的 产品，优雅降级不失为一种节约成本的方法。 采用优雅降级的写法，如果一个浏览器同时支持前缀写法和正常写法，后面的旧版浏览器样式就覆盖了新版样式，出现一些奇怪的问题 ，但是用渐进增强的写法就不存在这个问题。这种属性不止border-radius一个，所以为了避免这个不必要的错误，建议大家都采用渐进增强的写法。 绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。 参考文章 渐进增强和优雅降级之间有什么不同?]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动]]></title>
    <url>%2F2018%2F10%2F10%2FCSS3%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[转载：CSS-清除浮动 为什么要清除浮动 浮动的元素是脱离文档标准流的，如果我们不清楚浮动，那么就会造成父元素高度塌陷，影响页面布局。 清除浮动的方法使用带clear属性的空元素 div、hr、br都可以 使用clear:both会把浮动元素的边界拉下来到标准流，从而把对应标准流的位置撑开123456789# html&lt;div class="clear"&gt;&lt;/div&gt;&lt;br class="clear" /&gt;&lt;hr class="clear" /&gt;#css.clear &#123; clear: both;&#125; 优点：通俗易懂，容易掌握 缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。 使用CSS的 overflow 属性 给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发hasLayout，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。 12345678910111213141516.news &#123; background-color: gray; border: solid 1px black; overflow: hidden; *zoom: 1; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;&lt;div class="news"&gt; &lt;img src="news-pic.jpg" /&gt; &lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 优点：不存在结构和语义化问题，代码量极少 缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；04年POPO就发现overflow:hidden会导致中键失效，这是我作为一个多标签浏览控所不能接受的。所以还是不要使用. 父元素也设置浮动(给浮动的元素的容器添加浮动) 优点：不存在结构和语义化问题，代码量极少 缺点：给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。 使用邻接元素处理 什么都不做，给浮动元素后面的元素添加clear属性。12345678910111213141516171819202122.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.content&#123; clear:both; &#125;&lt;div class="news"&gt; &lt;img src="news-pic.jpg" /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;div class="content"&gt;***&lt;/div&gt;&lt;/div&gt; 使用 :after 伪元素 结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。 123456789101112131415161718192021222324252627282930.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;# 清除浮动.clearfix:after&#123; content: " "; display: block; height: 0; clear: both; visibility: hidden; &#125;.clearfix &#123; /* 触发 hasLayout */ zoom: 1; &#125;&lt;div class="news clearfix"&gt;&lt;img src="news-pic.jpg" /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 要点 清除浮动：清除对应的单词是 clear，对应CSS中的属性是 clear：left | right | both | none； 闭合浮动：更确切的含义是使浮动元素闭合，从而减少浮动带来的影响。其中涉及的原理有：hasLayout 和 Block formatting contexts 。 通过上面的例子，我们不难发现清除浮动的方法可以分成两类： 一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。 二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素. 在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。 最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bind、apply和call的区别]]></title>
    <url>%2F2018%2F10%2F10%2FJavaScript%2Fbind%E5%92%8Ccall%2F</url>
    <content type="text"><![CDATA[ing…bind和call的作用都是将某个函数的this指向绑定到另外一个作用域中，他们的参数调用都是相同的，第一个参数为绑定的作用域对象是什么，接下来就是可以添加不限的参数，而区别就是call在绑定的同时调用函数，bind是返回一个改变this指向的函数。apply方法和call方法有些相似，它也可以改变this的指向同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS模块化]]></title>
    <url>%2F2018%2F10%2F10%2FCSS3%2FCSS3%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[未完成ing… 设计原则 可复用能继承要完整 周期性迭代 优秀的代码是模仿/设计/重构出来的 设计方法 先整体后部分再颗粒化 布局-&gt; 页面 -&gt; 功能-&gt;业务 先抽象再具体 css模块化设计 reset.scss：浏览器不同，对默认的标签有默认的样式，为了表现统一化，要加一个这个。layout.scss:布局抽象成这个element.scss:列表、按钮 global的方式引用，比如说直接把某个模块引用进来，然后就可以写具体的样式了。scope就是用的module方法。比如说两个组件都叫做.btn，这样在之前会导致两个样式的名称一致，会被覆盖，如果想用相同的名称，样式不一样，就要用css module这样就不一致，因为编译出来的class带了一串编码。 优点： 提高代码重用率 提高开发效率、减少沟通成本 降低耦合 降低发布风险 减少Bug定位时间和Fix成本 提高页面容错 更好的实现快速迭代 更好的支持灰度发布 参考: CSS模块化如何实现？]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域的方法]]></title>
    <url>%2F2018%2F10%2F10%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端本地储存]]></title>
    <url>%2F2018%2F10%2F10%2FJavaScript%2F%E5%89%8D%E7%AB%AF%E6%9C%AC%E5%9C%B0%E5%82%A8%E5%AD%98%2F</url>
    <content type="text"><![CDATA[本地存储本地存储主要有以下几种，cookie，localStorage和sessionStorage，WebSql和IndexDB主要用在前端有大容量存储需求的页面上，例如，在线编辑浏览器或者网页邮箱。他们都可以将数据存储在浏览器，应该根据不同的场景进行使用。本文主要讲前三个。 cookiecookie机制采用的是在客户端保持状态的方案Cookie的主要内容包括：名字，值，过期时间，路径和域。可设置失效时间，没有设置的话，默认是关闭浏览器后失效。Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 优点 1. 给用户更人性化的使用体验，如记住“密码功能”、老用户登录欢迎语 2. 弥补了HTTP无连接特性 3. 站点统计访问人数的一个依据 4. 所有新旧浏览器都支持。 缺点 1. 它无法解决多人共用一台电脑的问题，带来了不安全因素 2. Cookie文件容易被误删除 3. 一人使用多台电脑 4. Cookies欺骗。修改host文件，可以非法访问目标站点的Cookie 5. 容量有限制，不能超过4kb 6. 在请求头上带着数据安全性差 为什么需要cookie 当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。Cookie 的作用就是用于解决 “如何记录客户端的用户信息”: 当用户访问 web 页面时，他的名字可以记录在 cookie 中。 在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。Cookie 以名/值对形式存储，如下所示:username=John Doe当浏览器从服务器上请求 web 页面时， 属于该页面的 cookie 会被添加到该请求中。服务端通过这种方式来获取用户的信息。 如何使用cookie12345678910# 创建Cookiedocument.cookie="username=John Doe";# 读取 Cookievar x = document.cookie;# 修改 Cookiedocument.cookie="username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/";# 删除 Cookie# 删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT"; 注意如果 cookie 被篡改了怎么办？预防 Cookie 被篡改set-cookie时加上防篡改验证码。 localStorage localStorage主要是前端开发人员，在前端设置，一旦数据保存在本地后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要地来回传递。 可以长期存储数据，没有时间限制，一天，一年，两年甚至更长，数据都可以使用。localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同 优点 1. localStorage拓展了cookie的4k限制 2. localStorage可以将第一次请求的5M大小数据直接存储到本地，相比于cookie可以节约带宽 3. localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage 缺点 1. 需要手动删除，否则长期存在 2. 浏览器大小不一，版本的支持也不一样 3. localStorage只支持string类型的存储，JSON对象需要转换 4. localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡123456789101112localStorage.setItem('x', 121313);localStorage.setItem('xxxx', 'baozhen');localStorage.getItem('x');for(let i = 0; i&lt; localStorage.length; i++) &#123; var name = localStorage.key(i); var value = localStorage.getItem(name) console.log("name:", name, "value:", value);&#125;localStorage.removeItem("x");localStorage.clear(); sessionStorage sessionStorage 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。存储上限限制：不同的浏览器存储的上限也不一样，但大多数浏览器把上限限制在5MB以下。 使用语法12345678# 保存数据语法：sessionStorage.setItem("key", "value");# 读取数据语法：var lastname = sessionStorage.getItem("key");# 删除指定键的数据语法：sessionStorage.removeItem("key");# 删除所有数据：sessionStorage.clear(); session 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session。 Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。 典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户的状态，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。 session机制采用的是在服务器端保持状态的方案。存在服务器的一种用来存放用户数据的类HashTable结构。 浏览器第一次发送请求时，服务器自动生成了一HashTable和一SessionID来唯一标识这个HashTable，并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的HashTable。 cookie 和 session 的区别 cookie数据存放在客户的浏览器上，session数据放在服务器上。 session 中保存的是对象，cookie 中保存的是字符串。 session 不能区分路径，同一个用户在访问一个网站期间，所有的session在任何地方都可以访问到。而 cookie 中如果设置了路径参数，那么同一个网站不同路径下的 cookie 互相是不可以访问的。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 localStorage 和 sessionStorage localStorage 和 sessionStorage两者的区别在于储存的有效期和作用域的不同：数据可以储存多长时间以及谁拥有数据的访问权。 名称 有效期 作用域 localStorage 永久性 同源文档 sessionStorage 当前窗口 同源文档 cookie 和 webStorage 的区别 webStorage 的优势 从容量上讲WebStorage一般浏览器提供5M的存储空间。 安全性上WebStorage 并不作为 HTTP header 发送的浏览器，所以相对安全。 从流量上讲，因为WebStorage不传送到服务器，所以不必要的流量可以节省。 Cookie和webstorage区别 数据的有效期不同 Webstorage:1.localstorage 2.sessionstorage sessionStorage：仅在当前的浏览器窗口关闭有效； localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据,除非手动删除； cookie：只在设置的cookie过期时间之前一直有效，即使窗口和浏览器关闭 作用域不同 sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面； localStorage：在所有同源窗口都是共享的； cookie：也是在所有同源窗口中共享的 webStorage支持事件通知机制，可以将数据更新的通知发生给监听者 转载： cookie和session, cookie和webStorage的区别 浏览器缓存原理以及本地存储 知乎问答]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端本地储存</tag>
      </tags>
  </entry>
</search>
